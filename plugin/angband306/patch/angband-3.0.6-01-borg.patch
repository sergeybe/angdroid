diff -Nru --strip-trailing-cr angband-3.0.6/lib/help/BORGREAD.TXT angband-3.0.6-borg/lib/help/BORGREAD.TXT
--- angband-3.0.6/lib/help/BORGREAD.TXT	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/lib/help/BORGREAD.TXT	2005-04-26 20:54:24.000000000 -0700
@@ -0,0 +1,189 @@
+
+Greetings my friends and welcome to the world of mindless dribble.
+This source code will enable you to spend countless hours staring
+at your computer when you should be doing something more productive,
+anything more productive.
+
+You have a couple of options on how to get the borg running.  Be sure
+to copy the file borg.txt into the angband\lib\user  directory.  On
+my system, borg.txt is in c:\games\ang305\lib\user.
+
+For those using Unix, you need to put it in a different directory.
+
+Option one:  Use the precompiled executable files and replace your
+     angband.exe or angband.scr files with the ones with this package.
+1. copy the angband.exe and replace the existing one in your angband
+   directory.  If using the screensaver, copy and replace the
+   angband.scr in your windows directory.
+2. If using screensaver, copy the angband.ini with the screensaver file
+   and put that in your windows directory as well.  Be sure to edit it.
+   (See the notes below)
+   
+
+Option two:  Compile your own executable file using the borg source
+     code provided in this package.  Follow the instructions below.
+
+To install and compile this borg, you will need to do the following:
+1.  Modify the config.h to uncomment:
+        a. the allow_borg line
+        b. the score_borg line
+        c. the allow_borg_graphics line
+2.  Modify the makefile to include the borg1.o (or borg1.obj if windows)
+    though borg9.o
+3.  Make sure the file borg.txt is located in the \lib\user\ directory.
+4.  Modify your borg.txt file if you want to run the borg in a particular
+    fashion, including continuous play borgs.
+5.  Compile
+6.  Start the game, load up a character or make new one.
+7.  Hit control z, read and ignore the messages, hit z again.
+8.  Grab some popcorn and a soda, and watch your mind go numb.
+
+The borg may get stuck in certain situations.  He may have a Clock Overflow.
+He may loop buying and selling the same stuff over and over.  Believe me
+when I say that these have been addressed.  His loops are greatly reduced.
+
+
+Continuous Play Mode: (option)
+Upon the death of a borg, he will automatically reroll a random character,
+with a random name and start fresh from clevel 1.  To enable the Continuous
+Play Mode, turn the game option cheat_live on.  To do that enter the
+options by pressing the equal sign (=) then Cheat Options (6).
+
+If you want, you can tell the borg to select a certain race and or class for
+the next one rolled up.  You can make these selections from the borg.txt file.
+
+The Continual Play Mode is NOT turned on by default, you will need to
+select it.
+
+This borg is updated just about everyday.  You can get the lastest source
+as well as executables at http://itctel.com/~apwhite/andrew.html
+
+Have Fun,
+Dr. Andrew White
+
+
+
+===========================
+ Angband Borg Screen Saver
+===========================
+
+by Robert Ruehlmann < rr9@angband.org >
+   Andrew White     < apwhite@itctel.com >
+   
+Version 1.2 (23 August 2002)
+
+Uses Andrew P. White's APWBorg.
+(see http://itctel.com/~apwhite/andrew.html).
+
+
+Description:
+------------
+
+A screensaver that runs the Angband 3.0.1 Windows version with the
+APW Borg and automatically restarts the Borg when the character dies
+(continuous play mode).
+
+The borg engine is updated almost daily, so visit Dr. White's page and
+obtain the most recent version of the borg.  You may also down-load
+an up to date executable of the screensaver from that page.
+
+Note that the Angband display is not always dynamic and may not
+protect your monitor from burning-in of images.  While this is highly
+unlikely with modern monitors you might want to configure the energy
+saving settings for your monitor so that it turns itself off after
+some time of inactivity.  The screensaver will also keep the
+processor and hard-disk busy.  Power-saving features that depend on
+inactivity of these parts won't be effective while the screensaver
+is running.  You have been warned.
+
+
+Installation:
+-------------
+
+Copy angband.scr and this angband.ini into your Windows directory.
+
+Make sure you have the Windows version of Angband installed.
+If you don't have it yet, then download it from
+http://thangorodrim.angband.org/ and install it.
+
+Open angband.ini with a text-editor and modify "AngbandPath" so that
+it points to the directory where Angband for Windows is
+installed. Note that the path has to end with a backslash ('\').
+
+The "SaverFile" variable should contain the name of the character you
+want to use for the screensaver.  A random character will be
+automatically created if the character doesn't exist yet.  Note that
+the savefile will be marked as cheater and won't get an highscore
+entry!
+
+Select the screensaver in the Windows display properties and test it!
+
+
+Technical stuff:
+----------------
+
+The screensaver is basically just a renamed Windows Angband
+executable.  The main-win.c file has been heavily modified to allow
+the game to act as screensaver.
+
+"SCORE_BORGS" has been turned on so that normal Borgs (but not Borgs
+used with the continuous play mode turned on like in the
+screensaver!) will get highscore entries.
+
+The screensaver uses the angband.ini of the normal Angband
+installation to determine the screen-layout, as well as the graphics
+and sound settings.
+
+My "ALLOW_BORG_GRAPHICS" code that is included in the APW Borg has
+been turned on, so the Borg runs nicely with the various graphics
+and "view_foo_lite" lighting settings.
+
+The screensaver can be used as normal Angband executable by renaming
+it to angband.exe and replacing the old exe in the Angband 3.0.1
+installation directory with it.
+
+The screensaver tries to be "nice" and only uses processor cycles
+when the processor would be idle otherwise.  It shouldn't slow down
+other processes that might be running.
+
+The user can also switch that feature on with the "Options/Low
+priority" menu-entry when using the screensaver as normal Angband
+executable (very useful for running Borgs in the background).
+
+Known problems:
+---------------
+
+- No preview of the screensaver when in the Windows display
+  properties.
+- Password protection doesn't work yet (note that Windows NT seems
+  to handle password protection itself, so this might be no problem
+  on NT and maybe Windows 2000 machines).
+- Configuration of the screenserver should be possible with a dialog
+  instead of an ini-file.
+- Selecting "Show scores" while the Borg is running will probably
+  crash the Borg since it can't parse the score-screen.
+- The screensaver probably won't work correctly with other Borgs that
+  don't provide a continuous play mode compatible with the APW code.
+- Running the same savefile twice at the same time (for example by
+  running a normal game and the screensaver with the same savefile)
+  might lead to problems.
+- The size of some info windows can increase when exiting the "pseudo-
+  screensaver" mode started from the options menu.
+- The Borg is a very complicated piece of code and contains lots of bugs.
+  Expect slowdowns, loops, crashes, and other problems.  If you encounter
+  a suspect bug, first consult the APWBorg Webpage for a updated screen-
+  saver, and check the Daily Log of Changes to see if your bug has been
+  fixed.  If not, then send the bug and savefile to Dr. White at
+  apwhite@itctel.com
+
+
+Links:
+------
+
+APW-Borg homepage:
+http://itctel.com/~apwhite/andrew.html
+
+Angband (and Angband screensaver) homepage:
+http://thangorodrim.angband.org/
+
+
diff -Nru --strip-trailing-cr angband-3.0.6/lib/user/BORG.TXT angband-3.0.6-borg/lib/user/BORG.TXT
--- angband-3.0.6/lib/user/BORG.TXT	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/lib/user/BORG.TXT	2005-10-09 21:28:40.000000000 -0700
@@ -0,0 +1,1386 @@
+
+# This file will allow you to customize your APWBorg along certain themes.
+# The borg is fairly successful, having won the game several times.
+# However, some players/observers of borgs would like to see it function
+# differently.  Some would like to see the borg play more aggressively, or
+# more conservatively.  While others would like to value armour class more.
+# Still others would like to see it collect more speed items.
+
+# With the expressions below, you can influence the borg's behavior and
+# equipment selection choices.  The 'borg_worship_' variables will influence
+# his equipment selection by adding additional bonuses to items which
+# enhance that attribute.  For example:  if a borg recieves 2000 pts for
+# a single point of armour class, an 'ac worshipping' borg would receive
+# 3000 pts.  This bonus would significantly influence equipment choices.
+
+# borg_worships_gold explained:
+# The borg_worships_gold option will greatly impact how the borg treats items
+# which he finds in the dungeon.  With this opion on, he will return to town
+# whenever he fills up with items then sell those items.  This can cause
+# the borg to lose some artifacts, since he will sell them even if not ID'd.
+# Generally speaking the borg will not sell an item unless it is at least
+# psuedo ID'd.  The benefit of this option is that the borg will significantly
+# increase his income at the low clevels.  This will increase his survivablity
+# by allowing him to invest in armour and arrows.  With this on,
+# he will not recall to town to sell stuff but climb the stairs instead.
+# He will also not recall into the dungeon until dlevel 8 (instead of 5).
+# This option has no effect after clevel 20.  One other downside of this is
+# that the borg will spend more time in town and may have to evade Vets more.
+
+
+# To modify, simply set it to TRUE or FALSE.
+
+# NOTE: THERE MUST BE A SPACE AFTER THE =
+# option = TRUE   is acceptable
+# option =TRUE    is NOT acceptable and will result in a default value.
+
+# Worships
+
+borg_worships_damage = FALSE
+borg_worships_speed = FALSE
+borg_worships_hp = FALSE
+borg_worships_mana = FALSE
+borg_worships_ac = FALSE
+borg_worships_gold = FALSE
+
+
+# use the POWER_ and REQ_ lines below.  If false the borg will
+# use the calcs in the C code.
+# note: the dynamic calcs are slower than the internal calcs
+
+borg_uses_dynamic_calcs = TRUE
+
+
+# Risky
+
+# A risky borg is one who is not confined by character level requirements
+# in order to dive deeper.  It is also more likely to stay in a battle than
+# to teleport out.  A risky borg will dive faster but is more likely to die.
+# A risky borg is not concerned with killing uniques before diving deeper.
+#
+# A borg who scums for uniques will set the auto_scum flag in order to generate
+# more exciting levels and hopefully encounter a unique
+
+borg_plays_risky = FALSE
+borg_scums_uniques = TRUE
+
+
+# Swap Items
+
+# The borg is designed to use Swap Items in the inventory.  A swap item
+# is an equipment item (like a sword or armour item) which posseses a
+# desireable resistance or trait.  If the borg is in danger, then he will
+# consider exchanging his current item for the swap item.  A prime example of
+# this is at dungeon level 60.  He is required to have several resists in
+# place.  If he does not have them then he will not dive deeper.  However,
+# with Swaps enabled he will select an item to cover the open resist then
+# dive down.  Having Swaps enabled allows the borg to dive deeper, faster.
+# The draw back is the Swap Items take up two inventory slots.
+
+borg_uses_swaps = TRUE
+
+
+
+# Home Storage
+
+# The borg has two routines to store items in the home.  One is very
+# effective and will make the best possible choice for adding an item to the
+# home.  Unfortunately, this function is very slow.  A much faster routine
+# will do a fine job at storing items in the home but it is not as
+# efficient.
+
+borg_slow_optimizehome = FALSE
+
+
+# Respawn
+
+# If the borg is in continual play mode (as with the screen saver),
+# he will respawn a randomly generated character at death.  This section
+# allows the user to make certain bias for the type of character generated.
+# You may select the race and or class and or minimal stats for the Borg.
+# You may also select the minimal character level needed before the
+# character dump is created in the game directory.
+
+# With regards to race, the borg is programmed to accept the variety of
+# user defined races which may be in the p_info.txt file.  So the values
+# given in table below are for the default races.  But if you are bright
+# enough to modify the p_info.txt file then you are bright enough to figure
+# out that race 0 does not necessarily equal Human.  It's just the first
+# race listed in your p_info.txt file.
+#
+# RACE:-1 Random Race          CLASS:  -1 Random Class
+#       0 Human                         0 Warrior
+#       1 Half Elf                      1 Mage
+#       2 Elf                           2 Priest
+#       3 Hobbit                        3 Rogue
+#       4 Gnome                         4 Ranger
+#       5 Dwarf                         5 Paladin
+#       6 Half Orc
+#       7 Half Troll
+#       8 Dunadan
+#       9 High Elf
+#	10 Kobold
+#
+# With regards to the stats.  The minimal stats are rolled by the
+# borg.  CON will be 16, the secondary stat (usually DEX) will be 17,
+# The primary stat will be 17.  These are the maximal values which
+# can be rolled (racial and class bonuses added after).
+# If the borg can not reach the stats after 500,000 tries the game
+# will just assign you a random stat.
+#
+# After killing Morgoth, generally, the borg will stop and allow you
+# to inspect the victory.  If you set the respawn_winners then after
+# killing Morgoth,the borg will generate a new character.  A map file
+# is created so you can see what the final battle looked like.
+
+borg_respawn_race = -1
+borg_respawn_class = -1
+borg_respawn_winners = FALSE
+
+
+# Dumps
+
+# This variable will determine the minimal character level at which the borg
+# will create a character dump file.  That file contains some vital information
+# concerning the status of the borg at the time of his demise.  It is placed
+# in the user directory.
+# The borg_save_death variable will tell the borg to save the game in the user
+# directory so that it can be examined more closely.  The clevel of the borg
+# must at least equal the borg_dump_level in order for the game to save.
+
+borg_dump_level = 1
+borg_save_death = 1
+
+# Auto Stops
+
+# The borg is able to stop when it reaches a certain dungeon depth or character
+# level.  He will also stop when he wins the game.  If you want him to keep
+# playing, even after Morgoth is dead, then change the borg_stop_king to FALSE.
+# Set the other values to the level at which you want the borg to stop.  Set
+# them out of bounds if you do not want him to stop.
+
+borg_stop_dlevel = 128
+borg_stop_clevel = 51
+borg_no_deeper = 127
+borg_stop_king = TRUE
+
+
+# Chest Tolerance
+
+# The borg is able to search, disarm, and open chests.  There is a inherant
+# risk when dealing with chests.  The risk of setting off the trap vs the
+# benefit of the loot within the chest.  The game uses a straight forward 
+# formula for calculating the success of a chest.  It is:
+# randint(100) < the skill of the player minus the dificulty of the chest.
+# Difficulties run from 1 to 63.  I would recommend a tolerance of about 7
+# for vanilla chests (since they suck) and about 15 for DrAngband.
+
+borg_chest_fail_tolerance = 7
+
+
+# Speed of the Borg
+
+# You can slow the borg down several different ways.  One way is to set the
+# base game delay factor in the options menu.  This will slow down the borg
+# and the visual effects (like missiles shooting, explosions).  If using the
+# screensaver, you will need to load angband.exe load the savefile, make the
+# modifications, then save and exit.  Another way to slow the borg down is
+# to add more term windows.  The more it has to do, the slower it will be.
+# I recommend using Inventory, Equipment, Messages, Monster Recall, Borg
+# Status windows. Then you can really see what the borg is up to.  Lastly,
+# to slow the borg down use the following variable.  The formula is:
+# base_game_delay_factor^2 + borg_delay_factor^2.
+
+borg_delay_factor = 0
+
+
+# Money Scumming
+
+# This started as more of a joke but it does have a useful purpose.  If you 
+# find yourself shopping in the BM and you really want that item and its just 
+# out of your price range, then you can set a dollar amount into this variable 
+# and the borg will run around town killing monsters and collecting items for 
+# cash.  Once he has reached his monetary goal, it will unhook and stop moving.  
+# The borg will wait on the level, to build up more towns people, kill them, 
+# buy food when it needs to.  But it won't leave the level until the goal
+# is reached.  To disengage the money scum, leave this variable at 0 (zero).
+# This will also simulate the borg_worships_gold and allow the borg to sell 
+# non-ID'd items which will be dropped in town.  The borg will flee from town 
+# from Scary Guys.  So keep this in mind with borgs under clevel 6. The borg 
+# will not scum unless he has a perma lite source (phial, or some glowing 
+# artifact). The borg will stop if the General Store runs out of food to buy.
+# It is not recommended for borgs with Regeneration and no Slow 
+# Digestion, since they will spend all their money on food.  But if you have a
+# borg with Satisfy Hunger spell, they can stay in town forever.
+# NOTE: if a human wants the borg to scum to a particular amount, turn the 
+# borg_self_scum to FALSE or else he will buy his own gear with that money.
+
+borg_money_scum_amount = 0
+
+
+# Borg Scumming
+
+# This is a companion to the Money Scum above.  The borg will scum town if
+# a stat potion is in the BM.  If the borg finds an item in town that he would
+# really like to have, then he will stay in town until he can gathered enough
+# money to buy it.  The borg will behave like the borg_money_scum_amount above.
+# If this is TRUE, then the borg is allowed to scum for items that he wants.
+# To forbid this behavior (which can take a very long time) set it FALSE.
+# NOTE: if a human wants the borg to scum to a particular amount, turn the 
+# borg_self_scum to FALSE or else he will buy his own gear with that money.
+# Also, the borg must be at least clevel 10, with a perma light, 
+# a 65% chance to avoid the pick pocket, and lots of food.
+
+borg_self_scum = TRUE
+
+
+# Lunal Borg
+
+# The borg will dive deep in the dungeon, even while he is still
+# low level, bouncing between levels to take nearby down stairs.
+# Once deep, he will gather items, then recall to town.  He will not recall
+# back down into the dungeon, but walk all the way down again.  If you want
+# a fast win, this is not the option for you.  If you want the borg to have
+# maxed stats early on at the expense of game turns, then give this a try.
+# The best way to use this is to have a borg that can cast Satisfy Hunger.
+# This is a one way trip for the borg and he will be getting hungry.
+# The borg should also have a perma light source (like the phial).  Again,
+# one way trip.  He won't be stopping to restock his fuel source.  However,
+# if he has food or fuel, he will use them when appropriate.  Having extra
+# speed will help the borg too.  Often he will come down the stairs, and 
+# find himself right next to a monster.  Sometimes, that monster can get
+# the first hit on a borg, killing him instantly.  Even +3 speed would help
+# to avoid this type of instadeath.
+#
+# Self Lunal Mode will allow the borg to use the stair scumming in order to
+# dive deep in the dungeon for his own goals.  For example, if the borg has
+# been down to depth 99, and now has no more potions of healing, he will
+# only be prepared for depth 45.  He will remain shallow in the dungeon,
+# from depth 1-10 waiting for the shops to cycle.  Then he will attempt to 
+# buy a healing potion from the town shops.  If none is available, he will
+# return to the shallow dungeon depths and wait for the shops to cycle.  He 
+# will repeat this pattern until he gets a potion of healing.  If the borg 
+# is allowed to self-lunal, then it will bounce the stairs down to a depth
+# where it feels comfortable.  In the case above, it will do this until
+# about depth 40.
+
+borg_lunal_mode = FALSE
+borg_self_lunal = TRUE
+
+
+
+# WARNING: If you mess with the objects.txt or the monster.txt and change 
+# the locations of things, then you must make those changes in borg.txt
+# as well as in this borg code.  The borg is very concerned about item 
+# index locations.  ie: borgs_has[242] is looking for a Potion of Healing.
+# The borg is concerned over several items, broken swords, and several 
+# monster locations (Tarresque, Sauron, Morgoth).
+
+
+
+# CHANGE THIS AT YOUR OWN RISK.  Changes here can cause VERY STUPID borg
+# behaviour.  If you do change them and your borg acts goofy, do not email me
+# complaining that your borg keeps dying.  Change these values if you know
+# exactly what you are doing.  It is strongly recommended that you keep a
+# backup copy of a borg.txt.
+
+# requirements 
+
+# format of line 
+# REQ_CLASSaaa_DEPTHbbb_(special value)
+
+# NOTE:  CLASS999 = all classes
+# NOTE:  CLASS000 = Warrior
+# NOTE:  CLASS001 = Mage
+# NOTE:  CLASS002 = Priests
+# NOTE:  CLASS003 = Rogue
+# NOTE:  CLASS004 = Ranger
+# NOTE:  CLASS005 = Paladin
+# NOTE:  it is possible to do stupid/impossible things, like require the borg 
+#        to have 3 Ringils or carry 999 potions of healing to get to level 1.
+#        there are no checks against such stupidity.
+# special values are:
+# _ITEMxxx = xxx is the index in k_info- Item in inventory
+# _WITEMxxx = xxx is the index in k_info- Item being worn
+# _ARTIFACTxxx = xxx is the index in a_info- Artifact being worn
+# _FORMULAxxx = formula found on seperate line
+# the rest do not require numbers.
+# Too add this to this list, add to array in borg1.c, add to enum in borg1.h 
+# (those must always match) then make sure the value is set in borg4.c borg_notice()
+# -personal attributes 
+# _STR  (0-39.  3 = 0, 15 = 18/00-18/09, 39 = 18/220)
+# _INT
+# _WIS
+# _DEX
+# _CON
+# _CHR
+# _CSTR (3-238+, 18/09 = 27)
+# _CINT
+# _CWIS
+# _CDEX
+# _CCON
+# _CCHR
+# Sustain Stat:
+# _SSTR
+# _SINT 
+# _SWIS 
+# _SDEX 
+# _SCON 
+# _SCHR 
+# 
+# _LITE = Has Lite
+# _CURHP   = Current HP
+# _MAXHP = Max HP
+# _OLDCHP = HP last round
+# _CURSP  = Current Mana
+# _MAXSP = max Mana
+# _ADJSP = mana adj due to Int/Wis
+# _OLDCSP = SP last round
+# _SFAIL1 = fail rate from array1
+# _SFAIL2 = min fail rate
+# _CLEVEL = cur char level
+# _MAXCLEVEL = Max char level
+# _ESP    = has telepathy
+# _CURLITE = Lite Radius
+# _RECALL = number of 'Recall's
+# _FOOD   = number of foods
+# _SPEED  = base speed (110 = normal speed)
+# _SDIG   = Slow Digest
+# _FEATH  = feather fall
+# _REG    = regen
+# _SINV   = See invis
+# _INFRA  = Infravision
+# _DIS    = Base Disarm
+# _DEV    = Base device use
+# _SAV    = Base Saving throw
+# _STL    = Stealth
+# _SRCH   = Search
+# _SERCHFREQ = Search Frequency
+# _THN    = To hit (normal)
+# _THB    = To hit (shooting)
+# _THT    = To hit (throwing)
+# _DIG    = Digging
+# Ignores/Immune
+# _IFIRE  
+# _IACID 
+# _ICOLD 
+# _IELEC 
+# Resists
+# _RFIRE 
+# _RCOLD 
+# _RELEC 
+# _RACID 
+# _RPOIS 
+# _RFEAR 
+# _RLITE 
+# _RDARK 
+# _RBLIND 
+# _RCONF 
+# _RSND 
+# _RSHRD 
+# _RNXUS 
+# _RNTHR 
+# _RKAOS 
+# _RDIS 
+# _HLIFE = Hold Life
+# _FRACT = Free Action
+# same as without S but includes swap
+# _SRFIRE    
+# _SRCOLD 
+# _SRELEC 
+# _SRACID 
+# _SRPOIS 
+# _SRFEAR 
+# _SRLITE 
+# _SRDARK 
+# _SRBLIND 
+# _SRCONF 
+# _SRSND 
+# _SRSHRD 
+# _SRNXUS 
+# _SRNTHR 
+# _SRKAOS 
+# _SRDIS 
+# _SHLIFE 
+# _SFRACT 
+# _DEPTH    = current depth being tested or Max Depth (for power)
+# _CDEPTH   = current depth borg is on
+#             when the borg is testing, he might see if he is ready for depth 10 while he is on
+#             depth 9
+# _MAXDEPTH = recall depth
+# _KING     = ***WINNER***
+# Player Status
+# _ISWEAK
+# _ISHUNGRY
+# _ISFULL
+# _ISGORGED
+# _ISBLIND
+# _ISAFRAID
+# _ISCONFUSED
+# _ISPOISONED
+# _ISCUT
+# _ISSTUN
+# _ISHEAVYSTUN
+# _ISIMAGE
+# _ISSTUDY
+# _ISSEARCHING
+# _ISFIXLEV
+# _ISFIXEXP
+# _ISFIXSTR
+# _ISFIXINT
+# _ISFIXWIS
+# _ISFIXDEX
+# _ISFIXCON
+# _ISFIXCHR
+# _ISFIXALL
+
+# _ARMOR    = base AC
+# _TOHIT    = base to hit, does not include weapon 
+# _TODAM    = base to damage, does not include weapon 
+# _WTOHIT   = weapon to hit 
+# _WTODAM   = weapon to damage 
+# _BTOHIT   = bow to hit 
+# _BTODAM   = bow to damage 
+# _BLOWS    = # attacks with current weapon
+# _SHOTS    = # shots with current bow
+# _WMAXDAM  =  max damage per round with weapon (normal blow) 
+#              Assumes you can enchant to +8 if you are level 25+ 
+# _WBASEDAM =  base damage per round with weapon (normal blow) 
+#              Assumes you no bonuses for to hit
+# _BMAXDAM  =  max damage per round with bow (normal hit) 
+#              Assumes you can enchant to +8 if you are level 25+ 
+# _HEAVYWEPON = Weapon is 'heavy' 
+# _HEAVYBOW   = bow is 'heavy'
+# _CRSTELE   = random teleport
+# _CRSAGRV   = Aggrevate
+# weapon attributes 
+# WS = slays
+# _WSANIMAL
+# _WSEVIL 
+# _WSUNDEAD 
+# _WSDEMON 
+# _WSORC 
+# _WSTROLL 
+# _WSGIANT 
+# _WSDRAGON 
+# WK = Weapon Kills
+# _WKDRAGON    
+# _WKDEMON    
+# _WKUNDEAD    
+# _WIMPACT 
+# WB = Weapon Branded With 
+# _WBACID       
+# _WBELEC 
+# _WBFIRE 
+# _WBCOLD 
+# _WBPOIS
+# inventory amounts 
+# _ATELEPORT 
+# _AESCAPE 
+# _FUEL 
+# _HEAL 
+# _EZHEAL 
+# _ID 
+# _ASPEED 
+# STF = Staff
+# _ASTFMAGI   Amount Staff Charges 
+# _ASTFDEST   
+# _AMISSILES    only ones for your current bow count 
+# _ACUREPOIS 
+# _ADETTRAP 
+# _ADETDOOR 
+# _ADETEVIL 
+# _AMAGICMAP 
+# _ALITE
+# _ARECHARGE 
+# _APFE        = Protection from Evil 
+# _AGLYPH      = Rune Protection 
+# _ACCW        = CCW potions
+# _ACSW        = CSW potions (+ CLW if cut)
+# _ARESHEAT    = Resist Heat potion
+# _ARESCOLD    = Resist Cold potion
+# _ATELEPORTLVL = Scroll of Teleport Level
+# _HWORD	= Holy Word spell is legal
+# _ADETONATE    = POTIONS TO THROW
+# _DINV         = See Inv spell is legal
+
+# Formulas are in (ew) reverse polish notation.  
+# Here is a copy of the formulas as defaults.
+# If you alter yours and mess them up, look here
+# to return them to the normal value.
+#FORMULA000=_CLEVEL 30 >= _ACCW _ACSW + 2 >= ||
+#FORMULA001=_CLEVEL 30 >= _ACCW _ACSW + 3 >= ||
+#FORMULA002=_ATELEPORT _AESCAPE + 2 >= 
+#FORMULA003=_CLEVEL _DEPTH 4 - >= _CLEVEL 19 >= ||
+#FORMULA004=_CLEVEL _DEPTH 5 + >= _CLEVEL 19 >= ||
+#FORMULA005=_CLEVEL _DEPTH  >= _CLEVEL 19 >= ||
+#FORMULA006=_CLEVEL 30 >= _ACCW 5 >= ||
+#FORMULA007=_ESP _SINV || _DINV || 
+#FORMULA008=_RCOLD _RELEC + _RACID + 1 >=
+#FORMULA009=_CLEVEL _DEPTH 5 + >= _CLEVEL 38 > ||
+#FORMULA010=_CLEVEL _DEPTH 8 + >= _CLEVEL 38 > ||
+#FORMULA011=_CLEVEL 38 - 2 * 30 + _DEPTH >= _CLEVEL 45 > ||
+#FORMULA012=_CLEVEL _DEPTH 10 - >= _CLEVEL 43 > ||
+#FORMULA013=_CLEVEL _DEPTH 13 - >= _CLEVEL 46 > ||
+#FORMULA014=_CLEVEL _DEPTH 8 - >= _CLEVEL 41 > ||
+#FORMULA015=_CLEVEL _DEPTH 7 - >= _CLEVEL 40 > ||
+#FORMULA016=_ATELEPORT _AESCAPE + 6 >= 
+#FORMULA017=_CLEVEL 30 >= _ACCW _ACSW + 10 >= ||
+#FORMULA018=_SHLIFE _CLEVEL 50 = || 
+#FORMULA019=_HEAL _EZHEAL || 
+#FORMULA020=_HEAL 1 > _EZHEAL ||
+#FORMULA021=_WMAXDAM 20 * _BLOWS 1 + *
+#           see also formulas 81+
+#FORMULA022=_WBASEDAM _BLOWS * 1 * _WSANIMAL *
+#FORMULA023=_WBASEDAM _BLOWS * 140 * _WSEVIL * 
+#FORMULA024=_WBASEDAM _BLOWS * 150 * _WSUNDEAD * _WKUNDEAD ! *
+#FORMULA025=_WBASEDAM _BLOWS * 90 * _WSDEMON * _WKDEMON ! *
+#FORMULA026=_WBASEDAM _BLOWS * 20 * _WSORC * 
+#FORMULA027=_WBASEDAM _BLOWS * 45 * _WSTROLL * 
+#FORMULA028=_WBASEDAM _BLOWS * 180 * _WSDRAGON * _WKDRAGON ! *
+#FORMULA029=_WBASEDAM _BLOWS * 120 * _WSGIANT * 
+#FORMULA030=_WBASEDAM _BLOWS * 130 * _WBACID * 
+#FORMULA031=_WBASEDAM _BLOWS * 150 * _WBELEC * 
+#FORMULA032=_WBASEDAM _BLOWS * 90 * _WBFIRE * 
+#FORMULA033=_WBASEDAM _BLOWS * 90 * _WBCOLD * 
+#FORMULA034=_WBASEDAM _BLOWS * 250 * _WKDRAGON * 
+#      See formulas 81+
+#CND035=_STR 9 <
+#FORMULA036=_SPEED 110 < _SPEED 114 > || _SPEED 110 - * 2500 *
+#CND037=_MAXHP 500 >
+#FORMULA038=_MAXHP 500 - 100 *
+#CND039=_CLEVEL 25 <
+#CND040=_ESP !
+#FORMULA041=_CLEVEL 50 == _HLIFE && 200 * _CLEVEL 50 != _HLIFE && 2000 * +
+#FORMULA042=_RCOLD _RFIRE && _RACID && _RELEC && 10000 *
+#FORMULA043=_SSTR _SINT && _SWIS && _SCON && _SDEX && 1000 *
+#FORMULA044=_SINV _ESP || 100000 *
+#CND045=_CLEVEL 50 !=
+#CND046=_ARMOR 15 <
+#CND047=_ARMOR 15 >= _ARMOR 75 < &&
+#CND048=_ARMOR 75 >= 
+#FORMULA049=_RCOLD _RFIRE && _RACID && _RELEC && 100000 *
+#CND050=_CDEPTH 90 >
+#CND051=_REG 1 >= 
+#CND052=_ITEM419 0 ==
+#CND056=_CLEVEL 1 ==
+#CND057=_MAXSP 100 >
+#CND058=_STR 15 >
+#CND059 _IFIRE !
+#CND060 _ICOLD !
+#FORMULA061= _AHWORD 1000 >=
+#CND062=_RCONF ! _CLEVEL 35 < ||
+#CND063=_RCONF !
+#FORMULA064=_ADJSP 35000 *
+#CND065=_RBLIND !
+#FORMULA066=_ADJSP 35000 *
+#CND067=_RPOIS !
+#FORMULA068=_WBASEDAM _BLOWS * 90 * _WBPOIS * 
+#
+#FORMULA071=_ITEM324 _ITEM327 + 3 < _ITEM324 _ITEM327 + * 500 *
+#FORMULA072=_ITEM324 _ITEM327 + 3 >= 3 * 500 *
+#FORMULA073=_CDEPTH ! _CURHP 60 >= ||
+#FORMULA074=_CDEPTH ! _CURHP 80 >= ||
+#FORMULA075=_CDEPTH ! _CLEVEL 6 >= ||
+#FORMULA076=_CDEPTH ! _CLEVEL 15 >= ||
+#FORMULA077=_CDEPTH ! _CLEVEL 10 >= ||
+
+#CND080=_STR 7 >
+#
+#Also see formulas 22-34
+#FORMULA081=_WBASEDAM _BLOWS * 40 * _WSORC * _WSEVIL ! *
+#FORMULA082=_WBASEDAM _BLOWS * 45 * _WSTROLL * _WSEVIL ! *
+#FORMULA083=_WBASEDAM _BLOWS * 20 * _WSANIMAL * _WBELEC ! *
+#FORMULA085=_WBASEDAM _BLOWS * 175 * _WKUNDEAD * 
+#FORMULA086=_WBASEDAM _BLOWS * 150 * _WKDEMON * 
+#CND087= _CLEVEL 10 <=
+#FORMULA088= _FUEL 5 >= _LITE 1 >= || 
+#
+#(heal + ez_heal > 45) && (ez_heal > 30)
+#FORMULA111=_ITEM242 _EZHEAL + 45 > _EZHEAL 30 >= &&
+
+# things marked depth 99 and greater are ignored if Morgoth is dead
+REQ_CLASS999_DEPTH001_CURLITE=1 
+REQ_CLASS999_DEPTH001_FOOD=5 
+REQ_CLASS999_DEPTH002_CURLITE=2 
+REQ_CLASS999_DEPTH002_FORMULA088
+REQ_CLASS999_DEPTH002_RECALL=1 
+REQ_CLASS999_DEPTH002_CURHP=30 
+REQ_CLASS000_DEPTH003_CURHP=50
+REQ_CLASS000_DEPTH003_CLEVEL=4
+REQ_CLASS001_DEPTH003_CURHP=60
+REQ_CLASS001_DEPTH003_CLEVEL=11
+REQ_CLASS002_DEPTH003_CURHP=50
+REQ_CLASS002_DEPTH003_CLEVEL=9
+REQ_CLASS003_DEPTH003_CURHP=50
+REQ_CLASS003_DEPTH003_CLEVEL=8
+REQ_CLASS004_DEPTH003_CURHP=50
+REQ_CLASS004_DEPTH003_CLEVEL=4
+REQ_CLASS005_DEPTH003_CURHP=50
+REQ_CLASS005_DEPTH003_CLEVEL=4
+REQ_CLASS999_DEPTH003_FORMULA000
+
+# this isn't quite what the original code did but no matter, it is commmented
+# out in the original code.
+# REQ_CLASS999_DEPTH003_ID=2
+REQ_CLASS000_DEPTH005_FORMULA073
+REQ_CLASS000_DEPTH005_FORMULA075
+REQ_CLASS001_DEPTH005_FORMULA074
+REQ_CLASS001_DEPTH005_FORMULA076
+REQ_CLASS002_DEPTH005_FORMULA073
+REQ_CLASS002_DEPTH005_FORMULA076
+REQ_CLASS003_DEPTH005_FORMULA073
+REQ_CLASS003_DEPTH005_FORMULA077
+REQ_CLASS004_DEPTH005_FORMULA073
+REQ_CLASS004_DEPTH005_FORMULA075
+REQ_CLASS005_DEPTH005_FORMULA073
+REQ_CLASS005_DEPTH005_FORMULA075
+
+# this isn't quite what the original code did but no matter, it is commmented
+# out in the original code.
+# REQ_CLASS999_DEPTH005_ID=5
+REQ_CLASS999_DEPTH005_RECALL=2
+REQ_CLASS999_DEPTH010_FORMULA001
+REQ_CLASS999_DEPTH010_FORMULA002
+REQ_CLASS000_DEPTH011_FORMULA003
+REQ_CLASS001_DEPTH011_FORMULA004
+REQ_CLASS002_DEPTH011_FORMULA005
+REQ_CLASS003_DEPTH011_FORMULA005
+REQ_CLASS004_DEPTH011_FORMULA005
+REQ_CLASS005_DEPTH011_FORMULA005
+# REQ_CLASS999_DEPTH010_ID=10
+REQ_CLASS999_DEPTH010_FORMULA007
+
+REQ_CLASS999_DEPTH020_FORMULA006
+REQ_CLASS999_DEPTH020_FRACT=1
+
+REQ_CLASS999_DEPTH021_SRFIRE=1
+REQ_CLASS999_DEPTH021_FORMULA008
+REQ_CLASS999_DEPTH021_CSTR=7
+REQ_CLASS999_DEPTH021_CDEX=7
+REQ_CLASS999_DEPTH021_CCON=7
+REQ_CLASS001_DEPTH021_CINT=7
+REQ_CLASS003_DEPTH021_CINT=7
+REQ_CLASS004_DEPTH021_CINT=7
+REQ_CLASS002_DEPTH021_CWIS=7
+REQ_CLASS005_DEPTH021_CWIS=7
+REQ_CLASS000_DEPTH021_FORMULA009
+REQ_CLASS001_DEPTH021_FORMULA010
+REQ_CLASS001_DEPTH033_FORMULA011
+REQ_CLASS003_DEPTH021_FORMULA012
+REQ_CLASS002_DEPTH021_FORMULA013
+REQ_CLASS004_DEPTH021_FORMULA014
+REQ_CLASS005_DEPTH021_FORMULA015
+REQ_CLASS999_DEPTH026_FORMULA016
+REQ_CLASS999_DEPTH026_FORMULA017
+REQ_CLASS999_DEPTH030_ATELEPORT=1
+REQ_CLASS999_DEPTH030_SRCOLD=1
+REQ_CLASS999_DEPTH030_SRACID=1
+REQ_CLASS999_DEPTH030_SRELEC=1
+REQ_CLASS999_DEPTH034_CLEVEL=40
+REQ_CLASS999_DEPTH035_SRPOIS=1
+REQ_CLASS999_DEPTH040_CSTR=16
+REQ_CLASS999_DEPTH040_CDEX=16
+REQ_CLASS999_DEPTH040_CCON=16
+REQ_CLASS001_DEPTH040_CINT=16
+REQ_CLASS003_DEPTH040_CINT=16
+REQ_CLASS004_DEPTH040_CINT=16
+REQ_CLASS002_DEPTH040_CWIS=16
+REQ_CLASS005_DEPTH040_CWIS=16
+REQ_CLASS999_DEPTH046_SPEED=115
+REQ_CLASS999_DEPTH046_RCONF=1
+REQ_CLASS999_DEPTH046_CURHP=500
+REQ_CLASS999_DEPTH046_CSTR=58
+REQ_CLASS999_DEPTH046_CDEX=68
+REQ_CLASS001_DEPTH046_CINT=118
+REQ_CLASS003_DEPTH046_CINT=115
+REQ_CLASS004_DEPTH046_CINT=115
+REQ_CLASS002_DEPTH046_CWIS=118
+REQ_CLASS005_DEPTH046_CWIS=115
+REQ_CLASS999_DEPTH046_FORMULA018
+REQ_CLASS999_DEPTH046_FORMULA019
+REQ_CLASS999_DEPTH056_FORMULA020
+REQ_CLASS999_DEPTH056_SRBLIND=1
+#REQ_CLASS999_DEPTH056_SRNTHR=1
+REQ_CLASS999_DEPTH056_ESP=1
+REQ_CLASS999_DEPTH060_SPEED=120
+REQ_CLASS999_DEPTH060_SRKAOS=1
+REQ_CLASS999_DEPTH060_SRDIS=1
+REQ_CLASS999_DEPTH081_SPEED=130
+# p of restore Mana
+REQ_CLASS001_DEPTH100_ITEM266=10
+REQ_CLASS002_DEPTH100_ITEM266=10
+REQ_CLASS003_DEPTH100_ITEM266=10
+REQ_CLASS004_DEPTH100_ITEM266=10
+REQ_CLASS005_DEPTH100_ITEM266=10
+# p of Healing
+REQ_CLASS999_DEPTH100_FORMULA111
+# (heal + ez_heal > 45) && (ez_heal > 30)
+FORMULA111=_ITEM242 _EZHEAL + 45 > _EZHEAL 30 >= &&
+REQ_CLASS999_DEPTH100_EZHEAL=15
+# p of speed
+REQ_CLASS999_DEPTH100_ASPEED=10
+#REQ_CLASS999_DEPTH101_KING=1
+
+# Formulas are in (ew) reverse polish notation.  
+# Sorry, it was easiest to process.
+# I will comment translations above the formulas for 
+# people who are not reverse polish.
+# ((max_level >= 30) || ((ccw+csw) >= 2))
+FORMULA000=_CLEVEL 30 >= _ACCW _ACSW + 2 >= ||
+# ((max_level >= 30) || ((ccw+csw) >= 3))
+FORMULA001=_CLEVEL 30 >= _ACCW _ACSW + 3 >= ||
+# amt_teleport + amt_escape >= 2
+FORMULA002=_ATELEPORT _AESCAPE + 2 >= 
+# max_level >= depth - 4 || clevel >= 19
+FORMULA003=_CLEVEL _DEPTH 4 - >= _CLEVEL 19 >= ||
+# max_level >= depth + 5 || clevel >= 19
+FORMULA004=_CLEVEL _DEPTH 5 + >= _CLEVEL 19 >= ||
+# max_level >= depth || clevel >= 19
+FORMULA005=_CLEVEL _DEPTH  >= _CLEVEL 19 >= ||
+# ((max_level >= 30) || (CCW >= 5))
+FORMULA006=_CLEVEL 30 >= _ACCW 5 >= ||
+# see invis or telepathy
+FORMULA007=_ESP _SINV || _DINV ||
+# one resist (other than fire)
+FORMULA008=_RCOLD _RELEC + _RACID + 1 >=
+# max_level >= depth + 5 || max_level > 38
+FORMULA009=_CLEVEL _DEPTH 5 + >= _CLEVEL 38 > ||
+# max_level >= depth + 8 || max_level > 38
+FORMULA010=_CLEVEL _DEPTH 8 + >= _CLEVEL 38 > ||
+# (max_level-38)*2+30 <= dlevel (or clevel > 45)
+FORMULA011=_CLEVEL 38 - 2 * 30 + _DEPTH >= _CLEVEL 45 > ||
+# max_level >= depth - 10 || max_level > 43
+FORMULA012=_CLEVEL _DEPTH 10 - >= _CLEVEL 43 > ||
+# max_level >= depth - 13 || max_level > 46
+FORMULA013=_CLEVEL _DEPTH 13 - >= _CLEVEL 46 > ||
+# max_level >= depth - 8 || max_level >= 41
+FORMULA014=_CLEVEL _DEPTH 8 - >= _CLEVEL 41 > ||
+# max_level >= depth - 7 || max_level >= 40
+FORMULA015=_CLEVEL _DEPTH 7 - >= _CLEVEL 40 > ||
+
+# amt_teleport + amt_escape >= 6
+FORMULA016=_ATELEPORT _AESCAPE + 6 >= 
+
+# ((max_level >= 30) || ((ccw+csw) >= 10))
+FORMULA017=_CLEVEL 30 >= _ACCW _ACSW + 10 >= ||
+
+# if below level 50, must have hold life
+FORMULA018=_SHLIFE _CLEVEL 50 = || 
+
+# have some heal or ez heal
+FORMULA019=_HEAL _EZHEAL || 
+
+# have 2 heal or 1 ez heal
+FORMULA020=_HEAL 1 > _EZHEAL ||
+
+# Priests have Holy Word
+CND061= _AHWORD 1000 >=
+
+# HP must be more than x unless we are checking from town (_CDEPTH 0)
+FORMULA073=_CDEPTH ! _CURHP 60 >= ||
+FORMULA074=_CDEPTH ! _CURHP 80 >= ||
+# player level must be more than x0 unless we are checking from town (_CDEPTH 0)
+FORMULA075=_CDEPTH ! _CLEVEL 6 >= ||
+FORMULA076=_CDEPTH ! _CLEVEL 15 >= ||
+FORMULA077=_CDEPTH ! _CLEVEL 10 >= ||
+
+#BI_FUEL >= 5 || BI_LITE >= 1
+FORMULA088= _FUEL 5 >= _LITE 1 >= ||
+
+# Power calculations
+
+# CHANGE THIS AT YOUR OWN RISK.  Changes here can cause VERY STUPID borg
+# behavior.
+
+# Stuff left in code:  1) heavy armor gives a sliding loss of power
+#                      2) bad gloves on a mage, -275K
+#                      3) bad weapon on a priest, -75K
+#                      4) special bonus for one item with RNeth RDisn RChaos = 25K
+#                      5) special bonus for one item with RNeth RDisn = 15K
+#                      6) CSW reward (complex)
+#                      7) low level spell books (complex... need to know what you can cast)
+#                      8) state specific things.  This includes, enchant weapon scrolls when
+#                         weapon needs enchanting, restore stat potions, cures when injured in town,
+#                         and extra food when hungry
+#                      9) weight/encumbrance penalty (too complex)
+#                     10) reward for empty slots (to avoid carrying worthless junk) 4K/slot
+#
+
+# POWER_CLASSxxx_DEPTHxxx_CNDxxx_RANGExxxTOxxx_(special value)=xxx EACH
+
+# NOTE:  CND is optional.  It refers to a _FORMULA line later.  The formula will be 
+#        evalulated and, if it is 0, the power calc is skipped
+# NOTE:  EACH is optional. 
+# NOTE:  with range, only amounts in that range will count.
+#        so if range is RANGE006TO007 and you have 12, you get
+#        2 * the 'power' with 'each' or nothing if not each
+#        Range is ignored for formulas (gives an error)
+# NOTE:  _RANGE000TO999 is a special case. it means 'no range used'
+
+# things marked depth 99 and greater are ignored if Morgoth is dead
+
+# 20 per damage point * (blows + 1)
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA021
+FORMULA021=_WMAXDAM 20 * _BLOWS 1 + *
+POWER_CLASS999_DEPTH000_RANGE000TO999_TOHIT= 750 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_WTOHIT= 750 EACH
+# slays and such... yikes!
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA022
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA083
+#Brands rewarded if Kill Brand not there.
+#SAnimal is rewarded only if weapon is not electric brand.
+FORMULA022=_WBASEDAM _BLOWS * 1 * _WSANIMAL *
+FORMULA083=_WBASEDAM _BLOWS * 20 * _WSANIMAL * _WBELEC ! *
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA023
+FORMULA023=_WBASEDAM _BLOWS * 140 * _WSEVIL *
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA024
+FORMULA024=_WBASEDAM _BLOWS * 150 * _WSUNDEAD * _WKUNDEAD ! *
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA025
+FORMULA025=_WBASEDAM _BLOWS * 90 * _WSDEMON * _WKDEMON ! *
+#SOrc is rewarded more if slay evil is not possesed
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA026
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA081
+FORMULA026=_WBASEDAM _BLOWS * 20 * _WSORC * 
+FORMULA081=_WBASEDAM _BLOWS * 20 * _WSORC * _WSEVIL ! *
+#STroll is rewarded more if slay evil is not possesed
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA027
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA082
+FORMULA027=_WBASEDAM _BLOWS * 45 * _WSTROLL * 
+FORMULA082=_WBASEDAM _BLOWS * 45 * _WSTROLL * _WSEVIL ! *
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA028
+FORMULA028=_WBASEDAM _BLOWS * 180 * _WSDRAGON * _WKDRAGON ! *
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA029
+FORMULA029=_WBASEDAM _BLOWS * 120 * _WSGIANT * 
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA030
+FORMULA030=_WBASEDAM _BLOWS * 130 * _WBACID * 
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA031
+FORMULA031=_WBASEDAM _BLOWS * 150 * _WBELEC * 
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA032
+FORMULA032=_WBASEDAM _BLOWS * 90 * _WBFIRE * 
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA033
+FORMULA033=_WBASEDAM _BLOWS * 90 * _WBCOLD * 
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA033
+FORMULA068=_WBASEDAM _BLOWS * 90 * _WBPOIS * 
+#Kills brands
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA034
+FORMULA034=_WBASEDAM _BLOWS * 250 * _WKDRAGON * 
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA085
+FORMULA085=_WBASEDAM _BLOWS * 175 * _WKUNDEAD * 
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA086
+FORMULA086=_WBASEDAM _BLOWS * 150 * _WKDEMON * 
+
+POWER_CLASS999_DEPTH000_RANGE000TO999_WIMPACT=5000
+POWER_CLASS999_DEPTH000_CND080_RANGE000TO999_HEAVYWEPON=-8000
+CND080=_STR 7 >
+POWER_CLASS999_DEPTH000_RANGE000TO999_HEAVYBOW=-500000
+
+# Borg worships num_blow, even on broken swords.
+# kind 47 is a broken sword usually 1d2 in damage 
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM030=-90000
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM047=-90000
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM390=-90000
+
+# slings force you to carry heavy ammo.  Penalty for that unles you have lots of str
+POWER_CLASS999_DEPTH000_CND035_RANGE000TO999_WITEM077= -5000
+CND035=_STR 9 <
+
+#We want the borg to use whips and daggers at first
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_BLOWS= 45000 EACH
+CND087= _CLEVEL 10 <=
+
+# bow damage
+POWER_CLASS999_DEPTH000_RANGE000TO999_BMAXDAM= 9 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_TOHIT= 250 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_BTOHIT= 250 EACH
+#We want low level dudes to really like ranged weaps
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_BMAXDAM= 300 EACH
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_TOHIT= 300 EACH
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_BTOHIT= 300 EACH
+#We want low level dudes to buy a sling asap
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_WITEM073= 3000 
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_WITEM074= 3000 
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_WITEM075= 3000 
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_WITEM076= 3000 
+POWER_CLASS999_DEPTH000_CND087_RANGE000TO999_WITEM077= 3000 
+
+
+# Rangers perfer bows
+POWER_CLASS004_DEPTH000_RANGE000TO999_WITEM073= 30000
+POWER_CLASS004_DEPTH000_RANGE000TO999_WITEM074= 30000
+
+# Dragon armor liked for the activation.  (AJG: I adjusted this slightly)
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM400=1100
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM401=1100
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM402=1100
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM403=1100
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM404=2750
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM405=3250
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM406=5550
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM407=5650
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM408=5750
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM409=5850
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM410=5950
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM411=5975
+POWER_CLASS999_DEPTH000_RANGE000TO999_WITEM412=5999
+
+# Light bonuses
+POWER_CLASS999_DEPTH000_RANGE000TO000_CURLITE=-3000
+POWER_CLASS999_DEPTH000_RANGE001TO003_CURLITE=500000 EACH
+POWER_CLASS999_DEPTH000_RANGE003TO099_CURLITE=580000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT001=8000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT002=10000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT003=12000
+
+# Speed formulas are slightly complex.  Note negative for poor speed
+# 110 is the base speed
+# (Speed - 110) * 2500
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA036
+FORMULA036=_SPEED 110 < _SPEED 114 > || _SPEED 110 - * 2500 *
+POWER_CLASS999_DEPTH000_RANGE111TO999_SPEED= 1000 EACH
+POWER_CLASS999_DEPTH000_RANGE110TO114_SPEED= 55000
+POWER_CLASS999_DEPTH000_RANGE115TO119_SPEED= 75000
+POWER_CLASS999_DEPTH000_RANGE120TO124_SPEED= 100000
+POWER_CLASS999_DEPTH000_RANGE125TO129_SPEED= 125000
+POWER_CLASS999_DEPTH000_RANGE130TO134_SPEED= 140000
+POWER_CLASS999_DEPTH000_RANGE135TO139_SPEED= 155000
+POWER_CLASS999_DEPTH000_RANGE140TO144_SPEED= 165000
+POWER_CLASS999_DEPTH000_RANGE145TO149_SPEED= 170000
+POWER_CLASS999_DEPTH000_RANGE150TO999_SPEED= 175000
+
+# stat bonuses
+POWER_CLASS999_DEPTH000_RANGE000TO999_STR= 100 EACH
+# note: division of bonus based on class
+POWER_CLASS001_DEPTH000_RANGE000TO999_INT= 200 EACH
+POWER_CLASS002_DEPTH000_RANGE000TO999_WIS= 200 EACH
+POWER_CLASS003_DEPTH000_RANGE000TO999_INT= 200 EACH
+POWER_CLASS004_DEPTH000_RANGE000TO999_INT= 200 EACH
+POWER_CLASS005_DEPTH000_RANGE000TO999_WIS= 200 EACH
+# we can't directly give a bonus for mana or your bonus 
+# would adjust as you cast spells.  Instead we give a 
+# bonus for 'mana adjustment' based on stats 
+POWER_CLASS001_DEPTH000_RANGE000TO999_ADJSP= 255 EACH
+POWER_CLASS002_DEPTH000_RANGE000TO999_ADJSP= 250 EACH
+POWER_CLASS003_DEPTH000_RANGE000TO999_ADJSP= 155 EACH
+POWER_CLASS004_DEPTH000_RANGE000TO999_ADJSP= 155 EACH
+POWER_CLASS005_DEPTH000_RANGE000TO999_ADJSP= 150 EACH
+# The fail rate is based on the table adj_mag_stat[]
+POWER_CLASS001_DEPTH000_RANGE000TO999_SFAIL1= 5010 EACH
+POWER_CLASS002_DEPTH000_RANGE000TO999_SFAIL1= 5000 EACH
+POWER_CLASS003_DEPTH000_RANGE000TO999_SFAIL1= 3010 EACH
+POWER_CLASS004_DEPTH000_RANGE000TO999_SFAIL1= 3010 EACH
+POWER_CLASS005_DEPTH000_RANGE000TO999_SFAIL1= 3000 EACH
+# This is the 'min fail rate' and it is nice if it is 0
+# (note range 0 to 0) (I hope this works)
+POWER_CLASS001_DEPTH000_RANGE000TO002_SFAIL2= 70000
+POWER_CLASS002_DEPTH000_RANGE000TO002_SFAIL2= 70000
+# Priests with Holy Word legal try to maximize WIS
+POWER_CLASS002_DEPTH000_CND061_RANGE000TO999_FORMULA064
+FORMULA064=_ADJSP 35000 *
+
+POWER_CLASS999_DEPTH000_RANGE000TO999_DEX= 120 EACH
+# like spell points, hit points are 'powered' based on your hp bonus
+# which is based on your con and adj_con_mhp[]
+POWER_CLASS999_DEPTH000_RANGE000TO999_CON= 150 EACH
+# first 500 hp's are more important than the next 500
+POWER_CLASS999_DEPTH000_RANGE000TO500_MAXHP= 350 EACH
+# can't use the range because of the 999 max :-(
+POWER_CLASS999_DEPTH000_CND037_RANGE000TO999_FORMULA038
+CND037=_MAXHP 500 >
+FORMULA038=_MAXHP 500 - 100 *
+# charisma is only nice at low levels
+POWER_CLASS999_DEPTH000_CND039_RANGE000TO999_CHR= 2 EACH
+CND039=_CLEVEL 25 <
+
+# 'minor' skills
+POWER_CLASS999_DEPTH000_RANGE000TO999_DIS= 2 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_DEV= 25 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_SAV= 25 EACH
+POWER_CLASS999_DEPTH000_RANGE100TO999_SAV= 10000
+POWER_CLASS999_DEPTH000_RANGE000TO999_STL= 2 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_SRCH= 1 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_SERCHFREQ= 1 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_THN= 5 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_THB= 35 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_THT= 2 EACH
+POWER_CLASS999_DEPTH000_RANGE000TO999_DIG= 2 EACH
+
+# other powers
+POWER_CLASS999_DEPTH000_RANGE000TO999_SDIG= 750
+
+# note: after depth 20 you only get 50 for Feather fall (500-450)
+POWER_CLASS999_DEPTH000_RANGE000TO999_FEATH= 500
+POWER_CLASS999_DEPTH020_RANGE000TO999_FEATH= -450
+POWER_CLASS999_DEPTH000_RANGE000TO999_LITE= 2000
+# 500 for ESP & See inv, 5000 for just see inv (ESP is rewarded later)
+POWER_CLASS999_DEPTH000_RANGE000TO999_SINV= 500
+POWER_CLASS999_DEPTH000_CND040_RANGE000TO999_SINV= 4500
+CND040=_ESP !
+POWER_CLASS999_DEPTH000_RANGE000TO999_FRACT= 10000
+# only 200 pts for Hold Life if you have maxed out your level
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA041
+FORMULA041=_CLEVEL 50 == _HLIFE && 200 * _CLEVEL 50 != _HLIFE && 2000 * +
+POWER_CLASS999_DEPTH000_RANGE000TO999_REG= 2000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ESP= 80000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ICOLD= 50000
+POWER_CLASS999_DEPTH000_RANGE000TO999_IELEC= 25000
+POWER_CLASS999_DEPTH000_RANGE000TO999_IFIRE= 70000
+POWER_CLASS999_DEPTH000_RANGE000TO999_IACID= 30000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RCOLD= 3000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RELEC= 4000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RACID= 6000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RFIRE= 8000
+# special bonus for base 4 resists
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA042
+FORMULA042=_RCOLD _RFIRE && _RACID && _RELEC && 10000 *
+POWER_CLASS999_DEPTH000_RANGE000TO999_RPOIS= 20000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RSND= 3500
+POWER_CLASS999_DEPTH000_RANGE000TO999_RLITE= 800
+POWER_CLASS999_DEPTH000_RANGE000TO999_RDARK= 800
+POWER_CLASS999_DEPTH000_RANGE000TO999_RKAOS= 5000
+# note, this is especially high because some items (CCW) give 
+# extra bonuses if you don't have RCONF, so we need to ensure
+# you will not do that -instead- of getting RCONF
+POWER_CLASS999_DEPTH000_RANGE000TO999_RCONF= 80000
+# and a little extra for a mage.
+POWER_CLASS001_DEPTH000_RANGE000TO999_RCONF= 2000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RDIS= 5000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RSHRD= 100
+POWER_CLASS999_DEPTH000_RANGE000TO999_RNXUS= 100
+POWER_CLASS999_DEPTH000_RANGE000TO999_RBLIND= 5000
+POWER_CLASS999_DEPTH000_RANGE000TO999_RNTHR= 5500
+POWER_CLASS999_DEPTH000_RANGE000TO999_RFEAR= 2000
+# sustains
+# note: don't care about SCHR
+POWER_CLASS999_DEPTH000_RANGE000TO999_SSTR= 50
+POWER_CLASS999_DEPTH000_RANGE000TO999_SINT= 50
+POWER_CLASS999_DEPTH000_RANGE000TO999_SWIS= 50
+POWER_CLASS999_DEPTH000_RANGE000TO999_SCON= 50
+POWER_CLASS999_DEPTH000_RANGE000TO999_SDEX= 50
+# special bonus for sustain all
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA043
+FORMULA043=_SSTR _SINT && _SWIS && _SCON && _SDEX && 1000 *
+
+# special rewards for 'must have' (based on requirements above)
+POWER_CLASS999_DEPTH009_RANGE000TO999_FORMULA044
+FORMULA044=_SINV _ESP || 100000 *
+POWER_CLASS999_DEPTH019_RANGE000TO999_FRACT= 100000
+POWER_CLASS999_DEPTH024_RANGE000TO999_RFIRE= 100000
+POWER_CLASS999_DEPTH035_RANGE000TO999_RPOIS= 100000
+POWER_CLASS999_DEPTH030_RANGE000TO999_RELEC= 100000
+POWER_CLASS999_DEPTH030_RANGE000TO999_RACID= 100000
+POWER_CLASS999_DEPTH030_RANGE000TO999_RCOLD= 100000
+POWER_CLASS999_DEPTH040_RANGE000TO999_RCONF= 100000
+POWER_CLASS999_DEPTH045_CND045_RANGE000TO999_HLIFE= 100000
+CND045=_CLEVEL 50 !=
+POWER_CLASS999_DEPTH045_RANGE115TO999_SPEED= 100000
+# note: Resist nether shows up several times... it is important
+POWER_CLASS999_DEPTH049_RANGE000TO999_RNTHR= 55000
+POWER_CLASS999_DEPTH049_RANGE000TO999_RSND= 100000
+POWER_CLASS999_DEPTH054_RANGE000TO999_RBLIND= 100000
+POWER_CLASS999_DEPTH054_RANGE000TO999_ESP= 100000
+POWER_CLASS999_DEPTH059_RANGE000TO999_RNTHR= 55000
+POWER_CLASS999_DEPTH059_RANGE000TO999_RKAOS= 104000
+POWER_CLASS999_DEPTH059_RANGE000TO999_RDIS= 90000
+# speed above 120 gets a bonus
+POWER_CLASS999_DEPTH059_RANGE120TO999_SPEED= 100000
+# speed above 130 gets a bonus
+POWER_CLASS999_DEPTH079_RANGE130TO999_SPEED= 100000
+POWER_CLASS999_DEPTH079_RANGE000TO999_RNTHR= 15000
+POWER_CLASS999_DEPTH079_RANGE000TO999_RDARK= 25000
+# Warrior's get an extra bonus for speed about 140
+POWER_CLASS000_DEPTH079_RANGE140TO999_SPEED= 100000
+
+# AC Bonuses (dependant on level)
+POWER_CLASS999_DEPTH000_CND046_RANGE000TO999_ARMOR= 2000 EACH
+CND046=_ARMOR 15 <
+POWER_CLASS999_DEPTH000_CND047_RANGE000TO999_ARMOR= 500 EACH
+CND047=_ARMOR 15 >= _ARMOR 75 < &&
+POWER_CLASS999_DEPTH000_CND048_RANGE000TO999_ARMOR= 100 EACH
+CND048=_ARMOR 75 >= 
+
+# cursed items
+POWER_CLASS999_DEPTH000_RANGE000TO999_CRSTELE= -100000
+POWER_CLASS000_DEPTH000_RANGE000TO999_CRSAGRV= -80000
+POWER_CLASS001_DEPTH000_RANGE000TO999_CRSAGRV= -8000
+POWER_CLASS002_DEPTH000_RANGE000TO999_CRSAGRV= -80000
+POWER_CLASS003_DEPTH000_RANGE000TO999_CRSAGRV= -80000
+POWER_CLASS004_DEPTH000_RANGE000TO999_CRSAGRV= -80000
+POWER_CLASS005_DEPTH000_RANGE000TO999_CRSAGRV= -80000
+
+# Depth 99+, assume going after Morgoth.
+# note: these are ignored if Morgoth is dead
+#POWER_CLASS999_DEPTH099_RANGE000TO999_SSTR= 35000
+#POWER_CLASS001_DEPTH099_RANGE000TO999_SINT= 45000
+#POWER_CLASS003_DEPTH099_RANGE000TO999_SINT= 45000
+#POWER_CLASS004_DEPTH099_RANGE000TO999_SINT= 45000
+#POWER_CLASS002_DEPTH099_RANGE000TO999_SWIS= 35000
+#POWER_CLASS005_DEPTH099_RANGE000TO999_SWIS= 35000
+#POWER_CLASS999_DEPTH099_RANGE000TO999_SCON= 55000
+#POWER_CLASS999_DEPTH099_RANGE000TO999_SDEX= 15000
+#POWER_CLASS999_DEPTH099_RANGE000TO999_WSEVIL= 15000
+#POWER_CLASS999_DEPTH099_RANGE000TO999_RNTHR= 15000
+#POWER_CLASS999_DEPTH099_RANGE000TO999_RDIS= 15000
+#POWER_CLASS999_DEPTH099_RANGE000TO999_RPOIS= 100000
+#Pots of Berserk Str for non Priest/Mage
+POWER_CLASS000_DEPTH099_RANGE000TO999_ITEM258= 2000 EACH
+POWER_CLASS003_DEPTH099_RANGE000TO999_ITEM258= 2000 EACH
+POWER_CLASS004_DEPTH099_RANGE000TO999_ITEM258= 2000 EACH
+POWER_CLASS005_DEPTH099_RANGE000TO999_ITEM258= 2000 EACH
+
+#POWER_CLASS999_DEPTH099_RANGE000TO999_FORMULA049
+FORMULA049=_RCOLD _RFIRE && _RACID && _RELEC && 100000 *
+
+#POWER_CLASS999_DEPTH099_RANGE000TO999_AGLYPH= 2500 EACH
+
+# artifact activation bonuses
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT001= 1500
+POWER_CLASS001_DEPTH000_RANGE000TO999_ARTIFACT001= 500
+POWER_CLASS002_DEPTH000_RANGE000TO999_ARTIFACT001= 500
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT001= 1000
+POWER_CLASS004_DEPTH000_RANGE000TO999_ARTIFACT001= 1000
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT001= 1000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT002= 1200
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT001= 2000
+POWER_CLASS001_DEPTH000_RANGE000TO999_ARTIFACT003= 2000
+POWER_CLASS002_DEPTH000_RANGE000TO999_ARTIFACT003= 1500
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT003= 2000
+POWER_CLASS004_DEPTH000_RANGE000TO999_ARTIFACT003= 2000
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT003= 2000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT067= 527
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT068= 518
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT069= 524
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT070= 596
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT072= 554
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT082= 700
+# NOTE: Don't do this if you are using random artifacts (ringil speed bonus)
+# POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT082= 25000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT083= 644
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT093= 620
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT097= 700
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT112= 700
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT115= 644
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT122= 590
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT016= 800
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT053= 507
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT054= 540
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT055= 527
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT056= 518
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT057= 522
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT059= 650
+# NOTE: Don't do this if you are using random artifacts (Feanor special bonus)
+# POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT060= 5000
+# Ok so I fudged this one: Dispel Evil (it was a nice formula in the code)
+# I took a random average
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT005= 650
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT010= 740
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT011= 900
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT012= 1000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT013= 999999
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT108= 1000
+POWER_CLASS001_DEPTH000_RANGE000TO999_ARTIFACT108= 500
+POWER_CLASS002_DEPTH000_RANGE000TO999_ARTIFACT108= 1000
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT108= 1000
+POWER_CLASS004_DEPTH000_RANGE000TO999_ARTIFACT108= 1000
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT108= 1000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT017= 650
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT017= 25000
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT017= 25000
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT017= 25000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT044= 650
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT044= 25000
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT044= 25000
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT044= 25000
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT045= 7500
+POWER_CLASS001_DEPTH000_RANGE000TO999_ARTIFACT045= 500
+POWER_CLASS002_DEPTH000_RANGE000TO999_ARTIFACT045= 500
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT045= 700
+POWER_CLASS004_DEPTH000_RANGE000TO999_ARTIFACT045= 700
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT045= 700
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT046= 600
+POWER_CLASS001_DEPTH000_RANGE000TO999_ARTIFACT046= 500
+POWER_CLASS002_DEPTH000_RANGE000TO999_ARTIFACT046= 600
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT046= 600
+POWER_CLASS004_DEPTH000_RANGE000TO999_ARTIFACT046= 600
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT046= 600
+POWER_CLASS000_DEPTH000_RANGE000TO999_ARTIFACT061= 700
+POWER_CLASS001_DEPTH000_RANGE000TO999_ARTIFACT061= 500
+POWER_CLASS002_DEPTH000_RANGE000TO999_ARTIFACT061= 500
+POWER_CLASS003_DEPTH000_RANGE000TO999_ARTIFACT061= 700
+POWER_CLASS004_DEPTH000_RANGE000TO999_ARTIFACT061= 700
+POWER_CLASS005_DEPTH000_RANGE000TO999_ARTIFACT061= 700
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT126= 800
+# NOTE: Don't do this if you are using random artifacts (Cubragol speed)
+# POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT126= 25000
+POWER_CLASS999_DEPTH000_RANGE000TO999_ARTIFACT031= 500
+
+# Condition 058 is used miltiple times relating to inventory
+# items.  Weak characters need to not be slow.
+CND058=_STR 15 >
+
+# Inventory items
+POWER_CLASS999_DEPTH000_RANGE001TO006_FUEL= 60000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE007TO008_FUEL= 500 EACH
+POWER_CLASS999_DEPTH000_RANGE001TO008_FOOD= 50000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE009TO015_FOOD= 200 EACH
+# Carry extra food if Regen 
+POWER_CLASS999_DEPTH000_CND051_RANGE000TO015_FOOD= 700 EACH
+CND051=_REG 1 >= _CLEVEL 20 <= &&
+# ID scrolls, but not too many if Low Strength
+POWER_CLASS999_DEPTH000_RANGE001TO004_ID= 6000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE005TO010_ID= 6000 EACH
+# This is *ID*
+POWER_CLASS999_DEPTH000_RANGE001TO003_ITEM177= 10000 EACH
+POWER_CLASS999_DEPTH000_RANGE005TO010_ITEM177= 2000 EACH
+POWER_CLASS999_DEPTH000_RANGE001TO005_APFE= 10000 EACH
+POWER_CLASS999_DEPTH000_RANGE006TO010_APFE= 2000 EACH
+POWER_CLASS999_DEPTH000_RANGE001TO005_AGLYPH= 10000 EACH
+POWER_CLASS999_DEPTH000_RANGE006TO010_AGLYPH= 2000 EACH
+POWER_CLASS999_DEPTH000_RANGE001TO003_RECALL= 50000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE004TO007_RECALL= 5000 EACH
+# Resist Heat and Cold for Warriors (for now)
+POWER_CLASS000_DEPTH000_CND059_RANGE001TO004_ARESHEAT= 500 EACH
+CND059=_IFIRE !
+POWER_CLASS000_DEPTH000_CND060_RANGE001TO004_ARESCOLD= 500 EACH
+CND060=_ICOLD !
+# scrolls of phase door
+POWER_CLASS999_DEPTH000_RANGE000TO004_APHASE= 50000 EACH
+POWER_CLASS999_DEPTH000_RANGE005TO008_APHASE= 1000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE009TO015_APHASE= 500 EACH
+POWER_CLASS999_DEPTH000_RANGE001TO009_AESCAPE= 10000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE010TO015_AESCAPE= 5000 EACH
+POWER_CLASS999_DEPTH090_CND050_RANGE006TO015_AESCAPE= 10000 EACH
+CND050=_CDEPTH 90 >
+POWER_CLASS999_DEPTH000_RANGE001TO005_ATELEPORT= 10000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE006TO010_ATELEPORT= 10000 EACH
+#POWER_CLASS999_DEPTH000_RANGE001TO005_ATELEPORTLVL= 10000 EACH
+
+# Healing stuff gets complex and is very class dependant
+POWER_CLASS000_DEPTH000_RANGE001TO020_HEAL= 8000 EACH
+POWER_CLASS003_DEPTH000_RANGE001TO020_HEAL= 8000 EACH
+# *HEAL*
+POWER_CLASS999_DEPTH000_RANGE001TO002_ITEM419= 10000 EACH
+# first two LIFE give 9000 if you have no *HEAL*
+POWER_CLASS999_DEPTH000_CND052_RANGE001TO002_ITEM420= 9000
+CND052=_ITEM419 0 ==
+# rod of healing
+POWER_CLASS000_DEPTH000_RANGE001TO002_ITEM374= 20000 EACH
+POWER_CLASS003_DEPTH000_RANGE001TO002_ITEM374= 20000 EACH
+POWER_CLASS001_DEPTH000_RANGE001TO020_HEAL= 4000 EACH
+POWER_CLASS004_DEPTH000_RANGE001TO020_HEAL= 4000 EACH
+POWER_CLASS005_DEPTH000_RANGE001TO020_HEAL= 4000 EACH
+POWER_CLASS001_DEPTH000_RANGE001TO002_ITEM419= 9000 EACH
+POWER_CLASS004_DEPTH000_RANGE001TO002_ITEM419= 9000 EACH
+POWER_CLASS005_DEPTH000_RANGE001TO002_ITEM419= 9000 EACH
+# make sure level 1 Priest sell thier healing potion for quick cash
+POWER_CLASS002_DEPTH000_CND056_RANGE000TO999_ITEM242= -2000 EACH
+CND056=_CLEVEL 1 ==
+POWER_CLASS002_DEPTH000_RANGE000TO010_ITEM242= 2000 EACH
+
+# if your max mana is more than 100, reward up to ten restore manas
+POWER_CLASS999_DEPTH000_CND057_RANGE001TO010_ITEM266= 4000 EACH
+CND057=_MAXSP 100 >
+# and some magi staff charges
+POWER_CLASS999_DEPTH000_CND057_RANGE001TO100_ASTFMAGI= 4000 EACH
+
+POWER_CLASS999_DEPTH000_RANGE001TO005_ACCW= 5000 EACH
+POWER_CLASS999_DEPTH000_CND058_RANGE006TO010_ACCW= 5000 EACH
+# next 5 at 500 if you done have resist conf or are below level 35
+POWER_CLASS999_DEPTH000_CND062_RANGE011TO015_ACCW= 500 EACH
+CND062=_RCONF ! _CLEVEL 35 < ||
+
+# If you don't have RCONF, give reward for collecting cure conf
+POWER_CLASS999_DEPTH000_CND063_RANGE001TO010_ITEM008= 400 EACH
+CND063=_RCONF !
+# If you don't have RBLIND, give reward for collecting cure blind
+POWER_CLASS999_DEPTH000_CND065_RANGE001TO005_ITEM006= 300 EACH
+CND065=_RBLIND !
+# If you don't have RPOIS, give reward for collecting cure pois
+POWER_CLASS999_DEPTH000_CND067_RANGE001TO005_ACUREPOIS= 250 EACH
+CND067=_RPOIS !
+POWER_CLASS999_DEPTH000_RANGE000TO999_ADETTRAP= 4000 
+POWER_CLASS999_DEPTH000_RANGE000TO999_ADETDOOR= 2000 
+POWER_CLASS999_DEPTH000_RANGE000TO999_ADETEVIL= 1000
+POWER_CLASS999_DEPTH000_RANGE000TO999_AMAGICMAP= 4000 
+POWER_CLASS999_DEPTH000_RANGE000TO999_ALITE= 1000 
+# Genocide - only collect when deep
+POWER_CLASS999_DEPTH100_RANGE001TO010_ITEM207= 10000 EACH
+POWER_CLASS999_DEPTH100_RANGE011TO020_ITEM207= 2000 EACH
+# Mass Genocide - only collect when deep
+POWER_CLASS999_DEPTH100_RANGE001TO010_ITEM200= 10000 EACH
+POWER_CLASS999_DEPTH100_RANGE011TO020_ITEM200= 2000 EACH
+
+POWER_CLASS999_DEPTH000_RANGE001TO005_ARECHARGE= 5000 EACH
+
+POWER_CLASS000_DEPTH000_RANGE001TO010_AMISSILES= 1000 EACH
+POWER_CLASS001_DEPTH000_RANGE001TO010_AMISSILES= 1000 EACH
+POWER_CLASS002_DEPTH000_RANGE001TO010_AMISSILES= 1000 EACH
+POWER_CLASS003_DEPTH000_RANGE001TO010_AMISSILES= 1000 EACH
+POWER_CLASS004_DEPTH000_RANGE001TO020_AMISSILES= 1000 EACH
+POWER_CLASS005_DEPTH000_RANGE001TO010_AMISSILES= 1000 EACH
+POWER_CLASS000_DEPTH000_CND058_RANGE011TO040_AMISSILES= 100 EACH
+POWER_CLASS001_DEPTH000_CND058_RANGE011TO040_AMISSILES= 100 EACH
+POWER_CLASS002_DEPTH000_CND058_RANGE011TO040_AMISSILES= 100 EACH
+POWER_CLASS003_DEPTH000_CND058_RANGE011TO040_AMISSILES= 100 EACH
+POWER_CLASS004_DEPTH000_CND058_RANGE021TO070_AMISSILES= 100 EACH
+POWER_CLASS005_DEPTH000_CND058_RANGE011TO040_AMISSILES= 100 EACH
+#too many missiles
+POWER_CLASS000_DEPTH000_RANGE050TO999_AMISSILES= -1000 EACH
+POWER_CLASS001_DEPTH000_RANGE050TO999_AMISSILES= -1000 EACH
+POWER_CLASS002_DEPTH000_RANGE050TO999_AMISSILES= -1000 EACH
+POWER_CLASS003_DEPTH000_RANGE050TO999_AMISSILES= -1000 EACH
+POWER_CLASS004_DEPTH000_RANGE075TO999_AMISSILES= -1000 EACH
+POWER_CLASS005_DEPTH000_RANGE050TO999_AMISSILES= -1000 EACH
+
+# Potions of Detonations 
+POWER_CLASS999_DEPTH000_RANGE001TO020_ADETONATE= 2000 EACH
+
+# If you have up to 3 staffs of power or holiness you get rewarded.
+#    first gets 2500
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA070
+FORMULA070=_ITEM324 _ITEM327 || 2500 *
+#    all three get 500
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA071
+FORMULA071=_ITEM324 _ITEM327 + 3 < _ITEM324 _ITEM327 + * 500 *
+POWER_CLASS999_DEPTH000_RANGE000TO999_FORMULA072
+FORMULA072=_ITEM324 _ITEM327 + 3 >= 3 * 500 *
+# If you have up to 3 staffs of destruction you get rewarded.
+POWER_CLASS999_DEPTH000_RANGE000TO999_ITEM307= 5000
+POWER_CLASS999_DEPTH000_RANGE000TO003_ITEM307= 200 EACH
+
+# Wand of Teleport Other (or Spells)
+POWER_CLASS999_DEPTH000_RANGE000TO999_ATPORTOTHER= 5000
+# bonus for Warriors
+POWER_CLASS000_DEPTH000_RANGE000TO999_ATPORTOTHER= 50000
+POWER_CLASS999_DEPTH000_RANGE000TO015_ATPORTOTHER= 1000 EACH
+
+# High Level Spell Books
+POWER_CLASS001_DEPTH000_RANGE001TO999_ITEM379= 300000
+POWER_CLASS003_DEPTH000_RANGE001TO999_ITEM379= 300000
+POWER_CLASS004_DEPTH000_RANGE001TO999_ITEM379= 300000
+POWER_CLASS002_DEPTH000_RANGE001TO999_ITEM384= 300000
+POWER_CLASS005_DEPTH000_RANGE001TO999_ITEM384= 300000
+POWER_CLASS001_DEPTH000_RANGE001TO999_ITEM380= 300000
+POWER_CLASS003_DEPTH000_RANGE001TO999_ITEM380= 300000
+POWER_CLASS004_DEPTH000_RANGE001TO999_ITEM380= 300000
+POWER_CLASS002_DEPTH000_RANGE001TO999_ITEM385= 300000
+POWER_CLASS005_DEPTH000_RANGE001TO999_ITEM385= 300000
+POWER_CLASS001_DEPTH000_RANGE001TO999_ITEM381= 300000
+POWER_CLASS003_DEPTH000_RANGE001TO999_ITEM381= 300000
+POWER_CLASS004_DEPTH000_RANGE001TO999_ITEM381= 300000
+POWER_CLASS002_DEPTH000_RANGE001TO999_ITEM386= 300000
+POWER_CLASS005_DEPTH000_RANGE001TO999_ITEM386= 300000
+POWER_CLASS001_DEPTH000_RANGE001TO999_ITEM382= 300000
+POWER_CLASS003_DEPTH000_RANGE001TO999_ITEM382= 300000
+POWER_CLASS004_DEPTH000_RANGE001TO999_ITEM382= 300000
+POWER_CLASS002_DEPTH000_RANGE001TO999_ITEM387= 300000
+POWER_CLASS005_DEPTH000_RANGE001TO999_ITEM387= 300000
+POWER_CLASS001_DEPTH000_RANGE001TO999_ITEM383= 300000
+POWER_CLASS003_DEPTH000_RANGE001TO999_ITEM383= 300000
+POWER_CLASS004_DEPTH000_RANGE001TO999_ITEM383= 300000
+POWER_CLASS002_DEPTH000_RANGE001TO999_ITEM388= 300000
+POWER_CLASS005_DEPTH000_RANGE001TO999_ITEM388= 300000
+
+
+
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg1.c angband-3.0.6-borg/src/borg1.c
--- angband-3.0.6/src/borg1.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg1.c	2005-10-09 21:28:40.000000000 -0700
@@ -0,0 +1,2674 @@
+/* File: borg1.c */
+/* Purpose: Low level stuff for the Borg -BEN- */
+#include "angband.h"
+
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+
+/* ** Changes made to make 3.0 work: **
+ * Silver ammo added to attack choices in borg6.c.
+ * Poison weapons, and ammo.
+ * Borg is cheating to know the flags on Dwarven, Gondolin, Fury items.
+ * Weapon Kill Slays added to borg4 and 6 and borg.txt
+ * Added all the new branded arrows to ranged attacks.
+ * Add some CF support for people who want want experiment
+ * Monsters throw Boulders---taken care of.
+ * New spell index system ok..
+ *
+ * New ego items with random extra powers need help:
+ *    need to know which items need the *ID*
+ * Spell adresses need verification
+ * Changes to spell damages to borg6.c needed
+ * Damage caps or changes to borg_danger() need verification
+ *
+ */
+
+/*
+ * This file contains various low level variables and routines.
+ */
+
+/* Date of the last change */
+char borg_engine_date[] = __DATE__;
+
+/*
+ * Borg information, ScreenSaver or continual play mode;
+ */
+int borg_respawn_race;
+int borg_respawn_class;
+int borg_respawn_str;
+int borg_respawn_int;
+int borg_respawn_wis;
+int borg_respawn_dex;
+int borg_respawn_con;
+int borg_respawn_chr;
+int borg_dump_level;
+int borg_save_death;
+bool borg_respawn_winners;
+int borg_delay_factor;
+
+
+/* dynamic borg stuff */
+bool borg_uses_swaps;
+bool borg_uses_calcs = TRUE;
+bool borg_worships_damage;
+bool borg_worships_speed;
+bool borg_worships_hp;
+bool borg_worships_mana;
+bool borg_worships_ac;
+bool borg_worships_gold;
+bool borg_plays_risky;
+bool borg_slow_optimizehome;
+bool borg_scums_uniques;
+int borg_chest_fail_tolerance;
+u32b borg_money_scum_amount;
+bool borg_self_scum; 	/* borg scums on his own */
+bool borg_lunal_mode;  /* see borg.txt */
+bool borg_self_lunal;  /* borg allowed to do this himself */
+
+/* HACK... this should really be a parm into borg_prepared */
+/*         I am just being lazy */
+bool borg_slow_return = FALSE;
+
+req_item **borg_required_item;
+int *n_req;
+power_item **borg_power_item;
+int *n_pwr;
+int *borg_has;
+int *borg_has_on;
+int *borg_artifact;
+int *borg_skill;
+int size_class;
+int size_depth;
+int size_obj;
+int *formula[1000];
+
+cptr prefix_pref[] =
+{
+/* personal attributes */
+    "_STR",
+    "_INT",
+    "_WIS",
+    "_DEX",
+    "_CON",
+    "_CHR",
+    "_CSTR",
+    "_CINT",
+    "_CWIS",
+    "_CDEX",
+    "_CCON",
+    "_CCHR",
+    "_SSTR",
+    "_SINT",
+    "_SWIS",
+    "_SDEX",
+    "_SCON",
+    "_SCHR",
+    "_LITE",
+    "_CURHP",
+    "_MAXHP",
+    "_CURSP",
+    "_MAXSP",
+    "_ADJSP",
+    "_SFAIL1",
+    "_SFAIL2",
+    "_CLEVEL",
+    "_MAXCLEVEL",
+    "_ESP",
+    "_CURLITE",
+    "_RECALL",
+    "_FOOD",  /* 29 */
+    "_SPEED",
+    "_SDIG",
+    "_FEATH",
+    "_REG",
+    "_SINV",
+    "_INFRA",
+    "_DIS",
+    "_DEV",
+    "_SAV",
+    "_STL",
+    "_SRCH",
+    "_SERCHFREQ",
+    "_THN",
+    "_THB",
+    "_THT",
+    "_DIG",
+    "_IFIRE",
+    "_IACID",
+    "_ICOLD",
+    "_IELEC",
+    "_RFIRE",
+    "_RCOLD",
+    "_RELEC",
+    "_RACID",
+    "_RPOIS",
+    "_RFEAR",
+    "_RLITE",
+    "_RDARK",
+    "_RBLIND",
+    "_RCONF",
+    "_RSND",
+    "_RSHRD",
+    "_RNXUS",
+    "_RNTHR",
+    "_RKAOS",
+    "_RDIS",
+    "_HLIFE",
+    "_FRACT",
+    "_SRFIRE", /* same as without S but includes swap */
+    "_SRCOLD",
+    "_SRELEC",
+    "_SRACID",
+    "_SRPOIS",
+    "_SRFEAR",
+    "_SRLITE",
+    "_SRDARK",
+    "_SRBLIND",
+    "_SRCONF",
+    "_SRSND",
+    "_SRSHRD",
+    "_SRNXUS",
+    "_SRNTHR",
+    "_SRKAOS",
+    "_SRDIS",
+    "_SHLIFE",
+    "_SFRACT",
+
+/* random extra variable */
+    "_DEPTH",  /* current depth being tested */
+    "_CDEPTH", /* borgs current depth */
+    "_MAXDEPTH", /* recall depth */
+    "_KING",    /* borg has won */
+
+/* player state things */
+    "_ISWEAK",
+    "_ISHUNGRY",
+    "_ISFULL",
+    "_ISGORGED",
+    "_ISBLIND",
+    "_ISAFRAID",
+    "_ISCONFUSED",
+    "_ISPOISONED",
+    "_ISCUT",
+    "_ISSTUN",
+    "_ISHEAVYSTUN",
+    "_ISPARALYZED",
+    "_ISIMAGE",
+    "_ISSTUDY",
+    "_ISSEARCHING",
+    "_ISFIXLEV",
+    "_ISFIXEXP",
+    "_ISFIXSTR",
+    "_ISFIXINT",
+    "_ISFIXWIS",
+    "_ISFIXDEX",
+    "_ISFIXCON",
+    "_ISFIXCHR",
+    "_ISFIXALL",
+
+/* some combat stuff */
+    "_ARMOR",
+    "_TOHIT",   /* base to hit, does not include weapon */
+    "_TODAM",   /* base to damage, does not include weapon */
+    "_WTOHIT",  /* weapon to hit */
+    "_WTODAM",  /* weapon to damage */
+    "_BTOHIT",  /* bow to hit */
+    "_BTODAM",  /* bow to damage */
+    "_BLOWS",
+    "_SHOTS",
+    "_WMAXDAM", /* max damage per round with weapon (normal blow) */
+                /* Assumes you can enchant to +8 if you are level 25+ */
+    "_WBASEDAM",/* max damage per round with weapon (normal blow) */
+                /* Assumes you have no enchantment */
+    "_BMAXDAM", /* max damage per round with bow (normal hit) */
+                /* Assumes you can enchant to +8 if you are level 25+ */
+    "_HEAVYWEPON",
+    "_HEAVYBOW",
+
+/* curses */
+    "_CRSTELE",
+    "_CRSAGRV",
+
+/* weapon attributes */
+    "_WSANIMAL",  /* WS = weapon slays */
+    "_WSEVIL",
+    "_WSUNDEAD",
+    "_WSDEMON",
+    "_WSORC",
+    "_WSTROLL",
+    "_WSGIANT",
+    "_WSDRAGON",
+    "_WKUNDEAD", /* WK = weapon kills */
+    "_WKDEMON",
+    "_WKDRAGON",
+    "_WIMPACT",
+    "_WBACID",     /* WB = Weapon Branded With */
+    "_WBELEC",
+    "_WBFIRE",
+    "_WBCOLD",
+    "_WBPOIS",
+
+
+/* amounts */
+	"_APHASE",
+    "_ATELEPORT",  /* all sources of teleport */
+    "_AESCAPE",     /* Staff, artifact (can be used when blind/conf) */
+    "_FUEL",
+    "_HEAL",
+    "_EZHEAL",
+    "_ID",
+    "_ASPEED",
+    "_ASTFMAGI",  /* Amount Staff Charges */
+    "_ASTFDEST",
+    "_ATPORTOTHER", /* How many Teleport Other charges you got? */
+    "_AMISSILES",  /* only ones for your current bow count */
+    "_ACUREPOIS",
+    "_ADETTRAP",
+    "_ADETDOOR",
+    "_ADETEVIL",
+    "_AMAGICMAP",
+    "_ALITE",
+    "_ARECHARGE",
+    "_APFE",      /* Protection from Evil */
+    "_AGLYPH",    /* Rune Protection */
+    "_ACCW",     /* CCW potions (just because we use it so often) */
+    "_ACSW",     /* CSW potions (+ CLW if cut) */
+    "_ARESHEAT", /* potions of res heat */
+    "_ARESCOLD", /* pot of res cold */
+    "_ATELEPORTLVL", /* scroll of teleport level */
+    "_AHWORD",      /* Holy Word prayer Legal*/
+	"_ADETONATE",      /* Potion of Detonation */
+	"_DINV",        /* See Inv Spell is Legal */
+    NULL
+};
+
+/*
+ * Some variables
+ */
+
+bool borg_active;       /* Actually active */
+bool borg_resurrect = FALSE;    /* continous play mode */
+
+bool borg_cancel;       /* Being cancelled */
+
+char genocide_target;   /* identity of the poor unsuspecting soul */
+int zap_slot;                  /* slot of a wand/staff---to avoid a game bug*/
+bool borg_casted_glyph;        /* because we dont have a launch anymore */
+int borg_stop_dlevel = -1;
+int borg_stop_clevel = -1;
+int borg_no_deeper = 127;
+bool borg_stop_king = TRUE;
+bool borg_dont_react = FALSE;
+int successful_target = 0;
+int sold_item_tval;
+int sold_item_sval;
+int sold_item_pval;
+int sold_item_store;
+int borg_numb_live_unique;
+int borg_living_unique_index;
+int borg_unique_depth;
+
+/*
+ * Various silly flags
+ */
+
+bool borg_flag_save = FALSE;    /* Save savefile at each level */
+bool borg_flag_dump = FALSE;    /* Save savefile at each death */
+bool borg_save = FALSE;        /* do a save next level */
+bool borg_graphics = FALSE;    /* rr9's graphics */
+bool borg_confirm_target = FALSE; /* emergency spell use */
+
+/*
+ * Use a simple internal random number generator
+ */
+
+bool borg_rand_quick;       /* Save system setting */
+
+u32b borg_rand_value;       /* Save system setting */
+
+u32b borg_rand_local;       /* Save personal setting */
+
+
+bool borg_do_star_id;
+
+
+/*
+ * Hack -- Time variables
+ */
+
+s16b borg_t = 0L;          /* Current "time" */
+s16b borg_t_morgoth = 0L;  /* Last time I saw Morgoth */
+s16b need_see_inviso = 0;    /* cast this when required */
+s16b borg_see_inv = 0;
+bool need_shift_panel = FALSE;    /* to spot offscreens */
+s16b when_shift_panel = 0L;
+s16b time_this_panel = 0L;   /* Current "time" on current panel*/
+bool vault_on_level;         /* Borg will search for a vault */
+int unique_on_level;
+bool scaryguy_on_level;     /* flee from certain guys */
+bool morgoth_on_level;
+bool borg_morgoth_position;
+
+
+bool breeder_level = FALSE;          /* Borg will shut door */
+s16b old_depth = 128;
+s16b borg_respawning = 0;
+s16b borg_hound_count = 0;
+s16b borg_lich_count = 0;
+s16b borg_demon_count = 0;
+s16b borg_angel_count = 0;
+s16b borg_wight_count = 0;
+s16b borg_no_retreat= 0;
+
+/*
+ * Hack -- Other time variables
+ */
+
+s16b when_call_lite;        /* When we last did call light */
+s16b when_wizard_lite;      /* When we last did wizard light */
+
+s16b when_detect_traps;     /* When we last detected traps */
+s16b when_detect_doors;     /* When we last detected doors */
+s16b when_detect_walls;     /* When we last detected walls */
+s16b when_detect_evil;      /* When we last detected monsters or evil */
+s16b when_last_kill_mult = 0;   /* When a multiplier was last killed */
+
+bool my_need_alter;        /* incase i hit a wall or door */
+bool my_no_alter;          /*  */
+bool my_need_redraw;        /* incase i hit a wall or door */
+bool borg_attempting_refresh_resist = FALSE;  /* for the Resistance spell */
+
+/*
+ * Some information
+ */
+
+s16b goal;          /* Goal type */
+
+bool goal_rising;       /* Currently returning to town */
+
+bool goal_leaving;      /* Currently leaving the level */
+
+bool goal_fleeing;      /* Currently fleeing the level */
+
+bool goal_fleeing_lunal; /* Fleeing level while in lunal Mode */
+
+bool borg_fleeing_town; /* Currently fleeing the level to return to town */
+
+bool goal_ignoring;     /* Currently ignoring monsters */
+
+int goal_recalling;     /* Currently waiting for recall, guessing the turns left */
+
+bool goal_less;         /* return to, but dont use, the next up stairs */
+
+s16b borg_times_twitch; /* how often twitchy on this level */
+s16b borg_escapes;      /* how often teleported on this level */
+
+bool stair_less;        /* Use the next "up" staircase */
+bool stair_more;        /* Use the next "down" staircase */
+
+s32b borg_began;        /* When this level began */
+s32b borg_time_town;    /* how long it has been since I was in town */
+
+s16b avoidance = 0;     /* Current danger thresh-hold */
+
+bool borg_failure;      /* Notice failure */
+
+bool borg_simulate;     /* Simulation flag */
+bool borg_attacking;        /* Simulation flag */
+bool borg_offsetting;    /* offset ball attacks */
+
+bool borg_completed;        /* Completed the level */
+bool borg_on_upstairs;      /* used when leaving a level */
+bool borg_on_dnstairs;      /* used when leaving a level */
+
+bool borg_needs_searching;  /* borg will search with each step */
+bool borg_full_damage;  /* make danger = full possible damage. */
+s16b borg_oldchp;		/* hit points last game turn */
+s16b borg_oldcsp;		/* mana points last game turn */
+
+/* defence flags */
+bool borg_prot_from_evil;
+bool borg_speed;
+bool borg_bless;
+bool borg_hero;
+bool borg_berserk;
+bool my_oppose_fire;
+bool my_oppose_cold;
+bool my_oppose_acid;
+bool my_oppose_pois;
+bool my_oppose_elec;
+s16b borg_game_ratio;  /* the ratio of borg time to game time */
+s16b borg_resistance;  /* borg is Resistant to all elements */
+s16b borg_no_rest_prep; /* borg wont rest for a few turns */
+
+bool borg_shield;
+bool borg_on_glyph;    /* borg is standing on a glyph of warding */
+bool borg_create_door;    /* borg is going to create doors */
+bool borg_sleep_spell;
+bool borg_sleep_spell_ii;
+bool borg_slow_spell;  /* borg is about to cast the spell */
+bool borg_confuse_spell;
+bool borg_fear_mon_spell;
+
+/*
+ * Current shopping information
+ */
+
+s16b goal_shop = -1;        /* Next shop to visit */
+s16b goal_ware = -1;        /* Next item to buy there */
+s16b goal_item = -1;        /* Next item to sell there */
+int borg_food_onsale = -1;      /* Are shops selling food? */
+int borg_fuel_onsale = -1;      /* Are shops selling fuel? */
+
+/*
+ * Location variables
+ */
+
+int w_x;            /* Current panel offset (X) */
+int w_y;            /* Current panel offset (Y) */
+int morgy_panel_y;
+int morgy_panel_x;
+
+int borg_target_y;
+int borg_target_x;  /* Current targetted location */
+
+int c_x;            /* Current location (X) */
+int c_y;            /* Current location (Y) */
+
+int g_x;            /* Goal location (X) */
+int g_y;            /* Goal location (Y) */
+
+/* BIG HACK! Assume only 10 cursed artifacts */
+int bad_obj_x[50];  /* Dropped cursed artifact at location (X) */
+int bad_obj_y[50];  /* Dropped cursed artifact at location (Y) */
+
+/*
+ * Some estimated state variables
+ */
+
+s16b my_stat_max[6];    /* Current "maximal" stat values */
+s16b my_stat_cur[6];    /* Current "natural" stat values */
+s16b my_stat_use[6];    /* Current "resulting" stat values */
+s16b my_stat_ind[6];    /* Current "additions" to stat values */
+bool my_need_stat_check[6];  /* do I need to check my stats? */
+
+s16b my_stat_add[6];  /* additions to stats  This will allow upgrading of */
+                      /* equiptment to allow a ring of int +4 to be traded */
+                      /* for a ring of int +6 even if maximized to allow a */
+                      /* later swap to be better. */
+
+s16b home_stat_add[6];
+
+int weapon_swap;    /* location of my swap weapon */
+int armour_swap;    /* my swap of armour */
+
+/* a 3 state boolean */
+/*-1 = not cursed, no help needed for it */
+/* 0 = light curse, needs light remove curse spell */
+/* 1 = heavy curse, needs heavy remove curse spell */
+int decurse_weapon_swap;  /* my swap is great, except its cursed */
+int enchant_weapon_swap_to_h;  /* my swap is great, except its cursed */
+int enchant_weapon_swap_to_d;  /* my swap is great, except its cursed */
+int decurse_armour_swap;  /* my swap is great, except its cursed */
+int enchant_armour_swap_to_a;  /* my swap is great, except its cursed */
+bool borg_wearing_cursed;
+
+s32b weapon_swap_value;
+s32b armour_swap_value;
+
+s16b weapon_swap_digger;
+byte weapon_swap_slay_animal;
+byte weapon_swap_slay_evil;
+byte weapon_swap_slay_undead;
+byte weapon_swap_slay_demon;
+byte weapon_swap_slay_orc;
+byte weapon_swap_slay_troll;
+byte weapon_swap_slay_giant;
+byte weapon_swap_slay_dragon;
+byte weapon_swap_kill_undead;
+byte weapon_swap_kill_demon;
+byte weapon_swap_kill_dragon;
+byte weapon_swap_impact;
+byte weapon_swap_brand_acid;
+byte weapon_swap_brand_elec;
+byte weapon_swap_brand_fire;
+byte weapon_swap_brand_cold;
+byte weapon_swap_brand_pois;
+byte weapon_swap_see_infra;
+byte weapon_swap_slow_digest;
+byte weapon_swap_aggravate;
+byte weapon_swap_teleport;
+byte weapon_swap_regenerate;
+byte weapon_swap_telepathy;
+byte weapon_swap_lite;
+byte weapon_swap_see_invis;
+byte weapon_swap_ffall;
+byte weapon_swap_free_act;
+byte weapon_swap_hold_life;
+byte weapon_swap_immune_fire;
+byte weapon_swap_immune_acid;
+byte weapon_swap_immune_cold;
+byte weapon_swap_immune_elec;
+byte weapon_swap_resist_acid;
+byte weapon_swap_resist_elec;
+byte weapon_swap_resist_fire;
+byte weapon_swap_resist_cold;
+byte weapon_swap_resist_pois;
+byte weapon_swap_resist_conf;
+byte weapon_swap_resist_sound;
+byte weapon_swap_resist_lite;
+byte weapon_swap_resist_dark;
+byte weapon_swap_resist_chaos;
+byte weapon_swap_resist_disen;
+byte weapon_swap_resist_shard;
+byte weapon_swap_resist_nexus;
+byte weapon_swap_resist_blind;
+byte weapon_swap_resist_neth;
+byte weapon_swap_resist_fear;
+byte armour_swap_slay_animal;
+byte armour_swap_slay_evil;
+byte armour_swap_slay_undead;
+byte armour_swap_slay_demon;
+byte armour_swap_slay_orc;
+byte armour_swap_slay_troll;
+byte armour_swap_slay_giant;
+byte armour_swap_slay_dragon;
+byte armour_swap_kill_undead;
+byte armour_swap_kill_demon;
+byte armour_swap_kill_dragon;
+byte armour_swap_impact;
+byte armour_swap_brand_acid;
+byte armour_swap_brand_elec;
+byte armour_swap_brand_fire;
+byte armour_swap_brand_cold;
+byte armour_swap_brand_pois;
+byte armour_swap_see_infra;
+byte armour_swap_slow_digest;
+byte armour_swap_aggravate;
+byte armour_swap_teleport;
+byte armour_swap_regenerate;
+byte armour_swap_telepathy;
+byte armour_swap_lite;
+byte armour_swap_see_invis;
+byte armour_swap_ffall;
+byte armour_swap_free_act;
+byte armour_swap_hold_life;
+byte armour_swap_immune_fire;
+byte armour_swap_immune_acid;
+byte armour_swap_immune_cold;
+byte armour_swap_immune_elec;
+byte armour_swap_resist_acid;
+byte armour_swap_resist_elec;
+byte armour_swap_resist_fire;
+byte armour_swap_resist_cold;
+byte armour_swap_resist_pois;
+byte armour_swap_resist_conf;
+byte armour_swap_resist_sound;
+byte armour_swap_resist_lite;
+byte armour_swap_resist_dark;
+byte armour_swap_resist_chaos;
+byte armour_swap_resist_disen;
+byte armour_swap_resist_shard;
+byte armour_swap_resist_nexus;
+byte armour_swap_resist_blind;
+byte armour_swap_resist_neth;
+byte armour_swap_resist_fear;
+
+byte my_ammo_tval;  /* Ammo -- "tval" */
+byte my_ammo_sides; /* Ammo -- "sides" */
+s16b my_ammo_power; /* Shooting multipler */
+s16b my_ammo_range; /* Shooting range */
+
+s16b my_need_enchant_to_a;  /* Need some enchantment */
+s16b my_need_enchant_to_h;  /* Need some enchantment */
+s16b my_need_enchant_to_d;  /* Need some enchantment */
+s16b my_need_brand_weapon;  /* apw actually brand bolts */
+
+/*
+ * Hack -- basic "power"
+ */
+
+s32b my_power;
+
+
+/*
+ * Various "amounts" (for the player)
+ */
+
+s16b amt_food_hical;
+s16b amt_food_lowcal;
+
+s16b amt_slow_poison;
+s16b amt_cure_confusion;
+s16b amt_cure_blind;
+
+s16b amt_book[9];
+
+s16b amt_add_stat[6];
+s16b amt_inc_stat[6];  /* Stat potions */
+s16b amt_fix_stat[7];  /* #7 is to fix all stats */
+s16b amt_fix_exp;
+
+s16b amt_cool_staff;   /* holiness - power staff */
+
+s16b amt_enchant_to_a;
+s16b amt_enchant_to_d;
+s16b amt_enchant_to_h;
+s16b amt_brand_weapon;  /* apw brand bolts */
+s16b amt_enchant_weapon;
+s16b amt_enchant_armor;
+s16b amt_digger;
+s16b amt_ego;
+
+/*
+ * Various "amounts" (for the home)
+ */
+
+s16b num_food;
+s16b num_fuel;
+s16b num_mold;
+s16b num_ident;
+s16b num_star_ident;
+s16b num_recall;
+s16b num_phase;
+s16b num_escape;
+s16b num_tele_staves;
+s16b num_teleport;
+s16b num_berserk;
+s16b num_teleport_level;
+s16b num_recharge;
+
+s16b num_cure_critical;
+s16b num_cure_serious;
+
+s16b num_pot_rheat;
+s16b num_pot_rcold;
+
+s16b num_missile;
+
+s16b num_book[9];
+
+s16b num_fix_stat[7]; /* #7 is to fix all stats */
+
+s16b num_fix_exp;
+s16b num_mana;
+s16b num_heal;
+s16b num_heal_true;
+s16b num_ez_heal;
+s16b num_ez_heal_true;
+s16b num_pfe;
+s16b num_glyph;
+s16b num_mass_genocide;
+s16b num_speed;
+s16b num_detonate;
+
+s16b num_enchant_to_a;
+s16b num_enchant_to_d;
+s16b num_enchant_to_h;
+s16b num_brand_weapon;  /*apw brand bolts */
+s16b num_genocide;
+
+s16b num_artifact;
+s16b num_ego;
+
+s16b home_slot_free;
+s16b home_damage;
+s16b num_duplicate_items;
+s16b num_slow_digest;
+s16b num_regenerate;
+s16b num_telepathy;
+s16b num_lite;
+s16b num_see_inv;
+s16b num_invisible;   /* apw */
+
+s16b num_ffall;
+s16b num_free_act;
+s16b num_hold_life;
+s16b num_immune_acid;
+s16b num_immune_elec;
+s16b num_immune_fire;
+s16b num_immune_cold;
+s16b num_resist_acid;
+s16b num_resist_elec;
+s16b num_resist_fire;
+s16b num_resist_cold;
+s16b num_resist_pois;
+s16b num_resist_conf;
+s16b num_resist_sound;
+s16b num_resist_lite;
+s16b num_resist_dark;
+s16b num_resist_chaos;
+s16b num_resist_disen;
+s16b num_resist_shard;
+s16b num_resist_nexus;
+s16b num_resist_blind;
+s16b num_resist_neth;
+s16b num_sustain_str;
+s16b num_sustain_int;
+s16b num_sustain_wis;
+s16b num_sustain_dex;
+s16b num_sustain_con;
+s16b num_sustain_all;
+
+s16b num_speed;
+s16b num_edged_weapon;
+s16b num_bad_gloves;
+s16b num_weapons;
+s16b num_bow;
+s16b num_rings;
+s16b num_neck;
+s16b num_armor;
+s16b num_cloaks;
+s16b num_shields;
+s16b num_hats;
+s16b num_gloves;
+s16b num_boots;
+
+/*
+ * Hack -- extra state variables
+ */
+
+int borg_feeling = 0;   /* Current level "feeling" */
+
+/*
+ * Hack -- current shop index
+ */
+
+s16b shop_num = -1;     /* Current shop index */
+
+
+
+/*
+ * State variables extracted from the screen
+ */
+
+s32b borg_exp;      /* Current experience */
+
+s32b borg_gold;     /* Current gold */
+
+int borg_stat[6];   /* Current stat values */
+
+int borg_book[9];   /* Current book slots */
+
+
+/*
+ * State variables extracted from the inventory/equipment
+ */
+
+int borg_cur_wgt;   /* Current weight */
+
+
+/*
+ * Constant state variables
+ */
+
+int borg_race;      /* Player race */
+int borg_class;     /* Player class */
+
+
+/*
+ * Hack -- access the class/race records
+ */
+
+player_race *rb_ptr;    /* Player race info */
+player_class *cb_ptr;   /* Player class info */
+
+player_magic *mb_ptr;   /* Player magic info */
+
+
+
+/*
+ * Number of turns to step for (zero means forever)
+ */
+u16b borg_step = 0;     /* Step count (if any) */
+
+
+/*
+ * Status message search string
+ */
+char borg_match[128] = "plain gold ring";  /* Search string */
+
+
+/*
+ * Log file
+ */
+FILE *borg_fff = NULL;      /* Log file */
+
+
+/*
+ * Hack -- single character constants
+ */
+
+const char p1 = '(', p2 = ')';
+const char c1 = '{', c2 = '}';
+const char b1 = '[', b2 = ']';
+
+
+/*
+ * Hack -- the detection arrays
+ */
+
+bool borg_detect_wall[6][6];
+
+bool borg_detect_trap[6][6];
+
+bool borg_detect_door[6][6];
+
+bool borg_detect_evil[6][6];
+
+/*
+ * Locate the store doors
+ */
+
+byte *track_shop_x;
+byte *track_shop_y;
+
+
+/*
+ * Track "stairs up"
+ */
+
+s16b track_less_num;
+s16b track_less_size;
+byte *track_less_x;
+byte *track_less_y;
+
+
+/*
+ * Track "stairs down"
+ */
+
+s16b track_more_num;
+s16b track_more_size;
+byte *track_more_x;
+byte *track_more_y;
+
+/*
+ * Track glyphs
+ */
+s16b track_glyph_num;
+s16b track_glyph_size;
+byte *track_glyph_x;
+byte *track_glyph_y;
+
+bool borg_needs_new_sea;
+
+/*
+ * ghijk  The borg will use the following ddx and ddy to search
+ * d827a  for a suitable grid in an open room.
+ * e4@3b
+ * f615c
+ * lmnop  24 grids
+ *
+ */
+const s16b borg_ddx_ddd[24] =
+{ 0, 0, 1, -1, 1, -1, 1, -1, 2, 2, 2, -2, -2, -2, -2, -1, 0, 1, 2, -2, -1, 0, 1, 2};
+const s16b borg_ddy_ddd[24] =
+{ 1, -1, 0, 0, 1, 1, -1, -1, -1, 0, 1, -1, 0, 1, -2, -2, -2, -2, -2, 2, 2, 2, 2, 2};
+
+/*
+ * Track Steps
+ */
+s16b track_step_num;
+s16b track_step_size;
+byte *track_step_x;
+byte *track_step_y;
+
+/*
+ * Track closed doors which I have closed
+ */
+s16b track_door_num;
+s16b track_door_size;
+byte *track_door_x;
+byte *track_door_y;
+
+/*
+ * Track closed doors which started closed
+ */
+s16b track_closed_num;
+s16b track_closed_size;
+byte *track_closed_x;
+byte *track_closed_y;
+
+/*
+ * The object list.  This list is used to "track" objects.
+ */
+
+s16b borg_takes_cnt;
+
+s16b borg_takes_nxt;
+
+borg_take *borg_takes;
+
+
+/*
+ * The monster list.  This list is used to "track" monsters.
+ */
+
+s16b borg_kills_cnt;
+s16b borg_kills_summoner;    /* index of a summoner */
+s16b borg_kills_nxt;
+
+borg_kill *borg_kills;
+
+
+/* a 3 state boolean */
+/*-1 = not checked yet */
+/* 0 = not ready */
+/* 1 = ready */
+int borg_ready_morgoth;
+
+
+/*
+ * Hack -- extra fear per "region"
+ */
+u16b borg_fear_region[6][18];
+
+/*
+ * Hack -- extra fear per "region" induced from extra monsters.
+ */
+u16b borg_fear_monsters[AUTO_MAX_Y][AUTO_MAX_X];
+
+/*
+ * Hack -- count racial appearances per level
+ */
+s16b *borg_race_count;
+
+
+/*
+ * Hack -- count racial kills (for uniques)
+ */
+
+s16b *borg_race_death;
+
+
+/*
+ * Classification of map symbols
+ */
+
+bool borg_is_take[256];     /* Symbol may be an object */
+
+bool borg_is_kill[256];     /* Symbol may be a monster */
+
+
+/*
+ * The current map
+ */
+
+borg_grid *borg_grids[AUTO_MAX_Y];  /* The grids */
+
+
+/*
+ * Maintain a set of grids marked as "BORG_LITE"
+ */
+
+s16b borg_lite_n = 0;
+
+byte borg_lite_x[AUTO_LITE_MAX];
+byte borg_lite_y[AUTO_LITE_MAX];
+
+/*
+ * Maintain a set of grids marked as "BORG_GLOW"
+ */
+
+s16b borg_glow_n = 0;
+
+byte borg_glow_x[AUTO_LITE_MAX];
+byte borg_glow_y[AUTO_LITE_MAX];
+
+
+/*
+ * Maintain a set of grids marked as "BORG_VIEW"
+ */
+
+s16b borg_view_n = 0;
+
+byte borg_view_x[AUTO_VIEW_MAX];
+byte borg_view_y[AUTO_VIEW_MAX];
+
+
+/*
+ * Maintain a temporary set of grids
+ * Used to store monster info.
+ */
+
+s16b borg_temp_n = 0;
+
+byte borg_temp_x[AUTO_TEMP_MAX];
+byte borg_temp_y[AUTO_TEMP_MAX];
+
+/*
+ * Maintain a temporary set of grids
+ * Used to store lit grid info
+ */
+s16b borg_temp_lit_n = 0;
+byte borg_temp_lit_x[AUTO_TEMP_MAX];
+byte borg_temp_lit_y[AUTO_TEMP_MAX];
+
+/*
+ * Maintain a set of special grids used for Teleport Other
+ */
+s16b borg_tp_other_n = 0;
+byte borg_tp_other_x[15];
+byte borg_tp_other_y[15];
+int borg_tp_other_index[15];
+
+
+
+byte offset_x;
+byte offset_y;
+
+
+/*
+ * Maintain a circular queue of grids
+ */
+
+s16b borg_flow_n = 0;
+
+byte borg_flow_x[AUTO_FLOW_MAX];
+byte borg_flow_y[AUTO_FLOW_MAX];
+
+
+/*
+ * Hack -- use "flow" array as a queue
+ */
+
+int flow_head = 0;
+int flow_tail = 0;
+
+
+
+/*
+ * Some variables
+ */
+
+borg_data *borg_data_flow;  /* Current "flow" data */
+
+borg_data *borg_data_cost;  /* Current "cost" data */
+
+borg_data *borg_data_hard;  /* Constant "hard" data */
+
+borg_data *borg_data_know;  /* Current "know" flags */
+
+borg_data *borg_data_icky;  /* Current "icky" flags */
+
+
+
+/*
+ * Strategy flags -- recalculate things
+ */
+
+bool borg_danger_wipe = FALSE;  /* Recalculate danger */
+
+bool borg_do_update_view = FALSE;  /* Recalculate view */
+
+bool borg_do_update_lite = FALSE;  /* Recalculate lite */
+
+
+/*
+ * Strategy flags -- examine the world
+ */
+
+bool borg_do_inven = TRUE;  /* Acquire "inven" info */
+
+bool borg_do_equip = TRUE;  /* Acquire "equip" info */
+
+bool borg_do_panel = TRUE;  /* Acquire "panel" info */
+
+bool borg_do_frame = TRUE;  /* Acquire "frame" info */
+
+bool borg_do_spell = TRUE;  /* Acquire "spell" info */
+
+byte borg_do_spell_aux = 0; /* Hack -- book for "borg_do_spell" */
+
+bool borg_do_browse = 0;    /* Acquire "store" info */
+
+byte borg_do_browse_what = 0;   /* Hack -- store for "borg_do_browse" */
+
+byte borg_do_browse_more = 0;   /* Hack -- pages for "borg_do_browse" */
+
+
+/*
+ * Strategy flags -- run certain functions
+ */
+
+bool borg_do_crush_junk = FALSE;
+
+bool borg_do_crush_hole = FALSE;
+
+bool borg_do_crush_slow = FALSE;
+
+/* am I fighting a unique? */
+int borg_fighting_unique;
+bool borg_fighting_evil_unique;
+
+/* am I fighting a summoner? */
+bool borg_fighting_summoner;
+
+/*
+ * Calculate "incremental motion". Used by project() and shoot().
+ * Assumes that (*y,*x) lies on the path from (y1,x1) to (y2,x2).
+ */
+/* changing this to be more like project_path */
+/* note that this is much slower but much more accurate */
+void mmove2(int *py, int *px, int y1, int x1, int y2, int x2)
+{
+    int dy, dx;
+    int sy, sx;
+    int y, x;
+
+    /* Scale factors */
+    int full, half;
+
+    /* Fractions */
+    int frac;
+
+    /* Slope */
+    int m;
+
+    /* Distance */
+    int k = 0;
+
+    /* Extract the distance travelled */
+    /* Analyze "dy" */
+    if (y2 < y1)
+    {
+        dy = (y1 - y2);
+        sy = -1;
+    }
+    else
+    {
+        dy = (y2 - y1);
+        sy = 1;
+    }
+
+    /* Analyze "dx" */
+    if (x2 < x1)
+    {
+        dx = (x1 - x2);
+        sx = -1;
+    }
+    else
+    {
+        dx = (x2 - x1);
+        sx = 1;
+    }
+
+    /* Paranoia -- Hack -- no motion */
+    if (!dy && !dx) return;
+
+    /* Number of "units" in one "half" grid */
+    half = (dy * dx);
+
+    /* Number of "units" in one "full" grid */
+    full = half << 1;
+
+    /* First step is fixed */
+    if (*px == x1 && *py == y1)
+    {
+        if (dy > dx)
+        {
+            *py+=sy;
+            return;
+        }
+        else if (dx > dy)
+        {
+            *px+=sx;
+            return;
+        }
+        else
+        {
+            *px+=sx;
+            *py+=sy;
+            return;
+        }
+    }
+
+    /* Move mostly vertically */
+    if (dy > dx)
+    {
+        k = dy;
+
+        /* Start at tile edge */
+        frac = dx * dx;
+
+        /* Let m = ((dx/dy) * full) = (dx * dx * 2) = (frac * 2) */
+        m = frac << 1;
+
+        /* Start */
+        y = y1 + sy;
+        x = x1;
+
+        /* Create the projection path */
+        while (1)
+        {
+            if (x == *px && y == *py)
+                k = 1;
+
+            /* Slant */
+            if (m)
+            {
+                /* Advance (X) part 1 */
+                frac += m;
+
+                /* Horizontal change */
+                if (frac >= half)
+                {
+                    /* Advance (X) part 2 */
+                    x += sx;
+
+                    /* Advance (X) part 3 */
+                    frac -= full;
+                }
+            }
+
+            /* Advance (Y) */
+            y += sy;
+
+            /* Track distance */
+            k--;
+
+            if (!k)
+            {
+                *px = x;
+                *py = y;
+                return;
+            }
+        }
+    }
+    /* Move mostly horizontally */
+    else if (dx > dy)
+    {
+        /* Start at tile edge */
+        frac = dy * dy;
+
+        /* Let m = ((dy/dx) * full) = (dy * dy * 2) = (frac * 2) */
+        m = frac << 1;
+
+        /* Start */
+        y = y1;
+        x = x1 + sx;
+        k = dx;
+
+        /* Create the projection path */
+        while (1)
+        {
+            if (x == *px && y == *py)
+                k = 1;
+
+            /* Slant */
+            if (m)
+            {
+                /* Advance (Y) part 1 */
+                frac += m;
+
+                /* Vertical change */
+                if (frac >= half)
+                {
+                    /* Advance (Y) part 2 */
+                    y += sy;
+
+                    /* Advance (Y) part 3 */
+                    frac -= full;
+                }
+            }
+
+            /* Advance (X) */
+            x += sx;
+
+            /* Track distance */
+            k--;
+
+            if (!k)
+            {
+                *px = x;
+                *py = y;
+                return;
+            }
+        }
+    }
+    /* Diagonal */
+    else
+    {
+        /* Start */
+        k = dy;
+        y = y1 + sy;
+        x = x1 + sx;
+
+        /* Create the projection path */
+        while (1)
+        {
+            if (x == *px && y == *py)
+                k=1;
+
+            /* Advance (Y) */
+            y += sy;
+
+            /* Advance (X) */
+            x += sx;
+
+            /* Track distance */
+            k--;
+
+            if (!k)
+            {
+                *px = x;
+                *py = y;
+                return;
+            }
+        }
+    }
+}
+#ifndef BORG_TK
+
+/*
+ * Query the "attr/char" at a given location on the screen
+ * We return "zero" if the given location was legal
+ *
+ * XXX XXX XXX We assume the given location is legal
+ */
+errr borg_what_char(int x, int y, byte *a, char *c)
+{
+    /* Direct access XXX XXX XXX */
+    (*a) = (Term->scr->a[y][x]);
+    (*c) = (Term->scr->c[y][x]);
+
+    /* Success */
+    return (0);
+}
+
+
+/*
+ * Query the "attr/chars" at a given location on the screen
+ *
+ * Note that "a" points to a single "attr", and "s" to an array
+ * of "chars", into which the attribute and text at the given
+ * location are stored.
+ *
+ * We will not grab more than "ABS(n)" characters for the string.
+ * If "n" is "positive", we will grab exactly "n" chars, or fail.
+ * If "n" is "negative", we will grab until the attribute changes.
+ *
+ * We automatically convert all "blanks" and "invisible text" into
+ * spaces, and we ignore the attribute of such characters.
+ *
+ * We do not strip final spaces, so this function will very often
+ * read characters all the way to the end of the line.
+ *
+ * We succeed only if a string of some form existed, and all of
+ * the non-space characters in the string have the same attribute,
+ * and the string was long enough.
+ *
+ * XXX XXX XXX We assume the given location is legal
+ */
+errr borg_what_text(int x, int y, int n, byte *a, char *s)
+{
+    int i;
+
+    byte t_a;
+    char t_c;
+
+    byte *aa;
+    char *cc;
+
+	int w, h;
+
+    /* Current attribute */
+    byte d_a = 0;
+
+    /* Max length to scan for */
+    int m = ABS(n);
+
+    /* Activate */
+    /* Do I need to get the right window? Term_activate(angband_term[0]); */
+
+	/* Obtain the size */
+	(void)Term_get_size(&w, &h);
+
+    /* Hack -- Do not run off the screen */
+    if (x + m > w) m = w - x;
+
+    /* Direct access XXX XXX XXX */
+    aa = &(Term->scr->a[y][x]);
+    cc = &(Term->scr->c[y][x]);
+
+    /* Grab the string */
+    for (i = 0; i < m; i++)
+    {
+        /* Access */
+        t_a = *aa++;
+        t_c = *cc++;
+
+        /* Handle spaces */
+        if ((t_c == ' ') || !t_a)
+        {
+            /* Save space */
+            s[i] = ' ';
+        }
+
+        /* Handle real text */
+        else
+        {
+            /* Attribute ready */
+            if (d_a)
+            {
+                /* Verify the "attribute" (or stop) */
+                if (t_a != d_a) break;
+            }
+
+            /* Acquire attribute */
+            else
+            {
+                /* Save it */
+                d_a = t_a;
+            }
+
+            /* Save char */
+            s[i] = t_c;
+        }
+    }
+
+    /* Terminate the string */
+    s[i] = '\0';
+
+    /* Save the attribute */
+    (*a) = d_a;
+
+    /* Too short */
+    if ((n > 0) && (i != n)) return (1);
+
+    /* Success */
+    return (0);
+}
+
+#endif /* not BORG_TK */
+
+
+/*
+ * Log a message to a file
+ */
+void borg_info(cptr what)
+{
+    /* Dump a log file message */
+    if (borg_fff) fprintf(borg_fff, "%s\n", what);
+
+}
+
+
+
+/*
+ * Memorize a message, Log it, Search it, and Display it in pieces
+ */
+void borg_note(cptr what)
+{
+    int j, n, i, k;
+
+    int w, h, x, y;
+
+
+#ifndef BORG_TK
+    term *old = Term;
+#endif
+
+    /* Memorize it */
+    message_add(what, MSG_GENERIC);
+
+
+    /* Log the message */
+    borg_info(what);
+
+
+    /* Mega-Hack -- Check against the search string */
+    if (borg_match[0] && strstr(what, borg_match))
+    {
+        /* Clean cancel */
+        borg_cancel = TRUE;
+    }
+
+    /* Mega-Hack -- Check against the swap loops */
+    if (strstr(what, "Best Combo"))
+    {
+        /* Tick the anti loop clock */
+        time_this_panel += 10;
+        borg_note(format("# Anti-loop variable tick (%d).", time_this_panel));
+    }
+
+#ifndef BORG_TK
+    /* Scan windows */
+    for (j = 0; j < 8; j++)
+    {
+        if (!angband_term[j]) continue;
+
+        /* Check flag */
+        if (!(op_ptr->window_flag[j] & PW_BORG_1)) continue;
+
+        /* Activate */
+        Term_activate(angband_term[j]);
+
+        /* Access size */
+        Term_get_size(&w, &h);
+
+        /* Access cursor */
+        Term_locate(&x, &y);
+
+        /* Erase current line */
+        Term_erase(0, y, 255);
+
+
+        /* Total length */
+        n = strlen(what);
+
+        /* Too long */
+        if (n > w - 2)
+        {
+            char buf[1024];
+
+            /* Split */
+            while (n > w - 2)
+            {
+                /* Default */
+                k = w - 2;
+
+                /* Find a split point */
+                for (i = w / 2; i < w - 2; i++)
+                {
+                    /* Pre-emptive split point */
+                    if (isspace(what[i])) k = i;
+                }
+
+                /* Copy over the split message */
+                for (i = 0; i < k; i++)
+                {
+                    /* Copy */
+                    buf[i] = what[i];
+                }
+
+                /* Indicate split */
+                buf[i++] = '\\';
+
+                /* Terminate */
+                buf[i] = '\0';
+
+                /* Show message */
+                Term_addstr(-1, TERM_WHITE, buf);
+
+                /* Advance (wrap) */
+                if (++y >= h) y = 0;
+
+                /* Erase next line */
+                Term_erase(0, y, 255);
+
+                /* Advance */
+                what += k;
+
+                /* Reduce */
+                n -= k;
+            }
+
+            /* Show message tail */
+            Term_addstr(-1, TERM_WHITE, what);
+
+            /* Advance (wrap) */
+            if (++y >= h) y = 0;
+
+            /* Erase next line */
+            Term_erase(0, y, 255);
+        }
+
+        /* Normal */
+        else
+        {
+            /* Show message */
+            Term_addstr(-1, TERM_WHITE, what);
+
+            /* Advance (wrap) */
+            if (++y >= h) y = 0;
+
+            /* Erase next line */
+            Term_erase(0, y, 255);
+        }
+
+
+        /* Flush output */
+        Term_fresh();
+
+        /* Use correct window */
+        Term_activate(old);
+    }
+#endif /* not BORG_TK */
+ }
+
+
+
+
+/*
+ * Abort the Borg, noting the reason
+ */
+void borg_oops(cptr what)
+{
+    /* Stop processing */
+    borg_active = FALSE;
+
+    /* Give a warning */
+    borg_note(format("# Aborting (%s).", what));
+
+    /* Forget borg keys */
+    borg_flush();
+}
+
+/*
+ * A Queue of keypresses to be sent
+ */
+static char *borg_key_queue;
+static s16b borg_key_head;
+static s16b borg_key_tail;
+
+
+/*
+ * Add a keypress to the "queue" (fake event)
+ */
+errr borg_keypress(char k)
+{
+    /* Hack -- Refuse to enqueue "nul" */
+    if (!k) return (-1);
+
+    /* Hack -- note the keypress */
+    if (borg_fff)
+    {
+		borg_info(format("& Key <%c>", k));
+	}
+    else
+    {
+		/* Hack -- note the keypress */
+    	borg_note(format("& Key <%c>", k));
+	}
+
+    /* Store the char, advance the queue */
+    borg_key_queue[borg_key_head++] = k;
+
+    /* Circular queue, handle wrap */
+    if (borg_key_head == KEY_SIZE) borg_key_head = 0;
+
+    /* Hack -- Catch overflow (forget oldest) */
+    if (borg_key_head == borg_key_tail) borg_oops("overflow");
+
+    /* Hack -- Overflow may induce circular queue */
+    if (borg_key_tail == KEY_SIZE) borg_key_tail = 0;
+
+    /* Success */
+    return (0);
+}
+
+
+/*
+ * Add a keypress to the "queue" (fake event)
+ */
+errr borg_keypresses(cptr str)
+{
+    cptr s;
+
+    /* Enqueue them */
+    for (s = str; *s; s++) borg_keypress(*s);
+
+    /* Success */
+    return (0);
+}
+
+
+/*
+ * Get the next Borg keypress
+ */
+char borg_inkey(bool take)
+{
+    int i;
+
+    /* Nothing ready */
+    if (borg_key_head == borg_key_tail)
+        return (0);
+
+    /* Extract the keypress */
+    i = borg_key_queue[borg_key_tail];
+
+    /* Do not advance */
+    if (!take) return (i);
+
+    /* Advance the queue */
+    borg_key_tail++;
+
+    /* Circular queue requires wrap-around */
+    if (borg_key_tail == KEY_SIZE) borg_key_tail = 0;
+
+    /* Return the key */
+    return (i);
+}
+
+
+
+/*
+ * Get the next Borg keypress
+ */
+void borg_flush(void)
+{
+    /* Simply forget old keys */
+    borg_key_tail = borg_key_head;
+}
+
+
+
+
+
+
+/*
+ * Hack -- take a note later
+ */
+bool borg_tell(cptr what)
+{
+    cptr s;
+
+    /* Hack -- self note */
+    borg_keypress(':');
+    for (s = what; *s; s++) borg_keypress(*s);
+    borg_keypress('\n');
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+/*
+ * Attempt to change the borg's name
+ */
+bool borg_change_name(cptr str)
+{
+    cptr s;
+
+    /* Cancel everything */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+
+    /* Character description */
+    borg_keypress('C');
+
+    /* Change the name */
+    borg_keypress('c');
+
+    /* Enter the new name */
+    for (s = str; *s; s++) borg_keypress(*s);
+
+    /* End the name */
+    borg_keypress('\r');
+
+    /* Cancel everything */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Attempt to dump a character description file
+ */
+bool borg_dump_character(cptr str)
+{
+    cptr s;
+
+    /* Cancel everything */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+
+    /* Character description */
+    borg_keypress('C');
+
+    /* Dump character file */
+    borg_keypress('f');
+
+    /* Enter the new name */
+    for (s = str; *s; s++) borg_keypress(*s);
+
+    /* End the file name */
+    borg_keypress('\r');
+
+    /* Cancel everything */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+
+/*
+ * Attempt to save the game
+ */
+bool borg_save_game(void)
+{
+    /* Cancel everything */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+
+    /* Save the game */
+    borg_keypress('^');
+    borg_keypress('S');
+
+    /* Cancel everything */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+
+/*
+ * Update the Borg based on the current "frame"
+ *
+ * Assumes the Borg is actually in the dungeon.
+ */
+void borg_update_frame(void)
+{
+    int i;
+
+    /* Assume level is fine */
+    borg_skill[BI_ISFIXLEV] = FALSE;
+
+    /* Note "Lev" vs "LEV" */
+    if (p_ptr->lev < p_ptr->max_lev) borg_skill[BI_ISFIXLEV] = TRUE;
+
+    /* Extract "LEVEL xxxxxx" */
+    borg_skill[BI_CLEVEL] = borg_skill[BI_CLEVEL] = p_ptr->lev;
+
+    /* cheat the max clevel */
+    borg_skill[BI_MAXCLEVEL] = p_ptr->max_lev;
+
+    /* Note "Winner" */
+    borg_skill[BI_KING] = p_ptr->total_winner;
+
+    /* Assume experience is fine */
+    borg_skill[BI_ISFIXEXP] = FALSE;
+
+    /* Note "Exp" vs "EXP" and am I lower than level 50*/
+    if ((p_ptr->exp < p_ptr->max_exp) &&
+        (borg_skill[BI_CLEVEL] != 50)) borg_skill[BI_ISFIXEXP] = TRUE;
+
+    /* Extract "EXP xxxxxxxx" */
+    borg_exp = p_ptr->exp;
+
+
+    /* Extract "AU xxxxxxxxx" */
+    borg_gold = p_ptr->au;
+
+
+    /* Extract "Fast (+x)" or "Slow (-x)" */
+    borg_skill[BI_SPEED] = p_ptr->pspeed;
+
+    /* Check my float for decrementing variables */
+    if (borg_skill[BI_SPEED] >110)
+    {
+        borg_game_ratio = 100000/(((borg_skill[BI_SPEED]-110)*10)+100);
+    }
+    else
+    {
+        borg_game_ratio = 1000;
+    }
+
+
+    /* if hasting, it doesn't count as 'borg_speed'.  The speed */
+    /* gained from hasting is counted seperately. */
+    if (borg_speed)
+        borg_skill[BI_SPEED] -= 10;
+
+    /* Extract "Cur AC xxxxx" */
+    borg_skill[BI_ARMOR] = p_ptr->dis_ac + p_ptr->dis_to_a;
+
+    /* Extract "Cur HP xxxxx" */
+    borg_skill[BI_CURHP] = p_ptr->chp;
+
+    /* Extract "Max HP xxxxx" */
+    borg_skill[BI_MAXHP] = p_ptr->mhp;
+
+    /* Extract "Cur SP xxxxx" (or zero) */
+    borg_skill[BI_CURSP] = p_ptr->csp;
+
+    /* Extract "Max SP xxxxx" (or zero) */
+    borg_skill[BI_MAXSP] = p_ptr->msp;
+
+    /* Clear all the "state flags" */
+    borg_skill[BI_ISWEAK] = borg_skill[BI_ISHUNGRY] = borg_skill[BI_ISFULL] = borg_skill[BI_ISGORGED] = FALSE;
+    borg_skill[BI_ISBLIND] = borg_skill[BI_ISCONFUSED] = borg_skill[BI_ISAFRAID] = borg_skill[BI_ISPOISONED] = FALSE;
+    borg_skill[BI_ISCUT] = borg_skill[BI_ISSTUN] = borg_skill[BI_ISHEAVYSTUN] = borg_skill[BI_ISIMAGE] = borg_skill[BI_ISSTUDY] = FALSE;
+    borg_skill[BI_ISSEARCHING] = FALSE;
+	borg_skill[BI_ISPARALYZED] = FALSE;
+
+    /* Check for "Weak" */
+    if (p_ptr->food < PY_FOOD_WEAK) borg_skill[BI_ISWEAK] = borg_skill[BI_ISHUNGRY] = TRUE;
+
+    /* Check for "Hungry" */
+    else if (p_ptr->food < PY_FOOD_ALERT) borg_skill[BI_ISHUNGRY] = TRUE;
+
+    /* Check for "Normal" */
+    else if (p_ptr->food < PY_FOOD_FULL) /* Nothing */;
+
+    /* Check for "Full" */
+    else if (p_ptr->food < PY_FOOD_MAX) borg_skill[BI_ISFULL] = TRUE;
+
+    /* Check for "Gorged" */
+    else borg_skill[BI_ISGORGED] = borg_skill[BI_ISFULL] = TRUE;
+
+    /* Check for "Blind" */
+    if (p_ptr->blind) borg_skill[BI_ISBLIND] = TRUE;
+
+    /* Check for "Confused" */
+    if (p_ptr->confused) borg_skill[BI_ISCONFUSED] = TRUE;
+
+    /* Check for "Afraid" */
+    if (p_ptr->afraid) borg_skill[BI_ISAFRAID] = TRUE;
+
+    /* Check for "Poisoned" */
+    if (p_ptr->poisoned) borg_skill[BI_ISPOISONED] = TRUE;
+
+    /* Check for any text */
+    if (p_ptr->cut) borg_skill[BI_ISCUT] = TRUE;
+
+    /* Check for Stun */
+    if (p_ptr->stun && (p_ptr->stun <= 50)) borg_skill[BI_ISSTUN] = TRUE;
+
+    /* Check for Heavy Stun */
+    if (p_ptr->stun > 50) borg_skill[BI_ISHEAVYSTUN] = TRUE;
+
+    /* Check for Paralyze */
+    if (p_ptr->paralyzed > 50) borg_skill[BI_ISPARALYZED] = TRUE;
+
+
+    /* XXX XXX XXX Parse "State" */
+    if (p_ptr->searching) borg_skill[BI_ISSEARCHING] = TRUE;
+
+    /* Check for "Study" */
+    if (p_ptr->new_spells) borg_skill[BI_ISSTUDY] = TRUE;
+
+    /* Check for "Hallucinating" */
+    if (p_ptr->image) borg_skill[BI_ISIMAGE] = TRUE;
+
+    /* Parse stats */
+    for (i = 0; i < 6; i++)
+    {
+        borg_skill[BI_ISFIXSTR+i] = p_ptr->stat_cur[A_STR+i] < p_ptr->stat_max[A_STR+i];
+        borg_skill[BI_CSTR+i] = p_ptr->stat_cur[A_STR+i];
+        borg_stat[i] = p_ptr->stat_cur[i];
+
+    }
+
+    /* Hack -- Access max depth */
+    borg_skill[BI_CDEPTH] = p_ptr->depth;
+
+    /* Hack -- Access max depth */
+    borg_skill[BI_MAXDEPTH] = p_ptr->max_depth;
+
+}
+
+
+int
+borg_check_formula(int *formula)
+{
+    int     oper1;          /* operand #1 */
+    int     oper2;          /* operand #2 */
+    int     stack[256];     /* stack */
+    int     *stackptr;      /* stack pointer */
+
+    /* loop until we hit BFO_DONE */
+    for (stackptr = stack; *formula; formula++)
+    {
+        if (stackptr < stack)
+            return 0;
+        switch (*formula)
+        {
+            /* Number */
+            case BFO_NUMBER:
+                *stackptr++ = *++formula;
+                break;
+
+            /* Variable */
+            case BFO_VARIABLE:
+                *stackptr++ = borg_has[*++formula];
+                if ((*formula) > (z_info->k_max + z_info->k_max + z_info->a_max + BI_MAX))
+                    return 0;
+                break;
+
+            /* Equal */
+            case BFO_EQ:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 == oper2);
+                break;
+
+            /* Not Equal */
+            case BFO_NEQ:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 != oper2);
+                break;
+
+            /* Less Than */
+            case BFO_LT:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 < oper2);
+                break;
+
+            /* Less Than Or Equal */
+            case BFO_LTE:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 <= oper2);
+                break;
+
+            /* Greater Than */
+            case BFO_GT:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 > oper2);
+                break;
+
+            /* Greater Than Or Equal */
+            case BFO_GTE:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 >= oper2);
+                break;
+
+            /* Logical And */
+            case BFO_AND:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 && oper2);
+                break;
+
+            /* Logical Or */
+            case BFO_OR:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 || oper2);
+                break;
+
+            /* Plus */
+            case BFO_PLUS:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 + oper2);
+                break;
+
+            /* Minus */
+            case BFO_MINUS:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 - oper2);
+                break;
+
+            /* Divide */
+            case BFO_DIVIDE:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 / (oper2 ? oper2 : 1));
+                break;
+
+            /* Multiply */
+            case BFO_MULT:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 * oper2);
+                break;
+
+            /* Logical Not */
+            case BFO_NOT:
+                oper1 = *--stackptr;
+                *stackptr++ = (!oper1);
+                break;
+
+            default:
+                return 0;
+        }
+    }
+
+    if (stackptr != (stack+1))
+        return 0;
+    return 1;
+}
+
+cptr
+borg_prt_formula(int *formula)
+{
+    static char FormulaStr[2000];
+    char tmpStr[50];
+
+    memset(FormulaStr, 0, sizeof(FormulaStr));
+    /* loop until we hit BFO_DONE */
+    for (; *formula; formula++)
+    {
+        switch (*formula)
+        {
+            /* Number */
+            case BFO_NUMBER:
+
+                sprintf(tmpStr, "%d ", *++formula);
+                strcat(FormulaStr, tmpStr);
+                break;
+
+            /* Variable */
+            case BFO_VARIABLE:
+                strcat(FormulaStr, "'");
+                strcat(FormulaStr, borg_prt_item(*++formula));
+                strcat(FormulaStr, "'");
+                strcat(FormulaStr, " ");
+                break;
+
+            /* Equal */
+            case BFO_EQ:
+                strcat(FormulaStr, "== ");
+                break;
+
+            /* Not Equal */
+            case BFO_NEQ:
+                strcat(FormulaStr, "!= ");
+                break;
+
+            /* Less Than */
+            case BFO_LT:
+                strcat(FormulaStr, "< ");
+                break;
+
+            /* Less Than Or Equal */
+            case BFO_LTE:
+                strcat(FormulaStr, "<= ");
+                break;
+
+            /* Greater Than */
+            case BFO_GT:
+                strcat(FormulaStr, "> ");
+                break;
+
+            /* Greater Than Or Equal */
+            case BFO_GTE:
+                strcat(FormulaStr, ">= ");
+                break;
+
+            /* Logical And */
+            case BFO_AND:
+                strcat(FormulaStr, "&& ");
+                break;
+
+            /* Logical Or */
+            case BFO_OR:
+                strcat(FormulaStr, "|| ");
+                break;
+
+            /* Plus */
+            case BFO_PLUS:
+                strcat(FormulaStr, "+ ");
+                break;
+
+            /* Minus */
+            case BFO_MINUS:
+                strcat(FormulaStr, "- ");
+                break;
+
+            /* Divide */
+            case BFO_DIVIDE:
+                strcat(FormulaStr, "/ ");
+                break;
+
+            /* Multiply */
+            case BFO_MULT:
+                strcat(FormulaStr, "* ");
+                break;
+
+            /* Logical Not */
+            case BFO_NOT:
+                strcat(FormulaStr, "! ");
+                break;
+        }
+    }
+
+    /* BFO_DONE */
+    return FormulaStr;
+}
+
+int
+borg_calc_formula(int *formula)
+{
+    int     oper1;          /* operand #1 */
+    int     oper2;          /* operand #2 */
+    int     stack[256];     /* stack */
+    int     *stackptr;      /* stack pointer */
+
+
+    if (!formula)
+        return 0;
+
+    *stack = 0;
+    /* loop until we hit BFO_DONE */
+    for (stackptr = stack; *formula; formula++)
+    {
+        switch (*formula)
+        {
+            /* Number */
+            case BFO_NUMBER:
+                *stackptr++ = *++formula;
+                break;
+
+            /* Variable */
+            case BFO_VARIABLE:
+                *stackptr++ = borg_has[*++formula];
+                break;
+
+            /* Equal */
+            case BFO_EQ:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 == oper2);
+                break;
+
+            /* Not Equal */
+            case BFO_NEQ:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 != oper2);
+                break;
+
+            /* Less Than */
+            case BFO_LT:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 < oper2);
+                break;
+
+            /* Less Than Or Equal */
+            case BFO_LTE:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 <= oper2);
+                break;
+
+            /* Greater Than */
+            case BFO_GT:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 > oper2);
+                break;
+
+            /* Greater Than Or Equal */
+            case BFO_GTE:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 >= oper2);
+                break;
+
+            /* Logical And */
+            case BFO_AND:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 && oper2);
+                break;
+
+            /* Logical Or */
+            case BFO_OR:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 || oper2);
+                break;
+
+            /* Plus */
+            case BFO_PLUS:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 + oper2);
+                break;
+
+            /* Minus */
+            case BFO_MINUS:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 - oper2);
+                break;
+
+            /* Divide */
+            case BFO_DIVIDE:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 / (oper2 ? oper2 : 1));
+                break;
+
+            /* Multiply */
+            case BFO_MULT:
+                oper2 = *--stackptr;
+                oper1 = *--stackptr;
+                *stackptr++ = (oper1 * oper2);
+                break;
+
+            /* Logical Not */
+            case BFO_NOT:
+                oper1 = *--stackptr;
+                *stackptr++ = (!oper1);
+                break;
+        }
+    }
+
+    /* BFO_DONE */
+    return *--stackptr;
+}
+
+
+
+
+bool (*borg_sort_comp)(void* u, void* v, int a, int b);
+void (*borg_sort_swap)(void* u, void* v, int a, int b);
+
+/*
+ * Borg's sorting algorithm -- quick sort in place
+ *
+ * Note that the details of the data we are sorting is hidden,
+ * and we rely on the "ang_sort_comp()" and "ang_sort_swap()"
+ * function hooks to interact with the data, which is given as
+ * two pointers, and which may have any user-defined form.
+ */
+void borg_sort_aux(void *u, void *v, int p, int q)
+{
+    int z, a, b;
+
+    /* Done sort */
+    if (p >= q) return;
+
+    /* Pivot */
+    z = p;
+
+    /* Begin */
+    a = p;
+    b = q;
+
+    /* Partition */
+    while (TRUE)
+    {
+        /* Slide i2 */
+        while (!(*borg_sort_comp)(u, v, b, z)) b--;
+
+        /* Slide i1 */
+        while (!(*borg_sort_comp)(u, v, z, a)) a++;
+
+        /* Done partition */
+        if (a >= b) break;
+
+        /* Swap */
+        (*borg_sort_swap)(u, v, a, b);
+
+        /* Advance */
+        a++, b--;
+    }
+
+    /* Recurse left side */
+    borg_sort_aux(u, v, p, b);
+
+    /* Recurse right side */
+    borg_sort_aux(u, v, b+1, q);
+}
+
+
+/*
+ * Borg's sorting algorithm -- quick sort in place
+ *
+ * Note that the details of the data we are sorting is hidden,
+ * and we rely on the "ang_sort_comp()" and "ang_sort_swap()"
+ * function hooks to interact with the data, which is given as
+ * two pointers, and which may have any user-defined form.
+ */
+void borg_sort(void *u, void *v, int n)
+{
+    /* Sort the array */
+    borg_sort_aux(u, v, 0, n-1);
+}
+
+/*
+ * Sorting hook -- comp function -- see below
+ *
+ * We use "u" to point to an array of strings, and "v" to point to
+ * an array of indexes, and we sort them together by the strings.
+ */
+bool borg_sort_comp_hook(void *u, void *v, int a, int b)
+{
+    cptr *text = (cptr*)(u);
+    s16b *what = (s16b*)(v);
+
+    int cmp;
+
+    /* Compare the two strings */
+    cmp = (strcmp(text[a], text[b]));
+
+    /* Strictly less */
+    if (cmp < 0) return (TRUE);
+
+    /* Strictly more */
+    if (cmp > 0) return (FALSE);
+
+    /* Enforce "stable" sort */
+    return (what[a] <= what[b]);
+}
+
+/*
+ * Sorting hook -- swap function -- see below
+ *
+ * We use "u" to point to an array of strings, and "v" to point to
+ * an array of indexes, and we sort them together by the strings.
+ */
+void borg_sort_swap_hook(void *u, void *v, int a, int b)
+{
+    cptr *text = (cptr*)(u);
+    s16b *what = (s16b*)(v);
+
+    cptr texttmp;
+    s16b whattmp;
+
+    /* Swap "text" */
+    texttmp = text[a];
+    text[a] = text[b];
+    text[b] = texttmp;
+
+    /* Swap "what" */
+    whattmp = what[a];
+    what[a] = what[b];
+    what[b] = whattmp;
+}
+
+
+
+/*
+ * Initialize this file
+ */
+void borg_init_1(void)
+{
+    int i, x, y;
+
+
+    /* Allocate the "keypress queue" */
+    C_MAKE(borg_key_queue, KEY_SIZE, char);
+
+
+    /* Prapare a local random number seed */
+if (!borg_rand_local)
+    borg_rand_local = rand_int(0x10000000);
+
+
+    /*** Grids ***/
+
+    /* Make each row of grids */
+    for (y = 0; y < AUTO_MAX_Y; y++)
+    {
+        /* Make each row */
+        C_MAKE(borg_grids[y], AUTO_MAX_X, borg_grid);
+    }
+
+
+    /*** Grid data ***/
+
+    /* Allocate */
+    MAKE(borg_data_flow, borg_data);
+
+    /* Allocate */
+    MAKE(borg_data_cost, borg_data);
+
+    /* Allocate */
+    MAKE(borg_data_hard, borg_data);
+
+    /* Allocate */
+    MAKE(borg_data_know, borg_data);
+
+    /* Allocate */
+    MAKE(borg_data_icky, borg_data);
+
+    /* Prepare "borg_data_hard" */
+    for (y = 0; y < AUTO_MAX_Y; y++)
+    {
+        for (x = 0; x < AUTO_MAX_X; x++)
+        {
+            /* Prepare "borg_data_hard" */
+            borg_data_hard->data[y][x] = 255;
+        }
+    }
+
+
+    /*** Very special "tracking" array ***/
+
+    /* Track the shop locations */
+    C_MAKE(track_shop_x, 9, byte);
+    C_MAKE(track_shop_y, 9, byte);
+
+
+    /*** Special "tracking" arrays ***/
+
+    /* Track "up" stairs */
+    track_less_num = 0;
+    track_less_size = 16;
+    C_MAKE(track_less_x, track_less_size, byte);
+    C_MAKE(track_less_y, track_less_size, byte);
+
+    /* Track "down" stairs */
+    track_more_num = 0;
+    track_more_size = 16;
+    C_MAKE(track_more_x, track_more_size, byte);
+    C_MAKE(track_more_y, track_more_size, byte);
+
+    /* Track glyphs */
+    track_glyph_num = 0;
+    track_glyph_size = 256;
+    C_MAKE(track_glyph_x, track_glyph_size, byte);
+    C_MAKE(track_glyph_y, track_glyph_size, byte);
+
+    /* Track Steps */
+    track_step_num = 0;
+    track_step_size = 100;
+    C_MAKE(track_step_x, track_step_size, byte);
+    C_MAKE(track_step_y, track_step_size, byte);
+
+    /* Track doors closed by borg */
+    track_door_num = 0;
+    track_door_size = 100;
+    C_MAKE(track_door_x, track_door_size, byte);
+    C_MAKE(track_door_y, track_door_size, byte);
+
+    /* Track closed doors on map */
+    track_closed_num = 0;
+    track_closed_size = 100;
+    C_MAKE(track_closed_x, track_closed_size, byte);
+    C_MAKE(track_closed_y, track_closed_size, byte);
+
+    /*** Object tracking ***/
+
+    /* No objects yet */
+    borg_takes_cnt = 0;
+    borg_takes_nxt = 1;
+
+    /* Array of objects */
+    C_MAKE(borg_takes, 256, borg_take);
+
+    /* Scan the objects */
+    for (i = 0; i < z_info->k_max; i++)
+    {
+        object_kind *k_ptr = &k_info[i];
+
+        /* Skip non-items */
+        if (!k_ptr->name) continue;
+
+        /* Notice this object */
+        borg_is_take[(byte)(k_ptr->d_char)] = TRUE;
+    }
+
+    /*** Monster tracking ***/
+
+    /* No monsters yet */
+    borg_kills_cnt = 0;
+    borg_kills_nxt = 1;
+
+    /* Array of monsters */
+    C_MAKE(borg_kills, 256, borg_kill);
+
+    /* Scan the monsters */
+    for (i = 1; i < z_info->r_max-1; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+
+        /* Skip non-monsters */
+        if (!r_ptr->name) continue;
+#if 0
+        /* Hack -- Skip "clear" monsters XXX XXX XXX */
+        if (r_ptr->flags1 & RF1_CHAR_CLEAR) continue;
+
+        /* Hack -- Skip "multi" monsters XXX XXX XXX */
+        if (r_ptr->flags1 & RF1_CHAR_MULTI) continue;
+#endif
+        /* Notice this monster */
+        borg_is_kill[(byte)(r_ptr->d_char)] = TRUE;
+    }
+
+
+    /*** Special counters ***/
+
+    /* Count racial appearances */
+    C_MAKE(borg_race_count, z_info->r_max, s16b);
+
+    /* Count racial deaths */
+    C_MAKE(borg_race_death, z_info->r_max, s16b);
+
+
+    /*** XXX XXX XXX Hack -- Cheat ***/
+
+    /* Hack -- Extract dead uniques */
+    for (i = 1; i < z_info->r_max-1; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+
+        /* Skip non-monsters */
+        if (!r_ptr->name) continue;
+
+        /* Skip non-uniques */
+        if (!(r_ptr->flags1 & RF1_UNIQUE)) continue;
+
+        /* Mega-Hack -- Access "dead unique" list */
+        if (r_ptr->max_num == 0) borg_race_death[i] = 1;
+    }
+
+}
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg1.h angband-3.0.6-borg/src/borg1.h
--- angband-3.0.6/src/borg1.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg1.h	2005-10-09 21:28:40.000000000 -0700
@@ -0,0 +1,1566 @@
+
+/* File: borg1.h */
+/* Purpose: Header file for "borg1.c" -BEN- */
+
+#ifndef INCLUDED_BORG1_H
+#define INCLUDED_BORG1_H
+
+#include "angband.h"
+
+
+
+#ifdef ALLOW_BORG
+
+
+/* Mega-Hack - indices of the player classes */
+
+#define CLASS_WARRIOR            0
+#define CLASS_MAGE               1
+#define CLASS_PRIEST             2
+#define CLASS_ROGUE              3
+#define CLASS_RANGER             4
+#define CLASS_PALADIN            5
+
+
+/* WARNING: If you mess with the objects.txt or the monster.txt and change
+ * the locations of things, then you must make those changes in borg.txt
+ * as well as in this borg code.  The borg is very concerned about item
+ * index locations.  ie: borgs_has[242] is looking for a Potion of Healing.
+ * The borg is concerned over several items, broken swords, and several
+ * monster locations (Tarresque, Sauron, Morgoth).
+ */
+
+/*
+ * This file provides support for "borg1.c".
+ */
+
+/*** Some constants ***/
+
+
+/*
+ * Maximum possible dungeon size
+ */
+#define AUTO_MAX_X  DUNGEON_WID
+#define AUTO_MAX_Y  DUNGEON_HGT
+
+
+
+/*
+ * Flags for the "info" field of grids
+ *
+ * Note that some of the flags below are not "perfect", in particular,
+ * several of the flags should be treated as "best guesses", see below.
+ *
+ * The "BORG_MARK" flag means that the grid has been "observed", though
+ * the terrain feature may or may not be memorized.  Note the use of the
+ * "FEAT_NONE", "FEAT_FLOOR", and "FEAT_INVIS" feature codes below.
+ *
+ * The "BORG_GLOW" flag means that a grid is probably "perma-lit", but
+ * sometimes it is really only "recently" perma-lit, but was then made
+ * dark with a darkness attack, and it is now torch-lit or off-screen.
+ *
+ * The "BORG_DARK" flag means that a grid is probably not "perma-lit",
+ * but sometimes it is really only "recently" dark, but was then made
+ * "lite" with a "call lite" spell, and it is now torch-lit or off-screen.
+ *
+ * The "BORG_LITE" flag means that a grid is probably lit by the player
+ * torch, but this may not be true if the nearby "BORG_VIEW" flags are
+ * not correct, or if the "lite radius" has changed recently.
+ *
+ * The "BORG_VIEW" flag means that a grid is probably in line of sight
+ * of the player, but this may not be true if some of the grids between
+ * the player and the grid contain previously unseen walls/doors/etc.
+ *
+ * The "BORG_TEMP" flag means that a grid has been added to the array
+ * "borg_temp_x"/"borg_temp_y", though normally we ignore this flag.
+ *
+ * The "BORG_XTRA" flag is used for various "extra" purposes, primarily
+ * to assist with the "update_view()" code.
+ */
+#define BORG_MARK   0x01    /* observed grid */
+#define BORG_GLOW   0x02    /* probably perma-lit */
+#define BORG_DARK   0x04    /* probably not perma-lit */
+#define BORG_OKAY   0x08    /* on the current panel */
+#define BORG_LITE   0x10    /* lit by the torch */
+#define BORG_VIEW   0x20    /* in line of sight */
+#define BORG_TEMP   0x40    /* temporary flag */
+#define BORG_XTRA   0x80    /* extra flag */
+
+
+/*
+ * Maximum size of the "lite" array
+ */
+#define AUTO_LITE_MAX 1536
+
+/*
+ * Some assistance with the borg_attack and magic arrows
+ */
+#define GF_ARROW_FLAME   70
+#define GF_ARROW_FROST   71
+#define GF_ARROW_ANIMAL  72
+#define GF_ARROW_UNDEAD  73
+#define GF_ARROW_DEMON   74
+#define GF_ARROW_ORC     75
+#define GF_ARROW_TROLL   76
+#define GF_ARROW_GIANT   77
+#define GF_ARROW_DRAGON  78
+#define GF_ARROW_EVIL    79
+#define GF_ARROW_WOUNDING 80
+#define GF_ARROW_POISON  81
+#define GF_ARROW_SEEKER  82
+#define GF_ARROW_SILVER  83
+#define GF_ARROW_HOLY	 84
+#define GF_HOLY_WORD     85
+#define GF_AWAY_ALL_MORGOTH 86
+
+/*
+ * Player race constants (hard-coded by save-files, arrays, etc)
+ */
+#define RACE_HUMAN      0
+#define RACE_HALF_ELF   1
+#define RACE_ELF        2
+#define RACE_HOBBIT     3
+#define RACE_GNOME      4
+#define RACE_DWARF      5
+#define RACE_HALF_ORC   6
+#define RACE_HALF_TROLL 7
+#define RACE_DUNADAN    8
+#define RACE_HIGH_ELF   9
+#define RACE_KOBOLD     10
+
+
+/*
+ * Maximum size of the "view" array
+ */
+/*#define AUTO_VIEW_MAX 1536*/
+#define AUTO_VIEW_MAX 9000
+
+
+/*
+ * Number of grids in the "temp" array
+ */
+#define AUTO_TEMP_MAX 9000
+
+
+/*
+ * Number of grids in the "flow" array
+ */
+#define AUTO_FLOW_MAX 1536
+
+
+
+/*
+ * Enable the "borg_note()" usage of the Recall Window
+ * Also specify the number of "rolling rows" to use
+ */
+#define BORG_NOTE_ROWS      12
+
+
+
+/*
+ * Size of Keypress buffer
+ */
+#define KEY_SIZE 8192
+
+
+
+
+/*
+ * Object information
+ */
+
+typedef struct borg_take borg_take;
+
+struct borg_take
+{
+    s16b    k_idx;      /* Kind index */
+
+    bool    known;      /* Verified kind */
+
+    bool    seen;       /* Assigned motion */
+
+    bool    extra;      /* Unused */
+
+    byte    x, y;       /* Location */
+
+    s16b    when;       /* When last seen */
+};
+
+
+/*
+ * Monster information
+ */
+
+typedef struct borg_kill borg_kill;
+
+struct borg_kill
+{
+    s16b    r_idx;      /* Race index */
+
+    bool    known;      /* Verified race */
+    bool    awake;      /* Probably awake */
+
+    bool    confused;   /* Probably confused */
+    bool    afraid;     /* Probably afraid */
+    bool    quiver;     /* Probably quivering */
+    bool    stunned;
+    bool    poisoned;   /* Probably poisoned */
+
+    bool    seen;       /* Assigned motion */
+    bool    used;       /* Assigned message */
+
+    byte    x, y;       /* Location */
+
+    byte    ox, oy;     /* Old location */
+
+    byte    speed;      /* Estimated speed */
+    byte    moves;      /* Estimates moves */
+    bool    ranged_attack; /* can attack from a dx */
+    s16b    power;      /* Estimated hit-points */
+    s16b    other;      /* Estimated something */
+    s16b    level;      /* Monsters Level */
+
+    s16b    when;       /* When last seen */
+};
+
+
+
+/*
+ * Maximum number of rooms.  This may be too small.
+ * But if AUTO_ROOMS * sizeof(borg_room) > 64K then some
+ * machines may not be able to allocate the room array.
+ */
+#define AUTO_ROOMS  (AUTO_MAX_X * AUTO_MAX_Y / 8)
+
+/*
+ * Forward declare
+ */
+typedef struct borg_grid borg_grid;
+
+/*
+ * A grid in the dungeon.  Several bytes.
+ *
+ * There is a set of eight bit flags (see below) called "info".
+ *
+ * There is a terrain feature type, which may be incorrect.  It is
+ * more or less based on the standard "feature" values, but some of
+ * the legal values are never used, such as "secret door", and others
+ * are used in bizarre ways, such as "invisible trap".
+ *
+ * There is an object index into the "object tracking" array.
+ *
+ * There is a monster index into the "monster tracking" array.
+ *
+ * There is a byte "hmmm" which is currently unused.
+ *
+ * There is a byte "xtra" which tracks how much "searching" has been done
+ * in the grid or in any grid next to the grid.
+ *
+ * To perform "navigation" from one place to another, the "flow" routines
+ * are used, which place "cost" information into the "cost" fields.  Then,
+ * if the path is clear, the "cost" information is copied into the "flow"
+ * fields, which are used for the actual navigation.  This allows multiple
+ * routines to check for "possible" flowing, without hurting the current
+ * flow, which may have taken a long time to construct.  We also assume
+ * that the Borg never needs to follow a path longer than 250 grids long.
+ * Note that the "cost" fields have been moved into external arrays.
+ *
+ * Hack -- note that the "char" zero will often crash the system!
+ */
+struct borg_grid
+{
+    byte feat;      /* Grid type */
+    byte info;      /* Grid flags */
+
+    byte take;      /* Object index */
+    byte kill;      /* Monster index */
+
+    byte hmmm;      /* Extra field (unused) */
+
+    byte xtra;      /* Extra field (search count) */
+};
+
+
+/*
+ * Forward declare
+ */
+typedef struct borg_data borg_data;
+
+/*
+ * Hack -- one byte of info per grid
+ *
+ * We use a structure to encapsulate the data into a "typed" form.
+ */
+struct borg_data
+{
+    byte data[AUTO_MAX_Y][AUTO_MAX_X];
+};
+
+
+
+
+/*** Some macros ***/
+
+
+/*
+ * Determine "twice" the distance between two points
+ * This results in "diagonals" being "correctly" ranged,
+ * that is, a diagonal appears "furthur" than an adjacent.
+ */
+#define double_distance(Y1,X1,Y2,X2) \
+    (distance(((int)(Y1))<<1,((int)(X1))<<1,((int)(Y2))<<1,((int)(X2))<<1))
+
+
+
+/*** Some variables ***/
+
+
+/*
+ * Some variables
+ */
+extern bool borg_active;        /* Actually active */
+extern bool borg_resurrect;     /* Continous play mode */
+extern bool borg_cancel;        /* Being cancelled */
+
+extern char genocide_target;    /* Identity of the poor unsuspecting soul */
+extern int zap_slot;            /* to avoid a nasty game bug with amnesia */
+extern bool borg_casted_glyph;  /* we dont have a launch messages anymore */
+extern int borg_stop_dlevel;
+extern int borg_stop_clevel;
+extern int borg_no_deeper;
+extern bool borg_stop_king;
+extern bool borg_dont_react;
+extern int successful_target;
+extern int sold_item_tval;
+extern int sold_item_sval;
+extern int sold_item_pval;
+extern int sold_item_store;
+
+/* options from the borg.txt file */
+extern int borg_respawn_race;
+extern int borg_respawn_class;
+extern int borg_respawn_str;
+extern int borg_respawn_int;
+extern int borg_respawn_wis;
+extern int borg_respawn_dex;
+extern int borg_respawn_con;
+extern int borg_respawn_chr;
+extern int borg_dump_level;
+extern int borg_save_death;
+extern bool borg_respawn_winners;
+extern int borg_delay_factor;
+
+extern bool borg_worships_damage;
+extern bool borg_worships_speed;
+extern bool borg_worships_hp;
+extern bool borg_worships_mana;
+extern bool borg_worships_ac;
+extern bool borg_worships_gold;
+extern bool borg_plays_risky;
+extern bool borg_uses_swaps;
+extern bool borg_uses_calcs;
+extern bool borg_slow_optimizehome;
+extern bool borg_scums_uniques;
+extern int borg_chest_fail_tolerance;
+extern u32b borg_money_scum_amount;
+extern bool borg_self_scum;
+extern bool borg_lunal_mode;
+extern bool borg_self_lunal;
+
+/* HACK... this should really be a parm into borg_prepared */
+/*         I am just being lazy */
+extern bool borg_slow_return;
+
+/* dynamic required items */
+/* dynamic required items */
+typedef struct req_item
+{
+   int depth;
+   int item;
+   int number;
+
+} req_item;
+
+extern req_item **borg_required_item;
+
+extern int *n_req;
+typedef struct power_item
+{
+   int depth;
+   int cnd;
+   int item;
+   int from;
+   int to;
+   int power;
+   bool each;
+} power_item;
+
+extern power_item **borg_power_item;
+extern int *n_pwr;
+extern int *borg_has;
+extern int *borg_has_on;
+extern int *borg_artifact;
+extern int *borg_skill;
+extern int size_depth;
+extern int size_obj;
+
+/* NOTE: This must exactly match the prefix_pref enums in BORG1.c */
+enum
+{
+    BI_STR,
+    BI_INT,
+    BI_WIS,
+    BI_DEX,
+    BI_CON,
+    BI_CHR,
+    BI_CSTR,
+    BI_CINT,
+    BI_CWIS,
+    BI_CDEX,
+    BI_CCON,
+    BI_CCHR,
+    BI_SSTR,
+    BI_SINT,
+    BI_SWIS,
+    BI_SDEX,
+    BI_SCON,
+    BI_SCHR,
+    BI_LITE,
+    BI_CURHP,
+    BI_MAXHP,
+    BI_CURSP,
+    BI_MAXSP,
+    BI_SP_ADJ,
+    BI_FAIL1,
+    BI_FAIL2,
+    BI_CLEVEL,
+    BI_MAXCLEVEL,
+    BI_ESP,
+    BI_CURLITE,
+    BI_RECALL,
+    BI_FOOD,
+    BI_SPEED,
+    BI_SDIG,
+    BI_FEATH,
+    BI_REG,
+    BI_SINV,
+    BI_INFRA,
+    BI_DIS,
+    BI_DEV,
+    BI_SAV,
+    BI_STL,
+    BI_SRCH,
+    BI_SRCHFREQ,
+    BI_THN,
+    BI_THB,
+    BI_THT,
+    BI_DIG,
+    BI_IFIRE,
+    BI_IACID,
+    BI_ICOLD,
+    BI_IELEC,
+    BI_RFIRE,
+    BI_RCOLD,
+    BI_RELEC,
+    BI_RACID,
+    BI_RPOIS,
+    BI_RFEAR,
+    BI_RLITE,
+    BI_RDARK,
+    BI_RBLIND,
+    BI_RCONF,
+    BI_RSND,
+    BI_RSHRD,
+    BI_RNXUS,
+    BI_RNTHR,
+    BI_RKAOS,
+    BI_RDIS,
+    BI_HLIFE,
+    BI_FRACT,
+    BI_SRFIRE,
+    BI_SRCOLD,
+    BI_SRELEC,
+    BI_SRACID,
+    BI_SRPOIS,
+    BI_SRFEAR,
+    BI_SRLITE,
+    BI_SRDARK,
+    BI_SRBLIND,
+    BI_SRCONF,
+    BI_SRSND,
+    BI_SRSHRD,
+    BI_SRNXUS,
+    BI_SRNTHR,
+    BI_SRKAOS,
+    BI_SRDIS,
+    BI_SHLIFE,
+    BI_SFRACT,
+    BI_DEPTH,
+    BI_CDEPTH,
+    BI_MAXDEPTH,
+    BI_KING,
+
+    BI_ISWEAK,
+    BI_ISHUNGRY,
+    BI_ISFULL,
+    BI_ISGORGED,
+    BI_ISBLIND,
+    BI_ISAFRAID,
+    BI_ISCONFUSED,
+    BI_ISPOISONED,
+    BI_ISCUT,
+    BI_ISSTUN,
+    BI_ISHEAVYSTUN,
+	BI_ISPARALYZED,
+    BI_ISIMAGE,
+    BI_ISSTUDY,
+    BI_ISSEARCHING,
+    BI_ISFIXLEV,
+    BI_ISFIXEXP,
+    BI_ISFIXSTR,
+    BI_ISFIXINT,
+    BI_ISFIXWIS,
+    BI_ISFIXDEX,
+    BI_ISFIXCON,
+    BI_ISFIXCHR,
+    BI_ISFIXALL,
+
+    BI_ARMOR,
+    BI_TOHIT,
+    BI_TODAM,
+    BI_WTOHIT,
+    BI_WTODAM,
+    BI_BTOHIT,
+    BI_BTODAM,
+    BI_BLOWS,
+    BI_SHOTS,
+    BI_WMAXDAM,
+    BI_WBASEDAM,
+    BI_BMAXDAM,
+    BI_HEAVYWEPON,
+    BI_HEAVYBOW,
+    BI_CRSTELE,
+    BI_CRSAGRV,
+    BI_WS_ANIMAL,
+    BI_WS_EVIL,
+    BI_WS_UNDEAD,
+    BI_WS_DEMON,
+    BI_WS_ORC,
+    BI_WS_TROLL,
+    BI_WS_GIANT,
+    BI_WS_DRAGON,
+    BI_WK_UNDEAD,
+    BI_WK_DEMON,
+    BI_WK_DRAGON,
+    BI_W_IMPACT,
+    BI_WB_ACID,
+    BI_WB_ELEC,
+    BI_WB_FIRE,
+    BI_WB_COLD,
+    BI_WB_POIS,
+	BI_APHASE,
+    BI_ATELEPORT,
+    BI_AESCAPE,
+    BI_AFUEL,
+    BI_AHEAL,
+    BI_AEZHEAL,
+    BI_AID,
+    BI_ASPEED,
+    BI_ASTFMAGI,
+    BI_ASTFDEST,
+    BI_ATPORTOTHER,
+    BI_AMISSILES,
+    BI_ACUREPOIS,
+    BI_ADETTRAP,
+    BI_ADETDOOR,
+    BI_ADETEVIL,
+    BI_AMAGICMAP,
+    BI_ARECHARGE,
+    BI_ALITE,
+    BI_APFE,
+    BI_AGLYPH,
+    BI_ACCW,
+    BI_ACSW,
+    BI_ARESHEAT,
+    BI_ARESCOLD,
+    BI_ATELEPORTLVL,  /* scroll of teleport level */
+    BI_AHWORD,            /* Holy Word prayer */
+	BI_ADETONATE, /* POTIONS used as weapons */
+	BI_DINV,	/* See Inv Spell Legal */
+
+    BI_MAX
+};
+
+#define MAX_FORMULA_ELEMENTS 60
+enum
+{
+    BFO_DONE, /* just to make sure we end fast if there is no formula */
+    BFO_NUMBER,
+    BFO_VARIABLE,
+    BFO_EQ,
+    BFO_NEQ,
+    BFO_NOT,
+    BFO_LT,
+    BFO_LTE,
+    BFO_GT,
+    BFO_GTE,
+    BFO_AND,
+    BFO_OR,
+    BFO_PLUS,
+    BFO_MINUS,
+    BFO_DIVIDE,
+    BFO_MULT
+};
+
+extern int *formula[1000];
+extern cptr prefix_pref[];
+
+/*
+ * Hack -- optional cheating flags
+ */
+
+extern bool borg_do_star_id;
+
+
+/*
+ * Various silly flags
+ */
+
+extern bool borg_flag_save;     /* Save savefile at each level */
+
+extern bool borg_flag_dump;     /* Save savefile at each death */
+
+extern bool borg_save; /* do a save next time we get to press a key! */
+
+extern bool borg_borg_message;      /* List borg messages or not */
+extern bool borg_graphics;          /* List borg messages or not */
+extern bool borg_confirm_target;
+
+extern char borg_engine_date[];       /* last update */
+
+/*
+ * Use a simple internal random number generator
+ */
+
+extern bool borg_rand_quick;        /* Save system setting */
+
+extern u32b borg_rand_value;        /* Save system setting */
+
+extern u32b borg_rand_local;        /* Save personal setting */
+
+
+/*
+ * Hack -- time variables
+ */
+
+extern s16b borg_t;        /* Current "time" */
+extern s16b borg_t_morgoth;
+extern s16b need_see_inviso;        /* To tell me to cast it */
+extern s16b borg_see_inv;
+extern bool need_shift_panel;        /* to spot offscreeners */
+extern s16b when_shift_panel;
+extern s16b time_this_panel;        /* Current "time" for current panel*/
+extern bool vault_on_level;     /* borg will search for a vault */
+extern int unique_on_level;
+extern bool scaryguy_on_level;
+extern bool morgoth_on_level;
+extern bool borg_morgoth_position;
+
+extern bool breeder_level;      /* Borg will shut doors */
+extern s16b old_depth;
+extern s16b borg_respawning;       /* to prevent certain crashes */
+extern s16b borg_hound_count;
+extern s16b borg_lich_count;
+extern s16b borg_demon_count;
+extern s16b borg_angel_count;
+extern s16b borg_wight_count;
+extern s16b borg_no_retreat;
+
+/*
+ * Hack -- Other time variables
+ */
+
+extern s16b when_call_lite; /* When we last did call light */
+extern s16b when_wizard_lite;   /* When we last did wizard light */
+
+extern s16b when_detect_traps;  /* When we last detected traps */
+extern s16b when_detect_doors;  /* When we last detected doors */
+extern s16b when_detect_walls;  /* When we last detected walls */
+extern s16b when_detect_evil;
+extern s16b when_last_kill_mult;   /* When a multiplier was last killed */
+
+extern bool my_need_alter;     /* incase of walls/doors */
+extern bool my_no_alter;     /* incase of walls/doors */
+extern bool my_need_redraw;     /* incase of walls/doors */
+extern bool borg_attempting_refresh_resist;  /* for the Resistance spell */
+
+/*
+ * Some information
+ */
+
+extern s16b goal;       /* Flowing (goal type) */
+
+extern bool goal_rising;    /* Currently returning to town */
+
+extern bool goal_leaving;   /* Currently leaving the level */
+
+extern bool goal_fleeing;   /* Currently fleeing the level */
+
+extern bool goal_fleeing_lunal;   /* Currently fleeing the level in lunal*/
+
+extern bool borg_fleeing_town; /* Currently fleeing the level to return to town */
+
+extern bool goal_ignoring;  /* Currently ignoring monsters */
+
+extern int goal_recalling;  /* Currently waiting for recall, guessing turns left */
+extern bool goal_less;      /* return to, but dont use, the next up stairs */
+
+extern s16b borg_times_twitch; /* how often twitchy on this level */
+extern s16b borg_escapes; /* how often teleported on this level */
+
+extern bool stair_less;     /* Use the next "up" staircase */
+extern bool stair_more;     /* Use the next "down" staircase */
+
+extern s32b borg_began;     /* When this level began */
+extern s32b borg_time_town; /* how long it has been since I was in town */
+
+extern s16b avoidance;      /* Current danger thresh-hold */
+
+extern bool borg_failure;   /* Notice failure */
+
+extern bool borg_simulate;  /* Simulation flag */
+extern bool borg_attacking; /* Are we attacking a monster? */
+extern bool borg_offsetting; /* Are we attacking a monster? with offsett balls*/
+
+extern bool borg_completed; /* Completed the level */
+extern bool borg_on_upstairs;      /* used when leaving a level */
+extern bool borg_on_dnstairs;      /* used when leaving a level */
+extern bool borg_needs_searching;  /* borg will search with each step */
+extern bool borg_full_damage;  /* make danger = full possible damage. */
+extern s16b borg_oldchp;		/* hit points last game turn */
+extern s16b borg_oldcsp;		/* mana points last game turn */
+
+/* defence flags */
+extern bool borg_prot_from_evil;
+extern bool borg_speed;
+extern bool borg_bless;
+extern bool borg_hero;
+extern bool borg_berserk;
+extern bool my_oppose_fire;
+extern bool my_oppose_cold;
+extern bool my_oppose_acid;
+extern bool my_oppose_pois;
+extern bool my_oppose_elec;
+extern s16b borg_game_ratio;
+extern s16b borg_resistance;
+extern s16b borg_no_rest_prep; /* borg wont rest for a few turns */
+extern bool borg_shield;
+extern bool borg_on_glyph; /* borg is standing on a glyph of warding */
+extern bool borg_create_door; /* borg is going to create doors */
+extern bool borg_sleep_spell;
+extern bool borg_sleep_spell_ii;
+extern bool borg_slow_spell;
+extern bool borg_confuse_spell;
+extern bool borg_fear_mon_spell;
+
+
+/*
+ * Shop goals
+ */
+
+extern s16b goal_shop;      /* Next shop to visit */
+extern s16b goal_ware;      /* Next item to buy there */
+extern s16b goal_item;      /* Next item to sell there */
+extern int borg_food_onsale;      /* Are shops selling food? */
+extern int borg_fuel_onsale;      /* Are shops selling fuel? */
+
+/*
+ * Other variables
+ */
+
+extern int w_x;         /* Current panel offset (X) */
+extern int w_y;         /* Current panel offset (Y) */
+extern int morgy_panel_y;
+extern int morgy_panel_x;
+
+extern int borg_target_y;
+extern int borg_target_x;  /* Current targetted location */
+
+extern int c_x;         /* Current location (X) */
+extern int c_y;         /* Current location (Y) */
+
+extern int g_x;         /* Goal location (X) */
+extern int g_y;         /* Goal location (Y) */
+
+extern int bad_obj_x[50];   /* Dropped cursed artifact at location (X) */
+extern int bad_obj_y[50];   /* Dropped cursed artifact at location (Y) */
+
+
+/*
+ * Some estimated state variables
+ */
+
+extern s16b my_stat_max[6]; /* Current "maximal" stat values    */
+extern s16b my_stat_cur[6]; /* Current "natural" stat values    */
+extern s16b my_stat_use[6]; /* Current "resulting" stat values  */
+extern s16b my_stat_ind[6]; /* Current "additions" to stat values   */
+extern bool my_need_stat_check[6];  /* do I need to check my stats */
+
+extern s16b my_stat_add[6];  /* aditions to stats */
+
+extern s16b home_stat_add[6];
+
+extern int  weapon_swap;   /* location of my swap weapon   */
+extern s32b weapon_swap_value;   /* value of my swap weapon   */
+extern int  armour_swap;   /* location of my swap weapon   */
+extern s32b armour_swap_value;   /* value of my swap weapon   */
+
+/* a 3 state boolean */
+/*-1 = not cursed, no help needed for it */
+/* 0 = light curse, needs light remove curse spell */
+/* 1 = heavy curse, needs heavy remove curse spell */
+extern int decurse_weapon_swap;  /* my swap is great, except its cursed */
+extern int enchant_weapon_swap_to_h;  /* my swap is great, except its cursed */
+extern int enchant_weapon_swap_to_d;  /* my swap is great, except its cursed */
+extern int decurse_armour_swap;  /* my swap is great, except its cursed */
+extern int enchant_armour_swap_to_a;  /* my swap is great, except its cursed */
+extern bool borg_wearing_cursed;
+
+extern s16b weapon_swap_digger;
+extern byte  weapon_swap_slay_animal;
+extern byte  weapon_swap_slay_evil;
+extern byte  weapon_swap_slay_undead;
+extern byte  weapon_swap_slay_demon;
+extern byte  weapon_swap_slay_orc;
+extern byte  weapon_swap_slay_troll;
+extern byte  weapon_swap_slay_giant;
+extern byte  weapon_swap_slay_dragon;
+extern byte  weapon_swap_kill_undead;
+extern byte  weapon_swap_kill_demon;
+extern byte  weapon_swap_kill_dragon;
+extern byte  weapon_swap_impact;
+extern byte  weapon_swap_brand_acid;
+extern byte  weapon_swap_brand_elec;
+extern byte  weapon_swap_brand_fire;
+extern byte  weapon_swap_brand_cold;
+extern byte  weapon_swap_brand_pois;
+extern byte  weapon_swap_see_infra;
+extern byte  weapon_swap_slow_digest;
+extern byte  weapon_swap_aggravate;
+extern byte  weapon_swap_teleport;
+extern byte  weapon_swap_regenerate;
+extern byte  weapon_swap_telepathy;
+extern byte  weapon_swap_lite;
+extern byte  weapon_swap_see_invis;
+extern byte  weapon_swap_ffall;
+extern byte  weapon_swap_free_act;
+extern byte  weapon_swap_hold_life;
+extern byte  weapon_swap_immune_fire;
+extern byte  weapon_swap_immune_acid;
+extern byte  weapon_swap_immune_cold;
+extern byte  weapon_swap_immune_elec;
+extern byte  weapon_swap_resist_acid;
+extern byte  weapon_swap_resist_elec;
+extern byte  weapon_swap_resist_fire;
+extern byte  weapon_swap_resist_cold;
+extern byte  weapon_swap_resist_pois;
+extern byte  weapon_swap_resist_conf;
+extern byte  weapon_swap_resist_sound;
+extern byte  weapon_swap_resist_lite;
+extern byte  weapon_swap_resist_dark;
+extern byte  weapon_swap_resist_chaos;
+extern byte  weapon_swap_resist_disen;
+extern byte  weapon_swap_resist_shard;
+extern byte  weapon_swap_resist_nexus;
+extern byte  weapon_swap_resist_blind;
+extern byte  weapon_swap_resist_neth;
+extern byte  weapon_swap_resist_fear;
+extern byte  armour_swap_slay_animal;
+extern byte  armour_swap_slay_evil;
+extern byte  armour_swap_slay_undead;
+extern byte  armour_swap_slay_demon;
+extern byte  armour_swap_slay_orc;
+extern byte  armour_swap_slay_troll;
+extern byte  armour_swap_slay_giant;
+extern byte  armour_swap_slay_dragon;
+extern byte  armour_swap_kill_undead;
+extern byte  armour_swap_kill_demon;
+extern byte  armour_swap_kill_dragon;
+extern byte  armour_swap_impact;
+extern byte  armour_swap_brand_acid;
+extern byte  armour_swap_brand_elec;
+extern byte  armour_swap_brand_fire;
+extern byte  armour_swap_brand_cold;
+extern byte  armour_swap_brand_pois;
+extern byte  armour_swap_see_infra;
+extern byte  armour_swap_slow_digest;
+extern byte  armour_swap_aggravate;
+extern byte  armour_swap_teleport;
+extern byte  armour_swap_regenerate;
+extern byte  armour_swap_telepathy;
+extern byte  armour_swap_lite;
+extern byte  armour_swap_see_invis;
+extern byte  armour_swap_ffall;
+extern byte  armour_swap_free_act;
+extern byte  armour_swap_hold_life;
+extern byte  armour_swap_immune_fire;
+extern byte  armour_swap_immune_acid;
+extern byte  armour_swap_immune_cold;
+extern byte  armour_swap_immune_elec;
+extern byte  armour_swap_resist_acid;
+extern byte  armour_swap_resist_elec;
+extern byte  armour_swap_resist_fire;
+extern byte  armour_swap_resist_cold;
+extern byte  armour_swap_resist_pois;
+extern byte  armour_swap_resist_conf;
+extern byte  armour_swap_resist_sound;
+extern byte  armour_swap_resist_lite;
+extern byte  armour_swap_resist_dark;
+extern byte  armour_swap_resist_chaos;
+extern byte  armour_swap_resist_disen;
+extern byte  armour_swap_resist_shard;
+extern byte  armour_swap_resist_nexus;
+extern byte  armour_swap_resist_blind;
+extern byte  armour_swap_resist_neth;
+extern byte  armour_swap_resist_fear;
+
+extern byte my_ammo_tval;   /* Ammo -- "tval"   */
+extern byte my_ammo_sides;  /* Ammo -- "sides"  */
+extern s16b my_ammo_power;  /* Shooting multipler   */
+extern s16b my_ammo_range;  /* Shooting range   */
+
+extern s16b my_need_enchant_to_a;   /* Need some enchantment */
+extern s16b my_need_enchant_to_h;   /* Need some enchantment */
+extern s16b my_need_enchant_to_d;   /* Need some enchantment */
+extern s16b my_need_brand_weapon;  /* apw brand bolts */
+
+
+/*
+ * Hack -- basic "power"
+ */
+
+extern s32b my_power;
+
+
+/*
+ * Various "amounts" (for the player)
+ */
+
+extern s16b amt_food_lowcal;
+extern s16b amt_food_hical;
+
+extern s16b amt_slow_poison;
+extern s16b amt_cure_confusion;
+extern s16b amt_cure_blind;
+
+extern s16b amt_cool_staff;  /* holiness-power staff */
+
+extern s16b amt_book[9];
+
+extern s16b amt_add_stat[6];
+extern s16b amt_inc_stat[6];
+extern s16b amt_fix_stat[7];
+
+extern s16b amt_fix_exp;
+
+extern s16b amt_enchant_to_a;
+extern s16b amt_enchant_to_d;
+extern s16b amt_enchant_to_h;
+extern s16b amt_brand_weapon;  /* cubragol and bolts */
+extern s16b amt_enchant_weapon;
+extern s16b amt_enchant_armor;
+extern s16b amt_digger;
+extern s16b amt_ego;
+
+/*
+ * Various "amounts" (for the home)
+ */
+
+extern s16b num_food;
+extern s16b num_fuel;
+extern s16b num_mold;
+extern s16b num_ident;
+extern s16b num_star_ident;
+extern s16b num_recall;
+extern s16b num_phase;
+extern s16b num_escape;
+extern s16b num_tele_staves;
+extern s16b num_teleport;
+extern s16b num_berserk;
+extern s16b num_teleport_level;
+extern s16b num_recharge;
+
+extern s16b num_cure_critical;
+extern s16b num_cure_serious;
+
+extern s16b num_pot_rheat;
+extern s16b num_pot_rcold;
+
+extern s16b num_missile;
+
+extern s16b num_book[9];
+
+extern s16b num_fix_stat[7];
+
+extern s16b num_fix_exp;
+extern s16b num_mana;
+extern s16b num_heal;
+extern s16b num_heal_true;
+extern s16b num_ez_heal;
+extern s16b num_ez_heal_true;
+extern s16b num_pfe;
+extern s16b num_glyph;
+extern s16b num_speed;
+extern s16b num_detonate;
+
+extern s16b num_enchant_to_a;
+extern s16b num_enchant_to_d;
+extern s16b num_enchant_to_h;
+extern s16b num_brand_weapon;  /* apw crubragol and bolts */
+extern s16b num_genocide;
+extern s16b num_mass_genocide;
+
+extern s16b num_artifact;
+extern s16b num_ego;
+
+extern s16b home_slot_free;
+extern s16b home_damage;
+extern s16b num_duplicate_items;
+extern s16b num_slow_digest;
+extern s16b num_regenerate;
+extern s16b num_telepathy;
+extern s16b num_lite;
+extern s16b num_see_inv;
+
+extern s16b num_invisible; /*apw*/
+
+extern s16b num_ffall;
+extern s16b num_free_act;
+extern s16b num_hold_life;
+extern s16b num_immune_acid;
+extern s16b num_immune_elec;
+extern s16b num_immune_fire;
+extern s16b num_immune_cold;
+extern s16b num_resist_acid;
+extern s16b num_resist_elec;
+extern s16b num_resist_fire;
+extern s16b num_resist_cold;
+extern s16b num_resist_pois;
+extern s16b num_resist_conf;
+extern s16b num_resist_sound;
+extern s16b num_resist_lite;
+extern s16b num_resist_dark;
+extern s16b num_resist_chaos;
+extern s16b num_resist_disen;
+extern s16b num_resist_shard;
+extern s16b num_resist_nexus;
+extern s16b num_resist_blind;
+extern s16b num_resist_neth;
+extern s16b num_sustain_str;
+extern s16b num_sustain_int;
+extern s16b num_sustain_wis;
+extern s16b num_sustain_dex;
+extern s16b num_sustain_con;
+extern s16b num_sustain_all;
+
+extern s16b num_speed;
+extern s16b num_edged_weapon;
+extern s16b num_bad_gloves;
+extern s16b num_weapons;
+extern s16b num_bow;
+extern s16b num_rings;
+extern s16b num_neck;
+extern s16b num_armor;
+extern s16b num_cloaks;
+extern s16b num_shields;
+extern s16b num_hats;
+extern s16b num_gloves;
+extern s16b num_boots;
+
+/*
+ * Deal with knowing which uniques are alive
+ */
+extern int borg_numb_live_unique;
+extern int borg_living_unique_index;
+extern int borg_unique_depth;
+
+/*
+ * Hack -- extra state variables
+ */
+
+extern int borg_feeling;    /* Current level "feeling" */
+
+/*
+ * Hack -- current shop index
+ */
+
+extern s16b shop_num;       /* Current shop index */
+
+
+
+/*
+ * State variables extracted from the screen
+ */
+
+extern s32b borg_exp;       /* Current experience */
+
+extern s32b borg_gold;      /* Current gold */
+
+extern int borg_stat[6];    /* Current stats */
+
+extern int borg_book[9];    /* Current book slots */
+
+
+/*
+ * State variables extracted from the inventory/equipment
+ */
+
+extern int borg_cur_wgt;    /* Current weight */
+
+
+/*
+ * Constant state variables
+ */
+
+extern int borg_race;       /* Current race */
+extern int borg_class;      /* Current class */
+
+
+
+/*
+ * Constant state structures
+ */
+
+extern player_race *rb_ptr; /* Player race info */
+extern player_class *cb_ptr;    /* Player class info */
+extern player_magic *mb_ptr;    /* Player magic info */
+
+
+extern void mmove2(int *y, int *x, int y1, int x1, int y2, int x2);
+
+/*
+ * Number of turns to step for (zero means forever)
+ */
+extern u16b borg_step;      /* Step count (if any) */
+
+
+/*
+ * Status message search string
+ */
+extern char borg_match[128];    /* Search string */
+
+
+/*
+ * Log file
+ */
+extern FILE *borg_fff;      /* Log file */
+
+
+/*
+ * Hack -- single character constants
+ */
+
+extern const char p1, p2, c1, c2, b1, b2;
+
+
+/*
+ * Hack -- the detection arrays
+ */
+
+extern bool borg_detect_wall[6][6];
+
+extern bool borg_detect_trap[6][6];
+
+extern bool borg_detect_door[6][6];
+
+extern bool borg_detect_evil[6][6];
+
+/*
+ * Locate the store doors
+ */
+
+extern byte *track_shop_x;
+extern byte *track_shop_y;
+
+
+/*
+ * Track "stairs up"
+ */
+
+extern s16b track_less_num;
+extern s16b track_less_size;
+extern byte *track_less_x;
+extern byte *track_less_y;
+
+
+/*
+ * Track "stairs down"
+ */
+
+extern s16b track_more_num;
+extern s16b track_more_size;
+extern byte *track_more_x;
+extern byte *track_more_y;
+
+/*
+ * Track glyphs
+ */
+extern s16b track_glyph_num;
+extern s16b track_glyph_size;
+extern byte *track_glyph_x;
+extern byte *track_glyph_y;
+
+extern bool borg_needs_new_sea;
+
+extern const s16b borg_ddx_ddd[24];
+extern const s16b borg_ddy_ddd[24];
+
+/*
+ * Track steps
+ */
+extern s16b track_step_num;
+extern s16b track_step_size;
+extern byte *track_step_x;
+extern byte *track_step_y;
+
+/*
+ * Track closed doors
+ */
+extern s16b track_door_num;
+extern s16b track_door_size;
+extern byte *track_door_x;
+extern byte *track_door_y;
+
+/*
+ * Track closed doors which started closed
+ */
+extern s16b track_closed_num;
+extern s16b track_closed_size;
+extern byte *track_closed_x;
+extern byte *track_closed_y;
+
+/*
+ * The object list.  This list is used to "track" objects.
+ */
+
+extern s16b borg_takes_cnt;
+
+extern s16b borg_takes_nxt;
+
+extern borg_take *borg_takes;
+
+
+/*
+ * The monster list.  This list is used to "track" monsters.
+ */
+
+extern s16b borg_kills_cnt;
+extern s16b borg_kills_summoner;   /* index of a summoning guy */
+extern s16b borg_kills_nxt;
+
+extern borg_kill *borg_kills;
+
+
+/*
+ * Hack -- depth readiness
+ */
+extern int borg_ready_morgoth;
+
+/*
+ * Hack -- extra fear per "region"
+ */
+
+extern u16b borg_fear_region[6][18];
+extern u16b borg_fear_monsters[AUTO_MAX_Y][AUTO_MAX_X];
+
+
+/*
+ * Hack -- count racial appearances per level
+ */
+
+extern s16b *borg_race_count;
+
+
+/*
+ * Hack -- count racial kills (for uniques)
+ */
+
+extern s16b *borg_race_death;
+
+
+/*
+ * Classification of map symbols
+ */
+
+extern bool borg_is_take[256];      /* Symbol may be an object */
+
+extern bool borg_is_kill[256];      /* Symbol may be a monster */
+
+
+/*
+ * Current "grid" list
+ */
+
+extern borg_grid *borg_grids[AUTO_MAX_Y];   /* Current "grid list" */
+
+/*
+ * Maintain a set of grids (liteable grids)
+ */
+
+extern s16b borg_lite_n;
+extern byte borg_lite_y[AUTO_LITE_MAX];
+extern byte borg_lite_x[AUTO_LITE_MAX];
+
+/*
+ * Maintain a set of glow grids (liteable grids)
+ */
+
+extern s16b borg_glow_n;
+extern byte borg_glow_y[AUTO_LITE_MAX];
+extern byte borg_glow_x[AUTO_LITE_MAX];
+
+
+/*
+ * Maintain a set of grids (viewable grids)
+ */
+
+extern s16b borg_view_n;
+extern byte borg_view_y[AUTO_VIEW_MAX];
+extern byte borg_view_x[AUTO_VIEW_MAX];
+
+
+/*
+ * Maintain a set of grids (scanning arrays)
+ */
+
+extern s16b borg_temp_n;
+extern byte borg_temp_y[AUTO_TEMP_MAX];
+extern byte borg_temp_x[AUTO_TEMP_MAX];
+
+/*
+ * Maintain a temporary set of grids
+ * Used to store lit grid info
+ */
+extern s16b borg_temp_lit_n;
+extern byte borg_temp_lit_x[AUTO_TEMP_MAX];
+extern byte borg_temp_lit_y[AUTO_TEMP_MAX];
+
+/*
+ * Maintain a set of special grids used for Teleport Other
+ */
+extern s16b borg_tp_other_n;
+extern byte borg_tp_other_x[15];
+extern byte borg_tp_other_y[15];
+extern int borg_tp_other_index[15];
+
+extern byte offset_y;
+extern byte offset_x;
+
+
+/*
+ * Maintain a set of grids (flow calculations)
+ */
+
+extern s16b borg_flow_n;
+extern byte borg_flow_y[AUTO_FLOW_MAX];
+extern byte borg_flow_x[AUTO_FLOW_MAX];
+
+
+/*
+ * Hack -- use "flow" array as a queue
+ */
+
+extern int flow_head;
+extern int flow_tail;
+
+
+/*
+ * Some variables
+ */
+
+extern borg_data *borg_data_flow;   /* Current "flow" data */
+
+extern borg_data *borg_data_cost;   /* Current "cost" data */
+
+extern borg_data *borg_data_hard;   /* Constant "hard" data */
+
+extern borg_data *borg_data_know;   /* Current "know" flags */
+
+extern borg_data *borg_data_icky;   /* Current "icky" flags */
+
+
+/*
+ * Strategy flags -- recalculate things
+ */
+
+extern bool borg_danger_wipe;       /* Recalculate danger */
+
+extern bool borg_do_update_view;       /* Recalculate view */
+
+extern bool borg_do_update_lite;       /* Recalculate lite */
+
+
+/*
+ * Strategy flags -- examine the world
+ */
+
+extern bool borg_do_inven;      /* Acquire "inven" info */
+
+extern bool borg_do_equip;      /* Acquire "equip" info */
+
+extern bool borg_do_panel;      /* Acquire "panel" info */
+
+extern bool borg_do_frame;      /* Acquire "frame" info */
+
+extern bool borg_do_spell;      /* Acquire "spell" info */
+
+extern byte borg_do_spell_aux;      /* Hack -- book for "borg_do_spell" */
+
+extern bool borg_do_browse;     /* Acquire "store" info */
+
+extern byte borg_do_browse_what;    /* Hack -- store for "borg_do_browse" */
+
+extern byte borg_do_browse_more;    /* Hack -- pages for "borg_do_browse" */
+
+
+/*
+ * Strategy flags -- run certain functions
+ */
+
+extern bool borg_do_crush_junk;
+
+extern bool borg_do_crush_hole;
+
+extern bool borg_do_crush_slow;
+
+/* am I fighting a unique */
+extern int borg_fighting_unique;
+extern bool borg_fighting_evil_unique;
+
+/* am I fighting a summoner */
+extern bool borg_fighting_summoner;
+
+
+
+/*** Some functions ***/
+
+/*
+ * Queue a keypress
+ */
+extern errr borg_keypress(char k);
+
+/*
+ * Queue several keypresses
+ */
+extern errr borg_keypresses(cptr str);
+
+/*
+ * Dequeue a keypress
+ */
+extern char borg_inkey(bool take);
+
+/*
+ * Flush the keypresses
+ */
+extern void borg_flush(void);
+
+
+/*
+ * Obtain some text from the screen (single character)
+ */
+extern errr borg_what_char(int x, int y, byte *a, char *c);
+
+/*
+ * Obtain some text from the screen (multiple characters)
+ */
+extern errr borg_what_text(int x, int y, int n, byte *a, char *s);
+
+
+/*
+ * Log a message to a file
+ */
+extern void borg_info(cptr what);
+
+/*
+ * Log a message, Search it, and Show/Memorize it in pieces
+ */
+extern void borg_note(cptr what);
+
+
+/*
+ * Abort the Borg, noting the reason
+ */
+extern void borg_oops(cptr what);
+
+
+/*
+ * Take a "memory note"
+ */
+extern bool borg_tell(cptr what);
+
+/*
+ * Change the player name
+ */
+extern bool borg_change_name(cptr str);
+
+/*
+ * Dump a character description
+ */
+extern bool borg_dump_character(cptr str);
+
+/*
+ * Save the game (but do not quit)
+ */
+extern bool borg_save_game(void);
+
+
+/*
+ * Update the "frame" info from the screen
+ */
+extern void borg_update_frame(void);
+
+/*
+ * Calc a formula out in RPN
+ */
+extern int borg_calc_formula(int *);
+/*
+ * check out a formula in RPN
+ */
+extern int borg_check_formula(int *);
+/*
+ * return a string for the formula
+ */
+extern cptr borg_prt_formula(int *formula);
+
+/*
+ * Print the string for an item
+ */
+extern cptr borg_prt_item(int item);
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_1(void);
+
+#ifdef ALLOW_BORG_GRAPHICS
+
+typedef struct glyph
+{
+   byte d_attr;        /* Attribute */
+   char d_char;        /* Character */
+} glyph;
+
+
+extern glyph translate_visuals[255][255];
+
+#endif /* ALLOW_BORG_GRAPHICS */
+
+#ifdef BORG_TK
+extern cptr BORG_DIR_ROOT;
+extern cptr BORG_DIR_DATA;
+#endif /* BORG_TK */
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg2.c angband-3.0.6-borg/src/borg2.c
--- angband-3.0.6/src/borg2.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg2.c	2004-03-04 08:17:00.000000000 -0800
@@ -0,0 +1,1267 @@
+/* File: borg2.c */
+/* Purpose: Low level dungeon mapping skills -BEN- */
+
+#include "angband.h"
+
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg2.h"
+
+
+/*
+ * This file helps the Borg understand mapping the dungeon.
+ *
+ * Currently, this includes general routines involving dungeon grids,
+ * including calculating "flow" values from place to place, determining
+ * "line of sight", plus "field of view" and "torch-lit grids", setting
+ * the target to a given location, and extracting the optimal direction
+ * for "movement" from place to place.
+ *
+ * Note that the dungeon is assumed smaller than 256 by 256.
+ *
+ * This file also supplies the (compiled out) support for "automatic
+ * room extraction".  This code will automatically group regions of
+ * the dungeon into rooms, and do the "flow" navigation on those rooms
+ * instead of on grids.  Often, this takes less space, and is faster,
+ * howver, it is more complicated, and does not allow "specialized"
+ * flow calculations that penalize grids by variable amounts.
+ */
+
+
+/*
+ * A simple, fast, integer-based line-of-sight algorithm.
+ *
+ * See "los()" in "cave.c" for complete documentation
+ */
+bool borg_los(int y1, int x1, int y2, int x2)
+{
+
+/* this routine is seriously flawed.  For the time being replace this with
+ * the function borg_projectable().  It is slightly better.
+ */
+
+ if (borg_projectable(y1,x1,y2,x2)) return (TRUE);
+ return (FALSE);
+
+#if 0
+    /* Delta */
+    int dx, dy;
+
+    /* Absolute */
+    int ax, ay;
+
+    /* Signs */
+    int sx, sy;
+
+    /* Fractions */
+    int qx, qy;
+
+    /* Scanners */
+    int tx, ty;
+
+    /* Scale factors */
+    int f1, f2;
+
+    /* Slope, or 1/Slope, of LOS */
+    int m;
+
+
+    /* Extract the offset */
+    dy = y2 - y1;
+    dx = x2 - x1;
+
+    /* Extract the absolute offset */
+    ay = ABS(dy);
+    ax = ABS(dx);
+
+
+    /* Handle adjacent (or identical) grids */
+    if ((ax < 2) && (ay < 2)) return (TRUE);
+
+
+    /* Paranoia -- require "safe" origin */
+    /* if (!in_bounds(y1, x1)) return (FALSE); */
+
+
+    /* Directly South/North */
+    if (!dx)
+    {
+        /* South -- check for walls */
+        if (dy > 0)
+        {
+            for (ty = y1 + 1; ty < y2; ty++)
+            {
+                if (!borg_cave_floor_bold(ty, x1)) return (FALSE);
+            }
+        }
+
+        /* North -- check for walls */
+        else
+        {
+            for (ty = y1 - 1; ty > y2; ty--)
+            {
+                if (!borg_cave_floor_bold(ty, x1)) return (FALSE);
+            }
+        }
+
+        /* Assume los */
+        return (TRUE);
+    }
+
+    /* Directly East/West */
+    if (!dy)
+    {
+        /* East -- check for walls */
+        if (dx > 0)
+        {
+            for (tx = x1 + 1; tx < x2; tx++)
+            {
+                if (!borg_cave_floor_bold(y1, tx)) return (FALSE);
+            }
+        }
+
+        /* West -- check for walls */
+        else
+        {
+            for (tx = x1 - 1; tx > x2; tx--)
+            {
+                if (!borg_cave_floor_bold(y1, tx)) return (FALSE);
+            }
+        }
+
+        /* Assume los */
+        return (TRUE);
+    }
+
+
+    /* Extract some signs */
+    sx = (dx < 0) ? -1 : 1;
+    sy = (dy < 0) ? -1 : 1;
+
+
+    /* Vertical "knights" */
+    if (ax == 1)
+    {
+        if (ay == 2)
+        {
+            if (borg_cave_floor_bold(y1 + sy, x1)) return (TRUE);
+        }
+    }
+
+    /* Horizontal "knights" */
+    else if (ay == 1)
+    {
+        if (ax == 2)
+        {
+            if (borg_cave_floor_bold(y1, x1 + sx)) return (TRUE);
+        }
+    }
+
+
+    /* Calculate scale factor div 2 */
+    f2 = (ax * ay);
+
+    /* Calculate scale factor */
+    f1 = f2 << 1;
+
+
+    /* Travel horizontally */
+    if (ax >= ay)
+    {
+        /* Let m = dy / dx * 2 * (dy * dx) = 2 * dy * dy */
+        qy = ay * ay;
+        m = qy << 1;
+
+        tx = x1 + sx;
+
+        /* Consider the special case where slope == 1. */
+        if (qy == f2)
+        {
+            ty = y1 + sy;
+            qy -= f1;
+        }
+        else
+        {
+            ty = y1;
+        }
+
+        /* Note (below) the case (qy == f2), where */
+        /* the LOS exactly meets the corner of a tile. */
+        while (x2 - tx)
+        {
+            if (!borg_cave_floor_bold(ty, tx)) return (FALSE);
+
+            qy += m;
+
+            if (qy < f2)
+            {
+                tx += sx;
+            }
+            else if (qy > f2)
+            {
+                ty += sy;
+                if (!borg_cave_floor_bold(ty, tx)) return (FALSE);
+                qy -= f1;
+                tx += sx;
+            }
+            else
+            {
+                ty += sy;
+                qy -= f1;
+                tx += sx;
+            }
+        }
+    }
+
+    /* Travel vertically */
+    else
+    {
+        /* Let m = dx / dy * 2 * (dx * dy) = 2 * dx * dx */
+        qx = ax * ax;
+        m = qx << 1;
+
+        ty = y1 + sy;
+
+        if (qx == f2)
+        {
+            tx = x1 + sx;
+            qx -= f1;
+        }
+        else
+        {
+            tx = x1;
+        }
+
+        /* Note (below) the case (qx == f2), where */
+        /* the LOS exactly meets the corner of a tile. */
+        while (y2 - ty)
+        {
+            if (!borg_cave_floor_bold(ty, tx)) return (FALSE);
+
+            qx += m;
+
+            if (qx < f2)
+            {
+                ty += sy;
+            }
+            else if (qx > f2)
+            {
+                tx += sx;
+                if (!borg_cave_floor_bold(ty, tx)) return (FALSE);
+                qx -= f1;
+                ty += sy;
+            }
+            else
+            {
+                tx += sx;
+                qx -= f1;
+                ty += sy;
+            }
+        }
+    }
+
+    /* Assume los */
+    return (TRUE);
+
+#endif  /* bypass this function */
+}
+
+/*
+ * Check the projection from (x1,y1) to (x2,y2).
+ * Assume that there is no monster in the way.
+ * Hack -- we refuse to assume that unknown grids are floors
+ * Adapted from "projectable()" in "spells1.c".
+ */
+bool borg_projectable(int y1, int x1, int y2, int x2)
+{
+    int dist, y, x;
+
+    borg_grid *ag;
+
+    /* Start at the initial location */
+    y = y1; x = x1;
+
+    /* Simulate the spell/missile path */
+    for (dist = 0; dist <= MAX_RANGE; dist++)
+    {
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        if ((borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 3 ||
+            borg_morgoth_position || scaryguy_on_level))
+        {
+            /* Assume all unknown grids more than distance 20 from you
+             * are walls--when I am wounded. This will make me more fearful
+             * of the grids that are up to 19 spaces away.  I treat them as
+             * regular floor grids.  Which means monsters are assumed to have
+             * LOS on me.  I am also more likely to shoot into the dark grids.
+             */
+            if ((dist > 20) && (ag->feat == FEAT_NONE)) break;
+        }
+        else if (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 2)
+        {
+            /* Assume all unknow grids more than distance 10 from you
+             * are walls--when I am wounded. This will make me more fearful
+             * of the grids that are up to 9 spaces away.  I treat them as
+             * regular floor grids.
+             */
+            if ((dist > 10) && (ag->feat == FEAT_NONE)) break;
+        }
+        else
+        {
+            /* Assume all unknow grids more than distance 3 from you
+             * are walls.  This makes me brave and chancey.
+             */
+            if ((dist > 2) && (ag->feat == FEAT_NONE)) break;
+        }
+        /* Never pass through walls/doors */
+        if (dist && (!borg_cave_floor_grid(ag))) break;
+
+        /* Check for arrival at "final target" */
+        if ((x == x2) && (y == y2)) return (TRUE);
+
+        /* Calculate the new location */
+        mmove2(&y, &x, y1, x1, y2, x2);
+    }
+
+    /* Assume obstruction */
+    return (FALSE);
+}
+
+
+/*
+ * Check the projection from (x1,y1) to (x2,y2).
+ * Assume that there is no monster in the way.
+ * Hack -- we refuse to assume that unknown grids are floors
+ * Adapted from "projectable()" in "spells1.c".
+ * This is used by borg_offset()
+ */
+bool borg_offset_projectable(int y1, int x1, int y2, int x2)
+{
+    int dist, y, x;
+
+    borg_grid *ag;
+
+    /* Start at the initial location */
+    y = y1; x = x1;
+
+    /* Simulate the spell/missile path */
+    for (dist = 0; dist <= MAX_RANGE; dist++)
+    {
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        /* Assume all unknown grids are walls. */
+        if ((dist) && (ag->feat == FEAT_NONE)) break;
+
+        /* Never pass through walls/doors */
+        if (dist && (!borg_cave_floor_grid(ag))) break;
+
+        /* Check for arrival at "final target" */
+        if ((x == x2) && (y == y2)) return (TRUE);
+
+        /* Calculate the new location */
+        mmove2(&y, &x, y1, x1, y2, x2);
+    }
+
+    /* Assume obstruction */
+    return (FALSE);
+}
+
+
+/*
+ * Check the projection from (x1,y1) to (x2,y2).
+ * Assume that monsters in the way will stop the projection
+ * Hack -- we refuse to assume that unknown grids are floors
+ * In fact, we assume they are walls.
+ * Adapted from "projectable()" in "spells1.c".
+ */
+bool borg_projectable_pure(int y1, int x1, int y2, int x2)
+{
+    int dist, y, x;
+    borg_grid *ag;
+
+    /* Start at the initial location */
+    y = y1; x = x1;
+
+    /* Simulate the spell/missile path */
+    for (dist = 0; dist <= MAX_RANGE; dist++)
+    {
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        /* Hack -- assume unknown grids are walls */
+        if (dist && (ag->feat == FEAT_NONE)) break;
+
+        /* Never pass through walls/doors */
+        if (dist && (!borg_cave_floor_grid(ag))) break;
+
+        /* Check for arrival at "final target" */
+        if ((x == x2) && (y == y2)) return (TRUE);
+
+        /* Stop at monsters */
+        if (ag->kill) break;
+
+        /* Calculate the new location */
+        mmove2(&y, &x, y1, x1, y2, x2);
+    }
+
+    /* Assume obstruction */
+    return (FALSE);
+}
+
+/*
+ * Check the projection from (x1,y1) to (x2,y2).
+ * Assume that monsters in the way will stop the projection.
+ * Assume that an unknown grid is a floor grid.
+ * We want at least one unknown grid.
+ *
+ * This routine is used mainly aiming beams of light and
+ * shooting into darkness, testing the projection path.
+ *
+ */
+bool borg_projectable_dark(int y1, int x1, int y2, int x2)
+{
+    int dist, y, x;
+    int unknown = 0;
+    borg_grid *ag;
+
+    /* Start at the initial location */
+    y = y1; x = x1;
+
+    /* Simulate the spell/missile path */
+    for (dist = 0; dist <= MAX_RANGE; dist++)
+    {
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        /* We want at least 1 unknown grid */
+        if (dist && (ag->feat == FEAT_NONE)) unknown ++;
+
+        /* Never pass through walls/doors */
+        if (dist && (!borg_cave_floor_grid(ag))) break;
+
+        /* Check for arrival at "final target" */
+        if ((x == x2) && (y == y2) && unknown >= 1) return (TRUE);
+
+        /* Stop at monsters */
+        if (ag->kill) break;
+
+        /* Calculate the new location */
+        mmove2(&y, &x, y1, x1, y2, x2);
+    }
+
+    /* Assume obstruction */
+    return (FALSE);
+}
+
+
+
+/*
+ * Clear the lite grids
+ */
+void borg_forget_lite(void)
+{
+    int i;
+
+    /* None to forget */
+    if (!borg_lite_n) return;
+
+    /* Clear them all */
+    for (i = 0; i < borg_lite_n; i++)
+    {
+        int y = borg_lite_y[i];
+        int x = borg_lite_x[i];
+
+        /* Forget that the grid is lit */
+        borg_grids[y][x].info &= ~BORG_LITE;
+    }
+
+    /* None left */
+    borg_lite_n = 0;
+}
+
+
+
+/*
+ * XXX XXX XXX
+ *
+ * This macro allows us to efficiently add a grid to the "lite" array,
+ * note that we are never called for illegal grids, or for grids which
+ * have already been placed into the "lite" array, and we are never
+ * called when the "lite" array is full.
+ */
+#define borg_cave_lite_hack(Y,X) \
+    borg_grids[Y][X].info |= BORG_LITE; \
+    borg_lite_y[borg_lite_n] = (Y); \
+    borg_lite_x[borg_lite_n] = (X); \
+    borg_lite_n++
+
+
+
+/*
+ * Update the set of grids "illuminated" by the player's lite.
+ *
+ * See "update_lite" in "cave.c" for complete documentation
+ *
+ * It is very important that the "player grid" be the first grid in the
+ * array of "BORG_LITE" grids, since this is assumed in several places.
+ */
+void borg_update_lite(void)
+{
+    int i, x, y, min_x, max_x, min_y, max_y;
+
+
+    /*** Clear old grids ***/
+
+    /* Clear them all */
+    for (i = 0; i < borg_lite_n; i++)
+    {
+        y = borg_lite_y[i];
+        x = borg_lite_x[i];
+
+        /* Mark the grid as not "lite" */
+        borg_grids[y][x].info &= ~BORG_LITE;
+    }
+
+    /* None left */
+    borg_lite_n = 0;
+
+    /* Hack -- Player has no lite */
+    if (borg_skill[BI_CURLITE] <= 0) return;
+
+
+    /*** Collect the new "lite" grids ***/
+
+    /* Player grid */
+    borg_cave_lite_hack(c_y, c_x);
+
+    /* Radius 1 -- torch radius */
+    if (borg_skill[BI_CURLITE] >= 1)
+    {
+        /* Adjacent grid */
+        borg_cave_lite_hack(c_y+1, c_x);
+        borg_cave_lite_hack(c_y-1, c_x);
+        borg_cave_lite_hack(c_y, c_x+1);
+        borg_cave_lite_hack(c_y, c_x-1);
+
+        /* Diagonal grids */
+        borg_cave_lite_hack(c_y+1, c_x+1);
+        borg_cave_lite_hack(c_y+1, c_x-1);
+        borg_cave_lite_hack(c_y-1, c_x+1);
+        borg_cave_lite_hack(c_y-1, c_x-1);
+    }
+
+    /* Radius 2 -- lantern radius */
+    if (borg_skill[BI_CURLITE] >= 2)
+    {
+        /* South of the player */
+        if (borg_cave_floor_bold(c_y+1, c_x))
+        {
+            borg_cave_lite_hack(c_y+2, c_x);
+            borg_cave_lite_hack(c_y+2, c_x+1);
+            borg_cave_lite_hack(c_y+2, c_x-1);
+        }
+
+        /* North of the player */
+        if (borg_cave_floor_bold(c_y-1, c_x))
+        {
+            borg_cave_lite_hack(c_y-2, c_x);
+            borg_cave_lite_hack(c_y-2, c_x+1);
+            borg_cave_lite_hack(c_y-2, c_x-1);
+        }
+
+        /* East of the player */
+        if (borg_cave_floor_bold(c_y, c_x+1))
+        {
+            borg_cave_lite_hack(c_y, c_x+2);
+            borg_cave_lite_hack(c_y+1, c_x+2);
+            borg_cave_lite_hack(c_y-1, c_x+2);
+        }
+
+        /* West of the player */
+        if (borg_cave_floor_bold(c_y, c_x-1))
+        {
+            borg_cave_lite_hack(c_y, c_x-2);
+            borg_cave_lite_hack(c_y+1, c_x-2);
+            borg_cave_lite_hack(c_y-1, c_x-2);
+        }
+    }
+
+    /* Radius 3+ -- artifact radius */
+    if (borg_skill[BI_CURLITE] >= 3)
+    {
+        int d, p;
+
+        /* Maximal radius */
+        p = borg_skill[BI_CURLITE];
+
+        /* Paranoia -- see "LITE_MAX" */
+        if (p > 5) p = 5;
+
+        /* South-East of the player */
+        if (borg_cave_floor_bold(c_y+1, c_x+1))
+        {
+            borg_cave_lite_hack(c_y+2, c_x+2);
+        }
+
+        /* South-West of the player */
+        if (borg_cave_floor_bold(c_y+1, c_x-1))
+        {
+            borg_cave_lite_hack(c_y+2, c_x-2);
+        }
+
+        /* North-East of the player */
+        if (borg_cave_floor_bold(c_y-1, c_x+1))
+        {
+            borg_cave_lite_hack(c_y-2, c_x+2);
+        }
+
+        /* North-West of the player */
+        if (borg_cave_floor_bold(c_y-1, c_x-1))
+        {
+            borg_cave_lite_hack(c_y-2, c_x-2);
+        }
+
+        /* Maximal north */
+        min_y = c_y - p;
+        if (min_y < 0) min_y = 0;
+
+        /* Maximal south */
+        max_y = c_y + p;
+        if (max_y > AUTO_MAX_Y-1) max_y = AUTO_MAX_Y-1;
+
+        /* Maximal west */
+        min_x = c_x - p;
+        if (min_x < 0) min_x = 0;
+
+        /* Maximal east */
+        max_x = c_x + p;
+        if (max_x > AUTO_MAX_X-1) max_x = AUTO_MAX_X-1;
+
+        /* Scan the maximal box */
+        for (y = min_y; y <= max_y; y++)
+        {
+            for (x = min_x; x <= max_x; x++)
+            {
+                int dy = (c_y > y) ? (c_y - y) : (y - c_y);
+                int dx = (c_x > x) ? (c_x - x) : (x - c_x);
+
+                /* Skip the "central" grids (above) */
+                if ((dy <= 2) && (dx <= 2)) continue;
+
+                /* Hack -- approximate the distance */
+                d = (dy > dx) ? (dy + (dx>>1)) : (dx + (dy>>1));
+
+                /* Skip distant grids */
+                if (d > p) continue;
+
+                /* Viewable, nearby, grids get "torch lit" */
+                if (borg_grids[y][x].info & BORG_VIEW)
+                {
+                    /* This grid is "torch lit" */
+                    borg_cave_lite_hack(y, x);
+                }
+            }
+        }
+    }
+}
+
+
+
+
+
+/*
+ * Clear the viewable space
+ */
+void borg_forget_view(void)
+{
+    int i;
+
+    borg_grid *ag;
+
+    /* None to forget */
+    if (!borg_view_n) return;
+
+    /* Clear them all */
+    for (i = 0; i < borg_view_n; i++)
+    {
+        int y = borg_view_y[i];
+        int x = borg_view_x[i];
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+        /* Forget that the grid is viewable */
+        ag->info &= ~BORG_VIEW;
+    }
+
+    /* None left */
+    borg_view_n = 0;
+}
+
+
+
+/*
+ * This macro allows us to efficiently add a grid to the "view" array,
+ * note that we are never called for illegal grids, or for grids which
+ * have already been placed into the "view" array, and we are never
+ * called when the "view" array is full.
+ */
+#define borg_cave_view_hack(A,Y,X) \
+    (A)->info |= BORG_VIEW; \
+    borg_view_y[borg_view_n] = (Y); \
+    borg_view_x[borg_view_n] = (X); \
+    borg_view_n++
+
+
+
+/*
+ * Helper function for "borg_update_view()" below
+ *
+ * See "update_view_aux()" in "cave.c" for complete documentation.
+ */
+static bool borg_update_view_aux(int y, int x, int y1, int x1, int y2, int x2)
+{
+    bool f1, f2, v1, v2, z1, z2, wall;
+
+    borg_grid *ag;
+
+    borg_grid *g1_ag;
+    borg_grid *g2_ag;
+
+
+    /* Access the grids */
+    g1_ag = &borg_grids[y1][x1];
+    g2_ag = &borg_grids[y2][x2];
+
+
+    /* Check for walls */
+    f1 = (borg_cave_floor_grid(g1_ag));
+    f2 = (borg_cave_floor_grid(g2_ag));
+
+    /* Totally blocked by physical walls */
+    if (!f1 && !f2) return (TRUE);
+
+
+    /* Check for visibility */
+    v1 = (f1 && (g1_ag->info & BORG_VIEW));
+    v2 = (f2 && (g2_ag->info & BORG_VIEW));
+
+    /* Totally blocked by "unviewable neighbors" */
+    if (!v1 && !v2) return (TRUE);
+
+
+    /* Access the grid */
+    ag = &borg_grids[y][x];
+
+
+    /* Check for walls */
+    wall = (!borg_cave_floor_grid(ag));
+
+
+    /* Check the "ease" of visibility */
+    z1 = (v1 && (g1_ag->info & BORG_XTRA));
+    z2 = (v2 && (g2_ag->info & BORG_XTRA));
+
+    /* Hack -- "easy" plus "easy" yields "easy" */
+    if (z1 && z2)
+    {
+        ag->info |= BORG_XTRA;
+
+        borg_cave_view_hack(ag, y, x);
+
+        return (wall);
+    }
+
+    /* Hack -- primary "easy" yields "viewed" */
+    if (z1)
+    {
+        borg_cave_view_hack(ag, y, x);
+
+        return (wall);
+    }
+
+
+    /* Hack -- "view" plus "view" yields "view" */
+    if (v1 && v2)
+    {
+        /* ag->info |= BORG_XTRA; */
+
+        borg_cave_view_hack(ag, y, x);
+
+        return (wall);
+    }
+
+
+    /* Mega-Hack -- the "borg_los()" function works poorly on walls */
+    if (wall)
+    {
+        borg_cave_view_hack(ag, y, x);
+
+        return (wall);
+    }
+
+
+    /* Hack -- check line of sight */
+    if (borg_los(c_y, c_x, y, x))
+    {
+        borg_cave_view_hack(ag, y, x);
+
+        return (wall);
+    }
+
+
+    /* Assume no line of sight. */
+    return (TRUE);
+}
+
+
+
+/*
+ * Calculate the region currently "viewable" by the player
+ *
+ * See "update_view()" in "cave.c" for complete documentation
+ *
+ * It is very important that the "player grid" be the first grid in the
+ * array of "BORG_VIEW" grids, since this is assumed in several places.
+ */
+void borg_update_view(void)
+{
+    int n, m, d, k, y, x, z;
+
+    int se, sw, ne, nw, es, en, ws, wn;
+
+    int full, over;
+
+    borg_grid *ag;
+
+
+    /*** Initialize ***/
+
+    /* Optimize */
+    if (view_reduce_lite && !borg_skill[BI_CDEPTH])
+    {
+        /* Full radius (10) */
+        full = MAX_SIGHT / 2;
+
+        /* Octagon factor (15) */
+        over = MAX_SIGHT * 3 / 4;
+    }
+
+    /* Normal */
+    else
+    {
+        /* Full radius (20) */
+        full = MAX_SIGHT;
+
+        /* Octagon factor (30) */
+        over = MAX_SIGHT * 3 / 2;
+    }
+
+
+    /*** Step 0 -- Begin ***/
+
+    /* Save the old "view" grids for later */
+    for (n = 0; n < borg_view_n; n++)
+    {
+        y = borg_view_y[n];
+        x = borg_view_x[n];
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+        /* Mark the grid as not in "view" */
+        ag->info &= ~(BORG_VIEW);
+    }
+
+    /* Start over with the "view" array */
+    borg_view_n = 0;
+
+
+    /*** Step 1 -- adjacent grids ***/
+
+    /* Now start on the player */
+    y = c_y;
+    x = c_x;
+
+    /* Access the grid */
+    ag = &borg_grids[y][x];
+
+    /* Assume the player grid is easily viewable */
+    ag->info |= BORG_XTRA;
+
+    /* Assume the player grid is viewable */
+    borg_cave_view_hack(ag, y, x);
+
+
+    /*** Step 2 -- Major Diagonals ***/
+
+    /* Hack -- Limit */
+    z = full * 2 / 3;
+
+    /* Scan south-east */
+    for (d = 1; d <= z; d++)
+    {
+        ag = &borg_grids[y+d][x+d];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y+d, x+d);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+    /* Scan south-west */
+    for (d = 1; d <= z; d++)
+    {
+        ag = &borg_grids[y+d][x-d];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y+d, x-d);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+    /* Scan north-east */
+    for (d = 1; d <= z; d++)
+    {
+        ag = &borg_grids[y-d][x+d];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y-d, x+d);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+    /* Scan north-west */
+    for (d = 1; d <= z; d++)
+    {
+        ag = &borg_grids[y-d][x-d];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y-d, x-d);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+
+    /*** Step 3 -- major axes ***/
+
+    /* Scan south */
+    for (d = 1; d <= full; d++)
+    {
+        ag = &borg_grids[y+d][x];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y+d, x);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+    /* Initialize the "south strips" */
+    se = sw = d;
+
+    /* Scan north */
+    for (d = 1; d <= full; d++)
+    {
+        ag = &borg_grids[y-d][x];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y-d, x);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+    /* Initialize the "north strips" */
+    ne = nw = d;
+
+    /* Scan east */
+    for (d = 1; d <= full; d++)
+    {
+        ag = &borg_grids[y][x+d];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y, x+d);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+    /* Initialize the "east strips" */
+    es = en = d;
+
+    /* Scan west */
+    for (d = 1; d <= full; d++)
+    {
+        ag = &borg_grids[y][x-d];
+        ag->info |= BORG_XTRA;
+        borg_cave_view_hack(ag, y, x-d);
+        if (!borg_cave_floor_grid(ag)) break;
+    }
+
+    /* Initialize the "west strips" */
+    ws = wn = d;
+
+
+    /*** Step 4 -- Divide each "octant" into "strips" ***/
+
+    /* Now check each "diagonal" (in parallel) */
+    for (n = 1; n <= over / 2; n++)
+    {
+        int ypn, ymn, xpn, xmn;
+
+
+        /* Acquire the "bounds" of the maximal circle */
+        z = over - n - n;
+        if (z > full - n) z = full - n;
+        while ((z + n + (n>>1)) > full) z--;
+
+
+        /* Access the four diagonal grids */
+        ypn = y + n;
+        ymn = y - n;
+        xpn = x + n;
+        xmn = x - n;
+
+
+        /* South strip */
+        if (ypn < AUTO_MAX_Y-1)
+        {
+            /* Maximum distance */
+            m = MIN(z, (AUTO_MAX_Y-1) - ypn);
+
+            /* East side */
+            if ((xpn <= AUTO_MAX_X-1) && (n < se))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ypn+d, xpn, ypn+d-1, xpn-1, ypn+d-1, xpn))
+                    {
+                        if (n + d >= se) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                se = k + 1;
+            }
+
+            /* West side */
+            if ((xmn >= 0) && (n < sw))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ypn+d, xmn, ypn+d-1, xmn+1, ypn+d-1, xmn))
+                    {
+                        if (n + d >= sw) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                sw = k + 1;
+            }
+        }
+
+
+        /* North strip */
+        if (ymn > 0)
+        {
+            /* Maximum distance */
+            m = MIN(z, ymn);
+
+            /* East side */
+            if ((xpn <= AUTO_MAX_X-1) && (n < ne))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ymn-d, xpn, ymn-d+1, xpn-1, ymn-d+1, xpn))
+                    {
+                        if (n + d >= ne) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                ne = k + 1;
+            }
+
+            /* West side */
+            if ((xmn >= 0) && (n < nw))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ymn-d, xmn, ymn-d+1, xmn+1, ymn-d+1, xmn))
+                    {
+                        if (n + d >= nw) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                nw = k + 1;
+            }
+        }
+
+
+        /* East strip */
+        if (xpn < AUTO_MAX_X-1)
+        {
+            /* Maximum distance */
+            m = MIN(z, (AUTO_MAX_X-1) - xpn);
+
+            /* South side */
+            if ((ypn <= AUTO_MAX_Y-1) && (n < es))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ypn, xpn+d, ypn-1, xpn+d-1, ypn, xpn+d-1))
+                    {
+                        if (n + d >= es) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                es = k + 1;
+            }
+
+            /* North side */
+            if ((ymn >= 0) && (n < en))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ymn, xpn+d, ymn+1, xpn+d-1, ymn, xpn+d-1))
+                    {
+                        if (n + d >= en) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                en = k + 1;
+            }
+        }
+
+
+        /* West strip */
+        if (xmn > 0)
+        {
+            /* Maximum distance */
+            m = MIN(z, xmn);
+
+            /* South side */
+            if ((ypn <= AUTO_MAX_Y-1) && (n < ws))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ypn, xmn-d, ypn-1, xmn-d+1, ypn, xmn-d+1))
+                    {
+                        if (n + d >= ws) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                ws = k + 1;
+            }
+
+            /* North side */
+            if ((ymn >= 0) && (n < wn))
+            {
+                /* Scan */
+                for (k = n, d = 1; d <= m; d++)
+                {
+                    /* Check grid "d" in strip "n", notice "blockage" */
+                    if (borg_update_view_aux(ymn, xmn-d, ymn+1, xmn-d+1, ymn, xmn-d+1))
+                    {
+                        if (n + d >= wn) break;
+                    }
+
+                    /* Track most distant "non-blockage" */
+                    else
+                    {
+                        k = n + d;
+                    }
+                }
+
+                /* Limit the next strip */
+                wn = k + 1;
+            }
+        }
+    }
+
+
+    /*** Step 5 -- Complete the algorithm ***/
+
+    /* Update all the new grids */
+    for (n = 0; n < borg_view_n; n++)
+    {
+        y = borg_view_y[n];
+        x = borg_view_x[n];
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+        /* Clear the "BORG_XTRA" flag */
+        ag->info &= ~BORG_XTRA;
+    }
+}
+
+
+
+
+
+/*
+ * Init this file.
+ */
+void borg_init_2(void)
+{
+    /* Nothing */
+}
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg2.h angband-3.0.6-borg/src/borg2.h
--- angband-3.0.6/src/borg2.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg2.h	2003-10-08 18:13:58.000000000 -0700
@@ -0,0 +1,84 @@
+/* File: borg2.h */
+/* Purpose: Header file for "borg2.c" -BEN- */
+
+#ifndef INCLUDED_BORG2_H
+#define INCLUDED_BORG2_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg2.c".
+ */
+
+#include "borg1.h"
+
+
+/*
+ * Determine if a grid is a floor grid
+ */
+#define borg_cave_floor_bold(Y,X) \
+    (!(borg_grids[Y][X].feat & 0x20))
+
+
+/*
+ * Grid based version of "borg_cave_floor_bold()"
+ */
+#define borg_cave_floor_grid(A) \
+    (!((A)->feat & 0x20))
+
+
+
+
+/*
+ * Check a path for line of sight
+ */
+extern bool borg_los(int y1, int x1, int y2, int x2);
+
+
+/*
+ * Check the projection from (x1,y1) to (x2,y2)
+ */
+extern bool borg_projectable(int y1, int x1, int y2, int x2);
+extern bool borg_offset_projectable(int y1, int x1, int y2, int x2);
+
+/*
+ * Check the projection from (x1,y1) to (x2,y2).
+ */
+extern bool borg_projectable_pure(int y1, int x1, int y2, int x2);
+extern bool borg_projectable_dark(int y1, int x1, int y2, int x2);
+
+
+/*
+ * Forget the "lite"
+ */
+extern void borg_forget_lite(void);
+
+/*
+ * Update the "lite"
+ */
+extern void borg_update_lite(void);
+
+/*
+ * Forget the "view"
+ */
+extern void borg_forget_view(void);
+
+/*
+ * Update the "view"
+ */
+extern void borg_update_view(void);
+
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_2(void);
+
+
+#endif
+
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg3.c angband-3.0.6-borg/src/borg3.c
--- angband-3.0.6/src/borg3.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg3.c	2005-09-07 09:28:34.000000000 -0700
@@ -0,0 +1,5425 @@
+/* File: borg3.c */
+
+/* Purpose: Object and Spell routines for the Borg -BEN- */
+
+#include "angband.h"
+
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg3.h"
+
+
+
+/*
+ * This file helps the Borg analyze "objects" and "shops", and to
+ * deal with objects and spells.
+ */
+
+
+
+/*
+ * Some variables
+ */
+
+borg_item *borg_items;      /* Current "inventory" */
+
+borg_shop *borg_shops;      /* Current "shops" */
+
+
+
+/*
+ * Safety arrays for simulating possible worlds
+ */
+
+borg_item *safe_items;      /* Safety "inventory" */
+borg_item *safe_home;       /* Safety "home stuff" */
+
+borg_shop *safe_shops;      /* Safety "shops" */
+
+
+/*
+ * Spell info
+ */
+
+borg_magic borg_magics[9][9];   /* Spell info, by book/what */
+
+
+/* Food Names */
+static char *food_syllable1[] =
+{
+    "BBQ ", "Boiled ", "Fresh ", "Frozen ", "Burned ", "Rotten ", "Raw ", "Toasted ", "Broiled ", "Baked ", "Fried ", "Buttered ", "Steamed ", "Gramma's ",
+};
+
+/* Food Names */
+static char *food_syllable2[] =
+{
+    "Pizza", "Eggs", "Spam", "Oatmeal", "Chicken", "Bacon", "Peanutbutter", "Roast Beef", "Cheese", "Toast", "Hamburger", "Carrots", "Corn", "Potato", "Pork Chops", "Chinese Takeout", "Cookies",
+};
+
+/* Slime Molds */
+static char *mold_syllable1[] =
+{
+    "Ab", "Ac", "Ad", "Af", "Agr", "Ast", "As", "Al", "Adw", "Adr", "Ar", "B", "Br", "C", "Cr", "Ch", "Cad", "D", "Dr", "Dw", "Ed", "Eth", "Et", "Er", "El", "Eow", "F", "Fr", "G", "Gr", "Gw", "Gal", "Gl", "H", "Ha", "Ib", "Jer", "K", "Ka", "Ked", "L", "Loth"
+, "Lar", "Leg", "M", "Mir", "N", "Nyd", "Ol", "Oc", "On", "P", "Pr", "R", "Rh", "S", "Sev", "T", "Tr", "Th", "V", "Y", "Z", "W", "Wic",
+};
+
+static char *mold_syllable2[] =
+{
+    "a", "adrie", "ara", "e", "ebri", "ele", "ere", "i", "io", "ithra", "ilma", "il-Ga", "ili", "o", "orfi", "u", "y",
+};
+
+static char *mold_syllable3[] =
+{
+    "bur", "fur", "gan", "gnus", "gnar", "li", "lin", "lir", "mli", "nar", "nus", "rin", "ran", "sin", "sil", "sur",
+};
+
+
+/*
+ * Hack -- help analyze the magic
+ *
+ * The comments yield the "name" of the spell or prayer.
+ *
+ * Also, the leading letter in the comment indicates how we use the
+ * spell or prayer, if at all, using "A" for "attack", "D" for "call
+ * light" and "detection", "E" for "escape", "H" for healing, "O" for
+ * "object manipulation", and "F" for "terrain feature manipulation",
+ * plus "!" for entries that can soon be handled.
+ */
+
+static byte borg_magic_method[2][9][9] =
+{
+    /*** Spells ***/
+
+    {
+        {
+            /* Magic for Beginners (sval 0) */
+            BORG_MAGIC_AIM  /* A "Magic Missile" */,
+            BORG_MAGIC_EXT  /*   "Detect Monsters" */,
+            BORG_MAGIC_NOP  /* E "Phase Door" */,
+            BORG_MAGIC_NOP  /* D "Light Area" */,
+            BORG_MAGIC_NOP  /*   "Treasure Detection" */,
+            BORG_MAGIC_NOP  /* H "Cure Light Wounds" */,
+            BORG_MAGIC_NOP  /*   "Object Detection" */,
+            BORG_MAGIC_NOP  /* D "Find Hidden Traps/Doors" */,
+            BORG_MAGIC_AIM  /* A "Stinking Cloud" */
+        },
+
+        {
+            /* Conjurings and Tricks (sval 1) */
+            BORG_MAGIC_AIM  /*   "Confusion" */,
+            BORG_MAGIC_AIM  /* A "Lightning Bolt" */,
+            BORG_MAGIC_NOP  /* F "Trap/Door Destruction" */,
+            BORG_MAGIC_NOP  /* H "Cure Poison" */,
+            BORG_MAGIC_AIM  /*   "Sleep I" */,
+            BORG_MAGIC_NOP  /* E "Teleport Self" */,
+            BORG_MAGIC_AIM  /* A "Spear of Light" */,
+            BORG_MAGIC_AIM  /* A "Frost Bolt" */,
+            BORG_MAGIC_AIM  /* A "Wonder" */
+        },
+
+        {
+            /* Incantations and Illusions (sval 2) */
+            BORG_MAGIC_NOP  /* H "Satisfy Hunger" */,
+            BORG_MAGIC_OBJ  /* O "Recharge Item I" */,
+            BORG_MAGIC_AIM  /*   "Stone to Mud" */,
+            BORG_MAGIC_AIM  /*   "Fire Bolt" */,
+            BORG_MAGIC_AIM  /* O "Polymorph" */,
+            BORG_MAGIC_OBJ  /*   "Identify" */,
+            BORG_MAGIC_NOP  /* A "Detect Inv" */,
+            BORG_MAGIC_AIM  /*   "Acid Bolt" */,
+            BORG_MAGIC_AIM  /* A "Slow Mon"*/
+        },
+
+        {
+            /* Sorcery and Evocations (sval 3) */
+            BORG_MAGIC_AIM  /* A "Frost Ball" */,
+            BORG_MAGIC_AIM  /* O "Teleport Other" */,
+            BORG_MAGIC_NOP  /*   "Haste Self" */,
+            BORG_MAGIC_NOP  /* A "Mass Sleep" */,
+            BORG_MAGIC_AIM  /*   "Fire Ball" */,
+            BORG_MAGIC_NOP  /*   "Detect Enchant" */,
+            BORG_MAGIC_ICK  /*   "(Blank)"*/,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Resistance of Scarabtarices (sval 4) */
+            BORG_MAGIC_NOP  /*   "Resist Cold" */,
+            BORG_MAGIC_NOP  /*   "Resist Fire" */,
+            BORG_MAGIC_NOP  /*   "Resist Pois" */,
+            BORG_MAGIC_NOP  /*   "Resistance" */,
+            BORG_MAGIC_NOP  /*   "Shield" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Raal's Tome of Destruction (sval 5) */
+            BORG_MAGIC_AIM  /* A "Shock Wave" */,
+            BORG_MAGIC_AIM  /* A "Explosion" */,
+            BORG_MAGIC_AIM  /* A "Cloud Kill" */,
+            BORG_MAGIC_AIM  /* A "Acid Kill" */,
+            BORG_MAGIC_AIM  /* A "Ice Storm" */,
+            BORG_MAGIC_AIM  /* A "Meteor Swarm" */,
+            BORG_MAGIC_AIM  /*   "Rift"*/,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Mordenkainen's Escapes (sval 6) */
+            BORG_MAGIC_NOP  /*   "Door Creation" */,
+            BORG_MAGIC_NOP  /*   "Stair Creation" */,
+            BORG_MAGIC_NOP  /*   "Teleport Level" */,
+            BORG_MAGIC_NOP  /*   "Word of Recall" */,
+            BORG_MAGIC_NOP  /* E "Rune of Protec" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Tenser's transformations... (sval 7) */
+            BORG_MAGIC_NOP  /* ! "Heroism" */,
+            BORG_MAGIC_NOP  /*   "Berserker" */,
+            BORG_MAGIC_OBJ  /* ! "Enchant Armour" */,
+            BORG_MAGIC_OBJ  /*   "Enchant Weapon" */,
+            BORG_MAGIC_OBJ  /*   "Recharge Item II" */,
+            BORG_MAGIC_OBJ  /*   "Elemental Brand" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Kelek's Grimoire of Power (sval 8) */
+            BORG_MAGIC_NOP  /*   "Earthquake" */,
+            BORG_MAGIC_AIM  /*   "Bedlam" */,
+            BORG_MAGIC_AIM  /* O "Rend Sould" */,
+            BORG_MAGIC_WHO  /*   "Genocide" */,
+            BORG_MAGIC_NOP  /*   "Word of Dest" */,
+            BORG_MAGIC_NOP  /*   "Mass Genocide"*/,
+            BORG_MAGIC_AIM  /*   "Chaos Strike"*/,
+            BORG_MAGIC_AIM  /*   "Mana Storm" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        }
+
+    },
+
+
+    /*** Prayers ***/
+
+    {
+        {
+            /* Beginners Handbook (sval 0) */
+            BORG_MAGIC_EXT  /*   "Detect Evil" */,
+            BORG_MAGIC_NOP  /*   "Cure Light Wounds" */,
+            BORG_MAGIC_NOP  /*   "Bless" */,
+            BORG_MAGIC_NOP  /* H "Remove Fear" */,
+            BORG_MAGIC_NOP  /* D "Call Light" */,
+            BORG_MAGIC_NOP  /* D "Find Traps" */,
+            BORG_MAGIC_NOP  /* D "Detect Doors/Stairs" */,
+            BORG_MAGIC_NOP  /*   "Slow Poison" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Words of Wisdom (sval 1) */
+            BORG_MAGIC_AIM  /*   "Scare Creature" */,
+            BORG_MAGIC_NOP  /* E "Portal" */,
+            BORG_MAGIC_NOP  /* H "Cure Serious Wounds" */,
+            BORG_MAGIC_NOP  /*   "Chant" */,
+            BORG_MAGIC_NOP  /*   "Sanctuary" */,
+            BORG_MAGIC_NOP  /* H "Satisfy Hunger" */,
+            BORG_MAGIC_NOP  /*   "Remove Curse" */,
+            BORG_MAGIC_NOP  /*   "Resist Heat and Cold" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Chants and Blessings (sval 2) */
+            BORG_MAGIC_NOP  /* H "Neutralize Poison" */,
+            BORG_MAGIC_AIM  /* A "Orb of Draining" */,
+            BORG_MAGIC_NOP  /* H "Cure Critical Wounds" */,
+            BORG_MAGIC_EXT  /*   "Sense Invisible" */,
+            BORG_MAGIC_NOP  /*   "Protection from Evil" */,
+            BORG_MAGIC_NOP  /*   "Earthquake" */,
+            BORG_MAGIC_NOP  /* D "Sense Surroundings" */,
+            BORG_MAGIC_NOP  /* H "Cure Mortal Wounds" */,
+            BORG_MAGIC_NOP  /*   "Turn Undead" */
+        },
+
+        {
+            /* Exorcism and Dispelling (sval 3) */
+            BORG_MAGIC_NOP  /*   "Prayer" */,
+            BORG_MAGIC_NOP  /* ! "Dispel Undead" */,
+            BORG_MAGIC_NOP  /* H "Heal" */,
+            BORG_MAGIC_NOP  /* ! "Dispel Evil" */,
+            BORG_MAGIC_NOP  /*   "Glyph of Warding" */,
+            BORG_MAGIC_NOP  /* ! "Holy Word" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Ethereal openings (sval 4) */
+            BORG_MAGIC_NOP  /* E "Blink" */,
+            BORG_MAGIC_NOP  /* E "Teleport" */,
+            BORG_MAGIC_AIM  /*   "Teleport Away" */,
+            BORG_MAGIC_NOP  /*   "Teleport Level" */,
+            BORG_MAGIC_NOP  /* E "Word of Recall" */,
+            BORG_MAGIC_NOP  /*   "Alter Reality" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Godly Insights... (sval 5) */
+            BORG_MAGIC_EXT  /*   "Detect Monsters" */,
+            BORG_MAGIC_EXT  /* D "Detection" */,
+            BORG_MAGIC_OBJ  /* O "Perception" */,
+            BORG_MAGIC_NOP  /*   "Probing" */,
+            BORG_MAGIC_NOP  /* D "Clairvoyance" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Purifications and Healing (sval 6) */
+            BORG_MAGIC_NOP  /* H "Cure Serious Wounds" */,
+            BORG_MAGIC_NOP  /* H "Cure Mortal Wounds" */,
+            BORG_MAGIC_NOP  /* H "Healing" */,
+            BORG_MAGIC_NOP  /* ! "Restoration" */,
+            BORG_MAGIC_NOP  /* ! "Remembrance" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Holy Infusions (sval 7) */
+            BORG_MAGIC_NOP  /* F "Unbarring Ways" */,
+            BORG_MAGIC_OBJ  /* O "Recharging" */,
+            BORG_MAGIC_NOP  /*   "Dispel Curse" */,
+            BORG_MAGIC_OBJ  /* O "Enchant Weapon" */,
+            BORG_MAGIC_OBJ  /* O "Enchant Armour" */,
+            BORG_MAGIC_OBJ  /*   "Elemental Brand" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        },
+
+        {
+            /* Wrath of God (sval 8) */
+            BORG_MAGIC_NOP  /* ! "Dispel Undead" */,
+            BORG_MAGIC_NOP  /* ! "Dispel Evil" */,
+            BORG_MAGIC_NOP  /*   "Banishment" */,
+            BORG_MAGIC_NOP  /*   "Word of Destruction" */,
+            BORG_MAGIC_AIM  /*   "Annihilation" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */,
+            BORG_MAGIC_ICK  /*   "(blank)" */
+        }
+    }
+};
+
+
+
+/*
+ * Hack -- help analyze the magic
+ *
+ * The comments yield the "name" of the spell or prayer.
+ *
+ * Also, the leading letter in the comment indicates how we use the
+ * spell or prayer, if at all, using "A" for "attack", "D" for "call
+ * light" and "detection", "E" for "escape", "H" for healing, "O" for
+ * "object manipulation", "F" for "terrain feature manipulation",
+ * "X" for "never use this", and "!" for "soon to be handled".
+ *
+ * The value indicates how much we want to know the spell/prayer.  A
+ * rating of zero indicates that the spell/prayer is useless, and should
+ * never be learned or used.  A rating from 1 to 49 indicates that the
+ * spell/prayer is worth some experience to use once, so we should study
+ * (and use) it when we get bored in town.  A rating from 50 to 99 means
+ * that the spell/prayer should be learned as soon as possible (and used
+ * when bored).
+ *
+ * XXX XXX XXX Verify ratings.
+ */
+static byte borg_magic_rating[2][9][9] =
+{
+    /*** Spells ***/
+
+    {
+        {
+            /* Magic for Beginners (sval 0) */
+            95          /* A "Magic Missile" */,
+            85          /*   "Detect Monsters" */,
+            75          /* E "Phase Door" */,
+            65          /* D "Light Area" */,
+            5           /*   "Treasure Detection" */,
+            75          /* H "Cure Light Wounds" */,
+            5           /*   "Object Detection" */,
+            95          /* D "Find Hidden Traps/Doors" */,
+            85          /* A "Stinking Cloud" */
+        },
+
+        {
+            /* Conjurings and Tricks (sval 1) */
+            55           /*   "Confusion" */,
+            85          /* A "Lightning Bolt" */,
+            55          /* F "Trap/Door Destruction" */,
+            65          /* H "Cure Poison" */,
+            65          /*   "Sleep I" */,
+            95          /* E "Teleport Self" */,
+            55          /* A "Spear of Light" */,
+            85          /* A "Frost Bolt" */,
+            75          /* A "Wonder" */
+        },
+
+        {
+            /* Incantations and Illusions (sval 2) */
+            95          /* H "Satisfy Hunger" */,
+            55          /* O "Recharge Item I" */,
+            75          /*   "Stone to mud" */,
+            75          /*   "Fire Bolt" */,
+            55          /* O "PolyMorph" */,
+            95          /*   "Identify" */,
+            75          /* A "Detect Inv" */,
+            75          /*   "Acid Bolt" */,
+            55          /*   "Slow Monster" */
+        },
+
+        {
+            /* Sorcery and Evocations (sval 3) */
+            85          /* A "Frost Ball" */,
+            75          /* O "Teleport Other" */,
+            85          /*   "Haste Self" */,
+            65          /*   "Mass Sleep" */,
+            75          /* A "Fire Ball" */,
+            55          /*   "Detect Enchantment" */,
+            0           /*   "blank" */,
+            0           /*   "blank" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Resistance of Scarabtarices (sval 4) */
+            65          /*   "Resist Cold" */,
+            65          /*   "Resist Fire" */,
+            60          /*   "Resist Poison" */,
+            70          /*   "Resistance" */,
+            75          /*   "Shield" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Raal's Tome of Destruction (sval 5) */
+            85          /* A "Shock Wave" */,
+            85          /* A "Explosion" */,
+            85          /* A "Cloud Kill" */,
+            85          /* A "Acid Ball" */,
+            85          /* A "Ice Storm" */,
+            85          /* A "Meteor Swarm" */,
+            85          /*   "Rift" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Mordenkainen's Escapes (sval 6) */
+            65          /*   "Door Creation" */,
+            5           /*   "Stair Creation" */,
+            65          /*   "Teleport Level" */,
+            65          /*   "Word of Recall" */,
+            55          /* E "Rune of Protection" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Tenser's transformations... (sval 7) */
+            75          /* H "Heroism" */,
+            75          /*   "Berserker" */,
+            75          /* H "Enchant Armor" */,
+            75          /*   "Enchant Weapon" */,
+            75          /*   "Recharge Item II" */,
+            75          /*   "Elemental Brand" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Kelek's Grimoire of Power (sval 8) */
+            55          /*   "Earthquake" */,
+            5           /*   "Bedlam" */,
+            75          /*   "Rend Soul" */,
+            55          /*   "Genocide" */,
+            55          /*   "Word of Dest" */,
+            65          /*   "Mass Genocide" */,
+            75          /*   "Chaos Strike" */,
+            75          /*   "Mana Storm" */,
+            0           /*   "(blank)" */
+        }
+
+    },
+
+
+    /*** Prayers ***/
+
+    {
+        {
+            /* Beginners Handbook (sval 0) */
+            85          /*   "Detect Evil" */,
+            55          /* H "Cure Light Wounds" */,
+            85          /*   "Bless" */,
+            35          /* H "Remove Fear" */,
+            35          /* D "Call Light" */,
+            75          /* D "Find Traps" */,
+            75          /* D "Detect Doors/Stairs" */,
+            55          /*   "Slow Poison" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Words of Wisdom (sval 1) */
+            55           /*   "Confuse Creature" */,
+            95          /* E "Portal" */,
+            55           /* H "Cure Serious Wounds" */,
+            55           /*   "Chant" */,
+            55           /*   "Sanctuary" */,
+            95          /* H "Satisfy Hunger" */,
+            5           /*   "Remove Curse" */,
+            55           /*   "Resist Heat and Cold" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Chants and Blessings (sval 2) */
+            65          /* H "Neutralize Poison" */,
+            90          /* A "Orb of Draining" */,
+            55          /* H "Cure Critical Wounds" */,
+            65          /*   "Sense Invisible" */,
+            65          /*   "Protection from Evil" */,
+            55          /*   "Earthquake" */,
+            65          /* D "Sense Surroundings" */,
+            55          /* H "Cure Mortal Wounds" */,
+            55           /*   "Turn Undead" */
+        },
+
+        {
+            /* Exorcism and Dispelling (sval 3) */
+            45          /*   "Prayer" */,
+            65          /* ! "Dispel Undead" */,
+            55          /* H "Heal" */,
+            55          /* ! "Dispel Evil" */,
+            55          /*   "Glyph of Warding" */,
+            55          /* ! "Holy Word" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Ethereal openings (sval 4) */
+            65          /* E "Blink" */,
+            65          /* E "Teleport" */,
+            55          /*   "Teleport Away" */,
+            55          /*   "Teleport Level" */,
+            75          /* E "Word of Recall" */,
+            65          /*   "Alter Reality" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Godly Insights... (sval 5) */
+            55          /*   "Detect Monsters" */,
+            65          /* D "Detection" */,
+            75          /* O "Perception" */,
+            5           /*   "Probing" */,
+            65          /* D "Clairvoyance" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Purifications and Healing (sval 6) */
+            55          /* H "Cure Serious Wounds" */,
+            55          /* H "Cure Mortal Wounds" */,
+            55          /* H "Healing" */,
+            45          /* ! "Restoration" */,
+            45          /* ! "Remembrance" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Holy Infusions (sval 7) */
+            50          /* F "Unbarring Ways" */,
+            50          /* O "Recharging" */,
+            5           /*   "Dispel Curse" */,
+            65          /* O "Enchant Weapon" */,
+            65          /* O "Enchant Armour" */,
+            65          /*   "Elemental Brand" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        },
+
+        {
+            /* Wrath of God (sval 8) */
+            65           /* ! "Dispel Undead" */,
+            65           /* ! "Dispel Evil" */,
+            55          /*   "Banishment" */,
+            55          /*  "Word of Destruction" */,
+            55          /*   "Annihilation" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */,
+            0           /*   "(blank)" */
+        }
+    }
+};
+
+
+/* Cheat the game's index for spells */
+static byte borg_magic_index[2][9][9] =
+{
+    /*** Spells ***/
+
+    {
+        {
+         /* Magic for Beginners */
+            0  /* SPELL_MAGIC_MISSILE */,
+            1  /* SPELL_DETECT_MONSTERS */,
+            2  /* SPELL_PHASE_DOOR */,
+            3  /* SPELL_LIGHT_AREA */,
+            6  /* SPELL_TREASURE_DETECTION */,
+            5  /* SPELL_CURE_LIGHT_WOUNDS */,
+            7  /* SPELL_OBJECT_DETECTION */,
+            4  /* SPELL_FIND_TRAPS_DOORS */,
+            11 /* SPELL_STINKING_CLOUD */
+         },
+
+        /* Conjurings and Tricks */
+        {
+            13 /* SPELL_CONFUSE_MONSTER */,
+            12 /* SPELL_LIGHTNING_BOLT */,
+            19 /* SPELL_TRAP_DOOR_DESTRUCTION */,
+            25 /* SPELL_CURE_POISON */,
+            14 /* SPELL_SLEEP_MONSTER */,
+            30 /* SPELL_TELEPORT_SELF */,
+            20 /* SPELL_SPEAR_OF_LIGHT */,
+            16 /* SPELL_FROST_BOLT */,
+            15 /* SPELL_WONDER */
+         },
+
+    /* Incantations and Illusions */
+        {
+            26 /* SPELL_SATISFY_HUNGER */,
+            50 /* SPELL_RECHARGE_ITEM_I */,
+            21 /* SPELL_TURN_STONE_TO_MUD */,
+            18 /* SPELL_FIRE_BOLT */,
+            35 /* SPELL_POLYMORPH_OTHER */,
+            8  /* SPELL_IDENTIFY */,
+            9  /* SPELL_DETECT_INVISIBLE */,
+            17 /* SPELL_ACID_BOLT */,
+            31 /* SPELL_SLOW_MONSTER */
+         },
+
+    /* Sorcery and Evocations */
+        {
+            55 /* SPELL_FROST_BALL */,
+            32 /* SPELL_TELEPORT_OTHER */,
+            29 /* SPELL_HASTE_SELF */,
+            39 /* SPELL_MASS_SLEEP */,
+            57 /* SPELL_FIRE_BALL */,
+            10 /* SPELL_DETECT_ENCHANTMENT */,
+            99,
+            99,
+            99
+        },
+
+    /* Resistances of Scarabtarices */
+        {
+            44 /* SPELL_RESIST_COLD */,
+            45 /* SPELL_RESIST_FIRE */,
+            46 /* SPELL_RESIST_POISON */,
+            47 /* SPELL_RESISTANCE */,
+            48 /* SPELL_SHIELD */,
+            99,
+            99,
+            99,
+            99
+        },
+
+    /* Raal's Tome of Destruction */
+        {
+            36 /* SPELL_SHOCK_WAVE */,
+            37 /* SPELL_EXPLOSION */,
+            38 /* SPELL_CLOUD_KILL */,
+            56 /* SPELL_ACID_BALL */,
+            58 /* SPELL_ICE_STORM */,
+            60 /* SPELL_METEOR_SWARM */,
+            62 /* SPELL_RIFT */,
+            99,
+            99
+        },
+
+    /* Mordenkainen's Escapes */
+        {
+            22 /* SPELL_DOOR_CREATION */,
+            24 /* SPELL_STAIR_CREATION */,
+            33 /* SPELL_TELEPORT_LEVEL */,
+            34 /* SPELL_WORD_OF_RECALL */,
+            49 /* SPELL_RUNE_OF_PROTECTION */,
+            99,
+            99,
+            99,
+            99
+         },
+
+    /* Tenser's transformations */
+        {
+            27 /* SPELL_HEROISM */,
+            28 /* SPELL_BERSERKER */,
+            51 /* SPELL_ENCHANT_ARMOR */,
+            52 /* SPELL_ENCHANT_WEAPON */,
+            53 /* SPELL_RECHARGE_ITEM_II */,
+            54 /* SPELL_ELEMENTAL_BRAND */,
+            99,
+            99,
+            99
+        },
+
+    /* Kelek's Grimoire of Power */
+        {
+            23 /* SPELL_EARTHQUAKE */,
+            40 /* SPELL_BEDLAM */,
+            41 /* SPELL_REND_SOUL */,
+            59 /* SPELL_GENOCIDE */,
+            42 /* SPELL_WORD_OF_DESTRUCTION */,
+            61 /* SPELL_MASS_GENOCIDE */,
+            43 /* SPELL_CHAOS_STRIKE */,
+            63 /* SPELL_MANA_STORM */,
+            99
+        }
+
+    },
+
+    {
+        /*** Priest spell books ***/
+        {
+            0 /* PRAYER_DETECT_EVIL */,
+            1 /* PRAYER_CURE_LIGHT_WOUNDS */,
+            2 /* PRAYER_BLESS */,
+            3 /* PRAYER_REMOVE_FEAR */,
+            4 /* PRAYER_CALL_LIGHT */,
+            5 /* PRAYER_FIND_TRAPS */,
+            6 /* PRAYER_DETECT_DOORS_STAIRS */,
+            7 /* PRAYER_SLOW_POISON */,
+            99
+        },
+
+        {
+            8 /* PRAYER_SCARE_MONSTER */,
+            9 /* PRAYER_PORTAL */,
+            10 /* PRAYER_CURE_SERIOUS_WOUNDS */,
+            11 /* PRAYER_CHANT */,
+            12 /* PRAYER_SANCTUARY */,
+            13 /* PRAYER_SATISFY_HUNGER */,
+            14 /* PRAYER_REMOVE_CURSE */,
+            15 /* PRAYER_RESIST_HEAT_COLD */,
+            99
+        },
+
+        {
+            16 /* PRAYER_NEUTRALIZE_POISON */,
+            17 /* PRAYER_ORB_OF_DRAINING */,
+            18 /* PRAYER_CURE_CRITICAL_WOUNDS */,
+            19 /* PRAYER_SENSE_INVISIBLE */,
+            20 /* PRAYER_PROTECTION_FROM_EVIL */,
+            21 /* PRAYER_EARTHQUAKE */,
+            22 /* PRAYER_SENSE_SURROUNDINGS */,
+            23 /* PRAYER_CURE_MORTAL_WOUNDS */,
+            24 /* PRAYER_TURN_UNDEAD */
+        },
+
+        {
+            25 /* PRAYER_PRAYER */,
+            26 /* PRAYER_DISPEL_UNDEAD */,
+            27 /* PRAYER_HEAL */,
+            28 /* PRAYER_DISPEL_EVIL */,
+            29 /* PRAYER_GLYPH_OF_WARDING */,
+            30 /* PRAYER_HOLY_WORD */,
+            99,
+            99,
+            99
+        },
+
+        {
+            52 /* PRAYER_BLINK */,
+            53 /* PRAYER_TELEPORT_SELF */,
+            54 /* PRAYER_TELEPORT_OTHER */,
+            55 /* PRAYER_TELEPORT_LEVEL */,
+            56 /* PRAYER_WORD_OF_RECALL */,
+            57 /* PRAYER_ALTER_REALITY */,
+            99,
+            99,
+            99
+        },
+
+        {
+            31 /* PRAYER_DETECT_MONSTERS */,
+            32 /* PRAYER_DETECTION */,
+            33 /* PRAYER_PERCEPTION */,
+            34 /* PRAYER_PROBING */,
+            35 /* PRAYER_CLAIRVOYANCE */,
+            99,
+            99,
+            99,
+            99
+        },
+
+        {
+            36 /* PRAYER_CURE_SERIOUS_WOUNDS2 */,
+            37 /* PRAYER_CURE_MORTAL_WOUNDS2 */,
+            38 /* PRAYER_HEALING */,
+            39 /* PRAYER_RESTORATION */,
+            40 /* PRAYER_REMEMBRANCE */,
+            99,
+            99,
+            99,
+            99
+        },
+
+        {
+            46 /* PRAYER_UNBARRING_WAYS */,
+            47 /* PRAYER_RECHARGING */,
+            48 /* PRAYER_DISPEL_CURSE */,
+            49 /* PRAYER_ENCHANT_WEAPON */,
+            50 /* PRAYER_ENCHANT_ARMOUR */,
+            51 /* PRAYER_ELEMENTAL_BRAND */,
+            99,
+            99,
+            99
+        },
+
+        {
+            41 /* PRAYER_DISPEL_UNDEAD2 */,
+            42 /* PRAYER_DISPEL_EVIL2 */,
+            43 /* PRAYER_BANISHMENT */,
+            44 /* PRAYER_WORD_OF_DESTRUCTION */,
+            45 /* PRAYER_ANNIHILATION */,
+            99,
+            99,
+            99,
+            99
+        }
+    }
+};
+
+static cptr borg_magic_name[2][9][9] =
+{
+    /*** Spells ***/
+
+    {
+        {
+            /* Magic for Beginners (sval 0) */
+            "Magic Missile" ,
+            "Detect Monsters" ,
+            "Phase Door" ,
+            "Light Area" ,
+            "Treasure Detection" ,
+            "Cure Light Wounds" ,
+            "Object Detection" ,
+            "Find Hidden Traps/Doors" ,
+            "Stinking Cloud"
+        },
+
+        {
+            /* Conjurings and Tricks (sval 1) */
+            "Confusion" ,
+            "Lightning Bolt" ,
+            "Trap/Door Destruction" ,
+            "Cure Poison" ,
+            "Sleep I" ,
+            "Teleport Self" ,
+            "Spear of Light" ,
+            "Frost Bolt" ,
+            "Wonder"
+        },
+
+        {
+            /* Incantations and Illusions (sval 2) */
+            "Satisfy Hunger" ,
+            "Recharge Item I" ,
+            "Stone to mud" ,
+            "Fire Bolt" ,
+            "PolyMorph" ,
+            "Identify" ,
+            "Detect Inv" ,
+            "Acid Bolt" ,
+            "Slow Monster"
+        },
+
+        {
+            /* Sorcery and Evocations (sval 3) */
+            "Frost Ball" ,
+            "Teleport Other" ,
+            "Haste Self" ,
+            "Mass Sleep" ,
+            "Fire Ball" ,
+            "Detect Enchantment" ,
+            "0x3x6" ,
+            "0x3x7" ,
+            "0x3x8"
+        },
+
+        {
+            /* Resistance of Scarabtarices (sval 4) */
+             "Resist Cold" ,
+             "Resist Fire" ,
+             "Resist Poison" ,
+             "Resistance" ,
+             "Shield" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Raal's Tome of Destruction (sval 5) */
+             "Shock Wave" ,
+             "Explosion" ,
+             "Cloud Kill" ,
+             "Acid Ball" ,
+             "Ice Storm" ,
+             "Meteor Swarm" ,
+             "Rift" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Mordenkainen's Escapes (sval 6) */
+             "Door Creation" ,
+             "Stair Creation" ,
+             "Teleport Level" ,
+             "Word of Recall" ,
+             "Rune of Protection" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Tenser's transformations... (sval 7) */
+             "Heroism" ,
+             "Berserker" ,
+             "Enchant Armor" ,
+             "Enchant Weapon" ,
+             "Recharge Item II" ,
+             "Elemental Brand" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Kelek's Grimoire of Power (sval 8) */
+             "Earthquake" ,
+             "Bedlam" ,
+             "Rend Soul" ,
+             "Genocide" ,
+             "Word of Dest" ,
+             "Mass Genocide" ,
+             "Chaos Strike" ,
+             "Mana Storm" ,
+             "(blank)"
+        }
+
+    },
+
+
+    /*** Prayers ***/
+
+    {
+        {
+            /* Beginners Handbook (sval 0) */
+             "Detect Evil" ,
+             "Cure Light Wounds" ,
+             "Bless" ,
+             "Remove Fear" ,
+             "Call Light" ,
+             "Find Traps" ,
+             "Detect Doors/Stairs" ,
+             "Slow Poison" ,
+             "(blank)"
+        },
+
+        {
+            /* Words of Wisdom (sval 1) */
+             "Confuse Creature" ,
+             "Portal" ,
+             "Cure Serious Wounds" ,
+             "Chant" ,
+             "Sanctuary" ,
+             "Satisfy Hunger" ,
+             "Remove Curse" ,
+             "Resist Heat and Cold" ,
+             "(blank)"
+        },
+
+        {
+            /* Chants and Blessings (sval 2) */
+             "Neutralize Poison" ,
+             "Orb of Draining" ,
+             "Cure Critical Wounds" ,
+             "Sense Invisible" ,
+             "Protection from Evil" ,
+             "Earthquake" ,
+             "Sense Surroundings" ,
+             "Cure Mortal Wounds" ,
+             "Turn Undead"
+        },
+
+        {
+            /* Exorcism and Dispelling (sval 3) */
+             "Prayer" ,
+             "Dispel Undead" ,
+             "Heal" ,
+             "Dispel Evil" ,
+             "Glyph of Warding" ,
+             "Holy Word" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Ethereal openings (sval 4) */
+             "Blink" ,
+             "Teleport" ,
+             "Teleport Away" ,
+             "Teleport Level" ,
+             "Word of Recall" ,
+             "Alter Reality" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Godly Insights... (sval 5) */
+             "Detect Monsters" ,
+             "Detection" ,
+             "Perception" ,
+             "Probing" ,
+             "Clairvoyance" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Purifications and Healing (sval 6) */
+             "Cure Serious Wounds" ,
+             "Cure Mortal Wounds" ,
+             "Healing" ,
+             "Restoration" ,
+             "Remembrance" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Holy Infusions (sval 7) */
+             "Unbarring Ways" ,
+             "Recharging" ,
+             "Dispel Curse" ,
+             "Enchant Weapon" ,
+             "Enchant Armour" ,
+             "Elemental Brand" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        },
+
+        {
+            /* Wrath of God (sval 8) */
+             "Dispel Undead" ,
+             "Dispel Evil" ,
+             "Banishment" ,
+             "Word of Destruction" ,
+             "Annihilation" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)" ,
+             "(blank)"
+        }
+    }
+};
+
+/*
+ * Constant "item description parsers" (singles)
+ */
+static int borg_single_size;        /* Number of "singles" */
+static s16b *borg_single_what;      /* Kind indexes for "singles" */
+static cptr *borg_single_text;      /* Textual prefixes for "singles" */
+
+/*
+ * Constant "item description parsers" (plurals)
+ */
+static int borg_plural_size;        /* Number of "plurals" */
+static s16b *borg_plural_what;      /* Kind index for "plurals" */
+static cptr *borg_plural_text;      /* Textual prefixes for "plurals" */
+static cptr *borg_sv_plural_text;   /* Save Textual prefixes for "plurals" (in kind order) */
+
+/*
+ * Constant "item description parsers" (suffixes)
+ */
+static int borg_artego_size;        /* Number of "artegos" */
+static s16b *borg_artego_what;      /* Indexes for "artegos" */
+static cptr *borg_artego_text;      /* Textual prefixes for "artegos" */
+static cptr *borg_sv_art_text;      /* Save textual prefixes for "artifacts" (in kind order) */
+
+/*
+ * Return the slot that items of the given type are wielded into
+ *
+ * Note that "rings" are tough because there are two slots
+ *
+ * Returns "-1" if the item cannot (or should not) be wielded
+ */
+int borg_wield_slot(borg_item *item)
+{
+        switch (p_ptr->pclass)
+           {
+            case CLASS_WARRIOR:
+            {
+                if ((item->tval == TV_SWORD) ||
+                (item->tval == TV_POLEARM) ||
+                (item->tval == TV_HAFTED) ||
+                (item->tval == TV_DIGGING) ) return (INVEN_WIELD);
+
+                if ((item->tval == TV_DRAG_ARMOR) ||
+                (item->tval == TV_HARD_ARMOR) ||
+                (item->tval == TV_SOFT_ARMOR) ) return (INVEN_BODY);
+
+                if (item->tval == TV_SHIELD) return (INVEN_ARM);
+
+                if ((item->tval == TV_CROWN) ||
+                (item->tval == TV_HELM) ) return (INVEN_HEAD);
+
+                if (item->tval == TV_BOW) return (INVEN_BOW);
+
+                if (item->tval == TV_RING) return (INVEN_LEFT);
+
+                if (item->tval == TV_AMULET) return (INVEN_NECK);
+
+                if (item->tval == TV_LITE) return (INVEN_LITE);
+
+                if (item->tval == TV_CLOAK) return (INVEN_OUTER);
+
+                if (item->tval == TV_GLOVES) return (INVEN_HANDS);
+
+                if (item->tval == TV_BOOTS) return (INVEN_FEET);
+            }
+                break;
+
+            case CLASS_MAGE:
+            {
+                if ((item->tval == TV_SWORD) ||
+                (item->tval == TV_POLEARM) ||
+                (item->tval == TV_HAFTED) ||
+                (item->tval == TV_DIGGING) ) return (INVEN_WIELD);
+
+                if ((item->tval == TV_DRAG_ARMOR) ||
+                (item->tval == TV_HARD_ARMOR) ||
+                (item->tval == TV_SOFT_ARMOR) ) return (INVEN_BODY);
+
+                if (item->tval == TV_SHIELD) return (INVEN_ARM);
+
+                if ((item->tval == TV_CROWN) ||
+                (item->tval == TV_HELM) ) return (INVEN_HEAD);
+
+                if (item->tval == TV_BOW) return (INVEN_BOW);
+
+                if (item->tval == TV_RING) return (INVEN_LEFT);
+
+                if (item->tval == TV_AMULET) return (INVEN_NECK);
+
+                if (item->tval == TV_LITE) return (INVEN_LITE);
+
+                if (item->tval == TV_CLOAK) return (INVEN_OUTER);
+
+                if (item->tval == TV_GLOVES) return (INVEN_HANDS);
+
+                if (item->tval == TV_BOOTS) return (INVEN_FEET);
+            }
+                break;
+
+            case CLASS_PRIEST:
+            {
+                if ((item->tval == TV_SWORD) ||
+                (item->tval == TV_POLEARM) ||
+                (item->tval == TV_HAFTED) ||
+                (item->tval == TV_DIGGING) ) return (INVEN_WIELD);
+
+                if ((item->tval == TV_DRAG_ARMOR) ||
+                (item->tval == TV_HARD_ARMOR) ||
+                (item->tval == TV_SOFT_ARMOR) ) return (INVEN_BODY);
+
+                if (item->tval == TV_SHIELD) return (INVEN_ARM);
+
+                if ((item->tval == TV_CROWN) ||
+                (item->tval == TV_HELM) ) return (INVEN_HEAD);
+
+                if (item->tval == TV_BOW) return (INVEN_BOW);
+
+                if (item->tval == TV_RING) return (INVEN_LEFT);
+
+                if (item->tval == TV_AMULET) return (INVEN_NECK);
+
+                if (item->tval == TV_LITE) return (INVEN_LITE);
+
+                if (item->tval == TV_CLOAK) return (INVEN_OUTER);
+
+                if (item->tval == TV_GLOVES) return (INVEN_HANDS);
+
+                if (item->tval == TV_BOOTS) return (INVEN_FEET);
+            }
+                break;
+
+            case CLASS_ROGUE:
+            {
+                if ((item->tval == TV_SWORD) ||
+                (item->tval == TV_POLEARM) ||
+                (item->tval == TV_HAFTED) ||
+                (item->tval == TV_DIGGING) ) return (INVEN_WIELD);
+
+                if ((item->tval == TV_DRAG_ARMOR) ||
+                (item->tval == TV_HARD_ARMOR) ||
+                (item->tval == TV_SOFT_ARMOR) ) return (INVEN_BODY);
+
+                if (item->tval == TV_SHIELD) return (INVEN_ARM);
+
+                if ((item->tval == TV_CROWN) ||
+                (item->tval == TV_HELM) ) return (INVEN_HEAD);
+
+                if (item->tval == TV_BOW) return (INVEN_BOW);
+
+                if (item->tval == TV_RING) return (INVEN_LEFT);
+
+                if (item->tval == TV_AMULET) return (INVEN_NECK);
+
+                if (item->tval == TV_LITE) return (INVEN_LITE);
+
+                if (item->tval == TV_CLOAK) return (INVEN_OUTER);
+
+                if (item->tval == TV_GLOVES) return (INVEN_HANDS);
+
+                if (item->tval == TV_BOOTS) return (INVEN_FEET);
+            }
+                break;
+
+            case CLASS_PALADIN:
+            {
+                if ((item->tval == TV_SWORD) ||
+                (item->tval == TV_POLEARM) ||
+                (item->tval == TV_HAFTED) ||
+                (item->tval == TV_DIGGING) ) return (INVEN_WIELD);
+
+                if ((item->tval == TV_DRAG_ARMOR) ||
+                (item->tval == TV_HARD_ARMOR) ||
+                (item->tval == TV_SOFT_ARMOR) ) return (INVEN_BODY);
+
+                if (item->tval == TV_SHIELD) return (INVEN_ARM);
+
+                if ((item->tval == TV_CROWN) ||
+                (item->tval == TV_HELM) ) return (INVEN_HEAD);
+
+                if (item->tval == TV_BOW) return (INVEN_BOW);
+
+                if (item->tval == TV_RING) return (INVEN_LEFT);
+
+                if (item->tval == TV_AMULET) return (INVEN_NECK);
+
+                if (item->tval == TV_LITE) return (INVEN_LITE);
+
+                if (item->tval == TV_CLOAK) return (INVEN_OUTER);
+
+                if (item->tval == TV_GLOVES) return (INVEN_HANDS);
+
+                if (item->tval == TV_BOOTS) return (INVEN_FEET);
+            }
+                break;
+
+            case CLASS_RANGER:
+            {
+                if ((item->tval == TV_SWORD) ||
+                (item->tval == TV_POLEARM) ||
+                (item->tval == TV_HAFTED) ||
+                (item->tval == TV_DIGGING) ) return (INVEN_WIELD);
+
+                if ((item->tval == TV_DRAG_ARMOR) ||
+                (item->tval == TV_HARD_ARMOR) ||
+                (item->tval == TV_SOFT_ARMOR) ) return (INVEN_BODY);
+
+                if (item->tval == TV_SHIELD) return (INVEN_ARM);
+
+                if ((item->tval == TV_CROWN) ||
+                (item->tval == TV_HELM) ) return (INVEN_HEAD);
+
+                if (item->tval == TV_BOW) return (INVEN_BOW);
+
+                if (item->tval == TV_RING) return (INVEN_LEFT);
+
+                if (item->tval == TV_AMULET) return (INVEN_NECK);
+
+                if (item->tval == TV_LITE) return (INVEN_LITE);
+
+                if (item->tval == TV_CLOAK) return (INVEN_OUTER);
+
+                if (item->tval == TV_GLOVES) return (INVEN_HANDS);
+
+                if (item->tval == TV_BOOTS) return (INVEN_FEET);
+            }
+                break;
+
+        }
+
+    /* No slot available */
+    return (-1);
+}
+
+/*
+ * Get the *ID information
+ *
+ * This function pulls the information from the screen if it is not passed
+ * a *real* item.  It is only passed in *real* items if the borg is allowed
+ * to 'cheat' for inventory.
+ * This function returns TRUE if space needs to be pressed
+ */
+bool borg_object_star_id_aux(borg_item *borg_item, object_type *real_item)
+{
+    u32b f1, f2, f3;
+
+    /* If a real item pointer is passed in then we are cheating to get */
+    /* the data directly from the real item    */
+    if (real_item)
+    {
+        object_flags(real_item, &f1, &f2, &f3);
+    }
+
+#ifndef BORG_TK
+    else
+    {
+        int i;
+
+        byte t_a;
+
+        char buf[71];
+
+        for (i = 2; i < 22; i++)
+        {
+            if (!(0 == borg_what_text(15, i, 65, &t_a, buf)))
+            {
+                /* bummer, problem reading from screen */
+                borg_oops("cannot read from screen");
+                return FALSE;
+            }
+
+            /* Gives Stat Bonus */
+            if (prefix(buf, "It affects your strength."))
+            {
+                f1 &= TR1_STR;
+                continue;
+            }
+            if (prefix(buf, "It affects your intelligence."))
+            {
+                f1 &= TR1_INT;
+                continue;
+            }
+            if (prefix(buf, "It affects your wisdom."))
+            {
+                f1 &= TR1_WIS;
+                continue;
+            }
+            if (prefix(buf, "It affects your dexterity."))
+            {
+                f1 &= TR1_DEX;
+                continue;
+            }
+            if (prefix(buf, "It affects your constitution."))
+            {
+                f1 &= TR1_CON;
+                continue;
+            }
+            if (prefix(buf, "It affects your charisma."))
+            {
+                f1 &= TR1_CHR;
+                continue;
+            }
+            /* Gives stealth Bonus */
+            if (prefix(buf, "It affects your stealth."))
+            {
+                f1 &= TR1_STEALTH;
+                continue;
+            }
+
+
+            /* Gives searching Bonus */
+            if (prefix(buf, "It affects your searching."))
+            {
+                f1 &= TR1_SEARCH;
+                continue;
+            }
+            /* Gives Infravision Bonus */
+            if (prefix(buf, "It affects your infravision."))
+            {
+                f1 &= TR1_INFRA;
+                continue;
+            }
+            /* Gives digging Bonus */
+            if (prefix(buf, "It affects your ability to tunnel."))
+            {
+                f1 &= TR1_TUNNEL;
+                continue;
+            }
+            /* Gives Speed Bonus  (Wee!) */
+            if (prefix(buf, "It affects your speed."))
+            {
+                f1 &= TR1_SPEED;
+                continue;
+            }
+            /* Gives Extra Blows */
+            if (prefix(buf, "It affects your attack speed."))
+            {
+                f1 &= TR1_BLOWS;
+                continue;
+            }
+            /* Various Brands */
+            if (prefix(buf, "It does extra damage from acid."))
+            {
+                f1 &= TR1_BRAND_ACID;
+                continue;
+            }
+            if (prefix(buf, "It does extra damage from electricity."))
+            {
+                f1 &= TR1_BRAND_ELEC;
+                continue;
+            }
+            if (prefix(buf, "It does extra damage from fire."))
+            {
+                f1 &= TR1_BRAND_FIRE;
+                continue;
+            }
+            if (prefix(buf, "It does extra damage from frost."))
+            {
+                f1 &= TR1_BRAND_COLD;
+                continue;
+            }
+            /* This is Grond. */
+            if (prefix(buf, "It can cause earthquakes."))
+            {
+                f3 &= TR3_IMPACT;
+                continue;
+            }
+            /* *SLAY* Dragon */
+            if (prefix(buf, "It is a great bane of dragons."))
+            {
+                f1 &= TR1_KILL_DRAGON;
+                continue;
+            }
+            /* Various Slays  */
+            if (prefix(buf, "It is especially deadly against dragons."))
+            {
+                f1 &= TR1_SLAY_DRAGON;
+                continue;
+            }
+            if (prefix(buf, "It is especially deadly against orcs."))
+            {
+                f1 &= TR1_SLAY_ORC;
+                continue;
+            }
+            if (prefix(buf, "It is especially deadly against trolls."))
+            {
+                f1 &= TR1_SLAY_TROLL;
+                continue;
+            }
+            if (prefix(buf, "It is especially deadly against giants."))
+            {
+                f1 &= TR1_SLAY_GIANT;
+                continue;
+            }
+            if (prefix(buf, "It strikes at demons with holy wrath."))
+            {
+                f1 &= TR1_SLAY_DEMON;
+                continue;
+            }
+            if (prefix(buf, "It strikes at undead with holy wrath."))
+            {
+                f1 &= TR1_SLAY_UNDEAD;
+                continue;
+            }
+            if (prefix(buf, "It fights against evil with holy fury."))
+            {
+                f1 &= TR1_SLAY_EVIL;
+                continue;
+            }
+            if (prefix(buf, "It is especially deadly against natural creatures."))
+            {
+                f1 &= TR1_SLAY_ANIMAL;
+                continue;
+            }
+
+            /* Various Sustains */
+            if (prefix(buf, "It sustains your strength."))
+            {
+                f2 &= TR2_SUST_STR;
+                continue;
+            }
+            if (prefix(buf, "It sustains your intelligence."))
+            {
+                f2 &= TR2_SUST_INT;
+                continue;
+            }
+            if (prefix(buf, "It sustains your wisdom."))
+            {
+                f2 &= TR2_SUST_WIS;
+                continue;
+            }
+            if (prefix(buf, "It sustains your dexterity."))
+            {
+                f2 &= TR2_SUST_DEX;
+                continue;
+            }
+            if (prefix(buf, "It sustains your constitution."))
+            {
+                f2 &= TR2_SUST_CON;
+                continue;
+            }
+            if (prefix(buf, "It sustains your charisma."))
+            {
+                f2 &= TR2_SUST_CHR;
+                continue;
+            }
+            /* Various immunities */
+            if (prefix(buf, "It provides immunity to acid."))
+            {
+                f2 &= TR2_IM_ACID;
+                continue;
+            }
+            if (prefix(buf, "It provides immunity to electricity."))
+            {
+                f2 &= TR2_IM_ELEC;
+                continue;
+            }
+            if (prefix(buf, "It provides immunity to fire."))
+            {
+                f2 &= TR2_IM_FIRE;
+                continue;
+            }
+            if (prefix(buf, "It provides immunity to cold."))
+            {
+                f2 &= TR2_IM_COLD;
+                continue;
+            }
+            /* Free Action */
+            if (prefix(buf, "It provides immunity to paralysis."))
+            {
+                f3 &= TR3_FREE_ACT;
+                continue;
+            }
+            /* Hold Life */
+            if (prefix(buf, "It provides resistance to life draining."))
+            {
+                f3 &= TR3_HOLD_LIFE;
+                continue;
+            }
+            /* Resists */
+            if (prefix(buf, "It provides resistance to acid."))
+            {
+                f2 &= TR2_RES_ACID;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to electricity."))
+            {
+                f2 &= TR2_RES_ELEC;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to fire."))
+            {
+                f2 &= TR2_RES_FIRE;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to cold."))
+            {
+                f2 &= TR2_RES_COLD;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to poison."))
+            {
+                f2 &= TR2_RES_POIS;
+                continue;
+            }
+
+            if (prefix(buf, "It provides resistance to light."))
+            {
+                f2 &= TR2_RES_LITE;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to dark."))
+            {
+                f2 &= TR2_RES_DARK;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to blindness."))
+            {
+                f2 &= TR2_RES_BLIND;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to confusion."))
+            {
+                f2 &= TR2_RES_CONFU;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to sound."))
+            {
+                f2 &= TR2_RES_SOUND;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to shards."))
+            {
+                f2 &= TR2_RES_SHARD;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to nether."))
+            {
+                f2 &= TR2_RES_NETHR;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to nexus."))
+            {
+                f2 &= TR2_RES_NEXUS;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to chaos."))
+            {
+                f2 &= TR2_RES_CHAOS;
+                continue;
+            }
+            if (prefix(buf, "It provides resistance to disenchantment."))
+            {
+                f2 &= TR2_RES_DISEN;
+                continue;
+            }
+            /* Feather Fall */
+            if (prefix(buf, "It induces feather falling."))
+            {
+                f3 &= TR3_FEATHER;
+                continue;
+            }
+            /* It Glows! */
+            if (prefix(buf, "It provides permanent light."))
+            {
+                f3 &= TR3_LITE;
+                continue;
+            }
+            /* See Invisible */
+            if (prefix(buf, "It allows you to see invisible monsters."))
+            {
+                f3 &= TR3_SEE_INVIS;
+                continue;
+            }
+            /* ESP */
+            if (prefix(buf, "It gives telepathic powers."))
+            {
+                f3 &= TR3_TELEPATHY;
+                continue;
+            }
+            /* Slow Digestion */
+            if (prefix(buf, "It slows your metabolism."))
+            {
+                f3 &= TR3_SLOW_DIGEST;
+                continue;
+            }
+            /* Regenerate */
+            if (prefix(buf, "It speeds your regenerative powers."))
+            {
+                f3 &= TR3_REGEN;
+                continue;
+            }
+            /* Extra Mult for Missle Weapons */
+            if (prefix(buf, "It fires missiles with extra might."))
+            {
+                f1 &= TR1_MIGHT;
+                continue;
+            }
+            /* Extra Shots */
+            if (prefix(buf, "It fires missiles excessively fast."))
+            {
+                f1 &= TR1_SHOTS;
+                continue;
+            }
+            /* The One Ring! */
+            if (prefix(buf, "It drains experience."))
+            {
+                f3 &= TR3_DRAIN_EXP;
+                continue;
+            }
+            /* Teleports (cursed) */
+            if (prefix(buf, "It induces random teleportation."))
+            {
+                f3 &= TR3_TELEPORT;
+                continue;
+            }
+            /* Aggravate */
+            if (prefix(buf, "It aggravates nearby creatures."))
+            {
+                f3 &= TR3_AGGRAVATE;
+                continue;
+            }
+            /* Can be used by priests */
+            if (prefix(buf, "It has been blessed by the gods."))
+            {
+                f3 &= TR3_BLESSED;
+                continue;
+            }
+            /* Perma-curse */
+            if (prefix(buf, "It is permanently cursed."))
+            {
+                f3 &= TR3_PERMA_CURSE;
+                continue;
+            }
+            /* Regualar old curse */
+            if (prefix(buf, "It is cursed."))
+            {
+                f3 &= TR3_LIGHT_CURSE;
+                continue;
+            }
+            /* Item imunity */
+            if (prefix(buf, "It cannot be harmed by acid."))
+            {
+                f3 &= TR3_IGNORE_ACID;
+                continue;
+            }
+            if (prefix(buf, "It cannot be harmed by electricity."))
+            {
+                f3 &= TR3_IGNORE_ELEC;
+                continue;
+            }
+            if (prefix(buf, "It cannot be harmed by fire."))
+            {
+                f3 &= TR3_IGNORE_FIRE;
+                continue;
+            }
+            if (prefix(buf, "It cannot be harmed by cold."))
+            {
+                f3 &= TR3_IGNORE_COLD;
+                continue;
+            }
+            /* press space to go to next screen. */
+            if (prefix(buf, "-- more --"))
+            {
+                return (TRUE);
+            }
+
+        }
+    }
+#endif /* not BORG_TK */
+
+    borg_item->flags1 = f1;
+    borg_item->flags2 = f2;
+    borg_item->flags3 = f3;
+
+    borg_item->needs_I = FALSE;
+
+    return (FALSE);
+}
+
+/*
+ * Look for an item that needs to be analysed because it has been *ID*d
+ *
+ * This will go through inventory and look for items that were just*ID*'d
+ * and examine them for their bonuses.
+ */
+bool borg_object_star_id( void )
+{
+    int i;
+
+    /* look in inventory and equiptment for something to *id* */
+    for (i = 0; i < INVEN_TOTAL; i++)
+    {
+
+        borg_item *item = &borg_items[i];
+
+        if (borg_items[i].needs_I)
+        {
+            if ((borg_cheat_equip && i >= INVEN_WIELD) ||
+                (borg_cheat_inven && i < INVEN_WIELD) )
+            {
+                /* cheat to get the information. */
+                borg_object_star_id_aux( &borg_items[i], &inventory[i]);
+            }
+#ifndef BORG_TK
+            else
+            {
+                byte t_a;
+
+                char buf[10];
+
+                /* Check to see if we are looking at the 'I' screen. */
+                if (!(0 == borg_what_text(0, 0, 9, &t_a, buf) &&
+                    (buf[0] == 'E') &
+                    (buf[1] == 'x') &
+                    (buf[2] == 'a') &
+                    (buf[3] == 'm') &
+                    (buf[4] == 'i') &
+                    (buf[5] == 'n') &
+                    (buf[6] == 'i') &
+                    (buf[7] == 'n') &
+                    (buf[8] == 'g')) )
+                {
+                    borg_keypress('I');
+                    if (i < INVEN_WIELD)
+                    {
+                        borg_keypress(I2A(i));
+                    }
+                    else
+                    {
+                        borg_keypress('/');
+                        borg_keypress(I2A(i - INVEN_WIELD));
+                    }
+                    return (TRUE);
+                }
+
+                /* Look at the screen to get the information */
+                if (borg_object_star_id_aux( &borg_items[i], 0 ))
+                {
+                    borg_keypress(' ');
+                    return (TRUE);
+                }
+
+                /* Get rid of the *ID* screen */
+                borg_keypress(' ');
+                borg_keypress(' ');
+                borg_keypress(ESCAPE);
+                borg_keypress(ESCAPE);
+                return (TRUE);
+            }
+#endif /* BORG_TK */
+
+            /* inscribe certain objects */
+
+            if (!borg_skill[BI_CDEPTH] &&
+                (item->name1 || item->name2 == EGO_ELVENKIND || item->name2 == EGO_PERMANENCE ||
+                item->name2 == EGO_AMAN || item->name2 == EGO_SHIELD_ELVENKIND || item->name2 == EGO_MAGI ||
+                (item->flags3 & TR3_BLESSED)) &&
+                (streq(item->note, "{ }")  || streq(item->note, "")  || streq(item->note, "{uncursed}")))
+            {
+
+                /* make the inscription */
+                borg_keypress('{');
+
+                if (i >= INVEN_WIELD)
+                {
+                borg_keypress('/');
+                borg_keypress(I2A(i - INVEN_WIELD));
+                }
+                else
+                {
+                borg_keypress(I2A(i));
+                }
+
+                if (item->flags1 & TR1_SPEED)
+                {
+                    borg_keypresses("Spd");
+                }
+                /* slays and immunities */
+                if (item->flags2 & TR2_RES_POIS)
+                {
+                	borg_keypresses("Poisn");
+                }
+                if (item->flags2 & TR2_IM_FIRE)
+                {
+                	borg_keypresses("IFir");
+                }
+                if (item->flags2 & TR2_IM_COLD)
+                {
+                	borg_keypresses("ICld");
+                }
+                if (item->flags2 & TR2_IM_ACID)
+                {
+                	borg_keypresses("IAcd");
+                }
+                if (item->flags2 & TR2_IM_ELEC)
+                {
+                	borg_keypresses("IElc");
+                }
+                if (item->flags2 & TR2_RES_LITE)
+                {
+                    borg_keypresses("Lite");
+                }
+                if (item->flags2 & TR2_RES_DARK)
+                {
+                    borg_keypresses("Dark");
+                }
+                if (item->flags2 & TR2_RES_BLIND)
+                {
+                    borg_keypresses("Blnd");
+                }
+                if (item->flags2 & TR2_RES_CONFU)
+                {
+                    borg_keypresses("Conf");
+                }
+                if (item->flags2 & TR2_RES_SOUND)
+                {
+                    borg_keypresses("Sound");
+                }
+                if (item->flags2 & TR2_RES_SHARD)
+                {
+                    borg_keypresses("Shrd");
+                }
+                if (item->flags2 & TR2_RES_NETHR)
+                {
+                    borg_keypresses("Nthr");
+                }
+                if (item->flags2 & TR2_RES_NEXUS)
+                {
+                    borg_keypresses("Nxs");
+                }
+                if (item->flags2 & TR2_RES_CHAOS)
+                {
+                    borg_keypresses("Chaos");
+                }
+                if (item->flags2 & TR2_RES_DISEN)
+                {
+                    borg_keypresses("Disn");
+                }
+                if (item->flags3 & TR3_ACTIVATE)
+                {
+                    borg_keypresses("Actv");
+                }
+                if (item->flags3 & TR3_TELEPATHY)
+                {
+                    borg_keypresses("ESP");
+                }
+                if (item->flags3 & TR3_HOLD_LIFE)
+                {
+                    borg_keypresses("HL");
+                }
+                if (item->flags3 & TR3_FREE_ACT)
+                {
+                    borg_keypresses("FA");
+                }
+                if (item->flags3 & TR3_SEE_INVIS)
+                {
+                    borg_keypresses("SInv");
+                }
+
+                /* end the inscription */
+                borg_keypress('\n');
+
+            }
+
+        }
+
+    }
+    return (FALSE);
+}
+
+
+
+/*
+ * Determine the "base price" of a known item (see below)
+ *
+ * This function is adapted from "object_value_known()".
+ *
+ * This routine is called only by "borg_item_analyze()", which
+ * uses this function to guess at the "value" of an item, if it
+ * was to be sold to a store, with perfect "charisma" modifiers.
+ */
+static s32b borg_object_value_known(borg_item *item)
+{
+    s32b value;
+
+
+    object_kind *k_ptr = &k_info[item->kind];
+
+    /* Worthless items */
+    if (!k_ptr->cost) return (0L);
+
+    /* Extract the base value */
+    value = k_ptr->cost;
+
+
+    /* Hack -- use artifact base costs */
+    if (item->name1)
+    {
+        artifact_type *a_ptr = &a_info[item->name1];
+
+        /* Worthless artifacts */
+        if (!a_ptr->cost) return (0L);
+
+        /* Hack -- use the artifact cost */
+        value = a_ptr->cost;
+    }
+
+    /* Hack -- add in ego-item bonus cost */
+    if (item->name2)
+    {
+        ego_item_type *e_ptr = &e_info[item->name2];
+
+        /* Worthless ego-items */
+        if (!e_ptr->cost) return (0L);
+
+        /* Hack -- reward the ego-item cost */
+        value += e_ptr->cost;
+    }
+
+
+    /* Analyze pval bonus */
+    switch (item->tval)
+    {
+        /* Wands/Staffs */
+        case TV_WAND:
+        case TV_STAFF:
+        {
+            /* Pay extra for charges */
+            value += ((value / 20) * item->pval);
+
+            break;
+        }
+
+        /* Wearable items */
+        case TV_SHOT:
+        case TV_ARROW:
+        case TV_BOLT:
+        case TV_BOW:
+        case TV_DIGGING:
+        case TV_HAFTED:
+        case TV_POLEARM:
+        case TV_SWORD:
+        case TV_BOOTS:
+        case TV_GLOVES:
+        case TV_HELM:
+        case TV_CROWN:
+        case TV_SHIELD:
+        case TV_CLOAK:
+        case TV_SOFT_ARMOR:
+        case TV_HARD_ARMOR:
+        case TV_DRAG_ARMOR:
+        case TV_LITE:
+        case TV_AMULET:
+        case TV_RING:
+        {
+            /* Hack -- Negative "pval" is always bad */
+            if (item->pval < 0) return (0L);
+
+            /* No pval */
+            if (!item->pval) break;
+
+            /* Give credit for stat bonuses */
+            if (item->flags1 & TR1_STR) value += (item->pval * 200L);
+            if (item->flags1 & TR1_INT) value += (item->pval * 200L);
+            if (item->flags1 & TR1_WIS) value += (item->pval * 200L);
+            if (item->flags1 & TR1_DEX) value += (item->pval * 200L);
+            if (item->flags1 & TR1_CON) value += (item->pval * 200L);
+            if (item->flags1 & TR1_CHR) value += (item->pval * 200L);
+
+            /* Give credit for stealth and searching */
+            if (item->flags1 & TR1_STEALTH) value += (item->pval * 100L);
+            if (item->flags1 & TR1_SEARCH) value += (item->pval * 100L);
+
+            /* Give credit for infra-vision and tunneling */
+            if (item->flags1 & TR1_INFRA) value += (item->pval * 50L);
+            if (item->flags1 & TR1_TUNNEL) value += (item->pval * 50L);
+
+            /* Give credit for extra attacks */
+            if (item->flags1 & TR1_BLOWS) value += (item->pval * 2000L);
+
+            /* Give credit for speed bonus */
+            if (item->flags1 & TR1_SPEED) value += (item->pval * 30000L);
+
+            break;
+        }
+    }
+
+
+    /* Analyze the item */
+    switch (item->tval)
+    {
+        /* Rings/Amulets */
+        case TV_RING:
+        case TV_AMULET:
+        {
+            /* Hack -- negative bonuses are bad */
+            if (item->to_a < 0) return (0L);
+            if (item->to_h < 0) return (0L);
+            if (item->to_d < 0) return (0L);
+
+            /* Give credit for bonuses */
+            value += ((item->to_h + item->to_d + item->to_a) * 100L);
+
+            break;
+        }
+
+        /* Armor */
+        case TV_BOOTS:
+        case TV_GLOVES:
+        case TV_CLOAK:
+        case TV_CROWN:
+        case TV_HELM:
+        case TV_SHIELD:
+        case TV_SOFT_ARMOR:
+        case TV_HARD_ARMOR:
+        case TV_DRAG_ARMOR:
+        {
+            /* Hack -- negative armor bonus */
+            if (item->to_a < 0) return (0L);
+
+            /* Give credit for bonuses */
+            value += ((item->to_h + item->to_d + item->to_a) * 100L);
+
+            break;
+        }
+
+        /* Bows/Weapons */
+        case TV_BOW:
+        case TV_DIGGING:
+        case TV_HAFTED:
+        case TV_SWORD:
+        case TV_POLEARM:
+        {
+            /* Hack -- negative hit/damage bonuses */
+            if (item->to_h + item->to_d < 0) return (0L);
+
+            /* Factor in the bonuses */
+            value += ((item->to_h + item->to_d + item->to_a) * 100L);
+
+            /* Hack -- Factor in extra damage dice */
+            if ((item->dd > k_ptr->dd) && (item->ds == k_ptr->ds))
+            {
+                value += (item->dd - k_ptr->dd) * item->ds * 200L;
+            }
+
+            break;
+        }
+
+        /* Ammo */
+        case TV_SHOT:
+        case TV_ARROW:
+        case TV_BOLT:
+        {
+            /* Hack -- negative hit/damage bonuses */
+            if (item->to_h + item->to_d < 0) return (0L);
+
+            /* Factor in the bonuses */
+            value += ((item->to_h + item->to_d) * 5L);
+
+            /* Hack -- Factor in extra damage dice */
+            if ((item->dd > k_ptr->dd) && (item->ds == k_ptr->ds))
+            {
+                value += (item->dd - k_ptr->dd) * item->ds * 5L;
+            }
+
+            break;
+        }
+    }
+
+
+    /* Return the value */
+    return (value);
+}
+
+
+/*
+ * Analyze an item given a description and (optional) cost
+ *
+ * From the description, extract the item identity, and the various
+ * bonuses, plus the "aware" and "known" flags (in an encoded state).
+ *
+ * Note the use of a "prefix binary search" on the arrays of object
+ * base names, and on the arrays of artifact/ego-item special names.
+ *
+ * A "prefix binary search" starts out just like a normal binary search,
+ * in that it searches a sorted array of entries for a specific entry,
+ * using a simple "less than or equal to" comparison.  When it finds
+ * an entry, however, instead of simply checking for "equality" of the
+ * entry to the key, it must check whether the key is a "prefix" of the
+ * entry.  And if any entry can be a prefix of another entry, then it
+ * must check whether the key is a "prefix" of any of the entries which
+ * precede the "found" entry.  Technically, it only has to check the
+ * preceding N entries, where N is the maximum distance between any two
+ * entries sharing a "prefix" relation, but note that only in the case
+ * of "failure" will the search need to check more than a few entries,
+ * even if it scans all the way to the start of the list.
+ *
+ * We use the object kind to guess at the object weight and flags, and
+ * then we use the artifact/ego-item information to update our guesses.
+ *
+ * We also guess at the value of the item, as given by "object_value()".
+ *
+ * Note that we will fail if the "description" was "partial", that is,
+ * if it was "broken" by the display functions for any reason.  This
+ * should only be an issue in "stores", which "chop" the description
+ * to a length of about 60 characters, which may be "messy".  Luckily,
+ * objects in stores never have important inscriptions, and we should
+ * correctly handle objects with "bizarre" inscriptions, or even with
+ * "broken" inscriptions, so we should be okay.
+ */
+void borg_item_analyze(borg_item *item, cptr desc)
+{
+    int i, m, n;
+
+    int d1 = 0;
+    int d2 = 0;
+    int ac = 0;
+    int th = 0;
+    int td = 0;
+    int ta = 0;
+	int charges = 0;
+
+    bool done = FALSE;
+
+    char *scan;
+    char *tail;
+
+    char temp[128];
+
+    artifact_type *a_ptr; /* For artifact understanding in 3.0 */
+
+    /* Wipe the item */
+    WIPE(item, borg_item);
+
+
+    /* Save the item description */
+    strcpy(item->desc, desc);
+
+
+    /* Advance to the "inscription" or end of string */
+    for (scan = item->desc; *scan && (*scan != c1); scan++) /* loop */;
+
+    /* Save a pointer to the inscription */
+    item->note = scan;
+
+    /* Empty item */
+    if (!desc[0]) return;
+	if (strstr(desc, "(nothing)")) return;
+
+
+    /* Assume singular */
+    item->iqty = 1;
+
+    /* Notice prefix "a " */
+    if ((desc[0] == 'a') && (desc[1] == ' '))
+    {
+        /* Skip "a " */
+        desc += 2;
+    }
+
+    /* Notice prefix "a " */
+    else if ((desc[0] == 'a') && (desc[1] == 'n') && (desc[2] == ' '))
+    {
+        /* Skip "an " */
+        desc += 3;
+    }
+
+    /* Notice prefix "The " */
+    else if ((desc[0] == 'T') && (desc[1] == 'h') &&
+             (desc[2] == 'e') && (desc[3] == ' '))
+    {
+        /* Skip "The " */
+        desc += 4;
+
+        /* hack-- he loops on randart phials */
+        /* if 'The' is known, then it is ID'd */
+        item->able = TRUE;
+    }
+
+    /* Notice "numerical" prefixes */
+    else if (isdigit(desc[0]))
+    {
+        cptr s;
+
+        /* Find the first space */
+        for (s = desc; *s && (*s != ' '); s++) /* loop */;
+
+        /* Paranoia -- Catch sillyness */
+        if (*s != ' ') return;
+
+        /* Extract a quantity */
+        item->iqty = atoi(desc);
+
+        /* Skip the quantity and space */
+        desc = s + 1;
+    }
+
+    /* Paranoia */
+    if (!desc[0]) return;
+
+
+    /* Obtain a copy of the description */
+    strcpy(temp, desc);
+
+    /* Advance to the "inscription" or end of string */
+    for (scan = temp; *scan && (*scan != c1); scan++) /* loop */;
+
+    /* Nuke the space before the inscription */
+    if ((scan[0] == c1) && (scan[-1] == ' ')) *--scan = '\0';
+
+    /* Note that "scan" points at the "tail" of "temp" */
+
+    /* Hack -- non-aware, singular, flavored items */
+    if (item->iqty == 1)
+    {
+        if (prefix(temp, "Scroll titled ")) item->tval = TV_SCROLL;
+        else if ((scan - temp > 7) && streq(scan-7, " Potion")) item->tval = TV_POTION;
+        else if ((scan - temp > 6) && streq(scan-6, " Staff")) item->tval = TV_STAFF;
+        else if ((scan - temp > 5) && streq(scan-5, " Wand")) item->tval = TV_WAND;
+        else if ((scan - temp > 4) && streq(scan-4, " Rod")) item->tval = TV_ROD;
+        else if ((scan - temp > 5) && streq(scan-5, " Ring")) item->tval = TV_RING;
+        else if ((scan - temp > 7) && streq(scan-7, " Amulet")) item->tval = TV_AMULET;
+        else if ((scan - temp > 9) && streq(scan-9, " Mushroom")) item->tval = TV_FOOD;
+    }
+
+    /* Hack -- non-aware, plural, flavored items */
+    else
+    {
+        if (prefix(temp, "Scrolls titled ")) item->tval = TV_SCROLL;
+        else if ((scan - temp > 8) && streq(scan-8, " Potions")) item->tval = TV_POTION;
+        else if ((scan - temp > 7) && streq(scan-7, " Staffs")) item->tval = TV_STAFF;
+        else if ((scan - temp > 6) && streq(scan-6, " Wands")) item->tval = TV_WAND;
+        else if ((scan - temp > 5) && streq(scan-5, " Rods")) item->tval = TV_ROD;
+        else if ((scan - temp > 6) && streq(scan-6, " Rings")) item->tval = TV_RING;
+        else if ((scan - temp > 8) && streq(scan-8, " Amulets")) item->tval = TV_AMULET;
+        else if ((scan - temp > 10) && streq(scan-10, " Mushrooms")) item->tval = TV_FOOD;
+    }
+
+    /* Accept non-aware flavored objects */
+    if (item->tval)
+    {
+        /* Guess at weight and cost */
+        switch (item->tval)
+        {
+            case TV_FOOD:
+            {
+                item->weight = 1;
+                item->value = 5L;
+                break;
+            }
+
+            case TV_POTION:
+            {
+                item->weight = 4;
+                item->value = 20L;
+                break;
+            }
+
+            case TV_SCROLL:
+            {
+                item->weight = 5;
+                item->value = 20L;
+                break;
+            }
+
+            case TV_STAFF:
+            {
+                item->weight = 50;
+                item->value = 70L;
+                break;
+            }
+
+            case TV_WAND:
+            {
+                item->weight = 10;
+                item->value = 50L;
+                break;
+            }
+
+            case TV_ROD:
+            {
+                item->weight = 15;
+                item->value = 90L;
+                break;
+            }
+
+            case TV_RING:
+            {
+                item->weight = 2;
+                item->value = 45L;
+                break;
+            }
+
+            case TV_AMULET:
+            {
+                item->weight = 3;
+                item->value = 45L;
+                break;
+            }
+        }
+
+        /* Done */
+        return;
+    }
+
+    /* Start at the beginning */
+    tail = temp;
+
+    /* Check singular items */
+    if (item->iqty == 1)
+    {
+        /* Start the search */
+        m = 0; n = borg_single_size;
+
+        /* Simple binary search */
+        while (m < n - 1)
+        {
+            /* Pick a "middle" entry */
+            i = (m + n) / 2;
+
+            /* Search to the right (or here) */
+            if (strcmp(borg_single_text[i], tail) <= 0)
+            {
+                m = i;
+            }
+
+            /* Search to the left */
+            else
+            {
+                n = i;
+            }
+        }
+
+        /* Check prefixes XXX */
+        for (i = m; i >= 0; i--)
+        {
+            /* Verify prefix */
+            if (prefix(tail, borg_single_text[i]))
+            {
+                /* Save the item kind */
+                item->kind = borg_single_what[i];
+
+                /* Skip past the base name */
+                tail += strlen(borg_single_text[i]);
+
+                /* Done */
+                break;
+            }
+        }
+    }
+
+    /* Check plural items */
+    else
+    {
+        /* Start the search */
+        m = 0; n = borg_plural_size;
+
+        /* Simple binary search */
+        while (m < n - 1)
+        {
+            /* Pick a "middle" entry */
+            i = (m + n) / 2;
+
+            /* Search to the right (or here) */
+            if (strcmp(borg_plural_text[i], tail) <= 0)
+            {
+                m = i;
+            }
+
+            /* Search to the left */
+            else
+            {
+                n = i;
+            }
+        }
+
+        /* Check prefixes XXX */
+        for (i = m; i >= 0; i--)
+        {
+            /* Verify prefix */
+            if (prefix(tail, borg_plural_text[i]))
+            {
+                /* Save the item kind */
+                item->kind = borg_plural_what[i];
+
+                /* Skip past the base name */
+                tail += strlen(borg_plural_text[i]);
+
+                /* Done */
+                break;
+            }
+        }
+    }
+
+    /* Oops */
+    if (!item->kind)
+    {
+        borg_note(format("Bizarre: %s", desc));
+        borg_oops("bizarre object");
+        return;
+    }
+
+
+    /* Extract some info */
+    item->tval = k_info[item->kind].tval;
+    item->sval = k_info[item->kind].sval;
+
+    /* Guess at the weight */
+    item->weight = k_info[item->kind].weight;
+
+    /* ID the level */
+    item->level = k_info[item->kind].level;
+
+    /* Extract the base flags */
+    item->flags1 = k_info[item->kind].flags1;
+    item->flags2 = k_info[item->kind].flags2;
+    item->flags3 = k_info[item->kind].flags3;
+
+
+    /* Analyze "bonuses" */
+    switch (item->tval)
+    {
+        /* Basic items */
+        case TV_MAGIC_BOOK:
+        case TV_PRAYER_BOOK:
+        case TV_FLASK:
+        case TV_FOOD:
+        case TV_POTION:
+        case TV_SCROLL:
+        case TV_SPIKE:
+        case TV_SKELETON:
+        case TV_BOTTLE:
+        case TV_JUNK:
+        {
+            /* Always "able" */
+            item->able = TRUE;
+
+            break;
+        }
+
+        /* Chests */
+        case TV_CHEST:
+        {
+            /* XXX XXX XXX */
+
+            /* Require the prefix and suffix */
+            if (!prefix(tail, " (")) break;
+            if (!suffix(tail, ")")) break;
+
+            /* Assume "able" */
+            item->able = TRUE;
+
+            /* Hack -- assume "trapped" */
+            item->pval = 63;
+
+            /* Hack -- extract "empty" */
+            if (streq(tail, " (empty)")) item->pval = 0;
+
+            break;
+        }
+
+        /* Wands/Staffs -- charges */
+        case TV_WAND:
+        case TV_STAFF:
+        {
+            /* assume 1 charge unless empty.  This will allow use of  */
+            /* staffs of teleport to get away when hit with a forget spell. */
+            item->pval = 1;
+
+            if (streq(item->note, "{empty}")) item->pval = 0;
+            if (streq(tail, "(empty)")) item->pval = 0;
+
+            /* Require the prefix and suffix */
+            if (!prefix(tail, " (")) break; /* --(-- */
+            if (!suffix(tail, " charge)") && !suffix(tail, " charges)")) break;
+
+			/* careful, no crashes */
+			if (item->iqty < 1) item->iqty = 1;
+
+            /* Extract the "charges" */
+            charges = (atoi(tail+2));
+
+			/* Define pval for each staff */
+			item->pval = charges / item->iqty;
+
+			/* the function ceil() would be preferred here, but it does not seem to work
+			 * correctly for rounding up the pval.  So we have to do it manually.
+			 */
+
+			/* the comp will round down, make sure we dont have 0 pval and some charges. */
+			if (charges && item->pval == 0) item->pval = 1;
+
+
+            /* Assume "able" */
+            item->able = TRUE;
+
+            break;
+        }
+
+        /* Rods -- charging */
+        case TV_ROD:
+        {
+            /* Always "able" */
+            item->able = TRUE;
+
+            /* Mega-Hack -- fake "charges" */
+            item->pval = item->iqty;
+
+            /* This is opposite from the game. (Pval is charge time) */
+            /* Mega-Hack -- "charging" means no "charges" */
+            if (streq(tail, " (charging)")) item->pval = 0;
+
+            /* Require the prefix and suffix */
+            if (!prefix(tail, " (")) break; /* --(-- */
+            if (!suffix(tail, " charging)") && !suffix(tail, " charging)")) break;
+
+            /* Extract the " x charging" */
+            item->pval = item->iqty - atoi(tail+2);
+
+            break;
+        }
+
+        /* Wearable items */
+        case TV_SHOT:
+        case TV_ARROW:
+        case TV_BOLT:
+        case TV_BOW:
+        case TV_DIGGING:
+        case TV_HAFTED:
+        case TV_POLEARM:
+        case TV_SWORD:
+        case TV_BOOTS:
+        case TV_GLOVES:
+        case TV_HELM:
+        case TV_CROWN:
+        case TV_SHIELD:
+        case TV_CLOAK:
+        case TV_SOFT_ARMOR:
+        case TV_HARD_ARMOR:
+        case TV_DRAG_ARMOR:
+        case TV_LITE:
+        case TV_AMULET:
+        case TV_RING:
+        {
+            /* Hack -- handle "easy know" */
+            if (k_info[item->kind].flags3 & TR3_EASY_KNOW)
+            {
+                /* Always known */
+                item->able = TRUE;
+            }
+
+            /* Hack -- for ammy of resistance which lacks the
+             * EASY_KNOW flag, but should have one.
+             */
+            if (item->tval == TV_AMULET &&
+               (!(k_info[item->kind].flags3 & TR3_HIDE_TYPE)))
+            {
+                /* Always known */
+                item->able = TRUE;
+            }
+
+            /* No suffix */
+            if (tail[0] != ' ') break;
+
+            /* Start the search */
+            m = 0; n = borg_artego_size;
+
+            /* Binary search */
+            while (m < n - 1)
+            {
+                /* Pick a "middle" entry */
+                i = (m + n) / 2;
+
+                /* Search to the right (or here) */
+                if (strcmp(borg_artego_text[i], tail) <= 0)
+                {
+                    m = i;
+                }
+
+                /* Search to the left */
+                else
+                {
+                    n = i;
+                }
+            }
+
+            /* Check prefixes XXX */
+            for (i = m; i >= 0; i--)
+            {
+                /* Verify prefix */
+                if (prefix(tail, borg_artego_text[i]))
+                {
+                    /* Paranoia */
+                    item->able = TRUE;
+
+                    /* Save the artifact name */
+                    if (borg_artego_what[i] < 256)
+                    {
+                        item->name1 = borg_artego_what[i];
+
+                        /* Must know activation */
+                        a_ptr = &a_info[item->name1];
+
+                        /* Define the borg's Activation as the Activation */
+                        item->activation = a_ptr->activation;
+				    }
+
+                    /* Save the ego-item name */
+                    else
+                    {
+                        item->name2 = borg_artego_what[i] - 256;
+                    }
+
+                    /* Skip the artifact/ego-item name */
+                    tail += strlen(borg_artego_text[i]);
+
+                    /* Done */
+                    break;
+                }
+            }
+
+            /* Hack -- grab "charging" suffix */
+            if (suffix(tail, " (charging)"))
+            {
+                /* Remove the suffix */
+                tail[strlen(tail)-11] = '\0';
+
+                /* Remember it */
+                item->timeout = 999;
+            }
+
+            /* Hack -- handle Lite's */
+            if (item->tval == TV_LITE)
+            {
+                /* Hack -- Artifact Lite's */
+                if (item->name1)
+                {
+                    /* Assume "able" */
+                    item->able = TRUE;
+
+                    /* Hack -- fuel */
+                    item->pval = 2;
+
+                    break;
+                }
+
+                /* Require the prefix and suffix */
+                if (!prefix(tail, " (with ")) break;
+                if (!suffix(tail, " of light)")) break;
+
+                /* Extract "turns of lite" */
+                item->pval = atoi(tail+7);
+
+                /* Assume "able" */
+                item->able = TRUE;
+
+                break;
+            }
+
+            /* Hack -- Skip spaces */
+            while (tail[0] == ' ') tail++;
+
+            /* No suffix */
+            if (!tail[0]) break;
+
+            /* Parse "weapon-style" damage strings */
+            if ((tail[0] == p1) &&
+                ((item->tval == TV_HAFTED) ||
+                 (item->tval == TV_POLEARM) ||
+                 (item->tval == TV_SWORD) ||
+                 (item->tval == TV_DIGGING) ||
+                 (item->tval == TV_BOLT) ||
+                 (item->tval == TV_ARROW) ||
+                 (item->tval == TV_SHOT)))
+            {
+                /* First extract the damage string */
+                for (scan = tail; *scan != p2; scan++) /* loop */;
+                scan++;
+
+                /* Hack -- Notice "end of string" */
+                if (scan[0] != ' ') done = TRUE;
+
+                /* Terminate the string and advance */
+                *scan++ = '\0';
+
+                /* Parse the damage string, or stop XXX */
+                if (sscanf(tail, "(%dd%d)", &d1, &d2) != 2) break;
+
+                /* Save the values */
+                item->dd = d1;
+                item->ds = d2;
+
+                /* No extra information means not identified */
+                if (done) break;
+
+                /* Skip the "damage" info */
+                tail = scan;
+            }
+
+            /* Parse the "damage" string for bows */
+            else if ((tail[0] == p1) &&
+                     (item->tval == TV_BOW))
+            {
+                /* First extract the damage string */
+                for (scan = tail; *scan != p2; scan++) /* loop */;
+                scan++;
+
+                /* Hack -- Notice "end of string" */
+                if (scan[0] != ' ') done = TRUE;
+
+                /* Terminate the string and advance */
+                *scan++ = '\0';
+
+                /* Parse the multiplier string, or stop */
+                if (sscanf(tail, "(x%d)", &d1) != 1) break;
+
+                /* No extra information means not identified */
+                if (done) break;
+
+                /* Skip the "damage" info */
+                tail = scan;
+            }
+
+
+            /* Parse the "bonus" string */
+            if (tail[0] == p1)
+            {
+                /* Extract the extra info */
+                for (scan = tail; *scan != p2; scan++) /* loop */;
+                scan++;
+
+                /* Hack -- Notice "end of string" */
+                if (scan[0] != ' ') done = TRUE;
+
+                /* Terminate the damage, advance */
+                *scan++ = '\0';
+
+                /* Parse standard "bonuses" */
+                if (sscanf(tail, "(%d,%d)", &th, &td) == 2)
+                {
+                    item->to_h = th;
+                    item->to_d = td;
+                    item->able = TRUE;
+                }
+
+                /* XXX XXX Hack -- assume non-final bonuses are "to_hit" */
+                else if (!done && sscanf(tail, "(%d)", &th) == 1)
+                {
+                    item->to_h = th;
+                    item->able = TRUE;
+                }
+
+                /* XXX XXX Hack -- assume final bonuses are "pval" codes */
+                else if (done)
+                {
+                    item->pval = atoi(tail + 1);
+                    item->able = TRUE;
+                }
+
+                /* Oops */
+                else
+                {
+                    break;
+                }
+
+                /* Nothing left */
+                if (done) break;
+
+                /* Skip the "damage bonus" info */
+                tail = scan;
+            }
+
+
+            /* Parse the "bonus" string */
+            if (tail[0] == b1)
+            {
+                /* Extract the extra info */
+                for (scan = tail; *scan != b2; scan++) /* loop */;
+                scan++;
+
+                /* Hack -- Notice "end of string" */
+                if (scan[0] != ' ') done = TRUE;
+
+                /* Terminate the armor string, advance */
+                *scan++ = '\0';
+
+                /* Parse the armor, and bonus */
+                if (sscanf(tail, "[%d,%d]", &ac, &ta) == 2)
+                {
+                    item->ac = ac;
+                    item->to_a = ta;
+                    item->able = TRUE;
+                }
+
+                /* Negative armor bonus */
+                else if (sscanf(tail, "[-%d]", &ta) == 1)
+                {
+                    item->to_a = -ta;
+                    item->able = TRUE;
+                }
+
+                /* Positive armor bonus */
+                else if (sscanf(tail, "[+%d]", &ta) == 1)
+                {
+                    item->to_a = ta;
+                    item->able = TRUE;
+                }
+
+                /* Just base armor */
+                else if (sscanf(tail, "[%d]", &ac) == 1)
+                {
+                    item->ac = ac;
+                }
+
+                /* Oops */
+                else
+                {
+                    break;
+                }
+
+                /* Nothing left */
+                if (done) break;
+
+                /* Skip the "armor" data */
+                tail = scan;
+            }
+
+
+            /* Parse the final "pval" string, if any */
+            if (tail[0] == p1)
+            {
+                /* Assume identified */
+                item->able = TRUE;
+
+                /* Hack -- Grab it */
+                item->pval = atoi(tail + 1);
+            }
+
+            break;
+        }
+    }
+
+
+    /* Hack -- repair rings of damage */
+    if ((item->tval == TV_RING) && (item->sval == SV_RING_DAMAGE))
+    {
+        /* Bonus to dam, not pval */
+        item->to_d = item->pval;
+        item->pval = 0;
+    }
+
+    /* Hack -- repair rings of accuracy */
+    if ((item->tval == TV_RING) && (item->sval == SV_RING_ACCURACY))
+    {
+        /* Bonus to hit, not pval */
+        item->to_h = item->pval;
+        item->pval = 0;
+    }
+
+
+    /* XXX XXX XXX Repair various "ego-items" */
+
+	/* Repair the Planatir of Westerness. The borg thinks
+	 * it is an ego item.since it has an ego name.
+	 */
+	if (item->kind == 512)
+	{
+		/* remove the name2 and replace it with correct name1 */
+		item->name1 = 7;
+		item->name2 = 0;
+		/* correct activation and pval */
+		item->activation = ACT_CLAIRVOYANCE;
+		item->pval = 2;
+	}
+
+	/* Repair the Shield of the Haradrim. The borg thinks
+	 * it is an ego item.since it has an ego name.
+	 */
+	if (item->kind == 129 && item->name2 == 107 && item->pval == 2)
+	{
+		/* remove the name2 and replace it with correct name1 */
+		item->name1 = 134;
+		item->name2 = 0;
+		/* correct activation and pval */
+		item->activation = ACT_BERSERKER;
+		item->pval = 2;
+	}
+
+	/* Repair the Elvenkind items that are not Armour so that
+	 * the borg can correctly handle the high resists
+	 */
+	if (item->name2 == 61 || item->name2 == 21) item->name2 = 9;
+
+    /* Hack -- examine artifacts */
+    if (item->name1)
+    {
+        /* XXX XXX Hack -- fix "weird" artifacts */
+        if ((item->tval != a_info[item->name1].tval) ||
+            (item->sval != a_info[item->name1].sval))
+        {
+            /* Save the kind */
+            item->kind = lookup_kind(item->tval, item->sval);
+
+            /* Save the tval/sval */
+            item->tval = k_info[item->kind].tval;
+            item->sval = k_info[item->kind].sval;
+        }
+
+        /* Extract the weight */
+        item->weight = a_info[item->name1].weight;
+
+        /* Extract the artifact flags */
+        item->flags1 = a_info[item->name1].flags1;
+        item->flags2 = a_info[item->name1].flags2;
+        item->flags3 = a_info[item->name1].flags3;
+     }
+
+
+    /* Hack -- examine ego-items */
+    if (item->name2)
+    {
+        /* XXX Extract the weight */
+
+        /* Extract the ego-item flags */
+        item->flags1 |= e_info[item->name2].flags1;
+        item->flags2 |= e_info[item->name2].flags2;
+        item->flags3 |= e_info[item->name2].flags3;
+    }
+
+
+    /* Known items */
+    if (item->able)
+    {
+        /* Process various fields */
+        item->value = borg_object_value_known(item);
+    }
+
+    /* Aware items */
+    else
+    {
+        /* Aware items can assume template cost */
+        item->value = k_info[item->kind].cost;
+    }
+
+
+    /* Parse various "inscriptions" */
+    if (item->note[0])
+    {
+        /* Special "discount" */
+        if (streq(item->note, "{on sale}")) item->discount = 50;
+
+        /* Standard "discounts" */
+        else if (streq(item->note, "{25% off}")) item->discount = 25;
+        else if (streq(item->note, "{50% off}")) item->discount = 50;
+        else if (streq(item->note, "{75% off}")) item->discount = 75;
+        else if (streq(item->note, "{90% off}")) item->discount = 90;
+
+        /* Cursed indicators */
+        else if (streq(item->note, "{cursed}"))
+        {
+            /* One Ring is not junk */
+            if (item->activation != ACT_BIZZARE)
+            {
+                item->value = 0L;
+            }
+            item->cursed = TRUE;
+        }
+
+        else if (streq(item->note, "{broken}")) item->value = 0L;
+        else if (streq(item->note, "{terrible}")) item->value = 0L;
+        else if (streq(item->note, "{worthless}")) item->value = 0L;
+        else if (suffix(item->note, "uncursed}"))
+                item->discount = INSCRIP_UNCURSED;
+
+        /* Ignore certain feelings */
+        /* "{average}" */
+        /* "{blessed}" */
+        /* "{good}" */
+        /* "{excellent}" */
+        /* "{special}" */
+
+        /* Ignore special inscriptions */
+        /* "{empty}", "{tried}" */
+    }
+
+
+    /* Apply "discount" if any */
+    if (item->discount) item->value -= item->value * item->discount / 100;
+
+    /* Assume not fully Identified. */
+    item->needs_I = TRUE;
+    item->fully_identified = FALSE;
+}
+
+
+
+
+/*
+ * Send a command to inscribe item number "i" with the inscription "str".
+ */
+void borg_send_inscribe(int i, cptr str)
+{
+    cptr s;
+
+    /* Label it */
+    borg_keypress(c1);
+
+    /* Choose from inventory */
+    if (i < INVEN_WIELD)
+    {
+        /* Choose the item */
+        borg_keypress(I2A(i));
+    }
+
+    /* Choose from equipment */
+    else
+    {
+        /* Go to equipment (if necessary) */
+        if (borg_items[0].iqty) borg_keypress('/');
+
+        /* Choose the item */
+        borg_keypress(I2A(i - INVEN_WIELD));
+    }
+
+    /* Send the label */
+    for (s = str; *s; s++) borg_keypress(*s);
+
+    /* End the inscription */
+    borg_keypress('\n');
+
+}
+
+
+
+
+/*
+ * Find the slot of an item with the given tval/sval, if available.
+ * Given multiple choices, choose the item with the largest "pval".
+ * Given multiple choices, choose the smallest available pile.
+ */
+int borg_slot(int tval, int sval)
+{
+    int i, n = -1;
+
+    /* Scan the pack */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip un-aware items */
+        if (!item->kind) continue;
+
+        /* Require correct tval */
+        if (item->tval != tval) continue;
+
+        /* Require correct sval */
+        if (item->sval != sval) continue;
+
+        /* Prefer largest "pval" */
+        if ((n >= 0) && (item->pval < borg_items[n].pval)) continue;
+
+        /* Prefer smallest pile */
+        if ((n >= 0) && (item->iqty > borg_items[n].iqty)) continue;
+
+        /* Save this item */
+        n = i;
+    }
+
+    /* Done */
+    return (n);
+}
+
+
+
+/*
+ * Hack -- refuel a torch
+ */
+bool borg_refuel_torch(void)
+{
+    int i;
+
+    /* Look for a torch */
+    i = borg_slot(TV_LITE, SV_LITE_TORCH);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* must first wield before one can refuel */
+    if (borg_items[INVEN_LITE].sval != SV_LITE_TORCH)
+        {
+            return (FALSE);
+        }
+
+    /* Dont bother with empty */
+    if (borg_items[i].pval == 0)
+    {
+        return (FALSE);
+    }
+
+    /* Cant refuel nothing */
+    if (borg_items[INVEN_LITE].iqty == 0)
+    {
+        return (FALSE);
+    }
+
+    /* Log the message */
+    borg_note(format("# Refueling with %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('F');
+    borg_keypress(I2A(i));
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Hack -- refuel a lantern
+ */
+bool borg_refuel_lantern(void)
+{
+    int i;
+
+    /* Look for a torch */
+    i = borg_slot(TV_FLASK, 0);
+
+    /* None available check for lantern */
+    if (i < 0)
+    {
+		i = borg_slot(TV_LITE, SV_LITE_LANTERN);
+
+		/* It better have some oil left */
+	    if (borg_items[i].pval <= 0) i = -1;
+	}
+
+	/* Still none */
+	if (i < 0) return (FALSE);
+
+    /* Cant refuel a torch with oil */
+    if (borg_items[INVEN_LITE].sval != SV_LITE_LANTERN)
+    {
+        return (FALSE);
+    }
+
+    /* Log the message */
+    borg_note(format("# Refueling with %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('F');
+    borg_keypress(I2A(i));
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+
+/*
+ * Hack -- attempt to eat the given food (by sval)
+ */
+bool borg_eat_food(int sval)
+{
+    int i;
+
+    /* Look for that food */
+    i = borg_slot(TV_FOOD, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* Log the message */
+    borg_note(format("# Eating %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('E');
+    borg_keypress(I2A(i));
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Quaff a potion of cure critical wounds.  This is a special case
+ *   for several reasons.
+ *   1) it is usually the only healing potion we have on us
+ *   2) we should try to conserve a couple for when we really need them
+ *   3) if we are burning through them fast we should probably teleport out of
+ *      the fight.
+ *   4) When it is the only/best way out of danger, drink away
+  */
+bool borg_quaff_crit( bool no_check )
+{
+    static s16b when_last_quaff = 0;
+
+    if (no_check)
+    {
+        if (borg_quaff_potion(SV_POTION_CURE_CRITICAL))
+        {
+            when_last_quaff = borg_t;
+            return (TRUE);
+        }
+        return (FALSE);
+    }
+
+    /* Avoid drinking CCW twice in a row */
+    if (when_last_quaff > (borg_t-4) &&
+        when_last_quaff <= borg_t  &&
+        (rand_int(100) < 75))
+        return FALSE;
+
+    /* Save the last two for when we really need them */
+    if (borg_skill[BI_ACCW] < 2)
+        return FALSE;
+
+    if (borg_quaff_potion(SV_POTION_CURE_CRITICAL))
+    {
+        when_last_quaff = borg_t;
+        return (TRUE);
+    }
+    return (FALSE);
+}
+
+
+/*
+ * Hack -- attempt to quaff the given potion (by sval)
+ */
+bool borg_quaff_potion(int sval)
+{
+    int i;
+
+    /* Look for that potion */
+    i = borg_slot(TV_POTION, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* Log the message */
+    borg_note(format("# Quaffing %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('q');
+    borg_keypress(I2A(i));
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+/*
+ * Hack -- attempt to quaff an unknown potion
+ */
+bool borg_quaff_unknown(void)
+{
+    int i, n = -1;
+
+    /* Scan the pack */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require correct tval */
+        if (item->tval != TV_POTION) continue;
+
+        /* Skip aware items */
+        if (item->kind) continue;
+
+        /* Save this item */
+        n = i;
+    }
+
+
+    /* None available */
+    if (n < 0) return (FALSE);
+
+    /* Log the message */
+    borg_note(format("# Quaffing unknown potion %s.", borg_items[n].desc));
+
+    /* Perform the action */
+    borg_keypress('q');
+    borg_keypress(I2A(n));
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Hack -- attempt to read an unknown scroll
+ */
+bool borg_read_unknown(void)
+{
+    int i, n = -1;
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+    /* Scan the pack */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require correct tval */
+        if (item->tval != TV_SCROLL) continue;
+
+        /* Skip aware items */
+        if (item->kind) continue;
+
+        /* Save this item */
+        n = i;
+    }
+
+
+    /* None available */
+    if (n < 0) return (FALSE);
+
+    /* Dark */
+    if (no_lite()) return (FALSE);
+
+    /* Blind or Confused */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+    /* Log the message */
+    borg_note(format("# Reading unknown scroll %s.", borg_items[n].desc));
+
+    /* Perform the action */
+    borg_keypress('r');
+    borg_keypress(I2A(n));
+
+	/* Incase it is ID scroll, ESCAPE out. */
+    borg_keypress(ESCAPE);
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Hack -- attempt to eat an unknown potion.  This is done in emergencies.
+ */
+bool borg_eat_unknown(void)
+{
+    int i, n = -1;
+
+    /* Scan the pack */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require correct tval */
+        if (item->tval != TV_FOOD) continue;
+
+        /* Skip aware items */
+        if (item->kind) continue;
+
+        /* Save this item */
+        n = i;
+    }
+
+
+    /* None available */
+    if (n < 0) return (FALSE);
+
+    /* Log the message */
+    borg_note(format("# Eating unknown mushroom %s.", borg_items[n].desc));
+
+    /* Perform the action */
+    borg_keypress('E');
+    borg_keypress(I2A(n));
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Hack -- attempt to use an unknown staff.  This is done in emergencies.
+ */
+bool borg_use_unknown(void)
+{
+    int i, n = -1;
+
+    /* Scan the pack */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require correct tval */
+        if (item->tval != TV_STAFF) continue;
+
+        /* Skip aware items */
+        if (item->kind) continue;
+
+        /* Save this item */
+        n = i;
+    }
+
+
+    /* None available */
+    if (n < 0) return (FALSE);
+
+    /* Log the message */
+    borg_note(format("# Using unknown Staff %s.", borg_items[n].desc));
+
+    /* Perform the action */
+    borg_keypress('u');
+    borg_keypress(I2A(n));
+
+	/* Incase it is ID staff, ESCAPE out. */
+    borg_keypress(ESCAPE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Hack -- attempt to read the given scroll (by sval)
+ */
+bool borg_read_scroll(int sval)
+{
+    int i;
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+    /* Dark */
+    if (no_lite()) return (FALSE);
+
+    /* Blind or Confused */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+    /* Look for that scroll */
+    i = borg_slot(TV_SCROLL, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* Log the message */
+    borg_note(format("# Reading %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+    borg_keypress('r');
+    borg_keypress(I2A(i));
+
+    /* Hack -- Clear "shop" goals */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Hack -- checks rod (by sval) and
+ * make a fail check on it.
+ */
+bool borg_equips_rod(int sval)
+{
+    int i, chance, lev;
+
+    /* Look for that staff */
+    i = borg_slot(TV_ROD, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* No charges */
+    if (!borg_items[i].pval) return (FALSE);
+
+    /* Extract the item level */
+    lev = (borg_items[i].level);
+
+    /* Base chance of success */
+    chance = borg_skill[BI_DEV];
+
+    /* Confusion hurts skill */
+    if (borg_skill[BI_ISCONFUSED]) chance = chance / 2;
+
+    /* High level objects are harder */
+    chance = chance - ((lev > 50) ? 50 : lev);
+
+    /* Roll for usage */
+    if (chance < USE_DEVICE*2) return (FALSE);
+
+    /* Yep we got one */
+    return (TRUE);
+}
+
+
+
+/*
+ * Hack -- attempt to zap the given (charged) rod (by sval)
+ */
+bool borg_zap_rod(int sval)
+{
+    int i, lev, chance;
+
+    /* Look for that rod */
+    i = borg_slot(TV_ROD, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* Hack -- Still charging */
+    if (!borg_items[i].pval) return (FALSE);
+
+    /* Extract the item level */
+    lev = (borg_items[i].level);
+
+    /* Base chance of success */
+    chance = borg_skill[BI_DEV];
+
+    /* Confusion hurts skill */
+    if (borg_skill[BI_ISCONFUSED]) chance = chance / 2;
+
+    /* High level objects are harder */
+    chance = chance - ((lev > 50) ? 50 : lev);
+
+    /* Roll for usage */
+    if (sval != SV_ROD_RECALL)
+    {
+		if (chance < USE_DEVICE+2) return (FALSE);
+	}
+
+    /* Log the message */
+    borg_note(format("# Zapping %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('z');
+    borg_keypress(I2A(i));
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Hack -- attempt to aim the given (charged) wand (by sval)
+ */
+bool borg_aim_wand(int sval)
+{
+    int i;
+
+    /* Look for that wand */
+    i = borg_slot(TV_WAND, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* No charges */
+    if (!borg_items[i].pval) return (FALSE);
+
+    /* record the address to avoid certain bugs with inscriptions&amnesia */
+    zap_slot = i;
+
+    /* Log the message */
+    borg_note(format("# Aiming %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('a');
+    borg_keypress(I2A(i));
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Hack -- attempt to use the given (charged) staff (by sval)
+ */
+bool borg_use_staff(int sval)
+{
+    int i;
+
+    /* Look for that staff */
+    i = borg_slot(TV_STAFF, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* No charges */
+    if (!borg_items[i].pval) return (FALSE);
+
+    /* record the address to avoid certain bugs with inscriptions&amnesia */
+    zap_slot = i;
+
+    /* Log the message */
+    borg_note(format("# Using %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('u');
+    borg_keypress(I2A(i));
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Hack -- attempt to use the given (charged) staff (by sval) and
+ * make a fail check on it.
+ */
+bool borg_use_staff_fail(int sval)
+{
+    int i, chance, lev;
+
+    /* Look for that staff */
+    i = borg_slot(TV_STAFF, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* No charges */
+    if (!borg_items[i].pval) return (FALSE);
+
+    /* Extract the item level */
+    lev = (borg_items[i].level);
+
+    /* Base chance of success */
+    chance = borg_skill[BI_DEV];
+
+    /* Confusion hurts skill */
+    if (borg_skill[BI_ISCONFUSED]) chance = chance / 2;
+
+    /* High level objects are harder */
+    chance = chance - ((lev > 50) ? 50 : lev);
+
+    /* Roll for usage, but if its a Teleport be generous. */
+    if (chance < USE_DEVICE*2)
+    {
+        if (sval != SV_STAFF_TELEPORTATION)
+        {
+            return (FALSE);
+        }
+
+        /* We need to give some "desparation attempt to teleport staff" */
+        if (!borg_skill[BI_ISCONFUSED] && !borg_skill[BI_ISBLIND]) /* Dark? */
+        {
+            /* We really have no chance, return false, attempt the scroll */
+            if (chance < USE_DEVICE) return (FALSE);
+        }
+        /* We might have a slight chance, or we cannot not read */
+    }
+
+
+    /* record the address to avoid certain bugs with inscriptions&amnesia */
+    zap_slot = i;
+
+    /* Log the message */
+    borg_note(format("# Using %s.", borg_items[i].desc));
+
+    /* Perform the action */
+    borg_keypress('u');
+    borg_keypress(I2A(i));
+
+    /* Success */
+    return (TRUE);
+}
+/*
+ * Hack -- checks staff (by sval) and
+ * make a fail check on it.
+ */
+bool borg_equips_staff_fail(int sval)
+{
+    int i, chance, lev;
+
+    /* Look for that staff */
+    i = borg_slot(TV_STAFF, sval);
+
+    /* None available */
+    if (i < 0) return (FALSE);
+
+    /* No charges */
+    if (!borg_items[i].pval) return (FALSE);
+
+    /* Extract the item level */
+    lev = (borg_items[i].level);
+
+    /* Base chance of success */
+    chance = borg_skill[BI_DEV];
+
+    /* Confusion hurts skill */
+    if (borg_skill[BI_ISCONFUSED]) chance = chance / 2;
+
+    /* High level objects are harder */
+    chance = chance - ((lev > 50) ? 50 : lev);
+
+    /* Roll for usage, but if its a Teleport be generous. */
+    if (chance < USE_DEVICE*2)
+    {
+        if (sval != SV_STAFF_TELEPORTATION && sval !=SV_STAFF_DESTRUCTION)
+        {
+            return (FALSE);
+        }
+
+        /* We need to give some "desparation attempt to teleport staff" */
+        if (!borg_skill[BI_ISCONFUSED])
+        {
+            /* We really have no chance, return false, attempt the scroll */
+            if (chance < USE_DEVICE) return (FALSE);
+        }
+
+        /* We might have a slight chance, continue on */
+    }
+
+    /* Yep we got one */
+    return (TRUE);
+}
+
+
+
+/*
+ * Hack -- attempt to use the given artifact (by index)
+ */
+bool borg_activate_artifact(int activation, int location)
+{
+    int i;
+
+    /* Check the equipment */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        borg_item *item = &borg_items[i];
+		artifact_type *a_ptr;
+
+		/* Skip non artifacts */
+        if (!artifact_p(item)) continue;
+
+		/* Skip artifacts w/o activation */
+        if (!(item->flags3 & TR3_ACTIVATE)) continue;
+
+		/* get the item */
+		a_ptr = &a_info[item->name1];
+
+		/* Skip wrong activation */
+		if (a_ptr->activation != activation) continue;
+
+        /* Check charge */
+        if (item->timeout) continue;
+
+        /*
+         * Random Artifact must be *ID* to know the activation power.
+         * The borg will cheat with random artifacts to know if the
+         * artifact number is activatable, but artifact names and
+         * types will be scrambled.  So he must first *ID* the artifact
+         * he must play with the artifact to learn its power, just as
+         * he plays with magic to gain experience.  But I am not about
+         * to undertake that coding.  He needs to *ID* it anyway to learn
+         * of the resists that go with the artifact.
+         * Lights dont need *id* just regular id.
+         */
+        if  ((birth_rand_artifacts || adult_rand_artifacts) && (item->activation != ACT_ILLUMINATION &&
+              item->activation != ACT_MAGIC_MAP &&
+              item->activation != ACT_CLAIRVOYANCE) &&
+             (!item->fully_identified))
+        {
+            borg_note(format("# %s must be *ID*'d before activation.", item->desc));
+            return (FALSE);
+        }
+
+        /* Log the message */
+        borg_note(format("# Activating artifact %s.", item->desc));
+
+        /* Perform the action */
+        borg_keypress('A');
+        borg_keypress(I2A(i - INVEN_WIELD));
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Oops */
+    return (FALSE);
+}
+
+
+/*
+ * apw Hack -- check and see if borg is wielding an artifact
+ */
+bool borg_equips_artifact(int activation, int location)
+{
+    int i;
+
+    /* Check the equipment */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        borg_item *item = &borg_items[i];
+		artifact_type *a_ptr;
+
+		/* Skip non artifacts */
+        if (!artifact_p(item)) continue;
+
+		/* Skip artifacts w/o activation */
+        if (!(item->flags3 & TR3_ACTIVATE)) continue;
+
+		/* get the item */
+		a_ptr = &a_info[item->name1];
+
+		/* Skip wrong activation */
+		if (a_ptr->activation != activation) continue;
+
+        /* Check charge.  But not on certain ones  Wor, ID, phase, TELEPORT.*/
+        /* this is to ensure that his borg_prep code is working ok */
+        if ((activation != ACT_WOR &&
+             activation != ACT_IDENTIFY &&
+             activation != ACT_PHASE &&
+             activation != ACT_TELEPORT) &&
+           (item->timeout >= 1) ) continue;
+
+        /*
+         * Random Artifact must be *ID* to know the activation power.
+         * The borg will cheat with random artifacts to know if the
+         * artifact number is activatable, but artifact names and
+         * types will be scrambled.  So he must first *ID* the artifact
+         * he must play with the artifact to learn its power, just as
+         * he plays with magic to gain experience.  But I am not about
+         * to undertake that coding.  He needs to *ID* it anyway to learn
+         * of the resists that go with the artifact.
+         * Lights dont need *id* just regular id.
+         */
+        if  ((birth_rand_artifacts || adult_rand_artifacts) && (item->activation != ACT_ILLUMINATION &&
+              item->activation != ACT_MAGIC_MAP &&
+              item->activation != ACT_CLAIRVOYANCE) &&
+             (!item->fully_identified))
+        {
+            borg_note(format("# %s must be *ID*'d before activation.", item->desc));
+            return (FALSE);
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* I do not have it or it is not charged */
+    return (FALSE);
+}
+
+/*
+ * Hack -- check and see if borg is wielding a dragon armor and if
+ * he will pass a fail check.
+ */
+bool borg_equips_dragon(int drag_sval)
+{
+    int lev, chance;
+
+       /* Check the equipment */
+       borg_item *item = &borg_items[INVEN_BODY];
+
+        /* Skip incorrect armours */
+        if (item->tval !=TV_DRAG_ARMOR) return (FALSE);
+        if (item->sval != drag_sval) return (FALSE);
+
+        /* Check charge */
+        if (item->timeout) return (FALSE);
+
+        /* apw Make Sure Mail is IDed */
+        if (!item->able) return (FALSE);
+
+       /* check on fail rate
+        * The fail check is automatic for dragon armor.  It is an attack
+        * item.  He should not sit around failing 5 or 6 times in a row.
+        * he should attempt to activate it, and if he is likely to fail, then
+        * eh should look at a different attack option.  We are assuming
+        * that the fail rate is about 50%.  So He may still try to activate it
+        * and fail.  But he will not even try if he has negative chance or
+        * less than twice the USE_DEVICE variable
+        */
+       /* Extract the item level */
+       lev = borg_items[INVEN_BODY].level;
+
+        /* Base chance of success */
+        chance = borg_skill[BI_DEV];
+
+        /* Confusion hurts skill */
+        if (borg_skill[BI_ISCONFUSED]) chance = chance / 2;
+
+        /* High level objects are harder */
+        chance = chance - ((lev > 50) ? 50 : lev);
+
+        /* Roll for usage */
+        if (chance < (USE_DEVICE*2)) return (FALSE);
+
+        /* Success */
+        return (TRUE);
+
+}
+
+/*
+ * apw Hack -- attempt to use the given dragon armour
+ */
+bool borg_activate_dragon(int drag_sval)
+{
+
+    /* Check the equipment */
+
+      borg_item *item = &borg_items[INVEN_BODY];
+
+        /* Skip incorrect mails */
+        if (item->tval != TV_DRAG_ARMOR) return (FALSE);
+        if (item->sval != drag_sval) return (FALSE);
+
+        /* Check charge */
+        if (item->timeout) return (FALSE);
+
+        /* apw Make Sure Mail is IDed */
+        if (!item->able) return (FALSE);
+
+        /* Log the message */
+        borg_note(format("# Activating dragon scale %s.", item->desc));
+
+        /* Perform the action */
+        borg_keypress('A');
+        borg_keypress(I2A(INVEN_BODY - INVEN_WIELD));
+
+        /* Success */
+        return (TRUE);
+}
+
+/*
+ * Hack -- check and see if borg is wielding a ring and if
+ * he will pass a fail check.
+ */
+bool borg_equips_ring(int ring_sval)
+{
+    int lev, chance, i;
+
+    for (i = INVEN_LEFT; i < INVEN_RIGHT; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip incorrect armours */
+        if (item->tval !=TV_RING) continue;
+        if (item->sval != ring_sval) continue;
+
+        /* Check charge */
+        if (item->timeout) continue;
+
+        /* apw Make Sure is IDed */
+        if (!item->able) continue;
+
+       /* check on fail rate
+        */
+
+       /* Extract the item level */
+       lev = borg_items[i].level;
+
+        /* Base chance of success */
+        chance = borg_skill[BI_DEV];
+
+        /* Confusion hurts skill */
+        if (borg_skill[BI_ISCONFUSED]) chance = chance / 2;
+
+        /* High level objects are harder */
+        chance = chance - ((lev > 50) ? 50 : lev);
+
+        /* Roll for usage */
+        if (chance < (USE_DEVICE*2)) continue;
+
+        /* Success */
+        return (TRUE);
+	}
+
+	return (FALSE);
+
+}
+
+/*
+ * apw Hack -- attempt to use the given ring
+ */
+bool borg_activate_ring(int ring_sval)
+{
+
+	int i;
+
+    /* Check the equipment */
+    for (i = INVEN_LEFT; i < INVEN_RIGHT; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip incorrect mails */
+        if (item->tval != TV_RING) continue;
+        if (item->sval != ring_sval) continue;
+
+        /* Check charge */
+        if (item->timeout) continue;
+
+        /* apw Make Sure item is IDed */
+        if (!item->able) continue;
+
+        /* Log the message */
+        borg_note(format("# Activating ring %s.", item->desc));
+
+        /* Perform the action */
+        borg_keypress('A');
+        borg_keypress(I2A(i - INVEN_WIELD));
+
+        /* Success */
+        return (TRUE);
+	}
+
+	return (FALSE);
+}
+
+/*
+ * Determine if borg can cast a given spell (when fully rested)
+ */
+bool borg_spell_legal(int book, int what)
+{
+    borg_magic *as = &borg_magics[book][what];
+
+    /* The borg must be able to "cast" spells */
+    if (cp_ptr->spell_book != TV_MAGIC_BOOK) return (FALSE);
+
+    /* The book must be possessed */
+    if (amt_book[book] <= 0) return (FALSE);
+
+    /* The spell must be "known" */
+    if (as->status < BORG_MAGIC_TEST) return (FALSE);
+
+    /* The spell must be affordable (when rested) */
+    if (as->power > borg_skill[BI_MAXSP]) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Determine if borg can cast a given spell (right now)
+ */
+bool borg_spell_okay(int book, int what)
+{
+    int reserve_mana = 0;
+
+    borg_magic *as = &borg_magics[book][what];
+
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+    /* Dark */
+    if (no_lite()) return (FALSE);
+
+    /* Define reserve_mana for each class */
+    if (borg_class == CLASS_MAGE) reserve_mana = 6;
+    if (borg_class == CLASS_RANGER) reserve_mana = 22;
+    if (borg_class == CLASS_ROGUE) reserve_mana = 20;
+
+    /* Low level spell casters should not worry about this */
+    if (borg_skill[BI_CLEVEL] < 35) reserve_mana = 0;
+
+    /* Require ability (when rested) */
+    if (!borg_spell_legal(book, what)) return (FALSE);
+
+    /* Hack -- blind/confused */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+
+    /* The spell must be affordable (now) */
+    if (as->power > borg_skill[BI_CURSP]) return (FALSE);
+
+    /* Do not cut into reserve mana (for final teleport) */
+    if (borg_skill[BI_CURSP] - as->power < reserve_mana)
+    {
+        /* Phase spells ok */
+        if (book == 0 && what == 2) return (TRUE);
+
+        /* Teleport spells ok */
+        if (book == 1 && what == 5) return (TRUE);
+
+        /* Satisfy Hunger OK */
+        if (book == 2 && what == 0) return (TRUE);
+
+		/* Magic Missile OK */
+        if (book == 0 && what == 0 && borg_skill[BI_CDEPTH] <= 35) return (TRUE);
+
+        /* others are rejected */
+        return (FALSE);
+    }
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * fail rate on a spell
+ */
+int borg_spell_fail_rate(int book, int what)
+{
+    int     chance, minfail;
+    borg_magic *as = &borg_magics[book][what];
+
+    /* Access the spell  */
+    chance = as->sfail;
+
+    /* Reduce failure rate by "effective" level adjustment */
+    chance -= 3 * (borg_skill[BI_CLEVEL] - as->level);
+
+    /* Reduce failure rate by INT/WIS adjustment */
+    chance -= 3 * (adj_mag_stat[my_stat_ind[A_INT]] - 1);
+
+    /* Extract the minimum failure rate */
+    minfail = adj_mag_fail[my_stat_ind[A_INT]];
+
+    /* Non mage characters never get too good */
+    if (!cp_ptr->flags & CF_ZERO_FAIL)
+    {
+        if (minfail < 5) minfail = 5;
+    }
+
+    /* Minimum failure rate */
+    if (chance < minfail) chance = minfail;
+
+    /* Stunning makes spells harder */
+    if (borg_skill[BI_ISHEAVYSTUN]) chance += 25;
+    if (borg_skill[BI_ISSTUN]) chance += 15;
+
+    /* Always a 5 percent chance of working */
+    if (chance > 95) chance = 95;
+
+    /* Return the chance */
+    return (chance);
+
+
+}
+
+/*
+ * same as borg_spell_okay with a fail % check
+ */
+bool borg_spell_okay_fail(int book, int what, int allow_fail )
+{
+    if (borg_spell_fail_rate(book, what) > allow_fail)
+        return FALSE;
+    return borg_spell_okay( book, what );
+}
+
+/*
+ * Same as borg_spell with a fail % check
+ */
+bool borg_spell_fail(int book, int what, int allow_fail)
+{
+    if (borg_spell_fail_rate(book, what) > allow_fail)
+        return FALSE;
+    return borg_spell( book, what );
+}
+
+/*
+ * Same as borg_spell_legal with a fail % check
+ */
+bool borg_spell_legal_fail(int book, int what, int allow_fail)
+{
+    if (borg_spell_fail_rate(book, what) > allow_fail)
+        return FALSE;
+    return borg_spell_legal( book, what );
+}
+
+/*
+ * Attempt to cast a spell
+ */
+bool borg_spell(int book, int what)
+{
+    int i;
+
+    borg_magic *as = &borg_magics[book][what];
+
+    /* Require ability (right now) */
+    if (!borg_spell_okay(book, what)) return (FALSE);
+
+    /* Look for the book */
+    i = borg_book[book];
+
+    /* Paranoia */
+    if (i < 0) return (FALSE);
+
+    /* Debugging Info */
+    borg_note(format("# Casting %s (%d,%d).", as->name, book, what));
+
+    /* Cast a spell */
+    borg_keypress('m');
+    borg_keypress(I2A(i));
+    borg_keypress(I2A(what));
+
+    /* increment the spell counter */
+    as->times ++;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Determine if borg can pray a given prayer (when fully rested)
+ */
+bool borg_prayer_legal(int book, int what)
+{
+    borg_magic *as = &borg_magics[book][what];
+
+    /* The borg must be able to "pray" prayers */
+    if (cp_ptr->spell_book != TV_PRAYER_BOOK) return (FALSE);
+
+    /* Look for the book */
+    if (amt_book[book] <= 0) return (FALSE);
+
+    /* The prayer must be "known" */
+    if (as->status < BORG_MAGIC_TEST) return (FALSE);
+
+    /* The prayer must be affordable (when fully rested) */
+    if (as->power > borg_skill[BI_MAXSP]) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Determine if borg can pray a given prayer (right now)
+ */
+bool borg_prayer_okay(int book, int what)
+{
+    int reserve_mana =0;
+
+    borg_magic *as = &borg_magics[book][what];
+
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+    /* Dark */
+    if (no_lite()) return (FALSE);
+
+    /* define reserve_mana */
+    if (borg_class == CLASS_PRIEST) reserve_mana = 8;
+    if (borg_class == CLASS_PALADIN) reserve_mana = 20;
+
+    /* Low level spell casters should not worry about this */
+    if (borg_skill[BI_CLEVEL] < 35) reserve_mana = 0;
+
+    /* Require ability (when rested) */
+    if (!borg_prayer_legal(book, what)) return (FALSE);
+
+    /* Hack -- blind/confused */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+    /* The prayer must be affordable (right now) */
+    if (as->power > borg_skill[BI_CURSP]) return (FALSE);
+
+    /* Do not cut into reserve mana (for final teleport) */
+    if (borg_skill[BI_CURSP] - as->power < reserve_mana)
+    {
+        /* Phase spells ok */
+        if (book == 1 && what == 1) return (TRUE);
+        if (book == 4 && what == 0) return (TRUE);
+
+        /* Teleport spells ok */
+        if (book == 4 && what == 1) return (TRUE);
+
+        /* Satisfy Hunger spells ok */
+        if (book == 1 && what == 5) return (TRUE);
+
+        /* others are rejected */
+        return (FALSE);
+    }
+
+    /* Success */
+    return (TRUE);
+}
+
+int borg_prayer_fail_rate(int book, int what)
+{
+    int     chance, minfail;
+    borg_magic *as = &borg_magics[book][what];
+
+    /* Access the spell  */
+    chance = as->sfail;
+
+    /* Reduce failure rate by "effective" level adjustment */
+    chance -= 3 * (borg_skill[BI_CLEVEL] - as->level);
+
+    /* Reduce failure rate by INT/WIS adjustment */
+    chance -= 3 * (adj_mag_stat[my_stat_ind[A_WIS]] - 1);
+
+    /* Extract the minimum failure rate */
+    minfail = adj_mag_fail[my_stat_ind[A_WIS]];
+
+    /* Non priest characters never get too good */
+    if (!cp_ptr->flags & CF_ZERO_FAIL)
+    {
+        if (minfail < 5) minfail = 5;
+    }
+
+    /* APW Hack -- Priest prayer penalty for "edged" weapons  -DGK */
+    if (cp_ptr->flags & CF_BLESS_WEAPON)
+    {
+        borg_item       *item;
+
+        item = &borg_items[INVEN_WIELD];
+
+        /* Penalize non-blessed edged weapons */
+        if (((item->tval == TV_SWORD) || (item->tval == TV_POLEARM)) &&
+            (!(item->flags3 & TR3_BLESSED)))
+        {
+            chance += 25;
+        }
+    }
+    /* Minimum failure rate */
+    if (chance < minfail) chance = minfail;
+
+    /* Stunning makes spells harder */
+    if (borg_skill[BI_ISHEAVYSTUN]) chance += 25;
+    if (borg_skill[BI_ISSTUN]) chance += 15;
+
+    /* Always a 5 percent chance of working */
+    if (chance > 95) chance = 95;
+
+    /* Return the chance */
+    return (chance);
+
+
+}
+
+
+/*
+ * same as borg_prayer_okay with a fail % check
+ */
+bool borg_prayer_okay_fail(int book, int what, int allow_fail )
+{
+    if (borg_prayer_fail_rate(book, what) > allow_fail)
+        return FALSE;
+    return borg_prayer_okay( book, what );
+}
+
+/*
+ * Same as borg_prayer with a fail % check
+ */
+bool borg_prayer_fail(int book, int what, int allow_fail)
+{
+    if (borg_prayer_fail_rate(book, what) > allow_fail)
+        return FALSE;
+    return borg_prayer( book, what );
+}
+
+/*
+ * Same as borg_prayer_legal with a fail % check
+ */
+bool borg_prayer_legal_fail(int book, int what, int allow_fail)
+{
+    if (borg_prayer_fail_rate(book, what) > allow_fail)
+        return FALSE;
+    return borg_prayer_legal( book, what );
+}
+
+/*
+ * Attempt to pray a prayer
+ */
+bool borg_prayer(int book, int what)
+{
+    int i;
+
+    borg_magic *as = &borg_magics[book][what];
+
+    /* Require ability (right now) */
+    if (!borg_prayer_okay(book, what)) return (FALSE);
+
+    /* Look for the book */
+    i = borg_book[book];
+
+    /* Paranoia */
+    if (i < 0) return (FALSE);
+
+    /* Debugging Info */
+    borg_note(format("# Praying %s (%d,%d).", as->name, book, what));
+
+    /* Pray a prayer */
+    borg_keypress('p');
+    borg_keypress(I2A(i));
+    borg_keypress(I2A(what));
+
+    /* Because we have no launch message to indicate failure */
+    if (book ==3 && what ==4)
+    {
+        borg_casted_glyph = TRUE;
+    }
+    else
+    {
+        borg_casted_glyph = FALSE;
+    }
+
+    /* increment the spell counter */
+    as->times ++;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Inscribe food and Slime Molds
+ */
+extern bool borg_inscribe_food(void)
+{
+    int ii;
+    char name[80];
+
+    for (ii=0; ii < INVEN_TOTAL; ii++)
+    {
+        borg_item *item = &borg_items[ii];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require correct tval */
+        if (item->tval != TV_FOOD) continue;
+
+        /* skip things already inscribed */
+        if (!(streq(item->note, "")) &&
+            !(streq(item->note, "{ }"))) continue;
+
+        /* inscribe foods and molds */
+        if (item->sval == SV_FOOD_SLIME_MOLD || item->sval == SV_FOOD_RATION)
+        {
+
+            if (item->sval == SV_FOOD_RATION)
+            {
+                /* get a name */
+                strcpy(name, food_syllable1[rand_int(sizeof(food_syllable1) / sizeof(char*))]);
+                strcat(name, food_syllable2[rand_int(sizeof(food_syllable2) / sizeof(char*))]);
+
+                borg_send_inscribe(ii, name);
+                return (TRUE);
+            }
+
+            if (item->sval == SV_FOOD_SLIME_MOLD)
+            {
+                /* get a name */
+                strcpy(name, mold_syllable1[rand_int(sizeof(mold_syllable1) / sizeof(char*))]);
+                strcat(name, mold_syllable2[rand_int(sizeof(mold_syllable2) / sizeof(char*))]);
+                strcat(name, mold_syllable3[rand_int(sizeof(mold_syllable3) / sizeof(char*))]);
+
+                borg_send_inscribe(ii, name);
+                return (TRUE);
+            }
+
+        }
+    }
+
+    /* all done */
+    return (FALSE);
+}
+/*
+ * Send a command to de-inscribe item number "i" .
+ */
+void borg_send_deinscribe(int i)
+{
+
+    /* Ok to inscribe Slime Molds */
+    if (borg_items[i].tval == TV_FOOD &&
+        borg_items[i].sval == SV_FOOD_SLIME_MOLD) return;
+
+    /* Label it */
+    borg_keypress('}');
+
+    /* Choose from inventory */
+    if (i < INVEN_WIELD)
+    {
+        /* Choose the item */
+        borg_keypress(I2A(i));
+    }
+
+    /* Choose from equipment */
+    else
+    {
+        /* Go to equipment (if necessary) */
+        if (borg_items[0].iqty) borg_keypress('/');
+
+        /* Choose the item */
+        borg_keypress(I2A(i - INVEN_WIELD));
+    }
+
+}
+
+/*
+ * Cheat the "equip" screen
+ */
+void borg_cheat_equip(void)
+{
+    int i;
+
+    char buf[256];
+
+    /* Extract the equipment */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+		/* skip non items */
+		if (!inventory[i].k_idx)
+		{
+			/* Be sure to wipe it from the borg equip */
+			WIPE(&borg_items[i], borg_item);
+		}
+
+        /* Default to "nothing" */
+        buf[0] = '\0';
+
+        /* Describe a real item */
+        if (inventory[i].k_idx)
+        {
+            /* Describe it */
+            object_desc(buf, sizeof(buf), &inventory[i], TRUE, 3);
+        }
+
+        /* Ignore "unchanged" items */
+        if (!streq(buf, borg_items[i].desc) || !borg_items[i].able)
+        {
+
+	        /* Analyze the item (no price) */
+	        borg_item_analyze(&borg_items[i], buf);
+
+	        /* get the fully id stuff */
+	        if (inventory[i].ident & IDENT_MENTAL)
+	        {
+	            borg_items[i].fully_identified = TRUE;
+	            borg_items[i].needs_I = FALSE;
+	            borg_do_star_id = TRUE;
+	        }
+		}
+    }
+}
+
+
+/*
+ * Cheat the "inven" screen
+ */
+void borg_cheat_inven(void)
+{
+    int i;
+
+    char buf[256];
+
+    /* Extract the current weight */
+    borg_cur_wgt = p_ptr->total_weight;
+
+    /* Extract the inventory */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+		/* Skip non-items */
+		if (!inventory[i].k_idx)
+		{
+			/* Wipe from borg lists */
+			WIPE(&borg_items[i], borg_item);
+		}
+
+        /* Default to "nothing" */
+        buf[0] = '\0';
+
+        /* Describe it */
+        object_desc(buf, sizeof(buf), &inventory[i], TRUE, 3);
+
+        /* Ignore "unchanged" items */
+        if (!streq(buf, borg_items[i].desc) || !borg_items[i].able)
+		{
+        	/* inventory changed so goals must change. */
+        	/* goal_shop = goal_ware = goal_item = -1; */
+
+        	/* Analyze the item (no price) */
+        	borg_item_analyze(&borg_items[i], buf);
+
+        	/* get the fully id stuff */
+        	if (inventory[i].ident & IDENT_MENTAL)
+        	{
+        	    borg_items[i].fully_identified = TRUE;
+        	    borg_items[i].needs_I = FALSE;
+        	    borg_do_star_id = TRUE;
+        	}
+
+        	/* Note changed inventory */
+        	borg_do_crush_junk = TRUE;
+        	borg_do_crush_hole = TRUE;
+        	borg_do_crush_slow = TRUE;
+    	}
+	}
+}
+
+#ifndef BORG_TK
+/*
+ * Parse the "equip" screen
+ */
+void borg_parse_equip(void)
+{
+    int i;
+
+    int row, col;
+
+    bool done = FALSE;
+
+    byte t_a;
+
+    char buf[160];
+
+
+    /* Find the column */
+    for (col = 0; col < 55; col++)
+    {
+        /* Look for first prefix */
+        if ((0 == borg_what_text(col, 1, 3, &t_a, buf)) &&
+            (buf[0] == I2A(0)) && (buf[1] == p2) && (buf[2] == ' '))
+        {
+            break;
+        }
+    }
+
+    /* Extract the inventory */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        /* Access the row */
+        row = i - INVEN_WIELD;
+
+        /* Attempt to get some text */
+        if (!done &&
+            (0 == borg_what_text(col, row+1, 3, &t_a, buf)) &&
+            (buf[0] == I2A(row)) && (buf[1] == p2) && (buf[2] == ' ') &&
+            (0 == borg_what_text(col+3, row+1, -80, &t_a, buf)) &&
+            (buf[0] && (buf[0] != ' ')))
+        {
+            int k;
+
+            /* Strip trailing spaces */
+            for (k = strlen(buf); (k > 0) && (buf[k-1] == ' '); k--) /* loop */;
+            buf[k] = '\0';
+        }
+
+        /* Default to "nothing" */
+        else
+        {
+            buf[0] = '\0';
+            done = TRUE;
+        }
+
+        /* Notice empty slots */
+        if (streq(buf, "(nothing)")) strcpy(buf, "");
+
+        /* Ignore "unchanged" items */
+        if (streq(buf, borg_items[i].desc) && borg_skill[BI_CDEPTH]) continue;
+
+        /* Analyze the item (no price) */
+        borg_item_analyze(&borg_items[i], buf);
+
+        /* get the fully *id* stuff */
+        if (inventory[i].ident & IDENT_MENTAL)
+        {
+            borg_items[i].fully_identified = TRUE;
+            borg_items[i].needs_I = FALSE;
+            borg_do_star_id = TRUE;
+        }
+
+    }
+}
+
+
+/*
+ * Parse the "inven" screen
+ */
+void borg_parse_inven(void)
+{
+    int i;
+
+    int row, col;
+
+    int w1a, w1b;
+
+    bool done = FALSE;
+
+    byte t_a;
+
+    char buf[160];
+
+
+    /* XXX XXX XXX */
+    /* Hack -- Parse the current total weight */
+    if ((0 == borg_what_text(0, 0, -80, &t_a, buf)) &&
+        (sscanf(buf, "Inventory (carrying %d.%d pounds)",
+                &w1a, &w1b) == 2))
+    {
+        /* Save the current weight */
+        borg_cur_wgt = w1a * 10 + w1b;
+    }
+
+
+    /* Find the column */
+    for (col = 0; col < 55; col++)
+    {
+        /* Look for first prefix */
+        if ((0 == borg_what_text(col, 1, 3, &t_a, buf)) &&
+            (buf[0] == I2A(0)) && (buf[1] == p2) && (buf[2] == ' '))
+        {
+            break;
+        }
+    }
+
+    /* Extract the inventory */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        /* Access the row */
+        row = i;
+
+        /* Attempt to get some text */
+        if (!done &&
+            (0 == borg_what_text(col, row+1, 3, &t_a, buf)) &&
+            (buf[0] == I2A(row)) && (buf[1] == p2) && (buf[2] == ' ') &&
+            (0 == borg_what_text(col+3, row+1, -80, &t_a, buf)) &&
+            (buf[0] && (buf[0] != ' ')))
+        {
+            int k;
+
+            /* Strip trailing spaces */
+            for (k = strlen(buf); (k > 0) && (buf[k-1] == ' '); k--) /* loop */;
+            buf[k] = '\0';
+        }
+
+        /* Default to "nothing" */
+        else
+        {
+            buf[0] = '\0';
+            done = TRUE;
+        }
+
+        /* Notice empty slots */
+        if (streq(buf, "(nothing)")) strcpy(buf, "");
+
+        /* Ignore "unchanged" items */
+        if (streq(buf, borg_items[i].desc)) continue;
+
+        /* Analyze the item (no price) */
+        borg_item_analyze(&borg_items[i], buf);
+
+        /* get the fully id stuff */
+        if (inventory[i].ident & IDENT_MENTAL)
+        {
+            borg_items[i].fully_identified = TRUE;
+            borg_items[i].needs_I = FALSE;
+            borg_do_star_id = TRUE;
+        }
+
+        /* Note changed inventory */
+        borg_do_crush_junk = TRUE;
+        borg_do_crush_hole = TRUE;
+        borg_do_crush_slow = TRUE;
+    }
+}
+
+
+#endif /* not BORG_TK */
+
+/*
+ * Hack -- Cheat the "spell" info
+ *
+ * Hack -- note the use of the "cheat" field for efficiency
+ */
+void borg_cheat_spell(int book)
+{
+    int what;
+
+
+    /* Can we use spells/prayers? */
+    if (!cp_ptr->spell_book) return;
+
+
+    /* Process the spells */
+    for (what = 0; what < 9; what++)
+    {
+        /* Access the spell */
+        borg_magic *as = &borg_magics[book][what];
+
+        /* Skip illegible spells */
+        if (as->status == BORG_MAGIC_ICKY) continue;
+
+        /* Note "forgotten" spells */
+        if (p_ptr->spell_flags[as->cheat] & PY_SPELL_FORGOTTEN)
+        {
+            /* Forgotten */
+            as->status = BORG_MAGIC_LOST;
+        }
+
+        /* Note "difficult" spells */
+        else if (borg_skill[BI_CLEVEL] < as->level)
+        {
+            /* Unknown */
+            as->status = BORG_MAGIC_HIGH;
+        }
+
+        /* Note "Unknown" spells */
+        else if (!(p_ptr->spell_flags[as->cheat] & PY_SPELL_LEARNED))
+        {
+            /* UnKnown */
+            as->status = BORG_MAGIC_OKAY;
+        }
+
+        /* Note "untried" spells */
+        else if (!(p_ptr->spell_flags[as->cheat] & PY_SPELL_WORKED))
+        {
+            /* Untried */
+            as->status = BORG_MAGIC_TEST;
+        }
+
+        /* Note "known" spells */
+        else
+        {
+            /* Known */
+            as->status = BORG_MAGIC_KNOW;
+        }
+    }
+}
+
+
+#ifndef BORG_TK
+/*
+ * Hack -- Parse the "spell" info (given the book)
+ */
+void borg_parse_spell(int book)
+{
+    int what;
+
+    byte t_a;
+
+    char buf[160];
+
+
+    /* Can we use spells/prayers? */
+    if (!cp_ptr->spell_book) return;
+
+
+    /* Process the spells */
+    for (what = 0; what < 9; what++)
+    {
+        int row = ROW_SPELL + 1 + what;
+        int col = COL_SPELL;
+
+        /* Access the spell */
+        borg_magic *as = &borg_magics[book][what];
+
+        /* Skip illegible spells */
+        if (as->status == BORG_MAGIC_ICKY) continue;
+
+#if 0
+        /* Format: "spell-name...................." at col 20+5 */
+        if (0 != borg_what_text(col-30, row, -30, &t_a, buf)) continue;
+#endif
+
+        /* Format: "Lv Mana Freq Comment" at col 20+35 */
+        if (0 != borg_what_text(col, row, -20, &t_a, buf)) continue;
+
+        /* Note "forgotten" spells */
+        if (prefix(buf + 13, "forgott"))
+        {
+            /* Forgotten */
+            as->status = BORG_MAGIC_LOST;
+        }
+
+        /* Note "difficult" spells */
+        else if (borg_skill[BI_CLEVEL] < as->level)
+        {
+            /* Unknown */
+            as->status = BORG_MAGIC_HIGH;
+        }
+
+        /* Note "unknown" spells */
+        else if (prefix(buf + 13, "unknown"))
+        {
+            /* Unknown */
+            as->status = BORG_MAGIC_OKAY;
+        }
+
+        /* Note "untried" spells */
+        else if (prefix(buf + 13, "untried"))
+        {
+            /* Untried */
+            as->status = BORG_MAGIC_TEST;
+        }
+
+        /* Note "known" spells */
+        else
+        {
+            /* Known */
+            as->status = BORG_MAGIC_KNOW;
+        }
+    }
+}
+
+#endif /* not BORG_TK */
+
+
+
+/*
+ * Prepare a book
+ */
+static void prepare_book_info(void)
+{
+    int what;
+
+    int book;
+
+    int index;
+
+    /* Reset each spell entry */
+    for (book = 0; book < 9; book++)
+    {
+        for (what = 0; what < 9; what++)
+        {
+            borg_magic *as = &borg_magics[book][what];
+
+            /* Assume no name */
+            as->name = NULL;
+
+            /* Assume illegible */
+            as->status = BORG_MAGIC_ICKY;
+
+            /* Assume illegible */
+            as->method = BORG_MAGIC_ICK;
+
+            /* Impossible values */
+            as->level = 99;
+            as->power = 99;
+
+            /* Impossible value */
+            as->cheat = 99;
+        }
+    }
+
+    /* Can we use spells/prayers? */
+    if (!cp_ptr->spell_book) return;
+
+    /* define the spell type */
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+    {
+        /* Mage book */
+        index = 0;
+    }
+    else
+    {
+        /* Priest */
+        index = 1;
+    }
+
+    /* Process each existing spell */
+    for (book = 0; book < 9; book++)
+    {
+        for (what = 0; what < 9; what++)
+        {
+            borg_magic *as = &borg_magics[book][what];
+
+            const magic_type *spell_ptr;
+
+            /* access the game index */
+            spell_ptr = &mp_ptr->info[borg_magic_index[index][book][what]];
+
+            /* Save the spell index */
+            as->cheat = borg_magic_index[index][book][what];
+
+            /* Hack -- assume excessive level */
+            as->status = BORG_MAGIC_HIGH;
+
+            /* Access the correct "method" */
+            as->method = borg_magic_method[index][book][what];
+
+            /* Access the correct "rating" */
+            as->rating = borg_magic_rating[index][book][what];
+
+            /* Save the spell name */
+            as->name = borg_magic_name[index][book][what];
+
+            /* Skip blank ones */
+            if (as->cheat == 99) continue;
+
+            /* Save the spell level */
+            as->level = spell_ptr->slevel;
+            /* Save the spell mana */
+            as->power = spell_ptr->smana;
+            /* Save the spell fail ratename */
+            as->sfail = spell_ptr->sfail;
+        }
+
+    }
+
+}
+
+
+
+/*
+ * Hack -- prepare some stuff based on the player race and class
+ */
+void prepare_race_class_info(void)
+{
+    /* Initialize the various spell arrays by book */
+    prepare_book_info();
+}
+
+
+void borg_clear_3(void)
+{
+    FREE(borg_items);
+    FREE(borg_shops);
+    FREE(safe_items);
+    FREE(safe_home);
+    FREE(safe_shops);
+    FREE(borg_plural_text);
+    FREE(borg_sv_plural_text);
+    FREE(borg_plural_what);
+    FREE(borg_single_text);
+    FREE(borg_single_what);
+    FREE(borg_artego_text);
+    FREE(borg_sv_art_text);
+    FREE(borg_artego_what);
+}
+
+/*
+ * Initialize this file
+ *
+ * Note that all six artifact "Rings" will parse as "kind 506"
+ * (the first artifact ring) and both artifact "Amulets" will
+ * parse as "kind 503" (the first of the two artifact amulets),
+ * but as long as we use the "name1" field (and not the "kind"
+ * or "sval" fields) we should be okay.
+ *
+ * We sort the two arrays of items names in reverse order, so that
+ * we will catch "mace of disruption" before "mace", "Scythe of
+ * Slicing" before "Scythe", and for "Ring of XXX" before "Ring".
+ *
+ * Note that we do not have to parse "plural artifacts" (!)
+ *
+ * Hack -- This entire routine is a giant hack, but it works
+ */
+void borg_init_3(void)
+{
+    int i, k, n;
+
+    int size;
+
+    s16b what[514];
+    cptr text[514];
+
+    char buf[256];
+
+
+    /*** Item/Ware arrays ***/
+
+    /* Make the inventory array */
+    C_MAKE(borg_items, INVEN_TOTAL, borg_item);
+
+    /* Make the stores in the town */
+    C_MAKE(borg_shops, 9, borg_shop);
+
+
+    /*** Item/Ware arrays (simulation) ***/
+
+    /* Make the "safe" inventory array */
+    C_MAKE(safe_items, INVEN_TOTAL, borg_item);
+    C_MAKE(safe_home,  STORE_INVEN_MAX, borg_item);
+
+    /* Make the "safe" stores in the town */
+    C_MAKE(safe_shops, 8, borg_shop);
+
+    /*** Plural Object Templates ***/
+
+    /* Start with no objects */
+    size = 0;
+
+    /* Analyze some "item kinds" */
+    for (k = 1; k < z_info->k_max; k++)
+    {
+        object_type hack;
+
+        /* Get the kind */
+        object_kind *k_ptr = &k_info[k];
+
+        /* Skip "empty" items */
+        if (!k_ptr->name) continue;
+
+        /* Skip "gold" objects */
+        if (k_ptr->tval == TV_GOLD) continue;
+
+        /* Skip "artifacts" */
+        if (k_ptr->flags3 & TR3_INSTA_ART) continue;
+
+        /* Hack -- make an item */
+        object_prep(&hack, k);
+
+        /* Describe a "plural" object */
+        hack.number = 2;
+        object_desc_spoil(buf, sizeof(buf), &hack, FALSE, 0);
+
+        /* Save an entry */
+        text[size] = string_make(buf);
+        what[size] = k;
+
+        size++;
+
+    }
+
+    /* Set the sort hooks */
+    borg_sort_comp = borg_sort_comp_hook;
+    borg_sort_swap = borg_sort_swap_hook;
+    /* Sort */
+       borg_sort(text, what, size);
+
+    C_MAKE(borg_sv_plural_text, z_info->k_max, cptr);
+    for (i = 0; i < size; i++) borg_sv_plural_text[what[i]] = text[i];
+
+
+    /* Save the size */
+    borg_plural_size = size;
+
+    /* Allocate the "item parsing arrays" (plurals) */
+    C_MAKE(borg_plural_text, borg_plural_size, cptr);
+    C_MAKE(borg_plural_what, borg_plural_size, s16b);
+
+    /* Save the entries */
+    for (i = 0; i < size; i++) borg_plural_text[i] = text[i];
+    for (i = 0; i < size; i++) borg_plural_what[i] = what[i];
+
+
+    /*** Singular Object Templates ***/
+
+    /* Start with no objects */
+    size = 0;
+
+    /* Analyze some "item kinds" */
+    for (k = 1; k < z_info->k_max; k++)
+    {
+        object_type hack;
+
+        /* Get the kind */
+        object_kind *k_ptr = &k_info[k];
+
+        /* Skip "empty" items */
+        if (!k_ptr->name) continue;
+
+        /* Skip "dungeon terrain" objects */
+        if (k_ptr->tval == TV_GOLD) continue;
+
+        /* Skip "artifacts" */
+        if (k_ptr->flags3 & TR3_INSTA_ART) continue;
+
+        /* Hack -- make an item */
+        object_prep(&hack, k);
+
+        /* Describe a "singular" object */
+        hack.number = 1;
+        object_desc_spoil(buf, sizeof(buf), &hack, FALSE, 0);
+
+        /* Save an entry */
+        text[size] = string_make(buf);
+        what[size] = k;
+        size++;
+    }
+
+    /* Analyze the "INSTA_ART" items */
+    for (i = 1; i < z_info->a_max; i++)
+    {
+        object_type hack;
+
+        artifact_type *a_ptr = &a_info[i];
+
+        cptr name = (a_name + a_ptr->name);
+
+        /* Skip "empty" items */
+        if (!a_ptr->name) continue;
+
+		/* Hack-- to handle bug in 301 code.
+		 * In the object.txt file, the new artifacts (jewel,
+		 * elfstones) have the INSTA_ART flag, but the flag is
+		 * not listed in the artifact.txt file.  Because of this,
+		 * these 2 items will be skipped over by the borg.
+		 * Remove this hack and restore the bypass below when
+		 * the bug in the artifact.txt file is fixed.
+		 */
+        if ((!(a_ptr->flags3 & TR3_INSTA_ART)) &&
+            (i != 14 && /* elfstone */
+             i != 15))  /* Jewel */
+        	continue;
+#if 0  /* Remove this bypass when bug is fixed in artifact.txt */
+        /* Skip non INSTA_ART things */
+        if (!(a_ptr->flags3 & TR3_INSTA_ART)) continue;
+#endif
+        /* Extract the "kind" */
+        k = lookup_kind(a_ptr->tval, a_ptr->sval);
+
+        /* Hack -- make an item */
+        object_prep(&hack, k);
+
+        /* Save the index */
+        hack.name1 = i;
+
+        /* Describe a "singular" object */
+        hack.number = 1;
+        object_desc_spoil(buf, sizeof(buf), &hack, FALSE, 0);
+
+        /* Extract the "suffix" length */
+        n = strlen(name) + 1;
+
+        /* Remove the "suffix" */
+        buf[strlen(buf) - n] = '\0';
+
+        /* Save an entry */
+        text[size] = string_make(buf);
+        what[size] = k;
+        size++;
+    }
+
+    /* Set the sort hooks */
+    borg_sort_comp = borg_sort_comp_hook;
+    borg_sort_swap = borg_sort_swap_hook;
+    /* Sort */
+    borg_sort(text, what, size);
+
+
+    /* Save the size */
+    borg_single_size = size;
+
+    /* Allocate the "item parsing arrays" (plurals) */
+    C_MAKE(borg_single_text, borg_single_size, cptr);
+    C_MAKE(borg_single_what, borg_single_size, s16b);
+
+    /* Save the entries */
+    for (i = 0; i < size; i++) borg_single_text[i] = text[i];
+    for (i = 0; i < size; i++) borg_single_what[i] = what[i];
+
+
+    /*** Artifact and Ego-Item Parsers ***/
+
+    /* No entries yet */
+    size = 0;
+
+    /* Collect the "artifact names" */
+    for (k = 1; k < z_info->a_max; k++)
+    {
+        artifact_type *a_ptr = &a_info[k];
+
+        /* Skip non-items */
+        if (!a_ptr->name) continue;
+
+        /* Extract a string */
+        sprintf(buf, " %s", (a_name + a_ptr->name));
+
+        /* Save an entry */
+        text[size] = string_make(buf);
+        what[size] = k;
+        size++;
+    }
+
+    C_MAKE(borg_sv_art_text, z_info->a_max, cptr);
+    for (i = 0; i < size; i++) borg_sv_art_text[what[i]] = text[i];
+
+    /* Collect the "ego-item names" */
+    for (k = 1; k < z_info->e_max; k++)
+    {
+        ego_item_type *e_ptr = &e_info[k];
+
+        /* Skip non-items */
+        if (!e_ptr->name) continue;
+
+        /* Extract a string */
+        sprintf(buf, " %s", (e_name + e_ptr->name));
+
+        /* Save an entry */
+        text[size] = string_make(buf);
+        what[size] = k + 256;
+        size++;
+    }
+    /* Set the sort hooks */
+    borg_sort_comp = borg_sort_comp_hook;
+    borg_sort_swap = borg_sort_swap_hook;
+
+    /* Sort */
+    borg_sort(text, what, size);
+
+    /* Save the size */
+    borg_artego_size = size;
+
+    /* Allocate the "item parsing arrays" (plurals) */
+    C_MAKE(borg_artego_text, borg_artego_size, cptr);
+    C_MAKE(borg_artego_what, borg_artego_size, s16b);
+
+    /* Save the entries */
+    for (i = 0; i < size; i++) borg_artego_text[i] = text[i];
+    for (i = 0; i < size; i++) borg_artego_what[i] = what[i];
+}
+
+cptr borg_prt_item(int item)
+{
+            if (item < z_info->k_max)
+            {
+                return borg_sv_plural_text[item];
+            }
+            if (item < z_info->k_max + z_info->k_max)
+                return borg_sv_plural_text[item - z_info->k_max];
+            if (item < z_info->k_max + z_info->k_max + z_info->a_max)
+                return borg_sv_art_text[item - z_info->k_max - z_info->k_max];
+            return (prefix_pref[item -
+                                z_info->k_max -
+                                z_info->k_max -
+                                z_info->a_max]);
+
+}
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg3.h angband-3.0.6-borg/src/borg3.h
--- angband-3.0.6/src/borg3.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg3.h	2004-10-05 21:11:40.000000000 -0700
@@ -0,0 +1,327 @@
+/* File: borg3.h */
+/* Purpose: Header file for "borg3.c" -BEN- */
+
+#ifndef INCLUDED_BORG3_H
+#define INCLUDED_BORG3_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg3.c".
+ */
+
+#include "borg1.h"
+
+
+extern void apw(void);
+
+/*
+ * Hack -- location of the "Lv Mana Fail" prompt
+ */
+#define ROW_SPELL   1
+#define COL_SPELL   20+35
+
+
+
+
+/*
+ * Forward declare
+ */
+typedef struct borg_item borg_item;
+typedef struct borg_shop borg_shop;
+
+extern bool (*borg_sort_comp)(void* u, void* v, int a, int b);
+extern void (*borg_sort_swap)(void* u, void* v, int a, int b);
+extern bool borg_sort_comp_hook(void* u, void* v, int a, int b);
+extern void borg_sort_swap_hook(void* u, void* v, int a, int b);
+extern void borg_sort_aux(void* u, void* v, int p, int q);
+extern void borg_sort(void* u, void* v, int n);
+
+/*
+ * A structure holding information about an object.  120 bytes.
+ *
+ * The "iqty" is zero if the object is "missing"
+ * The "kind" is zero if the object is "unaware" (or missing)
+ * The "able" is zero if the object is "unknown" (or unaware or missing)
+ *
+ * Note that unaware items will have a "tval" but an invalid "sval".
+ */
+struct borg_item
+{
+    char desc[80];  /* Actual Description */
+
+    cptr note;      /* Pointer to tail of 'desc' */
+
+    s16b kind;      /* Kind index */
+
+    bool able;      /* True if item is identified */
+
+    bool fully_identified; /* True if item is fully identified (AJG) */
+
+    bool needs_I;   /* True if item needs to be 'I'd (AJG) */
+
+    bool xxxx;      /* Unused */
+
+    byte tval;      /* Item type */
+    byte sval;      /* Item sub-type */
+    s16b pval;      /* Item extra-info */
+
+    byte discount;  /* Discount */
+
+    byte iqty;      /* Number of items */
+
+    s16b weight;    /* Probable weight */
+
+    byte name1;     /* Artifact index (if any) */
+    byte name2;     /* Ego-item index (if any) */
+	byte activation; /* Artifact activation */
+
+    s16b timeout;   /* Timeout counter */
+
+    s16b to_h;      /* Bonus to hit */
+    s16b to_d;      /* Bonus to dam */
+    s16b to_a;      /* Bonus to ac */
+    s16b ac;        /* Armor class */
+    byte dd;        /* Damage dice */
+    byte ds;        /* Damage sides */
+
+    byte level;     /* Level apw */
+
+    s32b cost;      /* Cost (in stores) */
+
+    s32b value;     /* Value (estimated) */
+
+    bool cursed;    /* Item is cursed */
+    u32b flags1;    /* Extracted item flags (set 1) */
+    u32b flags2;    /* Extracted item flags (set 2) */
+    u32b flags3;    /* Extracted item flags (set 3) */
+};
+
+
+/*
+ * A store
+ */
+struct borg_shop
+{
+    s16b when;      /* Time stamp */
+
+    s16b xtra;      /* Something unused */
+
+    s16b page;      /* Current page */
+    s16b more;      /* Number of pages */
+
+    borg_item ware[24]; /* Store contents */
+};
+
+
+
+/*
+ * Spell method values
+ */
+
+#define BORG_MAGIC_ICK      0   /* Spell is illegible */
+#define BORG_MAGIC_NOP      1   /* Spell takes no arguments */
+#define BORG_MAGIC_EXT      2   /* Spell has "detection" effects */
+#define BORG_MAGIC_AIM      3   /* Spell requires a direction */
+#define BORG_MAGIC_OBJ      4   /* Spell requires a pack object */
+#define BORG_MAGIC_WHO      5   /* Spell requires a monster symbol */
+
+
+/*
+ * Spell status values
+ */
+
+#define BORG_MAGIC_ICKY     0   /* Spell is illegible */
+#define BORG_MAGIC_LOST     1   /* Spell is forgotten */
+#define BORG_MAGIC_HIGH     2   /* Spell is high level */
+#define BORG_MAGIC_OKAY     3   /* Spell is learnable */
+#define BORG_MAGIC_TEST     4   /* Spell is untried */
+#define BORG_MAGIC_KNOW     5   /* Spell is known */
+
+
+/*
+ * Forward declare
+ */
+typedef struct borg_magic borg_magic;
+
+
+/*
+ * A spell/prayer in a book
+ */
+struct borg_magic
+{
+    cptr name;      /* Textual name */
+
+    byte status;    /* Status (see above) */
+
+    byte method;    /* Method (see above) */
+
+    byte rating;    /* Usefulness */
+
+    byte level;     /* Required level */
+
+    byte power;     /* Required power */
+
+    byte sfail;     /* Minimum chance of failure */
+
+    byte cheat;     /* Actual "spell index" (or 99) */
+
+    s32b times;     /* Times this spell was cast */
+};
+
+
+
+/*
+ * Some variables
+ */
+
+extern borg_item *borg_items;       /* Current "inventory" */
+
+extern borg_shop *borg_shops;       /* Current "shops" */
+
+
+/*
+ * Safety arrays for simulating possible worlds
+ */
+
+extern borg_item *safe_items;       /* Safety "inventory" */
+extern borg_item *safe_home;        /* Safety "home" */
+
+extern borg_shop *safe_shops;       /* Safety "shops" */
+
+
+/*
+ * Spell casting information
+ */
+
+extern borg_magic borg_magics[9][9];    /* Spell info */
+
+
+
+
+/*
+ * Determine which slot an item could be wielded into
+ */
+extern int borg_wield_slot(borg_item *item);
+
+/*
+ * Analyze an item, given a textual description
+ */
+extern void borg_item_analyze(borg_item *item, cptr desc);
+
+
+/* look for a *id*'d item */
+extern bool borg_object_star_id( void );
+
+/* look for a *id*'d item */
+extern bool borg_object_star_id_aux(borg_item *borg_item, object_type *real_item);
+
+/*
+ * Inscribe an object
+ */
+extern void borg_send_inscribe(int i, cptr str);
+extern void borg_send_deinscribe(int i);
+
+/*
+ * Count the items of a given tval/sval
+ */
+extern int borg_count(int tval, int sval);
+
+/*
+ * Find an item with a given tval/sval
+ */
+extern int borg_slot(int tval, int sval);
+
+/*
+ * Item usage functions
+ */
+extern bool borg_refuel_torch(void);
+extern bool borg_refuel_lantern(void);
+
+/*
+ * Item usage functions (by sval)
+ */
+extern bool borg_eat_food(int sval);
+extern bool borg_quaff_crit( bool no_check );
+extern bool borg_quaff_potion(int sval);
+extern bool borg_eat_unknown(void);
+extern bool borg_use_unknown(void);
+extern bool borg_quaff_unknown(void);
+extern bool borg_read_unknown(void);
+extern bool borg_read_scroll(int sval);
+extern bool borg_equips_rod(int sval);
+extern bool borg_zap_rod(int sval);
+extern bool borg_aim_wand(int sval);
+extern bool borg_use_staff(int sval);
+extern bool borg_use_staff_fail(int sval);
+extern bool borg_equips_staff_fail(int sval);
+extern bool borg_inscribe_food(void);
+
+/*
+ * Artifact usage function (by index)
+ */
+extern bool borg_activate_artifact(int activation, int location); /* apw */
+extern bool borg_equips_artifact(int activation, int location);  /* apw */
+extern bool borg_activate_dragon(int drag_sval); /* apw */
+extern bool borg_equips_dragon(int drag_sval);  /* apw */
+extern bool borg_activate_ring(int ring_sval); /* apw */
+extern bool borg_equips_ring(int ring_sval);  /* apw */
+
+
+/*
+ * Spell functions
+ */
+extern bool borg_spell_legal(int book, int what);
+extern bool borg_spell_okay(int book, int what);
+extern bool borg_spell(int book, int what);
+extern bool borg_spell_fail(int book, int what, int allow_fail);
+extern bool borg_spell_okay_fail(int book, int what, int allow_fail );
+extern bool borg_spell_legal_fail(int book, int what, int allow_fail );
+extern int borg_spell_fail_rate(int book, int what);
+extern int borg_prayer_fail_rate(int book, int what);
+
+/*
+ * Prayer functions
+ */
+extern bool borg_prayer_legal(int book, int what);
+extern bool borg_prayer_okay(int book, int what);
+extern bool borg_prayer(int book, int what);
+extern bool borg_prayer_fail(int book, int what, int allow_fail);
+extern bool borg_prayer_okay_fail(int book, int what, int allow_fail );
+extern bool borg_prayer_legal_fail(int book, int what, int allow_fail );
+
+
+
+/*
+ * Cheat/Parse the "equip" and "inven" screens.
+ */
+extern void borg_cheat_equip(void);
+extern void borg_cheat_inven(void);
+extern void borg_parse_equip(void);
+extern void borg_parse_inven(void);
+
+/*
+ * Cheat/Parse the "spell" screen
+ */
+extern void borg_cheat_spell(int book);
+extern void borg_parse_spell(int book);
+
+/*
+ * Hack -- prepare stuff based on the race/class
+ */
+extern void prepare_race_class_info(void);
+
+extern void borg_clear_3(void);
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_3(void);
+
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg4.c angband-3.0.6-borg/src/borg4.c
--- angband-3.0.6/src/borg4.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg4.c	2005-10-26 16:45:42.000000000 -0700
@@ -0,0 +1,9336 @@
+/* File: borg4.c */
+/*  Purpose: Notice and Power code for the Borg -BEN- */
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg4.h"
+
+
+
+/*
+ * Note that we assume that any item with quantity zero does not exist,
+ * thus, when simulating possible worlds, we do not actually have to
+ * "optimize" empty slots.
+ *
+ * XXX XXX XXX Also, we could reward equipment based on possible enchantment,
+ * up to the maximal amount available in the home, which would induce item
+ * switching when the item could be enchanted sufficiently.
+ */
+
+
+/*
+ * The "notice" functions examine various aspects of the player inventory,
+ * the player equipment, or the home contents, and extract various numerical
+ * quantities based on those aspects, adjusting them for various "abilities",
+ * such as the ability to cast certain spells, etc.
+ *
+ * The "power" functions use the numerical quantities described above, and
+ * use them to do two different things:  (1) rank the "value" of having
+ * various abilities relative to the possible "money" reward of carrying
+ * sellable items instead, and (2) rank the value of various abilities
+ * relative to each other, which is used to determine what to wear/buy,
+ * and in what order to wear/buy those items.
+ *
+ * These functions use some very heuristic values, by the way...
+ *
+ * We should probably take account of things like possible enchanting
+ * (especially when in town), and items which may be found soon.
+ *
+ * We consider several things:
+ *   (1) the actual "power" of the current weapon and bow
+ *   (2) the various "flags" imparted by the equipment
+ *   (3) the various abilities imparted by the equipment
+ *   (4) the penalties induced by heavy armor or gloves or edged weapons
+ *   (5) the abilities required to enter the "max_depth" dungeon level
+ *   (6) the various abilities of some useful inventory items
+ *
+ * Note the use of special "item counters" for evaluating the value of
+ * a collection of items of the given type.  Basically, the first item
+ * of the given type is always the most valuable, with subsequent items
+ * being worth less, until the "limit" is reached, after which point any
+ * extra items are only worth as much as they can be sold for.
+ */
+
+
+
+/*
+ * Helper function -- notice the player equipment
+ */
+static void borg_notice_aux1(void)
+{
+    int         i, hold;
+
+    int         extra_blows = 0;
+
+    int         extra_shots = 0;
+    int         extra_might = 0;
+    int         my_num_fire;
+
+    borg_item       *item;
+
+    u32b f1, f2, f3;
+
+
+    /* Recalc some Variables */
+    borg_skill[BI_ARMOR] = 0;
+    borg_skill[BI_SPEED] = 110;
+
+    /* Start with a single blow per turn */
+    borg_skill[BI_BLOWS] = 1;
+
+    /* Start with a single shot per turn */
+    my_num_fire = 1;
+
+    /* Reset the "ammo" tval */
+    my_ammo_tval = -1;
+
+    /* Reset the "ammo" sides for darts*/
+    my_ammo_sides = 4;
+
+    /* Reset the shooting power */
+    my_ammo_power = 0;
+
+    /* Reset the shooting range */
+    my_ammo_range = 0;
+
+    /* Base infravision (purely racial) */
+    borg_skill[BI_INFRA] = rb_ptr->infra;
+
+    /* Base skill -- disarming */
+    borg_skill[BI_DIS] = rb_ptr->r_dis + cb_ptr->c_dis;
+
+    /* Base skill -- magic devices */
+    borg_skill[BI_DEV] = rb_ptr->r_dev + cb_ptr->c_dev;
+
+    /* Base skill -- saving throw */
+    borg_skill[BI_SAV] = rb_ptr->r_sav + cb_ptr->c_sav;
+
+    /* Base skill -- stealth */
+    borg_skill[BI_STL] = rb_ptr->r_stl + cb_ptr->c_stl;
+
+    /* Base skill -- searching ability */
+    borg_skill[BI_SRCH] = rb_ptr->r_srh + cb_ptr->c_srh;
+
+    /* Base skill -- searching frequency */
+    borg_skill[BI_SRCHFREQ] = rb_ptr->r_fos + cb_ptr->c_fos;
+
+    /* Base skill -- combat (normal) */
+    borg_skill[BI_THN] = rb_ptr->r_thn + cb_ptr->c_thn;
+
+    /* Base skill -- combat (shooting) */
+    borg_skill[BI_THB] = rb_ptr->r_thb + cb_ptr->c_thb;
+
+    /* Base skill -- combat (throwing) */
+    borg_skill[BI_THT] = rb_ptr->r_thb + cb_ptr->c_thb;
+
+    /** Racial Skills **/
+
+    /* Extract the player flags */
+    player_flags(&f1, &f2, &f3);
+
+    /* Good flags */
+    if (f3 & (TR3_SLOW_DIGEST)) borg_skill[BI_SDIG] = TRUE;
+    if (f3 & (TR3_FEATHER)) borg_skill[BI_FEATH] = TRUE;
+    if (f3 & (TR3_LITE)) borg_skill[BI_LITE] ++;
+    if (f3 & (TR3_REGEN)) borg_skill[BI_REG] = TRUE;
+    if (f3 & (TR3_TELEPATHY)) borg_skill[BI_ESP] = TRUE;
+    if (f3 & (TR3_SEE_INVIS)) borg_skill[BI_SINV] = TRUE;
+    if (f3 & (TR3_FREE_ACT)) borg_skill[BI_FRACT] = TRUE;
+    if (f3 & (TR3_HOLD_LIFE)) borg_skill[BI_HLIFE] = TRUE;
+
+    /* Weird flags */
+
+    /* Bad flags */
+    if (f3 & (TR3_IMPACT)) borg_skill[BI_W_IMPACT] = TRUE;
+    if (f3 & (TR3_AGGRAVATE)) borg_skill[BI_CRSAGRV] = TRUE;
+    if (f3 & (TR3_TELEPORT)) borg_skill[BI_CRSTELE] = TRUE;
+
+    /* Immunity flags */
+    if (f2 & (TR2_IM_FIRE)) borg_skill[BI_IFIRE] = TRUE;
+    if (f2 & (TR2_IM_ACID)) borg_skill[BI_IACID] = TRUE;
+    if (f2 & (TR2_IM_COLD)) borg_skill[BI_ICOLD] = TRUE;
+    if (f2 & (TR2_IM_ELEC)) borg_skill[BI_IELEC] = TRUE;
+
+    /* Resistance flags */
+    if (f2 & (TR2_RES_ACID)) borg_skill[BI_RACID] = TRUE;
+    if (f2 & (TR2_RES_ELEC)) borg_skill[BI_RELEC] = TRUE;
+    if (f2 & (TR2_RES_FIRE)) borg_skill[BI_RFIRE] = TRUE;
+    if (f2 & (TR2_RES_COLD)) borg_skill[BI_RCOLD] = TRUE;
+    if (f2 & (TR2_RES_POIS)) borg_skill[BI_RPOIS] = TRUE;
+    if (f2 & (TR2_RES_FEAR)) borg_skill[BI_RFEAR] = TRUE;
+    if (f2 & (TR2_RES_LITE)) borg_skill[BI_RLITE] = TRUE;
+    if (f2 & (TR2_RES_DARK)) borg_skill[BI_RDARK] = TRUE;
+    if (f2 & (TR2_RES_BLIND)) borg_skill[BI_RBLIND] = TRUE;
+    if (f2 & (TR2_RES_CONFU)) borg_skill[BI_RCONF] = TRUE;
+    if (f2 & (TR2_RES_SOUND)) borg_skill[BI_RSND] = TRUE;
+    if (f2 & (TR2_RES_SHARD)) borg_skill[BI_RSHRD] = TRUE;
+    if (f2 & (TR2_RES_NEXUS)) borg_skill[BI_RNXUS] = TRUE;
+    if (f2 & (TR2_RES_NETHR)) borg_skill[BI_RNTHR] = TRUE;
+    if (f2 & (TR2_RES_CHAOS)) borg_skill[BI_RKAOS] = TRUE;
+    if (f2 & (TR2_RES_DISEN)) borg_skill[BI_RDIS] = TRUE;
+
+    /* Sustain flags */
+    if (f2 & (TR2_SUST_STR)) borg_skill[BI_SSTR] = TRUE;
+    if (f2 & (TR2_SUST_INT)) borg_skill[BI_SINT] = TRUE;
+    if (f2 & (TR2_SUST_WIS)) borg_skill[BI_SWIS] = TRUE;
+    if (f2 & (TR2_SUST_DEX)) borg_skill[BI_SDEX] = TRUE;
+    if (f2 & (TR2_SUST_CON)) borg_skill[BI_SCON] = TRUE;
+    if (f2 & (TR2_SUST_CHR)) borg_skill[BI_SCHR] = TRUE;
+
+	/* I am pretty sure the CF_flags will be caught by the
+	 * code above when the player flags are checked
+	 */
+
+    /* Clear the stat modifiers */
+    for (i = 0; i < 6; i++) my_stat_add[i] = 0;
+
+    /* Scan the usable inventory */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* track number of items the borg has on him */
+        /* Count up how many artifacts the borg has on him */
+        borg_has_on[item->kind] += item->iqty;
+        if (item->name1)
+            borg_artifact[item->name1] += item->iqty;
+
+        /* Affect stats */
+        if (item->flags1 & TR1_STR) my_stat_add[A_STR] += item->pval;
+        if (item->flags1 & TR1_INT) my_stat_add[A_INT] += item->pval;
+        if (item->flags1 & TR1_WIS) my_stat_add[A_WIS] += item->pval;
+        if (item->flags1 & TR1_DEX) my_stat_add[A_DEX] += item->pval;
+        if (item->flags1 & TR1_CON) my_stat_add[A_CON] += item->pval;
+        if (item->flags1 & TR1_CHR) my_stat_add[A_CHR] += item->pval;
+
+        /* various slays */
+        if (item->flags1 & TR1_SLAY_ANIMAL) borg_skill[BI_WS_ANIMAL] = TRUE;
+        if (item->flags1 & TR1_SLAY_EVIL)   borg_skill[BI_WS_EVIL] = TRUE;
+        if (item->flags1 & TR1_SLAY_UNDEAD) borg_skill[BI_WS_UNDEAD] = TRUE;
+        if (item->flags1 & TR1_SLAY_DEMON)  borg_skill[BI_WS_DEMON] = TRUE;
+        if (item->flags1 & TR1_SLAY_ORC)    borg_skill[BI_WS_ORC] = TRUE;
+        if (item->flags1 & TR1_SLAY_TROLL)  borg_skill[BI_WS_TROLL] = TRUE;
+        if (item->flags1 & TR1_SLAY_GIANT)  borg_skill[BI_WS_GIANT] = TRUE;
+        if (item->flags1 & TR1_SLAY_DRAGON) borg_skill[BI_WS_DRAGON] = TRUE;
+        if (item->flags1 & TR1_KILL_UNDEAD) borg_skill[BI_WK_UNDEAD] = TRUE;
+        if (item->flags1 & TR1_KILL_DEMON)  borg_skill[BI_WK_DEMON] = TRUE;
+        if (item->flags1 & TR1_KILL_DRAGON) borg_skill[BI_WK_DRAGON] = TRUE;
+        if (item->flags3 & TR3_IMPACT)      borg_skill[BI_W_IMPACT] = TRUE;
+        if (item->flags1 & TR1_BRAND_ACID)  borg_skill[BI_WB_ACID] = TRUE;
+        if (item->flags1 & TR1_BRAND_ELEC)  borg_skill[BI_WB_ELEC] = TRUE;
+        if (item->flags1 & TR1_BRAND_FIRE)  borg_skill[BI_WB_FIRE] = TRUE;
+        if (item->flags1 & TR1_BRAND_COLD)  borg_skill[BI_WB_COLD] = TRUE;
+        if (item->flags1 & TR1_BRAND_POIS)  borg_skill[BI_WB_POIS] = TRUE;
+
+        /* Affect infravision */
+        if (item->flags1 & TR1_INFRA) borg_skill[BI_INFRA] += item->pval;
+
+        /* Affect stealth */
+        if (item->flags1 & TR1_STEALTH) borg_skill[BI_STL] += item->pval;
+
+        /* Affect searching ability (factor of five) */
+        if (item->flags1 & TR1_SEARCH) borg_skill[BI_SRCH] += (item->pval * 5);
+
+        /* Affect searching frequency (factor of five) */
+        if (item->flags1 & TR1_SEARCH) borg_skill[BI_SRCHFREQ] += (item->pval * 5);
+
+        /* Affect digging (factor of 20) */
+        if (item->flags1 & TR1_TUNNEL) borg_skill[BI_DIG] += (item->pval * 20);
+
+        /* Affect speed */
+        if (item->flags1 & TR1_SPEED) borg_skill[BI_SPEED] += item->pval;
+
+        /* Affect blows */
+        if (item->flags1 & TR1_BLOWS) extra_blows += item->pval;
+
+        /* Boost shots */
+        if (item->flags1 & TR1_SHOTS) extra_shots++;
+
+        /* Boost might */
+        if (item->flags1 & TR1_MIGHT) extra_might++;
+
+        /* Various flags */
+        if (item->flags3 & TR3_SLOW_DIGEST) borg_skill[BI_SDIG] = TRUE;
+        if (item->flags3 & TR3_AGGRAVATE) borg_skill[BI_CRSAGRV] = TRUE;
+        if (item->flags3 & TR3_TELEPORT) borg_skill[BI_CRSTELE] = TRUE;
+        if (item->flags3 & TR3_REGEN) borg_skill[BI_REG] = TRUE;
+        if (item->flags3 & TR3_TELEPATHY) borg_skill[BI_ESP] = TRUE;
+        if (item->flags3 & TR3_LITE) borg_skill[BI_LITE] ++;
+        if (item->flags3 & TR3_SEE_INVIS) borg_skill[BI_SINV] = TRUE;
+        if (item->flags3 & TR3_FEATHER) borg_skill[BI_FEATH] = TRUE;
+        if (item->flags3 & TR3_FREE_ACT) borg_skill[BI_FRACT] = TRUE;
+        if (item->flags3 & TR3_HOLD_LIFE) borg_skill[BI_HLIFE] = TRUE;
+
+		/* Artifact do not grant the knowlege of some flags until
+		 * after the *ID*. So we allow the borg to know that the
+		 * item does have lite
+		 */
+		if ((item->name1 >=1 && item->name1 <= 3) || /* Phial, Star, Arkenstone */
+			 item->name1 == 7 || /* Planatir */
+			 item->name1 == 14 || /* Elfstone */
+			 item->name1 == 15)  /* Jewel */
+			 borg_skill[BI_LITE] ++;
+
+        /* Immunity flags */
+        /* if you are immune you automaticly resist */
+        if (item->flags2 & TR2_IM_FIRE)
+        {
+            borg_skill[BI_IFIRE] = TRUE;
+            borg_skill[BI_RFIRE] = TRUE;
+            my_oppose_fire = TRUE;
+        }
+        if (item->flags2 & TR2_IM_ACID)
+        {
+            borg_skill[BI_IACID] = TRUE;
+            borg_skill[BI_RACID] = TRUE;
+            my_oppose_acid = TRUE;
+        }
+        if (item->flags2 & TR2_IM_COLD)
+        {
+            borg_skill[BI_ICOLD] = TRUE;
+            borg_skill[BI_RCOLD] = TRUE;
+            my_oppose_cold = TRUE;
+        }
+        if (item->flags2 & TR2_IM_ELEC)
+        {
+            borg_skill[BI_IELEC] = TRUE;
+            borg_skill[BI_RELEC] = TRUE;
+            my_oppose_elec = TRUE;
+        }
+
+        /* Resistance flags */
+        if (item->flags2 & TR2_RES_ACID) borg_skill[BI_RACID] = TRUE;
+        if (item->flags2 & TR2_RES_ELEC) borg_skill[BI_RELEC] = TRUE;
+        if (item->flags2 & TR2_RES_FIRE) borg_skill[BI_RFIRE] = TRUE;
+        if (item->flags2 & TR2_RES_COLD) borg_skill[BI_RCOLD] = TRUE;
+        if (item->flags2 & TR2_RES_POIS) borg_skill[BI_RPOIS] = TRUE;
+        if (item->flags2 & TR2_RES_CONFU) borg_skill[BI_RCONF] = TRUE;
+        if (item->flags2 & TR2_RES_SOUND) borg_skill[BI_RSND] = TRUE;
+        if (item->flags2 & TR2_RES_LITE) borg_skill[BI_RLITE] = TRUE;
+        if (item->flags2 & TR2_RES_DARK) borg_skill[BI_RDARK] = TRUE;
+        if (item->flags2 & TR2_RES_CHAOS) borg_skill[BI_RKAOS] = TRUE;
+        if (item->flags2 & TR2_RES_DISEN) borg_skill[BI_RDIS] = TRUE;
+        if (item->flags2 & TR2_RES_SHARD) borg_skill[BI_RSHRD] = TRUE;
+        if (item->flags2 & TR2_RES_NEXUS) borg_skill[BI_RNXUS] = TRUE;
+        if (item->flags2 & TR2_RES_BLIND) borg_skill[BI_RBLIND] = TRUE;
+        if (item->flags2 & TR2_RES_NETHR) borg_skill[BI_RNTHR] = TRUE;
+
+        /* Sustain flags */
+        if (item->flags2 & TR2_SUST_STR) borg_skill[BI_SSTR] = TRUE;
+        if (item->flags2 & TR2_SUST_INT) borg_skill[BI_SINT] = TRUE;
+        if (item->flags2 & TR2_SUST_WIS) borg_skill[BI_SWIS] = TRUE;
+        if (item->flags2 & TR2_SUST_DEX) borg_skill[BI_SDEX] = TRUE;
+        if (item->flags2 & TR2_SUST_CON) borg_skill[BI_SCON] = TRUE;
+        if (item->flags2 & TR2_SUST_CHR) borg_skill[BI_SCHR] = TRUE;
+
+
+        /* Hack -- The borg will miss read acid damaged items such as
+         * Leather Gloves [2,-2] and falsely assume they help his power.
+         * this hack rewrites the bonus to an extremely negative value
+         * thus encouraging him to remove the non-helpful-non-harmful but
+         * heavy-none-the-less item.
+         */
+        if ((!item->name1 && !item->name2) &&
+             item->ac >= 1 && item->to_a + item->ac <= 0)
+        {
+            item->to_a -= 10;
+        }
+
+        /* Modify the base armor class */
+        borg_skill[BI_ARMOR] += item->ac;
+
+        /* Apply the bonuses to armor class */
+        borg_skill[BI_ARMOR] += item->to_a;
+
+        /* Hack -- do not apply "weapon" bonuses */
+        if (i == INVEN_WIELD) continue;
+
+        /* Hack -- do not apply "bow" bonuses */
+        if (i == INVEN_BOW) continue;
+
+        /* Apply the bonuses to hit/damage */
+        borg_skill[BI_TOHIT] += item->to_h;
+        borg_skill[BI_TODAM] += item->to_d;
+    }
+
+    /* Update "stats" */
+    for (i = 0; i < 6; i++)
+    {
+        int add, use, ind;
+
+        add = my_stat_add[i];
+
+        if (adult_maximize)
+        {
+            /* Modify the stats for race/class */
+            add += (rp_ptr->r_adj[i] + cp_ptr->c_adj[i]);
+        }
+        /* Extract the new "use_stat" value for the stat */
+        use = modify_stat_value(my_stat_cur[i], add);
+
+        /* Save the stat */
+        my_stat_use[i] = use;
+
+        /* Values: 3, ..., 17 */
+        if (use <= 18) ind = (use - 3);
+
+        /* Ranges: 18/00-18/09, ..., 18/210-18/219 */
+        else if (use <= 18+219) ind = (15 + (use - 18) / 10);
+
+        /* Range: 18/220+ */
+        else ind = (37);
+
+        /* Save the index */
+        if (ind > 37)
+            my_stat_ind[i] = 37;
+        else
+            my_stat_ind[i] = ind;
+        borg_skill[BI_STR+i] = my_stat_ind[i];
+        borg_skill[BI_CSTR+i] = borg_stat[i];
+    }
+
+
+    /* 'Mana' is actually the 'mana adjustment' */
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+    {
+        borg_skill[BI_SP_ADJ] =
+            ((adj_mag_mana[my_stat_ind[A_WIS]] * borg_skill[BI_CLEVEL]) / 2);
+        borg_skill[BI_FAIL1] = adj_mag_stat[my_stat_ind[A_WIS]];
+        borg_skill[BI_FAIL2] = adj_mag_fail[my_stat_ind[A_WIS]];
+    }
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+    {
+        borg_skill[BI_SP_ADJ] =
+            ((adj_mag_mana[my_stat_ind[A_INT]] * borg_skill[BI_CLEVEL]) / 2);
+        borg_skill[BI_FAIL1] = adj_mag_stat[my_stat_ind[A_INT]];
+        borg_skill[BI_FAIL2] = adj_mag_fail[my_stat_ind[A_INT]];
+    }
+
+
+    /* Bloating slows the player down (a little) */
+    if (borg_skill[BI_ISGORGED]) borg_skill[BI_SPEED] -= 10;
+
+
+    /* Actual Modifier Bonuses (Un-inflate stat bonuses) */
+    borg_skill[BI_ARMOR] += ((int)(adj_dex_ta[my_stat_ind[A_DEX]]) - 128);
+    borg_skill[BI_TODAM] += ((int)(adj_str_td[my_stat_ind[A_STR]]) - 128);
+    borg_skill[BI_TOHIT] += ((int)(adj_dex_th[my_stat_ind[A_DEX]]) - 128);
+    borg_skill[BI_TOHIT] += ((int)(adj_str_th[my_stat_ind[A_STR]]) - 128);
+
+
+    /* Obtain the "hold" value */
+    hold = adj_str_hold[my_stat_ind[A_STR]];
+
+
+    /** Examine the "current bow" **/
+    item = &borg_items[INVEN_BOW];
+
+    /* attacking with bare hands */
+    if (item->iqty == 0)
+    {
+        item->ds = 0;
+        item->dd = 0;
+        item->to_d = 0;
+        item->to_h = 0;
+        item->weight = 0;
+    }
+
+	/* Real bonuses */
+    borg_skill[BI_BTOHIT] = item->to_h;
+    borg_skill[BI_BTODAM] = item->to_d;
+
+    /* It is hard to carholdry a heavy bow */
+    if (hold < item->weight / 10)
+    {
+        borg_skill[BI_HEAVYBOW] = TRUE;
+        /* Hard to wield a heavy bow */
+        borg_skill[BI_TOHIT] += 2 * (hold - item->weight / 10);
+    }
+
+    /* Compute "extra shots" if needed */
+    if (item->iqty && (hold >= item->weight / 10))
+    {
+        /* Take note of required "tval" for missiles */
+        switch (item->sval)
+        {
+            case SV_SLING:
+            my_ammo_tval = TV_SHOT;
+            my_ammo_sides = 3;
+            my_ammo_power = 2;
+            break;
+
+            case SV_SHORT_BOW:
+            my_ammo_tval = TV_ARROW;
+            my_ammo_sides = 4;
+            my_ammo_power = 2;
+            break;
+
+            case SV_LONG_BOW:
+            my_ammo_tval = TV_ARROW;
+            my_ammo_sides = 4;
+            my_ammo_power = 3;
+            break;
+
+            case SV_LIGHT_XBOW:
+            my_ammo_tval = TV_BOLT;
+            my_ammo_sides = 5;
+            my_ammo_power = 3;
+            break;
+
+            case SV_HEAVY_XBOW:
+            my_ammo_tval = TV_BOLT;
+            my_ammo_sides = 5;
+            my_ammo_power = 4;
+            break;
+        }
+
+        /* Add in extra power */
+        my_ammo_power += extra_might;
+
+        /* Calculate total range */
+        my_ammo_range = 10 + my_ammo_power * 5;
+
+        /* Hack -- Reward High Level Rangers using Bows */
+        if ((cp_ptr->flags & CF_EXTRA_SHOT) && (my_ammo_tval == TV_ARROW))
+        {
+            /* Extra shot at level 20 */
+            if (borg_skill[BI_CLEVEL] >= 20) my_num_fire++;
+
+            /* Extra shot at level 40 */
+            if (borg_skill[BI_CLEVEL] >= 40) my_num_fire++;
+        }
+
+        /* Add in the "bonus shots" */
+        my_num_fire += extra_shots;
+
+        /* Require at least one shot */
+        if (my_num_fire < 1) my_num_fire = 1;
+    }
+    borg_skill[BI_SHOTS] = my_num_fire;
+
+    /* Calculate "average" damage per "normal" shot (times 2) */
+    borg_skill[BI_BMAXDAM] = (my_ammo_sides + borg_skill[BI_BTODAM]) * my_ammo_power;
+    borg_skill[BI_BMAXDAM] *= borg_skill[BI_SHOTS];
+
+    /* Examine the "main weapon" */
+    item = &borg_items[INVEN_WIELD];
+
+    /* attacking with bare hands */
+    if (item->iqty == 0)
+    {
+        item->ds = 0;
+        item->dd = 0;
+        item->to_d = 0;
+        item->to_h = 0;
+        item->weight = 0;
+    }
+
+	/* Real values */
+    borg_skill[BI_WTOHIT] = item->to_h;
+    borg_skill[BI_WTODAM] = item->to_d;
+
+    /* It is hard to hold a heavy weapon */
+    if (hold < item->weight / 10)
+    {
+        borg_skill[BI_HEAVYWEPON] = TRUE;
+
+        /* Hard to wield a heavy weapon */
+        borg_skill[BI_TOHIT] += 2 * (hold - item->weight / 10);
+    }
+
+    /* Normal weapons */
+    if (item->iqty && (hold >= item->weight / 10))
+    {
+        int str_index, dex_index;
+        int div;
+
+        /* Enforce a minimum "weight" (tenth pounds) */
+        div = ((item->weight < cp_ptr->min_weight) ? cp_ptr->min_weight : item->weight);
+
+        /* Get the strength vs weight */
+        str_index = (adj_str_blow[my_stat_ind[A_STR]] * cp_ptr->att_multiply / div);
+
+        /* Maximal value */
+        if (str_index > 11) str_index = 11;
+
+        /* Index by dexterity */
+        dex_index = (adj_dex_blow[my_stat_ind[A_DEX]]);
+
+        /* Maximal value */
+        if (dex_index > 11) dex_index = 11;
+
+        /* Use the blows table */
+        borg_skill[BI_BLOWS] = blows_table[str_index][dex_index];
+
+        /* Maximal value */
+        if (borg_skill[BI_BLOWS] > cp_ptr->max_attacks) borg_skill[BI_BLOWS] = cp_ptr->max_attacks;
+
+        /* Add in the "bonus blows" */
+        borg_skill[BI_BLOWS] += extra_blows;
+
+        /* Require at least one blow */
+        if (borg_skill[BI_BLOWS] < 1) borg_skill[BI_BLOWS] = 1;
+
+        /* Boost digging skill by weapon weight */
+        borg_skill[BI_DIG] += (item->weight / 10);
+
+    }
+
+    /* priest weapon penalty for non-blessed edged weapons */
+    if ((cp_ptr->flags & CF_BLESS_WEAPON) &&
+        ((item->tval == TV_SWORD) || (item->tval == TV_POLEARM)) &&
+        (!(item->flags3 & TR3_BLESSED)))
+    {
+        /* Reduce the real bonuses */
+        borg_skill[BI_TOHIT] -= 2;
+        borg_skill[BI_TODAM] -= 2;
+    }
+
+    /* Calculate "max" damage per "normal" blow  */
+    /* and assume we can enchant up to +8 if borg_skill[BI_CLEVEL] > 25 */
+    borg_skill[BI_WMAXDAM] =
+        (item->dd * item->ds + borg_skill[BI_TODAM] + borg_skill[BI_WTODAM]);
+    /* Calculate base damage, used to calculating slays */
+    borg_skill[BI_WBASEDAM] =
+        (item->dd * item->ds);
+
+     /* Hack -- Reward High Level Warriors with Res Fear */
+     if (cp_ptr->flags & CF_BRAVERY_30)
+     {
+         /* Resist fear at level 30 */
+         if (borg_skill[BI_CLEVEL] >= 30) borg_skill[BI_RFEAR] = TRUE;
+     }
+
+    /* Affect Skill -- stealth (bonus one) */
+    borg_skill[BI_STL] += 1;
+
+    /* Affect Skill -- disarming (DEX and INT) */
+    borg_skill[BI_DIS] += adj_dex_dis[my_stat_ind[A_DEX]];
+    borg_skill[BI_DIS] += adj_int_dis[my_stat_ind[A_INT]];
+
+    /* Affect Skill -- magic devices (INT) */
+    borg_skill[BI_DEV] += adj_int_dev[my_stat_ind[A_INT]];
+
+    /* Affect Skill -- saving throw (WIS) */
+    borg_skill[BI_SAV] += adj_wis_sav[my_stat_ind[A_WIS]];
+
+    /* Affect Skill -- digging (STR) */
+    borg_skill[BI_DIG] += adj_str_dig[my_stat_ind[A_STR]];
+
+
+    /* Affect Skill -- disarming (Level, by Class) */
+    borg_skill[BI_DIS] += (cb_ptr->x_dis * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- magic devices (Level, by Class) */
+    borg_skill[BI_DEV] += (cb_ptr->x_dev * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- saving throw (Level, by Class) */
+    borg_skill[BI_SAV] += (cb_ptr->x_sav * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- stealth (Level, by Class) */
+    borg_skill[BI_STL] += (cb_ptr->x_stl * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- search ability (Level, by Class) */
+    borg_skill[BI_SRCH] += (cb_ptr->x_srh * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- search frequency (Level, by Class) */
+    borg_skill[BI_SRCHFREQ] += (cb_ptr->x_fos * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- combat (normal) (Level, by Class) */
+    borg_skill[BI_THN] += (cb_ptr->x_thn * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- combat (shooting) (Level, by Class) */
+    borg_skill[BI_THB] += (cb_ptr->x_thb * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Affect Skill -- combat (throwing) (Level, by Class) */
+    borg_skill[BI_THT] += (cb_ptr->x_thb * borg_skill[BI_MAXCLEVEL] / 10);
+
+    /* Limit Skill -- stealth from 0 to 30 */
+    if (borg_skill[BI_STL] > 30) borg_skill[BI_STL] = 30;
+    if (borg_skill[BI_STL] < 0) borg_skill[BI_STL] = 0;
+
+    /* Limit Skill -- digging from 1 up */
+    if (borg_skill[BI_DIG] < 1) borg_skill[BI_DIG] = 1;
+
+    /*** Count needed enchantment ***/
+
+    /* Assume no enchantment needed */
+    my_need_enchant_to_a = 0;
+    my_need_enchant_to_h = 0;
+    my_need_enchant_to_d = 0;
+    my_need_brand_weapon = 0;
+
+    /* Hack -- enchant all the equipment (weapons) */
+    for (i = INVEN_WIELD; i <= INVEN_BOW; i++)
+    {
+        item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip "unknown" items */
+        if (!item->able) continue;
+
+		/* Most classes store the enchants until they get
+		 * a 3x shooter (like a long bow).
+		 * --Important: Also look in borg7.c for the enchanting.
+		 * --We do not want the bow enchanted by mistake.
+		 */
+		if (i == INVEN_BOW &&  /* bow */
+			my_ammo_power < 3) /* 3x shooter */
+			continue;
+
+        /* Enchant all weapons (to hit) */
+        if ((borg_prayer_okay_fail(7, 3, 65) ||
+        	 borg_spell_okay_fail(7, 3, 65) ||
+             amt_enchant_weapon >=1 ) )
+        {
+            if (item->to_h < 15)
+            {
+                my_need_enchant_to_h += (15 - item->to_h);
+            }
+
+            /* Enchant all weapons (to damage) */
+            if (item->to_d < 15)
+            {
+                my_need_enchant_to_d += (15 - item->to_d);
+            }
+        }
+        else /* I dont have the spell or *enchant* */
+        {
+            if (item->to_h < 8)
+            {
+                my_need_enchant_to_h += (8 - item->to_h);
+            }
+
+            /* Enchant all weapons (to damage) */
+            if (item->to_d < 8)
+            {
+                my_need_enchant_to_d += (8 - item->to_d);
+            }
+        }
+    }
+
+    /* Hack -- enchant all the equipment (armor) */
+    for (i = INVEN_BODY; i <= INVEN_FEET; i++)
+    {
+        item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip "unknown" items */
+        if (!item->able) continue;
+
+        /* Note need for enchantment */
+        if ((borg_prayer_okay_fail(7, 4, 65) ||
+            borg_spell_okay_fail(7, 2, 65) ||
+            amt_enchant_armor >=1 ))
+        {
+            if (item->to_a < 15)
+            {
+                my_need_enchant_to_a += (15 - item->to_a);
+            }
+        }
+        else
+        {
+            if (item->to_a < 8)
+            {
+                my_need_enchant_to_a += (8 - item->to_a);
+            }
+        }
+    }
+
+
+    /* Examine the lite */
+    item = &borg_items[INVEN_LITE];
+
+    /* Assume normal lite radius */
+    borg_skill[BI_CURLITE] = 0;
+
+    /* Glowing player has light */
+    if (borg_skill[BI_LITE]) borg_skill[BI_CURLITE] = borg_skill[BI_LITE];
+
+    /* Lite */
+    if (item->tval == TV_LITE)
+    {
+        /* Torches -- radius one */
+        if (item->sval == SV_LITE_TORCH && item->pval >= 1) borg_skill[BI_CURLITE] = borg_skill[BI_CURLITE] + 1;
+
+        /* Lanterns -- radius two */
+        if (item->sval == SV_LITE_LANTERN && item->pval >= 1) borg_skill[BI_CURLITE] = borg_skill[BI_CURLITE] + 2;
+
+        /* Artifact lites -- radius three */
+        /* HACK assume non-torch/non lantern lite is artifact */
+        if ((item->sval != SV_LITE_TORCH) &&
+            (item->sval != SV_LITE_LANTERN))
+        {
+            borg_skill[BI_CURLITE] = borg_skill[BI_CURLITE] + 3;
+        }
+    }
+
+	/* Special way to handle See Inv */
+	if (borg_see_inv) borg_skill[BI_SINV] = TRUE;
+	if (borg_skill[BI_CDEPTH] == 0 &&
+        (borg_prayer_legal(2, 3) ||
+         borg_spell_legal(2, 6))) borg_skill[BI_SINV] = TRUE;
+
+	/* Very special handling of Free Action.
+	 * If the person has perfect Savings throw, he can be
+	 * considered ok on Free Action.  This can free up an
+	 * equipment slot.
+	 */
+    if (borg_skill[BI_SAV] >= 100) borg_skill[BI_FRACT] = TRUE;
+
+	/* Special case for RBlindness.  Perfect saves and the
+	 * resistances for light and dark are good enough for RBlind
+	 */
+	if (borg_skill[BI_SAV] >= 100 && borg_skill[BI_RDARK] &&
+	    borg_skill[BI_RLITE]) borg_skill[BI_RBLIND] = TRUE;
+}
+
+
+/*
+ * Helper function -- notice the player inventory
+ */
+static void borg_notice_aux2(void)
+{
+    int i;
+
+    borg_item *item;
+
+
+    /*** Reset counters ***/
+
+
+    /* Reset basic */
+    amt_food_lowcal = 0;
+    amt_food_hical = 0;
+
+    /* Reset healing */
+    amt_slow_poison =0;
+    amt_cure_confusion = 0;
+    amt_cure_blind = 0;
+
+	/* Reset stat potions */
+    for (i = 0; i < 6; i++) amt_inc_stat[i] = 0;
+
+    /* Reset books */
+    amt_book[0] = 0;
+    amt_book[1] = 0;
+    amt_book[2] = 0;
+    amt_book[3] = 0;
+    amt_book[4] = 0;
+    amt_book[5] = 0;
+    amt_book[6] = 0;
+    amt_book[7] = 0;
+    amt_book[8] = 0;
+
+    /* Reset various */
+    amt_add_stat[A_STR] = 0;
+    amt_add_stat[A_INT] = 0;
+    amt_add_stat[A_WIS] = 0;
+    amt_add_stat[A_DEX] = 0;
+    amt_add_stat[A_CON] = 0;
+    amt_add_stat[A_CHR] = 0;
+    amt_fix_stat[A_STR] = 0;
+    amt_fix_stat[A_INT] = 0;
+    amt_fix_stat[A_WIS] = 0;
+    amt_fix_stat[A_DEX] = 0;
+    amt_fix_stat[A_CON] = 0;
+    amt_fix_stat[A_CHR] = 0;
+    amt_fix_stat[6] = 0;
+
+    amt_fix_exp = 0;
+    amt_cool_staff = 0;
+    amt_digger = 0;
+
+    /* Reset enchantment */
+    amt_enchant_to_a = 0;
+    amt_enchant_to_d = 0;
+    amt_enchant_to_h = 0;
+
+    amt_brand_weapon = 0;
+    amt_enchant_weapon = 0;
+    amt_enchant_armor = 0;
+
+	/* Reset number of Ego items needing *ID* */
+	amt_ego = 0;
+
+    /*** Process the inventory ***/
+
+    /* Scan the inventory */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Hack -- skip un-aware items */
+        if (!item->kind) continue;
+
+        /* count up the items on the borg (do not count artifacts  */
+        /* that are not being wielded) */
+        borg_has[item->kind] += item->iqty;
+
+        /* Analyze the item */
+        switch (item->tval)
+        {
+            /* Books */
+            case TV_MAGIC_BOOK:
+            case TV_PRAYER_BOOK:
+            /* Skip incorrect books */
+            if (item->tval != cp_ptr->spell_book) break;
+            /* Count the books */
+            amt_book[item->sval] += item->iqty;
+            break;
+
+
+            /* Food */
+            case TV_FOOD:
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_FOOD_WAYBREAD:
+                    amt_food_hical += item->iqty;
+                    break;
+                case SV_FOOD_RATION:
+                    amt_food_hical += item->iqty;
+                    break;
+                case SV_FOOD_JERKY:
+                    amt_food_lowcal += item->iqty;
+                    break;
+                case SV_FOOD_BISCUIT:
+                    amt_food_lowcal += item->iqty;
+                    break;
+                case SV_FOOD_SLIME_MOLD:
+                    amt_food_lowcal += item->iqty;
+                    break;
+
+                case SV_FOOD_RESTORE_STR:
+                    amt_fix_stat[A_STR] += item->iqty;
+                    break;
+                case SV_FOOD_RESTORE_CON:
+                    amt_fix_stat[A_CON] += item->iqty;
+                    break;
+                case SV_FOOD_RESTORING:
+                    amt_fix_stat[A_STR] += item->iqty;
+                    amt_fix_stat[A_INT] += item->iqty;
+                    amt_fix_stat[A_WIS] += item->iqty;
+                    amt_fix_stat[A_DEX] += item->iqty;
+                    amt_fix_stat[A_CON] += item->iqty;
+                    amt_fix_stat[A_CHR] += item->iqty;
+                    amt_fix_stat[6]     += item->iqty;
+                    break;
+
+                case SV_FOOD_CURE_CONFUSION:
+                amt_cure_confusion += item->iqty;
+                break;
+
+                case SV_FOOD_CURE_BLINDNESS:
+                amt_cure_blind += item->iqty;
+                break;
+
+                case SV_FOOD_CURE_POISON:
+                borg_skill[BI_ACUREPOIS] += item->iqty;
+                break;
+
+            }
+            break;
+
+
+            /* Potions */
+            case TV_POTION:
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_POTION_HEALING:
+                borg_skill[BI_AHEAL] += item->iqty;
+                break;
+                case SV_POTION_STAR_HEALING:
+                case SV_POTION_LIFE:
+                borg_skill[BI_AEZHEAL] += item->iqty;
+                break;
+                case SV_POTION_CURE_CRITICAL:
+                borg_skill[BI_ACCW] += item->iqty;
+                break;
+                case SV_POTION_CURE_SERIOUS:
+                borg_skill[BI_ACSW] += item->iqty;
+                break;
+                case SV_POTION_CURE_LIGHT:
+                if (borg_skill[BI_ISCUT]) borg_skill[BI_ACSW] += item->iqty;
+                break;
+                case SV_POTION_CURE_POISON:
+                borg_skill[BI_ACUREPOIS] += item->iqty;
+                break;
+                case SV_POTION_SLOW_POISON:
+                amt_slow_poison += item->iqty;
+                break;
+
+                case SV_POTION_RESIST_HEAT:
+                borg_skill[BI_ARESHEAT] += item->iqty;
+                break;
+                case SV_POTION_RESIST_COLD:
+                borg_skill[BI_ARESCOLD] += item->iqty;
+                break;
+
+                case SV_POTION_INC_STR:
+                amt_inc_stat[A_STR] += item->iqty;
+                break;
+                case SV_POTION_INC_INT:
+                amt_inc_stat[A_INT] += item->iqty;
+                break;
+                case SV_POTION_INC_WIS:
+                amt_inc_stat[A_WIS] += item->iqty;
+                break;
+                case SV_POTION_INC_DEX:
+                amt_inc_stat[A_DEX] += item->iqty;
+                break;
+                case SV_POTION_INC_CON:
+                amt_inc_stat[A_CON] += item->iqty;
+                break;
+                case SV_POTION_INC_CHR:
+                amt_inc_stat[A_CHR] += item->iqty;
+                break;
+
+                case SV_POTION_RES_STR:
+                amt_fix_stat[A_STR] += item->iqty;
+                break;
+                case SV_POTION_RES_INT:
+                amt_fix_stat[A_INT] += item->iqty;
+                break;
+                case SV_POTION_RES_WIS:
+                amt_fix_stat[A_WIS] += item->iqty;
+                break;
+                case SV_POTION_RES_DEX:
+                amt_fix_stat[A_DEX] += item->iqty;
+                break;
+                case SV_POTION_RES_CON:
+                amt_fix_stat[A_CON] += item->iqty;
+                break;
+                case SV_POTION_RES_CHR:
+                amt_fix_stat[A_CHR] += item->iqty;
+                break;
+                case SV_POTION_RESTORE_EXP:
+                amt_fix_exp += item->iqty;
+                break;
+
+                case SV_POTION_SPEED:
+                borg_skill[BI_ASPEED] += item->iqty;
+                break;
+
+  				case SV_POTION_DETONATIONS:
+  				borg_skill[BI_ADETONATE] += item->iqty;
+  				break;
+  			}
+
+            break;
+
+
+
+            /* Scrolls */
+            case TV_SCROLL:
+
+
+            /* Analyze the scroll */
+            switch (item->sval)
+            {
+                case SV_SCROLL_IDENTIFY:
+                borg_skill[BI_AID] += item->iqty;
+                break;
+
+                case SV_SCROLL_RECHARGING:
+                borg_skill[BI_ARECHARGE] += item->iqty;
+                break;
+
+                case SV_SCROLL_PHASE_DOOR:
+                borg_skill[BI_APHASE] += item->iqty;
+                break;
+
+                case SV_SCROLL_TELEPORT:
+                borg_skill[BI_ATELEPORT] += item->iqty;
+                break;
+
+                case SV_SCROLL_WORD_OF_RECALL:
+                borg_skill[BI_RECALL] += item->iqty;
+                break;
+
+                case SV_SCROLL_ENCHANT_ARMOR:
+                amt_enchant_to_a += item->iqty;
+                break;
+
+                case SV_SCROLL_ENCHANT_WEAPON_TO_HIT:
+                amt_enchant_to_h += item->iqty;
+                break;
+
+                case SV_SCROLL_ENCHANT_WEAPON_TO_DAM:
+                amt_enchant_to_d += item->iqty;
+                break;
+
+                case SV_SCROLL_STAR_ENCHANT_WEAPON:
+                amt_enchant_weapon += item->iqty;
+                break;
+
+                case SV_SCROLL_PROTECTION_FROM_EVIL:
+                borg_skill[BI_APFE] += item->iqty;
+                break;
+
+                case SV_SCROLL_STAR_ENCHANT_ARMOR:
+                amt_enchant_armor += item->iqty;
+                break;
+
+                case SV_SCROLL_RUNE_OF_PROTECTION:
+                borg_skill[BI_AGLYPH] += item->iqty;
+                break;
+
+                case SV_SCROLL_TELEPORT_LEVEL:
+                borg_skill[BI_ATELEPORTLVL] += item->iqty;
+                borg_skill[BI_ATELEPORT] += 1;
+                break;
+            }
+            break;
+
+
+            /* Rods */
+            case TV_ROD:
+
+
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_ROD_IDENTIFY:
+                if (borg_skill[BI_DEV] - item->level > 7)
+                {
+                    borg_skill[BI_AID] += item->iqty * 100;
+                }
+                else
+                {
+                    borg_skill[BI_AID] += item->iqty;
+                }
+                break;
+
+                case SV_ROD_RECALL:
+                /* Don't count on it if I suck at activations */
+                if (borg_skill[BI_DEV] - item->level > 7)
+                {
+                    borg_skill[BI_RECALL] += item->iqty * 100;
+                }
+                else
+                {
+                    borg_skill[BI_RECALL] += item->iqty;
+                }
+                break;
+
+                case SV_ROD_DETECT_TRAP:
+                borg_skill[BI_ADETTRAP] += item->iqty * 100;
+                break;
+
+                case SV_ROD_DETECT_DOOR:
+                borg_skill[BI_ADETDOOR] += item->iqty * 100;
+                break;
+
+                case SV_ROD_DETECTION:
+                borg_skill[BI_ADETTRAP] += item->iqty * 100;
+                borg_skill[BI_ADETDOOR] += item->iqty * 100;
+                borg_skill[BI_ADETEVIL] += item->iqty * 100;
+                break;
+
+                case SV_ROD_ILLUMINATION:
+                borg_skill[BI_ALITE] += item->iqty * 100;
+                break;
+
+                case SV_ROD_SPEED:
+                /* Don't count on it if I suck at activations */
+                if (borg_skill[BI_DEV] - item->level > 7)
+                {
+                    borg_skill[BI_ASPEED] += item->iqty * 100;
+                }
+                else
+                {
+                    borg_skill[BI_ASPEED] += item->iqty;
+                }
+                break;
+
+                case SV_ROD_MAPPING:
+                borg_skill[BI_AMAGICMAP] += item->iqty * 100;
+                break;
+
+                case SV_ROD_HEALING:
+                /* only +2 per rod because of long charge time. */
+                /* Don't count on it if I suck at activations */
+                if (borg_skill[BI_DEV] - item->level > 7)
+                {
+                    borg_skill[BI_AHEAL] += item->iqty * 3;
+                }
+                else
+                {
+                    borg_skill[BI_AHEAL] += item->iqty + 1;
+                }
+                break;
+            }
+
+            break;
+
+			/* Wands */
+			case TV_WAND:
+
+			/* Analyze each */
+			if (item->sval == SV_WAND_TELEPORT_AWAY)
+			{
+				borg_skill[BI_ATPORTOTHER] += item->pval * item->iqty;
+			}
+			break;
+
+            /* Staffs */
+            case TV_STAFF:
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_STAFF_IDENTIFY:
+                borg_skill[BI_AID] += item->pval * item->iqty;
+                break;
+
+                case SV_STAFF_TELEPORTATION:
+                borg_skill[BI_AESCAPE] += (item->pval * item->iqty) + 1; /* 1 pt for carrying the empty */
+                if (borg_skill[BI_DEV] - item->level > 7)
+                {
+					borg_skill[BI_ATELEPORT] += item->pval * item->iqty;
+				}
+                break;
+
+                case SV_STAFF_SPEED:
+                borg_skill[BI_ASPEED] += item->pval * item->iqty;
+                break;
+
+                case SV_STAFF_HEALING:
+                borg_skill[BI_AHEAL] += item->pval * item->iqty;
+                break;
+
+                case SV_STAFF_THE_MAGI:
+                borg_skill[BI_ASTFMAGI] += item->pval * item->iqty;
+                break;
+
+                case SV_STAFF_DESTRUCTION:
+                borg_skill[BI_ASTFDEST] +=item->pval * item->iqty;
+                break;
+
+                case SV_STAFF_POWER:
+                amt_cool_staff +=item->iqty;
+                break;
+
+                case SV_STAFF_HOLINESS:
+                amt_cool_staff +=item->iqty;
+                borg_skill[BI_AHEAL] +=item->pval * item->iqty;
+                break;
+            }
+
+            break;
+
+
+            /* Flasks */
+            case TV_FLASK:
+
+            /* Use as fuel if we equip a lantern */
+            if (borg_items[INVEN_LITE].sval == SV_LITE_LANTERN) borg_skill[BI_AFUEL] += item->iqty;
+
+            /* Count as Missiles */
+            if (borg_skill[BI_CLEVEL] < 15 ) borg_skill[BI_AMISSILES] += item->iqty;
+            break;
+
+
+            /* Torches */
+            case TV_LITE:
+
+            /* Use as fuel if it is a torch and we carry a torch */
+            if ((item->sval == SV_LITE_TORCH) &&
+                (borg_items[INVEN_LITE].sval == SV_LITE_TORCH))
+            {
+                borg_skill[BI_AFUEL] += item->iqty;
+            }
+
+            break;
+
+
+            /* Weapons */
+            case TV_HAFTED:
+            case TV_POLEARM:
+            case TV_SWORD:
+                /* These items are checked a bit later in a sub routine
+                 * to notice the flags.  It is done outside this switch.
+                 */
+                 break;
+
+            /* Shovels and such */
+            case TV_DIGGING:
+
+                /* Hack -- ignore worthless ones (including cursed) */
+                /* if (item->value <= 0) break; */
+                /* if (item->cursed) break; */
+
+                /* Do not carry if weak, won't be able to dig anyway */
+                /* if (borg_skill[BI_DIG] < 30) break; */
+
+
+                /* amt_digger += item->iqty; Lets skip diggers for a while, too heavy */
+               break;
+
+            /* Missiles */
+
+            case TV_SHOT:
+            case TV_ARROW:
+            case TV_BOLT:
+            /* Hack -- ignore invalid missiles */
+            if (item->tval != my_ammo_tval) break;
+
+            /* Hack -- ignore worthless missiles */
+            if (item->value <= 0) break;
+
+            /* Count plain missiles */
+            if (!item->name2) borg_skill[BI_AMISSILES] += item->iqty;
+
+			/* Only enchant ammo if we have a good shooter,
+			 * otherwise, store the enchants in the home.
+			 */
+			if (my_ammo_power < 3) break;
+
+            if ((borg_equips_artifact(ACT_FIREBRAND, INVEN_BOW) ||
+                 borg_spell_okay_fail(7, 5, 65)) &&
+              item->iqty >=5 &&
+              /* Skip artifacts and ego-items */
+              !artifact_p(item) &&
+              !ego_item_p(item) &&
+              item->able &&
+              item->tval == my_ammo_tval)
+              {
+                my_need_brand_weapon +=10L;
+              }
+
+            /* if we have shit loads of cash (as we will at level 35),  */
+            /* enchant missiles */
+            if (borg_skill[BI_CLEVEL] > 35)
+            {
+                if ((borg_spell_okay_fail(7, 3, 65) || borg_prayer_okay_fail(7, 3, 65))
+                    && item->iqty >= 5)
+                {
+                    if (item->to_h < 10)
+                    {
+                        my_need_enchant_to_h += (10 - item->to_h);
+                    }
+
+                    if (item->to_d < 10)
+                    {
+                        my_need_enchant_to_d += (10 - item->to_d);
+                    }
+                }
+                else
+                {
+                    if (item->to_h < 8)
+                    {
+                        my_need_enchant_to_h += (8 - item->to_h);
+                    }
+
+                    if (item->to_d < 8)
+                    {
+                        my_need_enchant_to_d += (8 - item->to_d);
+                    }
+                }
+            }
+
+            break;
+        }
+    }
+
+
+    /*** Process the Spells and Prayers ***/
+    /*  apw  artifact activations are accounted here
+     *  But some artifacts are not counted for two reasons .
+     *  1.  Some spells-powers are needed instantly and are considered in
+     *  the borg preparation code.  An artifact maybe non-charged at the
+     *  moment he needes it.  Then he would need the spell and not be able
+     *  to cast it. (ie. teleport, phase)
+     *  2.  An artifact may grant a power then he assumes he has infinite
+     *  amounts.  He then sells off his scrolls with the duplicate power.
+     *  When it comes time to upgrade and swap out the artifact, he wont
+     *  because his power drops since he does not have the scrolls anymore.
+     *  and he does not buy items first.
+     *
+     *  A possible solution would be to have him keep a few scrolls as a
+     *  back-up, or to remove the bonus for level preparation from borg_power.
+     *  Right now I think it is better that he not consider the artifacts
+     *  Whose powers are considered in borg_prep.
+     */
+
+    /* Handle "satisfy hunger" -> infinite food */
+    if (borg_spell_legal_fail(2, 0, 7) || borg_prayer_legal_fail(1, 5, 7))
+    {
+        borg_skill[BI_FOOD] += 1000;
+    }
+
+    /* Handle "identify" -> infinite identifies */
+    if (borg_spell_legal(2, 5) || borg_prayer_legal(5, 2) ||
+        borg_equips_artifact(ACT_IDENTIFY, INVEN_WIELD))
+    {
+        borg_skill[BI_AID] += 1000;
+    }
+
+    /* Handle "detect traps" */
+    if (borg_prayer_legal(0, 5))
+    {
+        borg_skill[BI_ADETTRAP] = 1000;
+    }
+
+    /* Handle "detect doors" */
+    if (borg_prayer_legal(0, 6))
+    {
+        borg_skill[BI_ADETDOOR] = 1000;
+    }
+
+    /* Handle "detect evil & monsters" */
+    if (borg_prayer_legal(0, 0) ||
+        borg_spell_legal(0, 1))
+    {
+        borg_skill[BI_ADETEVIL] = 1000;
+    }
+
+    /* Handle "detection" */
+    if (borg_prayer_legal(5, 1) ||
+    borg_equips_artifact(ACT_DETECT, INVEN_HEAD))
+    {
+        borg_skill[BI_ADETDOOR] = 1000;
+        borg_skill[BI_ADETTRAP] = 1000;
+        borg_skill[BI_ADETEVIL] = 1000;
+
+    }
+
+    /* Handle "See Invisible" in a special way. */
+    if (borg_prayer_legal(2, 3) ||
+        borg_spell_legal(2, 6))
+    {
+		borg_skill[BI_DINV] = TRUE;
+    }
+
+    /* Handle "magic mapping" */
+    if (borg_prayer_legal(2, 6) ||
+    borg_equips_artifact(ACT_MAGIC_MAP, INVEN_LITE))
+    {
+        borg_skill[BI_ADETDOOR] = 1000;
+        borg_skill[BI_ADETTRAP] = 1000;
+        borg_skill[BI_AMAGICMAP] = 1000;
+    }
+
+    /* Handle "call lite" */
+    if (borg_prayer_legal(0, 4) ||
+    	borg_equips_artifact(ACT_ILLUMINATION, INVEN_LITE) ||
+    	borg_equips_artifact(ACT_CLAIRVOYANCE, INVEN_LITE) ||
+    	borg_spell_legal(0, 3))
+    {
+        borg_skill[BI_ALITE] += 1000;
+    }
+
+    /* Handle "protection from evil" */
+    if (borg_prayer_legal(2, 4) ||
+    borg_equips_artifact(ACT_PROT_EVIL, INVEN_HEAD))
+    {
+        borg_skill[BI_APFE] += 1000;
+    }
+
+    /* Handle "rune of protection" glyph" */
+    if (borg_prayer_legal(3, 4) ||
+    	borg_spell_legal(6, 4))
+    {
+        borg_skill[BI_AGLYPH] += 1000;
+    }
+
+    /* Handle "detect traps/doors" */
+    if (borg_spell_legal(0, 7))
+    {
+        borg_skill[BI_ADETDOOR] = 1000;
+        borg_skill[BI_ADETTRAP] = 1000;
+    }
+
+    /* Handle "enchant weapon" */
+    if (borg_spell_okay_fail(7, 3, 65) ||
+        borg_prayer_legal_fail(7, 3, 65))
+    {
+        amt_enchant_to_h += 1000;
+        amt_enchant_to_d += 1000;
+        amt_enchant_weapon +=1000;
+    }
+
+    /* Handle "Brand Weapon (bolts)" */
+    if (borg_equips_artifact(ACT_FIREBRAND, INVEN_BOW) ||
+        borg_spell_okay_fail(7, 5, 65))
+    {
+        amt_brand_weapon += 1000;
+    }
+
+    /* Handle "enchant armor" */
+    if (borg_spell_okay_fail(7, 2, 65) ||
+        borg_prayer_legal_fail(7, 4, 65))
+    {
+        amt_enchant_to_a += 1000;
+        amt_enchant_armor +=1000;
+    }
+
+    /* Handle Diggers (stone to mud) */
+    if (borg_spell_legal_fail(2, 2, 40) ||
+    	borg_equips_artifact(ACT_STONE_TO_MUD, INVEN_WIELD))
+    {
+        amt_digger += 1;
+    }
+
+    /* Handle recall */
+    if (borg_prayer_legal_fail(4, 4, 40) || borg_spell_legal_fail(6, 3,40) ||
+        (borg_skill[BI_CDEPTH] == 100 && (borg_prayer_legal(4, 4) || borg_spell_legal(6, 3))))
+    {
+        borg_skill[BI_RECALL] += 1000;
+    }
+	if (borg_equips_artifact(ACT_WOR, INVEN_WIELD))
+	{
+		borg_skill[BI_RECALL] += 1;
+	}
+
+    /* Handle teleport_level */
+    if (borg_prayer_okay_fail(4, 3, 20) || borg_spell_okay_fail(6, 2, 20))
+    {
+        borg_skill[BI_ATELEPORTLVL] += 1000;
+    }
+
+    /* Handle PhaseDoor spell carefully */
+    if (borg_prayer_okay_fail(4, 0, 3) ||
+        borg_spell_okay_fail(0, 2, 3))
+    {
+        borg_skill[BI_APHASE] += 1000;
+    }
+	if (borg_equips_artifact(ACT_PHASE, INVEN_WIELD))
+	{
+		borg_skill[BI_APHASE] += 1;
+	}
+
+    /* Handle teleport spell carefully */
+    if (borg_prayer_okay_fail(1, 1, 1) ||
+        borg_prayer_okay_fail(4, 1, 1) ||
+        borg_spell_okay_fail(1, 5, 1))
+    {
+        borg_skill[BI_ATELEPORT] += 1000;
+    }
+	if (borg_equips_artifact(ACT_TELEPORT, INVEN_RIGHT))
+	{
+		borg_skill[BI_ATELEPORT] += 1;
+	}
+
+    /* Handle teleport away */
+    if (borg_prayer_legal_fail(4, 2, 40) || borg_spell_legal_fail(3, 1,40))
+    {
+        borg_skill[BI_ATPORTOTHER] += 1000;
+    }
+
+    /* Handle Holy Word prayer just to see if legal */
+    if (borg_prayer_legal(3, 5))
+    {
+        borg_skill[BI_AHWORD] += 1000;
+    }
+
+    /* speed spells HASTE*/
+    if ( borg_spell_legal( 3, 2 ) ||
+         borg_equips_artifact(ACT_HASTE1, INVEN_RIGHT) ||
+         borg_equips_artifact(ACT_HASTE2, INVEN_RIGHT))
+    {
+        borg_skill[BI_ASPEED] += 1000;
+    }
+
+    /* Handle "cure light wounds" */
+    if (borg_equips_artifact(ACT_CURE_WOUNDS, INVEN_WIELD))
+    {
+        borg_skill[BI_ACSW] += 1000;
+    }
+
+
+    /* Handle "heal" */
+    if (borg_equips_artifact(ACT_HEAL1,INVEN_BODY) ||
+        borg_equips_artifact(ACT_HEAL2,INVEN_HEAD) ||
+        borg_prayer_legal(3, 2) ||
+        borg_prayer_legal(6, 2))
+    {
+        borg_skill[BI_AHEAL] += 1000;
+    }
+
+    /* Handle "fix exp" */
+    if (borg_equips_artifact(ACT_RESTORE_LIFE, INVEN_OUTER))
+    {
+        amt_fix_exp += 1000;
+    }
+
+	/* Handle "Remembrance" -- is just as good as Hold Life */
+	if (borg_prayer_legal(6, 4) ||
+	    borg_equips_artifact(ACT_RESTORE_LIFE, INVEN_WIELD))
+	{
+		borg_skill[BI_HLIFE] = TRUE;
+	}
+
+    /* Handle "recharge" */
+    if (borg_equips_artifact(ACT_RECHARGE1, INVEN_OUTER) ||
+        borg_spell_legal(7,4) ||
+        borg_prayer_legal(7,1) ||
+        borg_spell_legal(2, 1))
+    {
+        borg_skill[BI_ARECHARGE] += 1000;
+    }
+
+    /*** Process the Needs ***/
+
+    /* No need for fuel */
+    if ((borg_items[INVEN_LITE].sval != SV_LITE_TORCH) &&
+        (borg_items[INVEN_LITE].sval != SV_LITE_LANTERN)) borg_skill[BI_AFUEL] += 1000;
+
+    /* No need to *buy* stat increase potions */
+    if (my_stat_cur[A_STR] >= (18+100) + 10 * adult_maximize *
+        (rp_ptr->r_adj[A_STR] + cp_ptr->c_adj[A_STR]))
+        amt_add_stat[A_STR] += 1000;
+
+    if (my_stat_cur[A_INT] >= (18+100) + 10 * adult_maximize *
+        (rp_ptr->r_adj[A_INT] + cp_ptr->c_adj[A_INT]))
+         amt_add_stat[A_INT] += 1000;
+
+    if (my_stat_cur[A_WIS] >= (18+100) + 10 * adult_maximize *
+        (rp_ptr->r_adj[A_WIS] + cp_ptr->c_adj[A_WIS]))
+        amt_add_stat[A_WIS] += 1000;
+
+    if (my_stat_cur[A_DEX] >= (18+100) + 10 * adult_maximize *
+        (rp_ptr->r_adj[A_DEX] + cp_ptr->c_adj[A_DEX]))
+         amt_add_stat[A_DEX] += 1000;
+
+    if (my_stat_cur[A_CON] >= (18+100) + 10 * adult_maximize *
+        (rp_ptr->r_adj[A_CON] + cp_ptr->c_adj[A_CON]))
+        amt_add_stat[A_CON] += 1000;
+
+    if (my_stat_cur[A_CHR] >= (18+100) + 10 * adult_maximize *
+        (rp_ptr->r_adj[A_CHR] + cp_ptr->c_adj[A_CHR]))
+         amt_add_stat[A_CHR] += 1000;
+
+    /* No need to *buy* stat repair potions */
+    if (!borg_skill[BI_ISFIXSTR]) amt_fix_stat[A_STR] += 1000;
+    if (!borg_skill[BI_ISFIXINT]) amt_fix_stat[A_INT] += 1000;
+    if (!borg_skill[BI_ISFIXWIS]) amt_fix_stat[A_WIS] += 1000;
+    if (!borg_skill[BI_ISFIXDEX]) amt_fix_stat[A_DEX] += 1000;
+    if (!borg_skill[BI_ISFIXCON]) amt_fix_stat[A_CON] += 1000;
+    if (!borg_skill[BI_ISFIXCHR]) amt_fix_stat[A_CHR] += 1000;
+
+
+    /* No need for experience repair */
+    if (!borg_skill[BI_ISFIXEXP]) amt_fix_exp += 1000;
+
+    /* Correct the high and low calorie foods */
+    borg_skill[BI_FOOD] += amt_food_hical;
+    if (amt_food_hical <= 3) borg_skill[BI_FOOD] += amt_food_lowcal;
+
+    /* If weak, do not count food spells */
+   if (borg_skill[BI_ISWEAK] && (borg_skill[BI_FOOD] >= 1000))
+        borg_skill[BI_FOOD] -= 1000;
+
+	/* Count the number of Ego items that need *ID* */
+	if (borg_has[177])
+	{
+	    /* Look for an ego or artifact item to identify (inventory) */
+	    for (i = 0; i < INVEN_PACK; i++)
+	    {
+	        borg_item *item = &borg_items[i];
+
+	        /* Skip empty items */
+	        if (!item->iqty) continue;
+
+			/* Skip Non *ID* and non Artifact */
+	        if (!item->name1 && !item->name2) continue;
+
+			/* Skip special items that already are *ID* */
+			if (item->fully_identified) continue;
+
+			/* Process Ego */
+	        if (item->name2 == EGO_ELVENKIND ||
+	            item->name2 == EGO_AMAN) amt_ego += item->iqty;
+
+			/* Process Artifact */
+	        if (item->name1)
+			{
+			    switch (item->name1)
+			    {
+			    }
+			}
+		}
+	}
+
+}
+
+
+/*
+ * Helper function -- notice the player swap weapon
+ */
+void borg_notice_weapon_swap(void)
+{
+    int i;
+    int b_i = 0;
+
+    s32b v =-1L;
+    s32b b_v = 0L;
+
+    int dam, damage;
+    borg_item *item;
+
+    weapon_swap =0;
+
+    /*** Process the inventory ***/
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        item = &borg_items[i];
+
+        /* reset counter */
+        v= -1L;
+        dam =0;
+        damage =0;
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Hack -- skip un-aware items */
+        if (!item->kind) continue;
+
+        /* Dont carry swaps until dlevel 50.  They are heavy.
+         * Unless the item is a digger, then carry it */
+        if (borg_skill[BI_MAXDEPTH] < 50 /* && item->tval !=TV_DIGGING */) continue;
+
+        /* priest weapon penalty for non-blessed edged weapons */
+        if (cp_ptr->flags & CF_BLESS_WEAPON &&
+            (item->tval == TV_SWORD || item->tval == TV_POLEARM) &&
+            (!(item->flags3 & TR3_BLESSED))) continue;
+
+        /* Require ID, "known" (or average, good, etc) */
+        if (!item->able &&
+            !streq(item->note, "{good}") &&
+            !streq(item->note, "{excellent}") &&
+            !streq(item->note, "{terrible}") &&
+            !streq(item->note, "{special}")) continue;
+
+       /* Clear all the swap weapon flags as I look at each one. */
+        weapon_swap_digger = 0;
+        weapon_swap_slay_animal = FALSE;
+        weapon_swap_slay_evil = FALSE;
+        weapon_swap_slay_undead = FALSE;
+        weapon_swap_slay_demon = FALSE;
+        weapon_swap_slay_orc = FALSE;
+        weapon_swap_slay_troll = FALSE;
+        weapon_swap_slay_giant = FALSE;
+        weapon_swap_slay_dragon = FALSE;
+        weapon_swap_kill_undead = FALSE;
+        weapon_swap_kill_demon = FALSE;
+        weapon_swap_kill_dragon = FALSE;
+        weapon_swap_impact = FALSE;
+        weapon_swap_brand_acid = FALSE;
+        weapon_swap_brand_elec = FALSE;
+        weapon_swap_brand_fire = FALSE;
+        weapon_swap_brand_cold = FALSE;
+        weapon_swap_brand_pois = FALSE;
+        weapon_swap_see_infra = FALSE;
+        weapon_swap_slow_digest = FALSE;
+        weapon_swap_aggravate = FALSE;
+        weapon_swap_teleport = FALSE;
+        weapon_swap_regenerate = FALSE;
+        weapon_swap_telepathy = FALSE;
+        weapon_swap_lite = FALSE;
+        weapon_swap_see_invis = FALSE;
+        weapon_swap_ffall = FALSE;
+        weapon_swap_free_act = FALSE;
+        weapon_swap_hold_life = FALSE;
+        weapon_swap_immune_fire = FALSE;
+        weapon_swap_immune_acid = FALSE;
+        weapon_swap_immune_cold = FALSE;
+        weapon_swap_immune_elec = FALSE;
+        weapon_swap_resist_acid = FALSE;
+        weapon_swap_resist_elec = FALSE;
+        weapon_swap_resist_fire = FALSE;
+        weapon_swap_resist_cold = FALSE;
+        weapon_swap_resist_pois = FALSE;
+        weapon_swap_resist_conf = FALSE;
+        weapon_swap_resist_sound = FALSE;
+        weapon_swap_resist_lite = FALSE;
+        weapon_swap_resist_dark = FALSE;
+        weapon_swap_resist_chaos = FALSE;
+        weapon_swap_resist_disen = FALSE;
+        weapon_swap_resist_shard = FALSE;
+        weapon_swap_resist_nexus = FALSE;
+        weapon_swap_resist_blind = FALSE;
+        weapon_swap_resist_neth = FALSE;
+        decurse_weapon_swap =-1;
+
+        /* Analyze the item */
+        switch (item->tval)
+        {
+
+            /* weapons */
+            case TV_HAFTED:
+            case TV_POLEARM:
+            case TV_SWORD:
+            /* case TV_DIGGING: */
+            {
+
+            /* Digging */
+            if (item->flags1 & TR1_TUNNEL)
+            {
+                /* Don't notice digger if we can turn stone to mud,
+                 * or I am using one.
+                 */
+                /* Hack -- ignore worthless ones (including cursed) */
+                if (item->value <= 0) break;
+                if (item->cursed) break;
+                if (!borg_spell_okay_fail(2, 2, 40) &&
+                    !(borg_items[INVEN_WIELD].flags1 & TR1_TUNNEL))
+                weapon_swap_digger = item->pval;
+            }
+
+            /* various slays */
+            if (item->flags1 & TR1_SLAY_ANIMAL) weapon_swap_slay_animal = TRUE;
+            if (item->flags1 & TR1_SLAY_EVIL)   weapon_swap_slay_evil = TRUE;
+            if (item->flags1 & TR1_SLAY_UNDEAD) weapon_swap_slay_undead = TRUE;
+            if (item->flags1 & TR1_SLAY_DEMON)  weapon_swap_slay_demon = TRUE;
+            if (item->flags1 & TR1_SLAY_ORC)    weapon_swap_slay_orc = TRUE;
+            if (item->flags1 & TR1_SLAY_TROLL)  weapon_swap_slay_troll = TRUE;
+            if (item->flags1 & TR1_SLAY_GIANT)  weapon_swap_slay_giant = TRUE;
+            if (item->flags1 & TR1_SLAY_DRAGON) weapon_swap_slay_dragon = TRUE;
+            if (item->flags1 & TR1_KILL_UNDEAD) weapon_swap_slay_undead = TRUE;
+            if (item->flags1 & TR1_KILL_DEMON)  weapon_swap_slay_demon = TRUE;
+            if (item->flags1 & TR1_KILL_DRAGON) weapon_swap_kill_dragon = TRUE;
+            if (item->flags3 & TR3_IMPACT)      weapon_swap_impact = TRUE;
+            if (item->flags1 & TR1_BRAND_ACID)  weapon_swap_brand_acid = TRUE;
+            if (item->flags1 & TR1_BRAND_ELEC)  weapon_swap_brand_elec = TRUE;
+            if (item->flags1 & TR1_BRAND_FIRE)  weapon_swap_brand_fire = TRUE;
+            if (item->flags1 & TR1_BRAND_COLD)  weapon_swap_brand_cold = TRUE;
+            if (item->flags1 & TR1_BRAND_POIS)  weapon_swap_brand_pois = TRUE;
+
+            /* Affect infravision */
+            if (item->flags1 & TR1_INFRA) weapon_swap_see_infra += item->pval;
+
+            /* Affect speed */
+
+            /* Various flags */
+            if (item->flags3 & TR3_SLOW_DIGEST) weapon_swap_slow_digest = TRUE;
+            if (item->flags3 & TR3_AGGRAVATE) weapon_swap_aggravate = TRUE;
+            if (item->flags3 & TR3_TELEPORT) weapon_swap_teleport = TRUE;
+            if (item->flags3 & TR3_REGEN) weapon_swap_regenerate = TRUE;
+            if (item->flags3 & TR3_TELEPATHY) weapon_swap_telepathy = TRUE;
+            if (item->flags3 & TR3_LITE) weapon_swap_lite = TRUE;
+            if (item->flags3 & TR3_SEE_INVIS) weapon_swap_see_invis = TRUE;
+            if (item->flags3 & TR3_FEATHER) weapon_swap_ffall = TRUE;
+            if (item->flags3 & TR3_FREE_ACT) weapon_swap_free_act = TRUE;
+            if (item->flags3 & TR3_HOLD_LIFE) weapon_swap_hold_life = TRUE;
+
+            /* Immunity flags */
+            /* if you are immune you automaticly resist */
+            if (item->flags2 & TR2_IM_FIRE)
+            {
+                weapon_swap_immune_fire = TRUE;
+                weapon_swap_resist_fire = TRUE;
+            }
+            if (item->flags2 & TR2_IM_ACID)
+            {
+                weapon_swap_immune_acid = TRUE;
+                weapon_swap_resist_acid = TRUE;
+            }
+            if (item->flags2 & TR2_IM_COLD)
+            {
+                weapon_swap_immune_cold = TRUE;
+                weapon_swap_resist_cold = TRUE;
+            }
+            if (item->flags2 & TR2_IM_ELEC)
+            {
+                weapon_swap_immune_elec = TRUE;
+                weapon_swap_resist_elec = TRUE;
+            }
+
+            /* Resistance flags */
+            if (item->flags2 & TR2_RES_ACID) weapon_swap_resist_acid = TRUE;
+            if (item->flags2 & TR2_RES_ELEC) weapon_swap_resist_elec = TRUE;
+            if (item->flags2 & TR2_RES_FIRE) weapon_swap_resist_fire = TRUE;
+            if (item->flags2 & TR2_RES_COLD) weapon_swap_resist_cold = TRUE;
+            if (item->flags2 & TR2_RES_POIS) weapon_swap_resist_pois = TRUE;
+            if (item->flags2 & TR2_RES_CONFU) weapon_swap_resist_conf = TRUE;
+            if (item->flags2 & TR2_RES_SOUND) weapon_swap_resist_sound = TRUE;
+            if (item->flags2 & TR2_RES_LITE) weapon_swap_resist_lite = TRUE;
+            if (item->flags2 & TR2_RES_DARK) weapon_swap_resist_dark = TRUE;
+            if (item->flags2 & TR2_RES_CHAOS) weapon_swap_resist_chaos = TRUE;
+            if (item->flags2 & TR2_RES_DISEN) weapon_swap_resist_disen = TRUE;
+            if (item->flags2 & TR2_RES_SHARD) weapon_swap_resist_shard = TRUE;
+            if (item->flags2 & TR2_RES_NEXUS) weapon_swap_resist_nexus = TRUE;
+            if (item->flags2 & TR2_RES_BLIND) weapon_swap_resist_blind = TRUE;
+            if (item->flags2 & TR2_RES_NETHR) weapon_swap_resist_neth = TRUE;
+            if (item->cursed) decurse_weapon_swap = 0;
+            if (item->flags3 & TR3_HEAVY_CURSE) decurse_weapon_swap = 1;
+            if (item->discount == INSCRIP_UNCURSED)
+            {
+                decurse_weapon_swap = -1;
+            }
+            /* Sustain flags */
+
+            /* calculating the value of the swap weapon. */
+            damage = (item->dd * (item->ds) *25L);
+
+            /* Reward "damage" and increased blows per round*/
+            v += damage * (borg_skill[BI_BLOWS]+1);
+
+            /* Reward "bonus to hit" */
+            v += ((borg_skill[BI_TOHIT] + item->to_h)*100L);
+
+            /* Reward "bonus to dam" */
+            v += ((borg_skill[BI_TODAM] + item->to_d)*75L);
+
+            dam = damage * borg_skill[BI_BLOWS];
+
+            /* assume 2x base damage for x% of creatures */
+            dam = damage * 2 * borg_skill[BI_BLOWS];
+            /* rewared SAnimal if no electric brand */
+            if (!borg_skill[BI_WS_ANIMAL] && !borg_skill[BI_WB_ELEC] && weapon_swap_slay_animal) v += (dam*2) /2;
+            if (!borg_skill[BI_WS_EVIL] && weapon_swap_slay_evil) v +=  (dam*7) /2;
+
+            /* assume 3x base damage for x% of creatures */
+            dam = damage *3*borg_skill[BI_BLOWS];
+
+            /* half of the reward now for SOrc and STroll*/
+            if (!borg_skill[BI_WS_ORC] && weapon_swap_slay_orc) v += (dam*1) /2;
+            if (!borg_skill[BI_WS_TROLL] && weapon_swap_slay_troll) v += (dam*2) /2;
+
+            if (!borg_skill[BI_WS_UNDEAD] && weapon_swap_slay_undead) v += (dam*5) /2;
+            if (!borg_skill[BI_WS_DEMON] && weapon_swap_slay_demon) v += (dam*3) /2;
+            if (!borg_skill[BI_WS_GIANT] && weapon_swap_slay_giant) v += (dam*4) /2;
+            if (!borg_skill[BI_WS_DRAGON] && !borg_skill[BI_WK_DRAGON] && weapon_swap_slay_dragon) v += (dam*6) /2;
+            if (!borg_skill[BI_WB_ACID] && weapon_swap_brand_acid) v += (dam*4) /2;
+            if (!borg_skill[BI_WB_ELEC] && weapon_swap_brand_elec) v += (dam*5) /2;
+            if (!borg_skill[BI_WB_FIRE] && weapon_swap_brand_fire) v += (dam*3) /2;
+            if (!borg_skill[BI_WB_COLD] && weapon_swap_brand_cold) v += (dam*3) /2;
+            if (!borg_skill[BI_WB_POIS] && weapon_swap_brand_pois) v += (dam*3) /2;
+            /* Orcs and Trolls get the second half of the reward if SEvil is not possesed. */
+            if (!borg_skill[BI_WS_ORC] && !borg_skill[BI_WS_EVIL] && weapon_swap_slay_orc) v += (dam*1) /2;
+            if (!borg_skill[BI_WS_TROLL] && !borg_skill[BI_WS_EVIL] && weapon_swap_slay_troll) v += (dam*1) /2;
+
+            /* assume 5x base damage for x% of creatures */
+            dam = damage  * 5 * borg_skill[BI_BLOWS];
+            if (!borg_skill[BI_WK_UNDEAD] && weapon_swap_kill_undead) v += (dam*5) /2;
+            if (!borg_skill[BI_WK_DEMON] && weapon_swap_kill_demon) v += (dam*3) /2;
+            if (!borg_skill[BI_WK_DRAGON] && weapon_swap_kill_dragon) v += (dam*5) /2;
+
+            /* reward the Tunnel factor when low level */
+            if (borg_skill[BI_MAXDEPTH] <= 54 && weapon_swap_digger) v += (weapon_swap_digger * 3500L) + 1000L;
+
+            /* Other Skills */
+            if (!borg_skill[BI_SDIG] && weapon_swap_slow_digest) v += 10L;
+            if (weapon_swap_aggravate) v -= 8000L;
+            if (weapon_swap_teleport) v -= 100000L;
+            if (decurse_weapon_swap != -1) v -= 5000L;
+            if (!borg_skill[BI_REG] && weapon_swap_regenerate) v += 2000L;
+            if (!borg_skill[BI_ESP] && weapon_swap_telepathy) v += 5000L;
+            if (!borg_skill[BI_LITE] && weapon_swap_lite) v += 2000L;
+            if (!borg_skill[BI_SINV] && weapon_swap_see_invis) v += 50000L;
+            if (!borg_skill[BI_FEATH] && weapon_swap_ffall) v += 10L;
+            if (!borg_skill[BI_FRACT] && weapon_swap_free_act) v += 10000L;
+            if (!borg_skill[BI_HLIFE] && (borg_skill[BI_MAXCLEVEL] < 50) && weapon_swap_hold_life) v += 2000L;
+            if (!borg_skill[BI_IFIRE] && weapon_swap_immune_fire) v += 70000L;
+            if (!borg_skill[BI_IACID] && weapon_swap_immune_acid) v += 30000L;
+            if (!borg_skill[BI_ICOLD] && weapon_swap_immune_cold) v += 50000L;
+            if (!borg_skill[BI_IELEC] && weapon_swap_immune_elec) v += 25000L;
+            if (!borg_skill[BI_RFIRE] && weapon_swap_resist_fire) v += 8000L;
+            if (!borg_skill[BI_RACID] && weapon_swap_resist_acid) v += 6000L;
+            if (!borg_skill[BI_RCOLD] && weapon_swap_resist_cold) v += 4000L;
+            if (!borg_skill[BI_RELEC] && weapon_swap_resist_elec) v += 3000L;
+            /* extra bonus for getting all basic resist */
+            if (weapon_swap_resist_fire &&
+                weapon_swap_resist_acid &&
+                weapon_swap_resist_elec &&
+                weapon_swap_resist_cold) v +=  10000L;
+            if (!borg_skill[BI_RPOIS] && weapon_swap_resist_pois) v += 20000L;
+            if (!borg_skill[BI_RCONF] && weapon_swap_resist_conf) v += 5000L;
+            if (!borg_skill[BI_RSND] && weapon_swap_resist_sound) v += 2000L;
+            if (!borg_skill[BI_RLITE] && weapon_swap_resist_lite) v += 800L;
+            if (!borg_skill[BI_RDARK] && weapon_swap_resist_dark) v += 800L;
+            if (!borg_skill[BI_RKAOS] && weapon_swap_resist_chaos) v += 8000L;
+            if (!borg_skill[BI_RDIS] && weapon_swap_resist_disen) v += 5000L;
+            if (!borg_skill[BI_RSHRD] && weapon_swap_resist_shard) v += 100L;
+            if (!borg_skill[BI_RNXUS] && weapon_swap_resist_nexus) v += 100L;
+            if (!borg_skill[BI_RBLIND] && weapon_swap_resist_blind) v += 5000L;
+            if (!borg_skill[BI_RNTHR] && weapon_swap_resist_neth) v += 5500L;
+            if (!borg_skill[BI_RFEAR] && weapon_swap_resist_fear) v += 5500L;
+
+            /* Special concern if Tarrasque is alive */
+            if (borg_skill[BI_MAXDEPTH] >= 75 &&
+               ((!borg_skill[BI_ICOLD] && weapon_swap_immune_cold) ||
+                (!borg_skill[BI_IFIRE] && weapon_swap_immune_fire)))
+            {
+               /* If Tarraseque is alive */
+               if (borg_race_death[539] == 0)
+               {
+                   if (!borg_skill[BI_ICOLD] && weapon_swap_immune_cold) v  += 90000L;
+                   if (!borg_skill[BI_IFIRE] && weapon_swap_immune_fire) v  += 90000L;
+               }
+
+            }
+
+
+            /*  Mega-Hack -- resists (level 60) */
+            /* its possible that he will get a sword and a cloak
+             * both with the same high resist and keep each based
+             * on that resist.  We want him to check to see
+             * that the other swap does not already have the high resist.
+             */
+            if (!borg_skill[BI_RNTHR]  && (borg_skill[BI_MAXDEPTH]+1 >= 55) &&
+                weapon_swap_resist_neth) v += 100000L;
+            if (!borg_skill[BI_RKAOS] && (borg_skill[BI_MAXDEPTH]+1 >= 60) &&
+                weapon_swap_resist_chaos) v += 100000L;
+            if (!borg_skill[BI_RDIS] && (borg_skill[BI_MAXDEPTH]+1 >= 60) &&
+                weapon_swap_resist_disen) v += 100000L;
+
+            /* some artifacts would make good back ups for their activation */
+
+
+            /* skip usless ones */
+            if (v <= 1000) continue;
+
+            /* collect the best one */
+            if (v < b_v) continue;
+
+            /* track it */
+            b_i = i;
+            b_v = v;
+        }
+
+
+        }
+    }
+    /* mark the swap item and its value */
+    weapon_swap_value = b_v;
+    weapon_swap = b_i;
+
+    /* Now that we know who the best swap is lets set our swap
+     * flags and get a move on
+     */
+    /*** Process the best inven item ***/
+
+    item = &borg_items[b_i];
+
+   /* Clear all the swap weapon flags as I look at each one. */
+    weapon_swap_slay_animal = FALSE;
+    weapon_swap_slay_evil = FALSE;
+    weapon_swap_slay_undead = FALSE;
+    weapon_swap_slay_demon = FALSE;
+    weapon_swap_slay_orc = FALSE;
+    weapon_swap_slay_troll = FALSE;
+    weapon_swap_slay_giant = FALSE;
+    weapon_swap_slay_dragon = FALSE;
+    weapon_swap_kill_undead = FALSE;
+    weapon_swap_kill_demon = FALSE;
+    weapon_swap_kill_dragon = FALSE;
+    weapon_swap_impact = FALSE;
+    weapon_swap_brand_acid = FALSE;
+    weapon_swap_brand_elec = FALSE;
+    weapon_swap_brand_fire = FALSE;
+    weapon_swap_brand_cold = FALSE;
+    weapon_swap_brand_pois = FALSE;
+    weapon_swap_see_infra = FALSE;
+    weapon_swap_slow_digest = FALSE;
+    weapon_swap_aggravate = FALSE;
+    weapon_swap_teleport = FALSE;
+    weapon_swap_regenerate = FALSE;
+    weapon_swap_telepathy = FALSE;
+    weapon_swap_lite = FALSE;
+    weapon_swap_see_invis = FALSE;
+    weapon_swap_ffall = FALSE;
+    weapon_swap_free_act = FALSE;
+    weapon_swap_hold_life = FALSE;
+    weapon_swap_immune_fire = FALSE;
+    weapon_swap_immune_acid = FALSE;
+    weapon_swap_immune_cold = FALSE;
+    weapon_swap_immune_elec = FALSE;
+    weapon_swap_resist_acid = FALSE;
+    weapon_swap_resist_elec = FALSE;
+    weapon_swap_resist_fire = FALSE;
+    weapon_swap_resist_cold = FALSE;
+    weapon_swap_resist_pois = FALSE;
+    weapon_swap_resist_conf = FALSE;
+    weapon_swap_resist_sound = FALSE;
+    weapon_swap_resist_lite = FALSE;
+    weapon_swap_resist_dark = FALSE;
+    weapon_swap_resist_chaos = FALSE;
+    weapon_swap_resist_disen = FALSE;
+    weapon_swap_resist_shard = FALSE;
+    weapon_swap_resist_nexus = FALSE;
+    weapon_swap_resist_blind = FALSE;
+    weapon_swap_resist_neth = FALSE;
+    decurse_weapon_swap = -1;
+
+    /* Assume no enchantment needed */
+    enchant_weapon_swap_to_h = 0;
+    enchant_weapon_swap_to_d = 0;
+
+    /* Enchant swap weapons (to hit) */
+    if ((borg_prayer_okay_fail(7, 3, 65) ||
+         borg_spell_okay_fail(7, 3, 65) ||
+         amt_enchant_weapon >=1 ) )
+    {
+        if (item->to_h < 10)
+        {
+            enchant_weapon_swap_to_h += (10 - item->to_h);
+        }
+
+        /* Enchant my swap (to damage) */
+        if (item->to_d < 10)
+        {
+            enchant_weapon_swap_to_d += (10 - item->to_d);
+        }
+    }
+    else
+    {
+        if (item->to_h < 8)
+        {
+            enchant_weapon_swap_to_h += (8 - item->to_h);
+        }
+
+        /* Enchant my swap (to damage) */
+        if (item->to_d < 8)
+        {
+            enchant_weapon_swap_to_d += (8 - item->to_d);
+        }
+    }
+
+    /* various slays */
+    if (item->flags1 & TR1_SLAY_ANIMAL) weapon_swap_slay_animal = TRUE;
+    if (item->flags1 & TR1_SLAY_EVIL)   weapon_swap_slay_evil = TRUE;
+    if (item->flags1 & TR1_SLAY_UNDEAD) weapon_swap_slay_undead = TRUE;
+    if (item->flags1 & TR1_SLAY_DEMON)  weapon_swap_slay_demon = TRUE;
+    if (item->flags1 & TR1_SLAY_ORC)    weapon_swap_slay_orc = TRUE;
+    if (item->flags1 & TR1_SLAY_TROLL)  weapon_swap_slay_troll = TRUE;
+    if (item->flags1 & TR1_SLAY_GIANT)  weapon_swap_slay_giant = TRUE;
+    if (item->flags1 & TR1_SLAY_DRAGON) weapon_swap_slay_dragon = TRUE;
+    if (item->flags1 & TR1_KILL_UNDEAD) weapon_swap_kill_undead = TRUE;
+    if (item->flags1 & TR1_KILL_DEMON)  weapon_swap_kill_demon = TRUE;
+    if (item->flags1 & TR1_KILL_DRAGON) weapon_swap_kill_dragon = TRUE;
+    if (item->flags3 & TR3_IMPACT)      weapon_swap_impact = TRUE;
+    if (item->flags1 & TR1_BRAND_ACID)  weapon_swap_brand_acid = TRUE;
+    if (item->flags1 & TR1_BRAND_ELEC)  weapon_swap_brand_elec = TRUE;
+    if (item->flags1 & TR1_BRAND_FIRE)  weapon_swap_brand_fire = TRUE;
+    if (item->flags1 & TR1_BRAND_COLD)  weapon_swap_brand_cold = TRUE;
+    if (item->flags1 & TR1_BRAND_POIS)  weapon_swap_brand_pois = TRUE;
+
+    /* Affect infravision */
+    if (item->flags1 & TR1_INFRA) weapon_swap_see_infra += item->pval;
+    /* Affect various skills */
+    /* Affect speed */
+
+    /* Various flags */
+    if (item->flags3 & TR3_SLOW_DIGEST) weapon_swap_slow_digest = TRUE;
+    if (item->flags3 & TR3_AGGRAVATE) weapon_swap_aggravate = TRUE;
+    if (item->flags3 & TR3_TELEPORT) weapon_swap_teleport = TRUE;
+    if (item->flags3 & TR3_REGEN) weapon_swap_regenerate = TRUE;
+    if (item->flags3 & TR3_TELEPATHY) weapon_swap_telepathy = TRUE;
+    if (item->flags3 & TR3_LITE) weapon_swap_lite = TRUE;
+    if (item->flags3 & TR3_SEE_INVIS) weapon_swap_see_invis = TRUE;
+    if (item->flags3 & TR3_FEATHER) weapon_swap_ffall = TRUE;
+    if (item->flags3 & TR3_FREE_ACT) weapon_swap_free_act = TRUE;
+    if (item->flags3 & TR3_HOLD_LIFE) weapon_swap_hold_life = TRUE;
+
+    /* Immunity flags */
+    /* if you are immune you automaticly resist */
+    if (item->flags2 & TR2_IM_FIRE)
+    {
+        weapon_swap_immune_fire = TRUE;
+        weapon_swap_resist_fire = TRUE;
+    }
+    if (item->flags2 & TR2_IM_ACID)
+    {
+        weapon_swap_immune_acid = TRUE;
+        weapon_swap_resist_acid = TRUE;
+    }
+    if (item->flags2 & TR2_IM_COLD)
+    {
+        weapon_swap_immune_cold = TRUE;
+        weapon_swap_resist_cold = TRUE;
+    }
+    if (item->flags2 & TR2_IM_ELEC)
+    {
+        weapon_swap_immune_elec = TRUE;
+        weapon_swap_resist_elec = TRUE;
+    }
+
+    /* Resistance flags */
+    if (item->flags2 & TR2_RES_ACID) weapon_swap_resist_acid = TRUE;
+    if (item->flags2 & TR2_RES_ELEC) weapon_swap_resist_elec = TRUE;
+    if (item->flags2 & TR2_RES_FIRE) weapon_swap_resist_fire = TRUE;
+    if (item->flags2 & TR2_RES_COLD) weapon_swap_resist_cold = TRUE;
+    if (item->flags2 & TR2_RES_POIS) weapon_swap_resist_pois = TRUE;
+    if (item->flags2 & TR2_RES_CONFU) weapon_swap_resist_conf = TRUE;
+    if (item->flags2 & TR2_RES_SOUND) weapon_swap_resist_sound = TRUE;
+    if (item->flags2 & TR2_RES_LITE) weapon_swap_resist_lite = TRUE;
+    if (item->flags2 & TR2_RES_DARK) weapon_swap_resist_dark = TRUE;
+    if (item->flags2 & TR2_RES_CHAOS) weapon_swap_resist_chaos = TRUE;
+    if (item->flags2 & TR2_RES_DISEN) weapon_swap_resist_disen = TRUE;
+    if (item->flags2 & TR2_RES_SHARD) weapon_swap_resist_shard = TRUE;
+    if (item->flags2 & TR2_RES_NEXUS) weapon_swap_resist_nexus = TRUE;
+    if (item->flags2 & TR2_RES_BLIND) weapon_swap_resist_blind = TRUE;
+    if (item->flags2 & TR2_RES_NETHR) weapon_swap_resist_neth = TRUE;
+    if (item->cursed) decurse_weapon_swap = 0;
+    if (item->flags3 & TR3_HEAVY_CURSE) decurse_weapon_swap = 1;
+    if (item->discount == INSCRIP_UNCURSED)
+    {
+       decurse_weapon_swap = -1;
+    }
+
+}
+
+/*
+ * Helper function -- notice the player swap armour
+ */
+void borg_notice_armour_swap(void)
+{
+    int i;
+    int b_i = 0;
+    s32b v = -1L;
+    s32b b_v = 0L;
+    int dam, damage;
+
+    borg_item *item;
+
+    armour_swap = 0;
+
+    /* borg option to not use them */
+    if (!borg_uses_swaps) return;
+
+    /*** Process the inventory ***/
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        item = &borg_items[i];
+
+        /* reset counter */
+        v= -1L;
+        dam =0;
+        damage =0;
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Hack -- skip un-aware items */
+        if (!item->kind) continue;
+
+        /* Dont carry swaps until dlevel 50.  They are heavy */
+        if (borg_skill[BI_MAXDEPTH] < 50) continue;
+
+        /* Require "known" (or average, good, etc) */
+        if (!item->able &&
+            !streq(item->note, "{good}") &&
+            !streq(item->note, "{excellent}") &&
+            !streq(item->note, "{terrible}") &&
+            !streq(item->note, "{special}")) continue;
+
+        /* One Ring is not a swap */
+        if (item->activation == ACT_BIZZARE) continue;
+
+        /* Clear all the swap weapon flags as I look at each one. */
+        armour_swap_slay_animal = FALSE;
+        armour_swap_slay_evil = FALSE;
+        armour_swap_slay_undead = FALSE;
+        armour_swap_slay_demon = FALSE;
+        armour_swap_slay_orc = FALSE;
+        armour_swap_slay_troll = FALSE;
+        armour_swap_slay_giant = FALSE;
+        armour_swap_slay_dragon = FALSE;
+        armour_swap_kill_undead = FALSE;
+        armour_swap_kill_demon = FALSE;
+        armour_swap_kill_dragon = FALSE;
+        armour_swap_impact = FALSE;
+        armour_swap_brand_acid = FALSE;
+        armour_swap_brand_elec = FALSE;
+        armour_swap_brand_fire = FALSE;
+        armour_swap_brand_cold = FALSE;
+        armour_swap_brand_pois = FALSE;
+        armour_swap_see_infra = FALSE;
+        armour_swap_slow_digest = FALSE;
+        armour_swap_aggravate = FALSE;
+        armour_swap_teleport = FALSE;
+        armour_swap_regenerate = FALSE;
+        armour_swap_telepathy = FALSE;
+        armour_swap_lite = FALSE;
+        armour_swap_see_invis = FALSE;
+        armour_swap_ffall = FALSE;
+        armour_swap_free_act = FALSE;
+        armour_swap_hold_life = FALSE;
+        armour_swap_immune_fire = FALSE;
+        armour_swap_immune_acid = FALSE;
+        armour_swap_immune_cold = FALSE;
+        armour_swap_immune_elec = FALSE;
+        armour_swap_resist_acid = FALSE;
+        armour_swap_resist_elec = FALSE;
+        armour_swap_resist_fire = FALSE;
+        armour_swap_resist_cold = FALSE;
+        armour_swap_resist_pois = FALSE;
+        armour_swap_resist_conf = FALSE;
+        armour_swap_resist_sound = FALSE;
+        armour_swap_resist_lite = FALSE;
+        armour_swap_resist_dark = FALSE;
+        armour_swap_resist_chaos = FALSE;
+        armour_swap_resist_disen = FALSE;
+        armour_swap_resist_shard = FALSE;
+        armour_swap_resist_nexus = FALSE;
+        armour_swap_resist_blind = FALSE;
+        armour_swap_resist_neth = FALSE;
+        decurse_armour_swap = -1;
+
+        /* Analyze the item */
+        switch (item->tval)
+        {
+            /* ARMOUR TYPE STUFF */
+            case TV_RING:
+            case TV_AMULET:
+            case TV_BOOTS:
+            case TV_HELM:
+            case TV_CROWN:
+            case TV_SHIELD:
+            case TV_CLOAK:
+            case TV_SOFT_ARMOR:
+            case TV_HARD_ARMOR:
+            case TV_DRAG_ARMOR:
+            {
+            /* various slays */
+            /* as of 280, armours dont have slays but random artifacts might.
+             */
+            if (item->flags1 & TR1_SLAY_ANIMAL) armour_swap_slay_animal = TRUE;
+            if (item->flags1 & TR1_SLAY_EVIL)   armour_swap_slay_evil = TRUE;
+            if (item->flags1 & TR1_SLAY_UNDEAD) armour_swap_slay_undead = TRUE;
+            if (item->flags1 & TR1_SLAY_DEMON)  armour_swap_slay_demon = TRUE;
+            if (item->flags1 & TR1_SLAY_ORC)    armour_swap_slay_orc = TRUE;
+            if (item->flags1 & TR1_SLAY_TROLL)  armour_swap_slay_troll = TRUE;
+            if (item->flags1 & TR1_SLAY_GIANT)  armour_swap_slay_giant = TRUE;
+            if (item->flags1 & TR1_SLAY_DRAGON) armour_swap_slay_dragon = TRUE;
+            if (item->flags1 & TR1_KILL_UNDEAD) armour_swap_kill_undead = TRUE;
+            if (item->flags1 & TR1_KILL_DEMON)  armour_swap_kill_demon = TRUE;
+            if (item->flags1 & TR1_KILL_DRAGON) armour_swap_kill_dragon = TRUE;
+            if (item->flags3 & TR3_IMPACT)      armour_swap_impact = TRUE;
+            if (item->flags1 & TR1_BRAND_ACID)  armour_swap_brand_acid = TRUE;
+            if (item->flags1 & TR1_BRAND_ELEC)  armour_swap_brand_elec = TRUE;
+            if (item->flags1 & TR1_BRAND_FIRE)  armour_swap_brand_fire = TRUE;
+            if (item->flags1 & TR1_BRAND_COLD)  armour_swap_brand_cold = TRUE;
+            if (item->flags1 & TR1_BRAND_POIS)  armour_swap_brand_pois = TRUE;
+
+            /* Affect infravision */
+            if (item->flags1 & TR1_INFRA) armour_swap_see_infra += item->pval;
+            /* Affect various skills */
+            /* Affect speed */
+
+            /* Various flags */
+            if (item->flags3 & TR3_SLOW_DIGEST) armour_swap_slow_digest = TRUE;
+            if (item->flags3 & TR3_AGGRAVATE) armour_swap_aggravate = TRUE;
+            if (item->flags3 & TR3_TELEPORT) armour_swap_teleport = TRUE;
+            if (item->flags3 & TR3_REGEN) armour_swap_regenerate = TRUE;
+            if (item->flags3 & TR3_TELEPATHY) armour_swap_telepathy = TRUE;
+            if (item->flags3 & TR3_LITE) armour_swap_lite = TRUE;
+            if (item->flags3 & TR3_SEE_INVIS) armour_swap_see_invis = TRUE;
+            if (item->flags3 & TR3_FEATHER) armour_swap_ffall = TRUE;
+            if (item->flags3 & TR3_FREE_ACT) armour_swap_free_act = TRUE;
+            if (item->flags3 & TR3_HOLD_LIFE) armour_swap_hold_life = TRUE;
+
+            /* Immunity flags */
+            /* if you are immune you automaticly resist */
+            if (item->flags2 & TR2_IM_FIRE)
+            {
+                armour_swap_immune_fire = TRUE;
+                armour_swap_resist_fire = TRUE;
+            }
+            if (item->flags2 & TR2_IM_ACID)
+            {
+                armour_swap_immune_acid = TRUE;
+                armour_swap_resist_acid = TRUE;
+            }
+            if (item->flags2 & TR2_IM_COLD)
+            {
+                armour_swap_immune_cold = TRUE;
+                armour_swap_resist_cold = TRUE;
+            }
+            if (item->flags2 & TR2_IM_ELEC)
+            {
+                armour_swap_immune_elec = TRUE;
+                armour_swap_resist_elec = TRUE;
+            }
+
+            /* Resistance flags */
+            if (item->flags2 & TR2_RES_ACID) armour_swap_resist_acid = TRUE;
+            if (item->flags2 & TR2_RES_ELEC) armour_swap_resist_elec = TRUE;
+            if (item->flags2 & TR2_RES_FIRE) armour_swap_resist_fire = TRUE;
+            if (item->flags2 & TR2_RES_COLD) armour_swap_resist_cold = TRUE;
+            if (item->flags2 & TR2_RES_POIS) armour_swap_resist_pois = TRUE;
+            if (item->flags2 & TR2_RES_CONFU) armour_swap_resist_conf = TRUE;
+            if (item->flags2 & TR2_RES_SOUND) armour_swap_resist_sound = TRUE;
+            if (item->flags2 & TR2_RES_LITE) armour_swap_resist_lite = TRUE;
+            if (item->flags2 & TR2_RES_DARK) armour_swap_resist_dark = TRUE;
+            if (item->flags2 & TR2_RES_CHAOS) armour_swap_resist_chaos = TRUE;
+            if (item->flags2 & TR2_RES_DISEN) armour_swap_resist_disen = TRUE;
+            if (item->flags2 & TR2_RES_SHARD) armour_swap_resist_shard = TRUE;
+            if (item->flags2 & TR2_RES_NEXUS) armour_swap_resist_nexus = TRUE;
+            if (item->flags2 & TR2_RES_BLIND) armour_swap_resist_blind = TRUE;
+            if (item->flags2 & TR2_RES_NETHR) armour_swap_resist_neth = TRUE;
+            if (item->cursed) decurse_armour_swap = 0;
+            if (item->flags3 & TR3_HEAVY_CURSE) decurse_armour_swap = 1;
+
+            /* Sustain flags */
+
+            /* calculating the value of the swap weapon. */
+            damage = (item->dd * item->ds *35L);
+
+            /* Reward "damage" and increased blows per round*/
+            v += damage * (borg_skill[BI_BLOWS]+1);
+
+            /* Reward "bonus to hit" */
+            v += ((borg_skill[BI_TOHIT] + item->to_h)*100L);
+
+            /* Reward "bonus to dam" */
+            v += ((borg_skill[BI_TODAM] + item->to_d)*35L);
+
+            dam = damage * borg_skill[BI_BLOWS];
+
+            /* assume 2x base damage for x% of creatures */
+            dam = damage * 2 * borg_skill[BI_BLOWS];
+
+            if (!borg_skill[BI_WS_ANIMAL] && !borg_skill[BI_WB_ELEC] && armour_swap_slay_animal) v += (dam*2) /2;
+            if (!borg_skill[BI_WS_EVIL] && armour_swap_slay_evil) v +=  (dam*7) /2;
+            /* assume 3x base damage for x% of creatures */
+            dam = damage *3*borg_skill[BI_BLOWS];
+
+            if (!borg_skill[BI_WS_UNDEAD] && armour_swap_slay_undead) v += (dam*5) /2;
+            if (!borg_skill[BI_WS_DEMON] && armour_swap_slay_demon) v += (dam*3) /2;
+            if (!borg_skill[BI_WS_GIANT] && armour_swap_slay_giant) v += (dam*4) /2;
+            if (!borg_skill[BI_WS_DRAGON] && !borg_skill[BI_WK_DRAGON] && armour_swap_slay_dragon) v += (dam*6) /2;
+            if (!borg_skill[BI_WB_ACID] && armour_swap_brand_acid) v += (dam*4) /2;
+            if (!borg_skill[BI_WB_ELEC] && armour_swap_brand_elec) v += (dam*5) /2;
+            if (!borg_skill[BI_WB_FIRE] && armour_swap_brand_fire) v += (dam*3) /2;
+            if (!borg_skill[BI_WB_COLD] && armour_swap_brand_cold) v += (dam*3) /2;
+            if (!borg_skill[BI_WB_POIS] && armour_swap_brand_pois) v += (dam*3) /2;
+            /* SOrc and STroll get 1/2 reward now */
+            if (!borg_skill[BI_WS_ORC] && armour_swap_slay_orc) v += (dam*1) /2;
+            if (!borg_skill[BI_WS_TROLL] && armour_swap_slay_troll) v += (dam*2) /2;
+            /* SOrc and STroll get 2/2 reward if slay evil not possesed */
+            if (!borg_skill[BI_WS_ORC] && !borg_skill[BI_WS_EVIL] && armour_swap_slay_orc) v += (dam*1) /2;
+            if (!borg_skill[BI_WS_TROLL] && !borg_skill[BI_WS_EVIL] && armour_swap_slay_troll) v += (dam*1) /2;
+
+            /* assume 5x base damage for x% of creatures */
+            dam = damage  * 5 * borg_skill[BI_BLOWS];
+            if (!borg_skill[BI_WK_UNDEAD] && armour_swap_kill_undead) v += (dam*5) /2;
+            if (!borg_skill[BI_WK_DEMON] && armour_swap_kill_demon) v += (dam*3) /2;
+            if (!borg_skill[BI_WK_DRAGON] && armour_swap_kill_dragon) v += (dam*5) /2;
+
+
+            if (!borg_skill[BI_SDIG] && armour_swap_slow_digest) v += 10L;
+            if (armour_swap_aggravate) v -= 8000L;
+            if (armour_swap_teleport) v -= 100000L;
+            if (decurse_armour_swap != -1) v -= 5000L;
+            if (!borg_skill[BI_REG] && armour_swap_regenerate) v += 2000L;
+            if (!borg_skill[BI_ESP] && armour_swap_telepathy) v += 5000L;
+            if (!borg_skill[BI_LITE] && armour_swap_lite) v += 2000L;
+            if (!borg_skill[BI_SINV] && armour_swap_see_invis) v += 50000L;
+            if (!borg_skill[BI_FEATH] && armour_swap_ffall) v += 10L;
+            if (!borg_skill[BI_FRACT] && armour_swap_free_act) v += 10000L;
+            if (!borg_skill[BI_HLIFE] && (borg_skill[BI_MAXCLEVEL] < 50) && armour_swap_hold_life) v += 2000L;
+            if (!borg_skill[BI_IFIRE] && armour_swap_immune_fire) v += 70000L;
+            if (!borg_skill[BI_IACID] && armour_swap_immune_acid) v += 30000L;
+            if (!borg_skill[BI_ICOLD] && armour_swap_immune_cold) v += 50000L;
+            if (!borg_skill[BI_IELEC] && armour_swap_immune_elec) v += 25000L;
+            if (!borg_skill[BI_RFIRE] && armour_swap_resist_fire) v += 8000L;
+            if (!borg_skill[BI_RACID] && armour_swap_resist_acid) v += 6000L;
+            if (!borg_skill[BI_RCOLD] && armour_swap_resist_cold) v += 4000L;
+            if (!borg_skill[BI_RELEC] && armour_swap_resist_elec) v += 3000L;
+            /* extra bonus for getting all basic resist */
+            if (armour_swap_resist_fire &&
+                armour_swap_resist_acid &&
+                armour_swap_resist_elec &&
+                armour_swap_resist_cold) v +=  10000L;
+            if (!borg_skill[BI_RPOIS] && armour_swap_resist_pois) v += 20000L;
+            if (!borg_skill[BI_RCONF] && armour_swap_resist_conf) v += 5000L;
+            if (!borg_skill[BI_RSND] && armour_swap_resist_sound) v += 2000L;
+            if (!borg_skill[BI_RLITE] && armour_swap_resist_lite) v += 800L;
+            if (!borg_skill[BI_RDARK] && armour_swap_resist_dark) v += 800L;
+            if (!borg_skill[BI_RKAOS] && armour_swap_resist_chaos) v += 8000L;
+            if (!borg_skill[BI_RDIS] && armour_swap_resist_disen) v += 5000L;
+            if (!borg_skill[BI_RSHRD] && armour_swap_resist_shard) v += 100L;
+            if (!borg_skill[BI_RNXUS] && armour_swap_resist_nexus) v += 100L;
+            if (!borg_skill[BI_RBLIND] && armour_swap_resist_blind) v += 5000L;
+            if (!borg_skill[BI_RNTHR] && armour_swap_resist_neth) v += 5500L;
+            /* Special concern if Tarraseque is alive */
+            if (borg_skill[BI_MAXDEPTH] >= 75 &&
+               ((!borg_skill[BI_ICOLD] && armour_swap_immune_cold) ||
+                (!borg_skill[BI_IFIRE] && armour_swap_immune_fire)))
+            {
+               /* If Tarraseque is alive */
+               if (borg_race_death[539] == 0)
+               {
+                  if (!borg_skill[BI_ICOLD] && armour_swap_immune_cold) v  += 90000L;
+                  if (!borg_skill[BI_IFIRE] && armour_swap_immune_fire) v  += 90000L;
+               }
+
+            }
+
+
+
+            /*  Mega-Hack -- resists (level 60) */
+            /* Its possible that he will get a sword and a cloak
+             * both with the same high resist and keep each based
+             * on that resist.  We want him to check to see
+             * that the other swap does not already have the high resist.
+             */
+            if (!borg_skill[BI_RNTHR]  && borg_skill[BI_MAXDEPTH]+1 >= 55  &&
+                !weapon_swap_resist_neth &&
+                armour_swap_resist_neth) v += 105000L;
+            if (!borg_skill[BI_RKAOS] && borg_skill[BI_MAXDEPTH]+1 >= 60 &&
+                !weapon_swap_resist_chaos &&
+                armour_swap_resist_chaos) v += 104000L;
+            if (!borg_skill[BI_RDIS] && borg_skill[BI_MAXDEPTH]+1 >= 60 &&
+                !weapon_swap_resist_disen &&
+                armour_swap_resist_disen) v += 100000L;
+
+            /* some artifacts would make good back ups for their activation */
+
+            }
+
+            /* skip usless ones */
+            if (v <= 1000) continue;
+
+            /* collect the best one */
+            if ((b_i >=0) && (v < b_v)) continue;
+
+            /* track it */
+            b_i = i;
+            b_v = v;
+            armour_swap_value = v;
+            armour_swap = i;
+        }
+    }
+
+        /* Now that we know who the best swap is lets set our swap
+         * flags and get a move on
+         */
+        /*** Process the best inven item ***/
+
+        item = &borg_items[b_i];
+
+       /* Clear all the swap weapon flags as I look at each one. */
+        armour_swap_slay_animal = FALSE;
+        armour_swap_slay_evil = FALSE;
+        armour_swap_slay_undead = FALSE;
+        armour_swap_slay_demon = FALSE;
+        armour_swap_slay_orc = FALSE;
+        armour_swap_slay_troll = FALSE;
+        armour_swap_slay_giant = FALSE;
+        armour_swap_slay_dragon = FALSE;
+        armour_swap_kill_dragon = FALSE;
+        armour_swap_impact = FALSE;
+        armour_swap_brand_acid = FALSE;
+        armour_swap_brand_elec = FALSE;
+        armour_swap_brand_fire = FALSE;
+        armour_swap_brand_cold = FALSE;
+        armour_swap_brand_pois = FALSE;
+        armour_swap_see_infra = FALSE;
+        armour_swap_slow_digest = FALSE;
+        armour_swap_aggravate = FALSE;
+        armour_swap_teleport = FALSE;
+        armour_swap_regenerate = FALSE;
+        armour_swap_telepathy = FALSE;
+        armour_swap_lite = FALSE;
+        armour_swap_see_invis = FALSE;
+        armour_swap_ffall = FALSE;
+        armour_swap_free_act = FALSE;
+        armour_swap_hold_life = FALSE;
+        armour_swap_immune_fire = FALSE;
+        armour_swap_immune_acid = FALSE;
+        armour_swap_immune_cold = FALSE;
+        armour_swap_immune_elec = FALSE;
+        armour_swap_resist_acid = FALSE;
+        armour_swap_resist_elec = FALSE;
+        armour_swap_resist_fire = FALSE;
+        armour_swap_resist_cold = FALSE;
+        armour_swap_resist_pois = FALSE;
+        armour_swap_resist_conf = FALSE;
+        armour_swap_resist_sound = FALSE;
+        armour_swap_resist_lite = FALSE;
+        armour_swap_resist_dark = FALSE;
+        armour_swap_resist_chaos = FALSE;
+        armour_swap_resist_disen = FALSE;
+        armour_swap_resist_shard = FALSE;
+        armour_swap_resist_nexus = FALSE;
+        armour_swap_resist_blind = FALSE;
+        armour_swap_resist_neth = FALSE;
+        decurse_armour_swap = -1;
+
+        /* various slays */
+            if (item->flags1 & TR1_SLAY_ANIMAL) armour_swap_slay_animal = TRUE;
+            if (item->flags1 & TR1_SLAY_EVIL)   armour_swap_slay_evil = TRUE;
+            if (item->flags1 & TR1_SLAY_UNDEAD) armour_swap_slay_undead = TRUE;
+            if (item->flags1 & TR1_SLAY_DEMON)  armour_swap_slay_demon = TRUE;
+            if (item->flags1 & TR1_SLAY_ORC)    armour_swap_slay_orc = TRUE;
+            if (item->flags1 & TR1_SLAY_TROLL)  armour_swap_slay_troll = TRUE;
+            if (item->flags1 & TR1_SLAY_GIANT)  armour_swap_slay_giant = TRUE;
+            if (item->flags1 & TR1_SLAY_DRAGON) armour_swap_slay_dragon = TRUE;
+            if (item->flags1 & TR1_KILL_UNDEAD) armour_swap_kill_undead = TRUE;
+            if (item->flags1 & TR1_KILL_DEMON) armour_swap_kill_demon = TRUE;
+            if (item->flags1 & TR1_KILL_DRAGON) armour_swap_kill_dragon = TRUE;
+            if (item->flags3 & TR3_IMPACT)      armour_swap_impact = TRUE;
+            if (item->flags1 & TR1_BRAND_ACID)  armour_swap_brand_acid = TRUE;
+            if (item->flags1 & TR1_BRAND_ELEC)  armour_swap_brand_elec = TRUE;
+            if (item->flags1 & TR1_BRAND_FIRE)  armour_swap_brand_fire = TRUE;
+            if (item->flags1 & TR1_BRAND_COLD)  armour_swap_brand_cold = TRUE;
+            if (item->flags1 & TR1_BRAND_POIS)  armour_swap_brand_pois = TRUE;
+
+            /* Affect infravision */
+            if (item->flags1 & TR1_INFRA) armour_swap_see_infra += item->pval;
+            /* Affect various skills */
+            /* Affect speed */
+
+            /* Various flags */
+            if (item->flags3 & TR3_SLOW_DIGEST) armour_swap_slow_digest = TRUE;
+            if (item->flags3 & TR3_AGGRAVATE) armour_swap_aggravate = TRUE;
+            if (item->flags3 & TR3_TELEPORT) armour_swap_teleport = TRUE;
+            if (item->flags3 & TR3_REGEN) armour_swap_regenerate = TRUE;
+            if (item->flags3 & TR3_TELEPATHY) armour_swap_telepathy = TRUE;
+            if (item->flags3 & TR3_LITE) armour_swap_lite = TRUE;
+            if (item->flags3 & TR3_SEE_INVIS) armour_swap_see_invis = TRUE;
+            if (item->flags3 & TR3_FEATHER) armour_swap_ffall = TRUE;
+            if (item->flags3 & TR3_FREE_ACT) armour_swap_free_act = TRUE;
+            if (item->flags3 & TR3_HOLD_LIFE) armour_swap_hold_life = TRUE;
+
+            /* Immunity flags */
+            /* if you are immune you automaticly resist */
+            if (item->flags2 & TR2_IM_FIRE)
+            {
+                armour_swap_immune_fire = TRUE;
+                armour_swap_resist_fire = TRUE;
+            }
+            if (item->flags2 & TR2_IM_ACID)
+            {
+                armour_swap_immune_acid = TRUE;
+                armour_swap_resist_acid = TRUE;
+            }
+            if (item->flags2 & TR2_IM_COLD)
+            {
+                armour_swap_immune_cold = TRUE;
+                armour_swap_resist_cold = TRUE;
+            }
+            if (item->flags2 & TR2_IM_ELEC)
+            {
+                armour_swap_immune_elec = TRUE;
+                armour_swap_resist_elec = TRUE;
+            }
+
+            /* Resistance flags */
+            if (item->flags2 & TR2_RES_ACID) armour_swap_resist_acid = TRUE;
+            if (item->flags2 & TR2_RES_ELEC) armour_swap_resist_elec = TRUE;
+            if (item->flags2 & TR2_RES_FIRE) armour_swap_resist_fire = TRUE;
+            if (item->flags2 & TR2_RES_COLD) armour_swap_resist_cold = TRUE;
+            if (item->flags2 & TR2_RES_POIS) armour_swap_resist_pois = TRUE;
+            if (item->flags2 & TR2_RES_CONFU) armour_swap_resist_conf = TRUE;
+            if (item->flags2 & TR2_RES_SOUND) armour_swap_resist_sound = TRUE;
+            if (item->flags2 & TR2_RES_LITE) armour_swap_resist_lite = TRUE;
+            if (item->flags2 & TR2_RES_DARK) armour_swap_resist_dark = TRUE;
+            if (item->flags2 & TR2_RES_CHAOS) armour_swap_resist_chaos = TRUE;
+            if (item->flags2 & TR2_RES_DISEN) armour_swap_resist_disen = TRUE;
+            if (item->flags2 & TR2_RES_SHARD) armour_swap_resist_shard = TRUE;
+            if (item->flags2 & TR2_RES_NEXUS) armour_swap_resist_nexus = TRUE;
+            if (item->flags2 & TR2_RES_BLIND) armour_swap_resist_blind = TRUE;
+            if (item->flags2 & TR2_RES_NETHR) armour_swap_resist_neth = TRUE;
+            if (item->cursed) decurse_armour_swap = 0;
+            if (item->flags3 & TR3_HEAVY_CURSE) decurse_armour_swap = 1;
+
+        enchant_armour_swap_to_a = 0;
+
+        /* dont look for enchantment on non armours */
+        if (item->tval >= TV_LITE) return;
+
+        /* Hack -- enchant the swap equipment (armor) */
+        /* Note need for enchantment */
+        if ((borg_prayer_okay_fail(7, 4, 65) ||
+             borg_spell_okay_fail(7, 2, 65) ||
+             amt_enchant_armor >=1 ))
+        {
+            if (item->to_a < 10)
+            {
+                enchant_armour_swap_to_a += (10 - item->to_a);
+            }
+        }
+        else
+        {
+            if (item->to_a < 8)
+            {
+                enchant_armour_swap_to_a += (8 - item->to_a);
+            }
+        }
+
+}
+
+/*
+ * Analyze the equipment and inventory
+ */
+void borg_notice(bool notice_swap)
+{
+	int inven_weight;
+	int carry_capacity;
+
+    /* Clear out 'has' array */
+    memset(borg_has, 0, size_obj*sizeof(int));
+
+    /* Many of our variables are tied to borg_skill[], which is erased at the
+     * the start of borg_notice().  So we must update the frame the cheat in
+     * all the non inventory skills.
+     */
+    borg_update_frame();
+
+    /* Notice the equipment */
+    borg_notice_aux1();
+
+    /* Notice the inventory */
+    borg_notice_aux2();
+
+    /* Notice and locate my swap weapon */
+    if (notice_swap)
+    {
+        borg_notice_weapon_swap();
+        borg_notice_armour_swap();
+    }
+    borg_skill[BI_SRACID] = borg_skill[BI_RACID]
+                            || armour_swap_resist_acid
+                            || weapon_swap_resist_acid
+                            || borg_spell_okay_fail(4, 3, 15) /* Res FECAP */
+							|| borg_spell_okay_fail(4, 3, 15); /* Res A */
+    borg_skill[BI_SRELEC] = borg_skill[BI_RELEC]
+                            || armour_swap_resist_elec
+                            || weapon_swap_resist_elec
+                            || borg_spell_okay_fail(4, 3, 15); /* Res FECAP */
+    borg_skill[BI_SRFIRE] = borg_skill[BI_RFIRE]
+                            || armour_swap_resist_fire
+                            || weapon_swap_resist_fire
+                            || borg_spell_okay_fail(4, 3, 15) /* Res FECAP */
+							|| borg_prayer_okay_fail(1, 7, 15) /* Res FC */
+							|| borg_spell_okay_fail(4, 1, 15); /* Res F */
+	borg_skill[BI_SRCOLD] = borg_skill[BI_RCOLD]
+                            || armour_swap_resist_cold
+                            || weapon_swap_resist_cold
+                            || borg_spell_okay_fail(4, 3, 15) /* Res FECAP */
+							|| borg_prayer_okay_fail(1, 7, 15) /* Res FC */
+							|| borg_spell_okay_fail(4, 0, 15); /* Res C */
+    borg_skill[BI_SRPOIS] = borg_skill[BI_RPOIS]
+                            || armour_swap_resist_pois
+                            || weapon_swap_resist_pois
+                            || borg_spell_okay_fail(4, 3, 15) /* Res FECAP */
+							|| borg_spell_okay_fail(4, 2, 15); /* Res P */
+    borg_skill[BI_SRFEAR] = borg_skill[BI_RFEAR]
+                            || armour_swap_resist_fear
+                            || weapon_swap_resist_fear;
+    borg_skill[BI_SRLITE] = borg_skill[BI_RLITE]
+                            || armour_swap_resist_lite
+                            || weapon_swap_resist_lite;
+    borg_skill[BI_SRDARK] = borg_skill[BI_RDARK]
+                            || armour_swap_resist_dark
+                            || weapon_swap_resist_dark;
+    borg_skill[BI_SRBLIND] = borg_skill[BI_RBLIND]
+                            || armour_swap_resist_blind
+                            || weapon_swap_resist_blind;
+    borg_skill[BI_SRCONF] = borg_skill[BI_RCONF]
+                            || armour_swap_resist_conf
+                            || weapon_swap_resist_conf;
+    borg_skill[BI_SRSND] = borg_skill[BI_RSND]
+                            || armour_swap_resist_sound
+                            || weapon_swap_resist_sound;
+    borg_skill[BI_SRSHRD] = borg_skill[BI_RSHRD]
+                            || armour_swap_resist_shard
+                            || weapon_swap_resist_shard;
+    borg_skill[BI_SRNXUS] = borg_skill[BI_RNXUS]
+                            || armour_swap_resist_nexus
+                            || weapon_swap_resist_nexus;
+    borg_skill[BI_SRNTHR] = borg_skill[BI_RNTHR]
+                            || armour_swap_resist_neth
+                            || weapon_swap_resist_neth;
+    borg_skill[BI_SRKAOS] = borg_skill[BI_RKAOS]
+                            || armour_swap_resist_chaos
+                            || weapon_swap_resist_chaos;
+    borg_skill[BI_SRDIS] = borg_skill[BI_RDIS]
+                            || armour_swap_resist_disen
+                            || weapon_swap_resist_disen;
+    borg_skill[BI_SHLIFE] = borg_skill[BI_HLIFE]
+                            || armour_swap_hold_life
+                            || weapon_swap_hold_life;
+    borg_skill[BI_SFRACT] = borg_skill[BI_FRACT]
+                            || armour_swap_free_act
+                            || weapon_swap_free_act;
+
+
+    /* Hack -- Apply "encumbrance" from weight */
+    /* Extract the current weight (in tenth pounds) */
+    inven_weight = p_ptr->total_weight;
+
+    /* Extract the "weight limit" (in tenth pounds) */
+    carry_capacity = adj_str_wgt[my_stat_ind[A_STR]] * 100;
+
+    /* Apply "encumbrance" from weight */
+    if (inven_weight > carry_capacity/2) borg_skill[BI_SPEED] -= ((inven_weight - (carry_capacity/2)) / (carry_capacity / 10));
+
+}
+
+/*
+ * Helper function -- notice the home equipment
+ */
+static void borg_notice_home_aux1(borg_item *in_item, bool no_items)
+{
+
+    /*** Reset counters ***/
+
+    /* Reset basic */
+    num_food = 0;
+    num_fuel = 0;
+    num_mold = 0;
+    num_ident = 0;
+    num_star_ident = 0;
+    num_recall = 0;
+    num_phase = 0;
+    num_escape = 0;
+	num_tele_staves = 0;
+    num_teleport = 0;
+    num_teleport_level =0;
+	num_recharge = 0;
+
+    num_artifact = 0;
+    num_ego = 0;
+
+    num_invisible = 0;
+    num_pfe =0;
+    num_glyph = 0;
+    num_genocide = 0;
+    num_mass_genocide = 0;
+    num_berserk = 0;
+    num_pot_rheat = 0;
+    num_pot_rcold = 0;
+    num_speed = 0;
+	num_detonate = 0;
+
+    num_slow_digest = 0;
+    num_regenerate = 0;
+    num_telepathy = 0;
+    num_see_inv = 0;
+    num_ffall = 0;
+    num_free_act = 0;
+    num_hold_life = 0;
+    num_immune_acid = 0;
+    num_immune_elec = 0;
+    num_immune_fire = 0;
+    num_immune_cold = 0;
+    num_resist_acid = 0;
+    num_resist_elec = 0;
+    num_resist_fire = 0;
+    num_resist_cold = 0;
+    num_resist_pois = 0;
+    num_resist_conf = 0;
+    num_resist_sound = 0;
+    num_resist_lite = 0;
+    num_resist_dark = 0;
+    num_resist_chaos = 0;
+    num_resist_disen = 0;
+    num_resist_shard = 0;
+    num_resist_nexus = 0;
+    num_resist_blind = 0;
+    num_resist_neth = 0;
+    num_sustain_str = 0;
+    num_sustain_int = 0;
+    num_sustain_wis = 0;
+    num_sustain_dex =0;
+    num_sustain_con = 0;
+    num_sustain_all = 0;
+
+    home_stat_add[A_STR] = 0;
+    home_stat_add[A_INT] = 0;
+    home_stat_add[A_WIS] = 0;
+    home_stat_add[A_DEX] = 0;
+    home_stat_add[A_CON] = 0;
+    home_stat_add[A_CHR] = 0;
+
+    num_weapons = 0;
+
+    num_bow =0;
+    num_rings = 0;
+    num_neck = 0;
+    num_armor = 0;
+    num_cloaks = 0;
+    num_shields = 0;
+    num_hats = 0;
+    num_gloves = 0;
+    num_boots = 0;
+    num_lite = 0;
+    num_speed = 0;
+    num_edged_weapon = 0;
+    num_bad_gloves= 0;
+
+    /* Reset healing */
+    num_cure_critical = 0;
+    num_cure_serious = 0;
+    num_fix_exp = 0;
+    num_mana = 0;
+    num_heal = 0;
+    num_ez_heal = 0;
+    if (!in_item && !no_items) num_ez_heal_true = 0;
+    if (!in_item && !no_items) num_heal_true = 0;
+
+
+    /* Reset missiles */
+    num_missile = 0;
+
+    /* Reset books */
+    num_book[0] = 0;
+    num_book[1] = 0;
+    num_book[2] = 0;
+    num_book[3] = 0;
+    num_book[4] = 0;
+    num_book[5] = 0;
+    num_book[6] = 0;
+    num_book[7] = 0;
+    num_book[8] = 0;
+
+    /* Reset various */
+    num_fix_stat[A_STR] = 0;
+    num_fix_stat[A_INT] = 0;
+    num_fix_stat[A_WIS] = 0;
+    num_fix_stat[A_DEX] = 0;
+    num_fix_stat[A_CON] = 0;
+    num_fix_stat[A_CHR] = 0;
+    num_fix_stat[6] = 0;
+
+    /* Reset enchantment */
+    num_enchant_to_a = 0;
+    num_enchant_to_d = 0;
+    num_enchant_to_h = 0;
+
+    home_slot_free = 0;
+    home_damage = 0;
+
+    num_duplicate_items = 0;
+}
+
+
+/*
+ * This checks for duplicate items in the home
+ */
+static void borg_notice_home_dupe(borg_item *item, bool check_sval, int i)
+{
+/* eventually check for power overlap... armor of resistence is same as weak elvenkind.*/
+/*  two armors of elvenkind that resist poison is a dupe.  AJG*/
+
+    int dupe_count, x;
+    borg_item *item2;
+
+    /* check for a duplicate.  */
+    /* be carefull about extra powers (elvenkind/magi) */
+    switch (item->name2)
+    {
+        case EGO_BLESS_BLADE:
+        case EGO_PERMANENCE:
+        case EGO_ELVENKIND:
+		case EGO_SHIELD_ELVENKIND:
+        case EGO_MAGI:
+        case EGO_AMAN:
+        case EGO_HA:
+            return;
+            break;
+        case EGO_DF:
+        default:
+            break;
+    }
+
+    /* if this is a stack of items then all after the first are a */
+    /* duplicate */
+    dupe_count = item->iqty-1;
+
+    /* Look for other items before this one that are the same */
+    for (x = 0; x < i; x++)
+    {
+        if (x < STORE_INVEN_MAX)
+            item2 = &borg_shops[7].ware[x];
+        else
+            /* Check what the borg has on as well.*/
+            item2 = &borg_items[((x-STORE_INVEN_MAX)+INVEN_WIELD)];
+
+        /* if everything matches it is a duplicate item */
+        /* Note that we only check sval on certain items.  This */
+        /* is because, for example, two pairs of dragon armor */
+        /* are not the same unless thier subtype (color) matches */
+        /* but a defender is a defender even if one is a dagger and */
+        /* one is a mace */
+        if ( (item->tval == item2->tval) &&
+             (check_sval ? (item->sval == item2->sval) : TRUE) &&
+             (item->name1 == item2->name1) &&
+             (item->name2 == item2->name2) )
+        {
+            dupe_count++;
+        }
+    }
+
+    /* there can be one dupe of rings because there are two ring slots. */
+    if (item->tval == TV_RING && dupe_count)
+        dupe_count--;
+
+    /* Add this items count to the total duplicate count */
+    num_duplicate_items += dupe_count;
+}
+
+/*
+ * Helper function -- notice the home inventory
+ */
+static void borg_notice_home_aux2(borg_item *in_item, bool no_items)
+{
+    int i;
+
+    borg_item *item;
+
+    borg_shop *shop = &borg_shops[7];
+
+    u32b f1, f2, f3;
+
+    /*** Process the inventory ***/
+
+    /* Scan the home */
+    for (i = 0; i < (STORE_INVEN_MAX+(INVEN_TOTAL-INVEN_WIELD)); i++)
+    {
+        if (no_items) break;
+
+        if (!in_item)
+            if (i < STORE_INVEN_MAX)
+                item = &shop->ware[i];
+            else
+                item = &borg_items[((i-STORE_INVEN_MAX)+INVEN_WIELD)];
+        else
+            item = in_item;
+
+        /* Skip empty items */
+        if (!item->iqty)
+        {
+            home_slot_free++;
+            continue;
+        }
+
+        /* Hack -- skip un-aware items */
+        if (!item->kind)
+        {
+            home_slot_free++;
+            continue;
+        }
+
+        if (item->flags3 & TR3_SLOW_DIGEST) num_slow_digest += item->iqty;
+        if (item->flags3 & TR3_REGEN) num_regenerate += item->iqty;
+        if (item->flags3 & TR3_TELEPATHY) num_telepathy += item->iqty;
+        if (item->flags3 & TR3_SEE_INVIS) num_see_inv += item->iqty;
+        if (item->flags3 & TR3_FEATHER) num_ffall += item->iqty;
+        if (item->flags3 & TR3_FREE_ACT) num_free_act += item->iqty;
+        if (item->flags3 & TR3_HOLD_LIFE) num_hold_life += item->iqty;
+        if (item->flags2 & TR2_IM_FIRE)
+        {
+            num_immune_fire += item->iqty;
+            num_resist_fire += item->iqty;
+        }
+        if (item->flags2 & TR2_IM_ACID)
+        {
+            num_immune_acid += item->iqty;
+            num_resist_acid += item->iqty;
+        }
+        if (item->flags2 & TR2_IM_COLD)
+        {
+            num_immune_cold += item->iqty;
+            num_resist_cold += item->iqty;
+        }
+        if (item->flags2 & TR2_IM_ELEC)
+        {
+            num_immune_elec += item->iqty;
+            num_resist_elec += item->iqty;
+        }
+        if (item->flags2 & TR2_RES_ACID) num_resist_acid += item->iqty;
+        if (item->flags2 & TR2_RES_ELEC) num_resist_elec += item->iqty;
+        if (item->flags2 & TR2_RES_FIRE) num_resist_fire += item->iqty;
+        if (item->flags2 & TR2_RES_COLD) num_resist_cold += item->iqty;
+        if (item->flags2 & TR2_RES_POIS) num_resist_pois += item->iqty;
+        if (item->flags2 & TR2_RES_SOUND) num_resist_sound += item->iqty;
+        if (item->flags2 & TR2_RES_LITE) num_resist_lite += item->iqty;
+        if (item->flags2 & TR2_RES_DARK) num_resist_dark += item->iqty;
+        if (item->flags2 & TR2_RES_CHAOS) num_resist_chaos += item->iqty;
+        if (item->flags2 & TR2_RES_CONFU) num_resist_conf += item->iqty;
+        if (item->flags2 & TR2_RES_DISEN) num_resist_disen += item->iqty;
+        if (item->flags2 & TR2_RES_SHARD) num_resist_shard += item->iqty;
+        if (item->flags2 & TR2_RES_NEXUS) num_resist_nexus += item->iqty;
+        if (item->flags2 & TR2_RES_BLIND) num_resist_blind += item->iqty;
+        if (item->flags2 & TR2_RES_NETHR) num_resist_neth += item->iqty;
+
+        /* Count Sustains */
+        if (item->flags2 & TR2_SUST_STR) num_sustain_str += item->iqty;
+        if (item->flags2 & TR2_SUST_INT) num_sustain_str += item->iqty;
+        if (item->flags2 & TR2_SUST_WIS) num_sustain_str += item->iqty;
+        if (item->flags2 & TR2_SUST_DEX) num_sustain_str += item->iqty;
+        if (item->flags2 & TR2_SUST_CON) num_sustain_str += item->iqty;
+        if (item->flags2 & TR2_SUST_STR &&
+           item->flags2 & TR2_SUST_INT  &&
+           item->flags2 & TR2_SUST_WIS  &&
+           item->flags2 & TR2_SUST_DEX  &&
+           item->flags2 & TR2_SUST_CON) num_sustain_all +=item->iqty;
+
+        /* count up bonus to stats */
+        /* HACK only collect stat rings above +3 */
+        if (item->flags1 & TR1_STR)
+        {
+            if (item->tval != TV_RING || item->pval > 3)
+                home_stat_add[A_STR] += item->pval * item->iqty;
+        }
+        if (item->flags1 & TR1_INT)
+        {
+            if (item->tval != TV_RING || item->pval > 3)
+                home_stat_add[A_INT] += item->pval * item->iqty;
+        }
+        if (item->flags1 & TR1_WIS)
+        {
+            if (item->tval != TV_RING || item->pval > 3)
+                home_stat_add[A_WIS] += item->pval * item->iqty;
+        }
+        if (item->flags1 & TR1_DEX)
+        {
+            if (item->tval != TV_RING || item->pval > 3)
+                home_stat_add[A_DEX] += item->pval * item->iqty;
+        }
+        if (item->flags1 & TR1_CON)
+        {
+            if (item->tval != TV_RING || item->pval > 3)
+                home_stat_add[A_CON] += item->pval * item->iqty;
+        }
+        if (item->flags1 & TR1_CHR)
+        {
+            if (item->tval != TV_RING || item->pval > 3)
+                home_stat_add[A_CHR] += item->pval * item->iqty;
+        }
+
+        /* count up bonus to speed */
+        if (item->flags1 & TR1_SPEED) num_speed += item->pval * item->iqty;
+
+        /* count artifacts */
+        if (item->name1)
+        {
+            num_artifact += item->iqty;
+        }
+
+        /* count egos that need *ID* */
+        if ((item->name2 == EGO_ELVENKIND ||
+			 item->name2 == EGO_AMAN) &&
+			!item->fully_identified)
+        {
+            num_ego += item->iqty;
+        }
+
+        /* Analyze the item */
+        switch (item->tval)
+        {
+            case TV_SOFT_ARMOR:
+            case TV_HARD_ARMOR:
+                num_armor += item->iqty;
+
+                /* see if this item is duplicated */
+                borg_notice_home_dupe( item, FALSE, i );
+                break;
+
+            case TV_DRAG_ARMOR:
+                num_armor += item->iqty;
+
+                /* see if this item is duplicated */
+                borg_notice_home_dupe( item, TRUE, i );
+                break;
+
+            case TV_CLOAK:
+                num_cloaks += item->iqty;
+
+                /* see if this item is duplicated */
+                borg_notice_home_dupe( item, FALSE, i );
+
+                break;
+
+            case TV_SHIELD:
+                num_shields += item->iqty;
+
+                /* see if this item is duplicated */
+                borg_notice_home_dupe( item, FALSE, i );
+                break;
+
+            case TV_HELM:
+            case TV_CROWN:
+                num_hats += item->iqty;
+
+                /* see if this item is duplicated */
+                borg_notice_home_dupe( item, FALSE, i );
+
+                break;
+
+            case TV_GLOVES:
+                num_gloves += item->iqty;
+
+                /* most gloves hurt magic for spell-casters */
+                if (cp_ptr->flags & CF_CUMBER_GLOVE && borg_skill[BI_MAXSP] > 3)
+                {
+                    /* Penalize non-usable gloves */
+                    if (item->iqty &&
+                        (!(item->flags3 & TR3_FREE_ACT)) &&
+                        (!((item->flags1 & TR1_DEX) && (item->pval > 0))))
+                    {
+                        num_bad_gloves += item->iqty;
+                    }
+                }
+
+                /* gloves of slaying give a damage bonus */
+                home_damage += item->to_d * 3;
+
+                /* see if this item is duplicated */
+                borg_notice_home_dupe( item, FALSE, i );
+
+                break;
+
+	        case TV_FLASK:
+	            /* Use as fuel if we equip a lantern */
+	            if (borg_items[INVEN_LITE].sval == SV_LITE_LANTERN)
+	            {
+					num_fuel += item->iqty;
+					/* borg_note(format("1.num_fuel=%d",num_fuel)); */
+				}
+				break;
+
+            case TV_LITE:
+				/* Fuel */
+	            if (borg_items[INVEN_LITE].sval == SV_LITE_TORCH)
+	            {
+					num_fuel += item->iqty;
+					/* borg_note(format("2.num_fuel=%d",num_fuel)); */
+				}
+
+		        /* Artifacts */
+		        if (item->name1)
+                {
+                    num_lite += item->iqty;
+                }
+                break;
+
+            case TV_BOOTS:
+                num_boots += item->iqty;
+
+                /* see if this item is duplicated */
+                borg_notice_home_dupe( item, FALSE, i );
+                break;
+
+            case TV_SWORD:
+            case TV_POLEARM:
+            case TV_HAFTED:
+            /* case TV_DIGGING: */
+            {
+                s16b num_blow;
+
+                num_weapons += item->iqty;
+                /* apw most edged weapons hurt magic for priests */
+                if (cp_ptr->flags & CF_BLESS_WEAPON)
+                {
+                    /* Penalize non-blessed edged weapons */
+                    if (((item->tval == TV_SWORD) || (item->tval == TV_POLEARM)) &&
+                        (!(item->flags3 & TR3_BLESSED)))
+                    {
+                        num_edged_weapon += item->iqty;
+                    }
+                }
+
+
+                /* NOTE:  This damage does not take slays into account. */
+                /* it is just a rough estimate to make sure the glave of pain*/
+                /* is kept if it is found */
+                /* It is hard to hold a heavy weapon */
+                num_blow = 1;
+                if (adj_str_hold[my_stat_ind[A_STR]] >= item->weight / 10)
+                {
+                    int str_index, dex_index;
+                    int num = 0, wgt = 0, mul = 0, div = 0;
+
+                    /* Analyze the class */
+                    switch (borg_class)
+                    {
+                        /* Warrior */
+                        case CLASS_WARRIOR: num = 6; wgt = 30; mul = 5; break;
+
+                        /* Mage */
+                        case CLASS_MAGE: num = 4; wgt = 40; mul = 2; break;
+
+                        /* Priest (was mul = 3.5) */
+                        case CLASS_PRIEST: num = 5; wgt = 35; mul = 3; break;
+
+                        /* Rogue */
+                        case CLASS_ROGUE: num = 5; wgt = 30; mul = 3; break;
+
+                        /* Ranger */
+                        case CLASS_RANGER: num = 5; wgt = 35; mul = 4; break;
+
+                        /* Paladin */
+                        case CLASS_PALADIN: num = 5; wgt = 30; mul = 4; break;
+
+                    }
+
+                    /* Enforce a minimum "weight" */
+                    div = ((item->weight < wgt) ? wgt : item->weight);
+
+                    /* Access the strength vs weight */
+                    str_index = (adj_str_blow[my_stat_ind[A_STR]] * mul / div);
+
+                    /* Maximal value */
+                    if (str_index > 11) str_index = 11;
+
+                    /* Index by dexterity */
+                    dex_index = (adj_dex_blow[my_stat_ind[A_DEX]]);
+
+                    /* Maximal value */
+                    if (dex_index > 11) dex_index = 11;
+
+                    /* Use the blows table */
+                    num_blow = blows_table[str_index][dex_index];
+
+                    /* Maximal value */
+                    if (num_blow > num) num_blow = num;
+
+                }
+
+                /* Require at least one blow */
+                if (num_blow < 1) num_blow = 1;
+
+                if (item->flags1 & TR1_BLOWS)
+                    num_blow += item->pval;
+                    num_blow *= item->iqty;
+                if ( item->to_d > 8 || borg_skill[BI_CLEVEL] < 15 )
+                {
+                    home_damage += num_blow * (item->dd * (item->ds) +
+                                         (borg_skill[BI_TODAM] + item->to_d));
+                }
+                else
+                {
+                    home_damage += num_blow * (item->dd * (item->ds) +
+                                        (borg_skill[BI_TODAM] + 8));
+                }
+
+                /* see if this item is a duplicate */
+                borg_notice_home_dupe( item, FALSE, i );
+                break;
+            }
+
+            case TV_BOW:
+                num_bow += item->iqty;
+
+                /* see if this item is a duplicate */
+                borg_notice_home_dupe( item, FALSE, i );
+                break;
+
+            case TV_RING:
+                num_rings += item->iqty;
+
+                /* see if this item is a duplicate */
+                borg_notice_home_dupe( item, TRUE, i );
+
+                break;
+
+            case TV_AMULET:
+                num_neck += item->iqty;
+
+                /* see if this item is a duplicate */
+                borg_notice_home_dupe( item, TRUE, i );
+                break;
+
+
+            /* Books */
+            case TV_MAGIC_BOOK:
+            case TV_PRAYER_BOOK:
+
+            /* Skip incorrect books */
+            if (item->tval != cp_ptr->spell_book) break;
+
+            /* Count the books */
+            num_book[item->sval] += item->iqty;
+
+            break;
+
+
+            /* Food */
+            case TV_FOOD:
+
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_FOOD_WAYBREAD:
+                num_food += item->iqty;
+                break;
+
+                case SV_FOOD_RATION:
+                num_food += item->iqty;
+                break;
+
+                case SV_FOOD_SLIME_MOLD:
+                num_mold += item->iqty;
+                break;
+
+#if 0
+                /* dont clutter the house with these low calorie foods */
+                case SV_FOOD_JERKY:
+                    num_food += item->iqty;
+                break;
+                /* dont clutter the house with these low calorie foods */
+                case SV_FOOD_BISCUIT:
+                    num_food += item->iqty;
+                break;
+#endif
+
+                case SV_FOOD_RESTORE_STR:
+                num_fix_stat[A_STR] += item->iqty;
+                break;
+
+                case SV_FOOD_RESTORE_CON:
+                num_fix_stat[A_CON] += item->iqty;
+                break;
+
+                case SV_FOOD_RESTORING:
+                num_fix_stat[A_STR] += item->iqty;
+                num_fix_stat[A_INT] += item->iqty;
+                num_fix_stat[A_WIS] += item->iqty;
+                num_fix_stat[A_DEX] += item->iqty;
+                num_fix_stat[A_CON] += item->iqty;
+                num_fix_stat[A_CHR] += item->iqty;
+                num_fix_stat[6]     += item->iqty;
+                break;
+            }
+
+            break;
+
+
+            /* Potions */
+            case TV_POTION:
+
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_POTION_CURE_CRITICAL:
+                num_cure_critical += item->iqty;
+                break;
+
+                case SV_POTION_CURE_SERIOUS:
+                num_cure_serious += item->iqty;
+                break;
+
+                case SV_POTION_RESIST_HEAT:
+                num_pot_rheat += item->iqty;
+                break;
+                case SV_POTION_RESIST_COLD:
+                num_pot_rcold += item->iqty;
+                break;
+
+                case SV_POTION_RES_STR:
+                num_fix_stat[A_STR] += item->iqty;
+                break;
+
+                case SV_POTION_RES_INT:
+                num_fix_stat[A_INT] += item->iqty;
+                break;
+
+                case SV_POTION_RES_WIS:
+                num_fix_stat[A_WIS] += item->iqty;
+                break;
+
+                case SV_POTION_RES_DEX:
+                num_fix_stat[A_DEX] += item->iqty;
+                break;
+
+                case SV_POTION_RES_CON:
+                num_fix_stat[A_CON] += item->iqty;
+                break;
+
+                case SV_POTION_RES_CHR:
+                num_fix_stat[A_CHR] += item->iqty;
+                break;
+
+                case SV_POTION_RESTORE_EXP:
+                num_fix_exp += item->iqty;
+                break;
+
+                case SV_POTION_RESTORE_MANA:
+                num_mana += item->iqty;
+                break;
+
+                case SV_POTION_HEALING:
+                num_heal += item->iqty;
+                if (!in_item && !no_items) num_heal_true += item->iqty;
+                break;
+
+                case SV_POTION_STAR_HEALING:
+                num_ez_heal += item->iqty;
+                if (!in_item && !no_items) num_ez_heal_true += item->iqty;
+                break;
+
+                case SV_POTION_LIFE:
+                num_ez_heal += item->iqty;
+                if (!in_item && !no_items) num_ez_heal_true += item->iqty;
+                break;
+
+                case SV_POTION_BERSERK_STRENGTH:
+                num_berserk += item->iqty;
+                break;
+
+                case SV_POTION_SPEED:
+                num_speed += item->iqty;
+                break;
+
+				case SV_POTION_DETONATIONS:
+				num_detonate +=item->iqty;
+				break;
+
+            }
+
+            break;
+
+
+            /* Scrolls */
+            case TV_SCROLL:
+
+            /* Analyze the scroll */
+            switch (item->sval)
+            {
+                case SV_SCROLL_IDENTIFY:
+                num_ident += item->iqty;
+                break;
+
+                case SV_SCROLL_STAR_IDENTIFY:
+                num_star_ident += item->iqty;
+                break;
+
+                case SV_SCROLL_PHASE_DOOR:
+                num_phase += item->iqty;
+                break;
+
+                case SV_SCROLL_TELEPORT:
+                num_teleport += item->iqty;
+                break;
+
+                case SV_SCROLL_WORD_OF_RECALL:
+                num_recall += item->iqty;
+                break;
+
+                case SV_SCROLL_ENCHANT_ARMOR:
+                num_enchant_to_a += item->iqty;
+                break;
+
+                case SV_SCROLL_ENCHANT_WEAPON_TO_HIT:
+                num_enchant_to_h += item->iqty;
+                break;
+
+                case SV_SCROLL_ENCHANT_WEAPON_TO_DAM:
+                num_enchant_to_d += item->iqty;
+                break;
+
+                case SV_SCROLL_PROTECTION_FROM_EVIL:
+                num_pfe += item->iqty;
+                break;
+
+                case SV_SCROLL_RUNE_OF_PROTECTION:
+                num_glyph += item->iqty;
+                break;
+
+                case SV_SCROLL_TELEPORT_LEVEL:
+                num_teleport_level += item->iqty;
+                break;
+
+                case SV_SCROLL_RECHARGING:
+                num_recharge += item->iqty;
+                break;
+            }
+
+            break;
+
+
+            /* Rods */
+            case TV_ROD:
+
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_ROD_IDENTIFY:
+                num_ident += item->iqty * 100;
+                break;
+
+                case SV_ROD_RECALL:
+                num_recall += item->iqty * 100;
+                break;
+            }
+
+            break;
+
+
+            /* Staffs */
+            case TV_STAFF:
+
+            /* only collect staves with more than 3 charges at high level */
+            if (item->pval <= 3 && borg_skill[BI_CLEVEL] > 30)
+                break;
+
+            /* Analyze */
+            switch (item->sval)
+            {
+                case SV_STAFF_IDENTIFY:
+                num_ident += item->pval * item->iqty;
+                break;
+
+                case SV_STAFF_TELEPORTATION:
+                num_escape += item->pval * item->iqty;
+                num_tele_staves ++;
+                break;
+            }
+
+            break;
+
+
+            /* Missiles */
+            case TV_SHOT:
+            case TV_ARROW:
+            case TV_BOLT:
+
+            /* Hack -- ignore invalid missiles */
+            if (item->tval != my_ammo_tval) break;
+
+            /* Hack -- ignore worthless missiles */
+            if (item->value <= 0) break;
+
+            /* Count them */
+            num_missile += item->iqty;
+
+            break;
+        }
+
+        /* if only doing one item, break. */
+        if (in_item) break;
+    }
+
+
+    /*** Process the Spells and Prayers ***/
+
+    /* Handle "satisfy hunger" -> infinite food */
+    if (borg_spell_legal(2, 0) || borg_prayer_legal(1, 5))
+    {
+        num_food += 1000;
+    }
+
+    /* Handle "identify" -> infinite identifies */
+    if (borg_spell_legal(2, 5) ||
+	    borg_prayer_legal(5, 2))
+    {
+        num_ident += 1000;
+    }
+
+    /* Handle "enchant weapon" */
+    if (borg_spell_okay_fail(7, 3, 65) ||
+        borg_prayer_okay_fail(7, 3, 65))
+    {
+        num_enchant_to_h += 1000;
+        num_enchant_to_d += 1000;
+    }
+
+    /* apw Handle "protection from evil" */
+    if (borg_prayer_legal(2, 4))
+    {
+        num_pfe += 1000;
+    }
+
+    /* apw Handle "rune of protection" glyph */
+    if (borg_prayer_legal(3, 4) ||
+    	borg_spell_legal(6, 4))
+    {
+        num_glyph += 1000;
+    }
+
+    /* handle restore */
+
+    /* Handle recall */
+    if (borg_prayer_legal(4, 4) ||
+        borg_spell_legal(6, 3))
+    {
+        num_recall += 1000;
+    }
+
+    /* Handle teleport_level */
+    if (borg_prayer_legal(4, 3) ||
+        borg_spell_legal(6, 2))
+    {
+        num_teleport_level += 1000;
+    }
+
+    /* Handle recharge */
+    if (borg_prayer_legal(7, 1) ||
+        borg_spell_legal(2, 1) ||
+        borg_spell_legal(7, 4))
+    {
+        num_recharge += 1000;
+    }
+
+    /*** Process the Needs ***/
+
+    /* Hack -- No need for stat repair */
+    if (borg_skill[BI_SSTR]) num_fix_stat[A_STR] += 1000;
+    if (borg_skill[BI_SINT]) num_fix_stat[A_INT] += 1000;
+    if (borg_skill[BI_SWIS]) num_fix_stat[A_WIS] += 1000;
+    if (borg_skill[BI_SDEX]) num_fix_stat[A_DEX] += 1000;
+    if (borg_skill[BI_SCON]) num_fix_stat[A_CON] += 1000;
+    if (borg_skill[BI_SCHR]) num_fix_stat[A_CHR] += 1000;
+
+    /* Extract the player flags */
+    player_flags(&f1, &f2, &f3);
+
+    /* Good flags */
+    if (f3 & (TR3_SLOW_DIGEST)) num_slow_digest = TRUE;
+    if (f3 & (TR3_FEATHER)) num_ffall = TRUE;
+    if (f3 & (TR3_LITE)) num_lite = TRUE;
+    if (f3 & (TR3_REGEN)) num_regenerate = TRUE;
+    if (f3 & (TR3_TELEPATHY)) num_telepathy = TRUE;
+    if (f3 & (TR3_SEE_INVIS)) num_see_inv = TRUE;
+    if (f3 & (TR3_FREE_ACT)) num_free_act = TRUE;
+    if (f3 & (TR3_HOLD_LIFE)) num_hold_life = TRUE;
+
+    /* Weird flags */
+
+    /* Bad flags */
+
+    /* Immunity flags */
+    if (f2 & (TR2_IM_FIRE)) num_immune_fire = TRUE;
+    if (f2 & (TR2_IM_ACID)) num_immune_acid = TRUE;
+    if (f2 & (TR2_IM_COLD)) num_immune_cold = TRUE;
+    if (f2 & (TR2_IM_ELEC)) num_immune_elec = TRUE;
+
+    /* Resistance flags */
+    if (f2 & (TR2_RES_ACID)) num_resist_acid = TRUE;
+    if (f2 & (TR2_RES_ELEC)) num_resist_elec = TRUE;
+    if (f2 & (TR2_RES_FIRE)) num_resist_fire = TRUE;
+    if (f2 & (TR2_RES_COLD)) num_resist_cold = TRUE;
+    if (f2 & (TR2_RES_POIS)) num_resist_pois = TRUE;
+    if (f2 & (TR2_RES_LITE)) num_resist_lite = TRUE;
+    if (f2 & (TR2_RES_DARK)) num_resist_dark = TRUE;
+    if (f2 & (TR2_RES_BLIND)) num_resist_blind = TRUE;
+    if (f2 & (TR2_RES_CONFU)) num_resist_conf = TRUE;
+    if (f2 & (TR2_RES_SOUND)) num_resist_sound = TRUE;
+    if (f2 & (TR2_RES_SHARD)) num_resist_shard = TRUE;
+    if (f2 & (TR2_RES_NEXUS)) num_resist_nexus = TRUE;
+    if (f2 & (TR2_RES_NETHR)) num_resist_neth = TRUE;
+    if (f2 & (TR2_RES_CHAOS)) num_resist_chaos = TRUE;
+    if (f2 & (TR2_RES_DISEN)) num_resist_disen = TRUE;
+
+    /* Sustain flags */
+    if (f2 & (TR2_SUST_STR)) num_sustain_str = TRUE;
+    if (f2 & (TR2_SUST_INT)) num_sustain_int = TRUE;
+    if (f2 & (TR2_SUST_WIS)) num_sustain_wis = TRUE;
+    if (f2 & (TR2_SUST_DEX)) num_sustain_dex = TRUE;
+    if (f2 & (TR2_SUST_CON)) num_sustain_con = TRUE;
+
+}
+
+/*
+ * Extract the bonuses for items in the home.
+ *
+ * in_item is passed in if you want to pretend that in_item is
+ *          the only item in the home.
+ * no_items is passed in as TRUE if you want to pretend that the
+ *          home is empty.
+ */
+void borg_notice_home(borg_item *in_item, bool no_items)
+{
+    /* Notice the home equipment */
+    borg_notice_home_aux1(in_item, no_items);
+
+    /* Notice the home inventory */
+    borg_notice_home_aux2(in_item, no_items);
+}
+
+/*
+ * Helper function -- calculate "dynamic power" of equipment
+ */
+static s32b borg_power_aux1(void)
+{
+    s32b        value = 0L;
+
+    power_item* Power_item;
+    int         iEntry, nEntrys;
+    int         nItems;
+    bool        Range;
+
+    nEntrys = n_pwr[borg_class];
+    borg_skill[BI_DEPTH] = borg_skill[BI_MAXDEPTH];
+    borg_skill[BI_CDEPTH] = p_ptr->depth;
+
+    for (iEntry = 0; iEntry < nEntrys; iEntry++)
+    {
+        Power_item = &borg_power_item[borg_class][iEntry];
+        if (Power_item->depth > borg_skill[BI_MAXDEPTH])
+            continue;
+        /* do not count special 'go after morgoth' stuff if morgoth is dead */
+        if (Power_item->depth > 98 && borg_skill[BI_KING])
+            continue;
+        if (Power_item->item == -1)
+        {
+            if (Power_item->cnd == -1 ||
+                borg_calc_formula(formula[Power_item->cnd]))
+                value += borg_calc_formula(formula[Power_item->power]);
+                continue;
+        }
+        nItems = borg_has[Power_item->item];
+        Range = (Power_item->from || Power_item->to != 999);
+        if (Range && Power_item->from > nItems)
+            continue;
+        if (!Power_item->each)
+        {
+            if ((!Range && nItems) || (Range && Power_item->to >= nItems))
+            {
+                if (Power_item->cnd == -1 ||
+                    borg_calc_formula(formula[Power_item->cnd]))
+                    value += Power_item->power;
+            }
+            continue;
+        }
+        if (Range)
+        {
+            if (nItems > Power_item->to)
+                nItems = Power_item->to;
+            if (!Power_item->from)
+                Power_item->from = 1;
+            nItems -= (Power_item->from - 1);
+        }
+        if (nItems == 0)
+            continue;
+
+        if (Power_item->cnd == -1 ||
+            borg_calc_formula(formula[Power_item->cnd]))
+            value += nItems * Power_item->power;
+     }
+
+    /* Result */
+    return (value);
+}
+
+
+
+/*
+ * Helper function -- calculate non dynamic entries of dynamic calcs
+ * and the borg_worship_ bonuses
+ */
+static s32b borg_power_aux2(void)
+{
+     int         k, carry_capacity, inven_weight, book;
+    int         cur_wgt = 0;
+    int         max_wgt = 0;
+    int         i;
+
+    borg_item       *item;
+
+    s32b        value = 0L;
+
+    /*** Basic abilities ***/
+
+    /* apw
+     * In here, we must subtract out the bonus granted from certain
+     * Artifacts.  They grant amt_x = 1000 then the power is increased
+     * by 1000 times whatever bonus.  In the case of Gondor.  This is
+     * 1000 heals times 4000 points per heal.
+     *
+     */
+
+    /* HACK - a small bonus for adding to stats even above max. */
+    /*        This will allow us to swap a ring of int +6 for */
+    /*        our ring of int +2 even though we are at max int because */
+    /*        we are wielding a weapon that has +4 int */
+    /*        later it might be nice to swap to a weapon that does not */
+    /*        have an int bonus */
+    for (i = 0; i < 6; i++) value += my_stat_add[i];
+
+
+    /*** Penalize armor weight ***/
+    if (my_stat_ind[A_STR] < 15)
+    {
+        if (borg_items[INVEN_BODY].weight > 200)
+            value -= (borg_items[INVEN_BODY].weight - 200) * 15;
+        if (borg_items[INVEN_HEAD].weight > 30)
+            value -= 250;
+        if (borg_items[INVEN_ARM].weight > 10)
+            value -= 250;
+        if (borg_items[INVEN_FEET].weight > 50)
+            value -= 250;
+    }
+
+    /* Compute the total armor weight */
+    cur_wgt += borg_items[INVEN_BODY].weight;
+    cur_wgt += borg_items[INVEN_HEAD].weight;
+    cur_wgt += borg_items[INVEN_ARM].weight;
+    cur_wgt += borg_items[INVEN_OUTER].weight;
+    cur_wgt += borg_items[INVEN_HANDS].weight;
+    cur_wgt += borg_items[INVEN_FEET].weight;
+
+    /* Determine the weight allowance */
+    max_wgt = cp_ptr->spell_weight;
+
+    /* Hack -- heavy armor hurts magic */
+    if (cp_ptr->spell_book &&
+        (((cur_wgt - max_wgt) / 10) > 0) &&
+        ((adj_mag_mana[my_stat_ind[A_INT]] * borg_skill[BI_CLEVEL]) / 2) < 150)
+    {
+        /* Mega-Hack -- Penalize heavy armor which hurts mana */
+        if (borg_skill[BI_MAXSP] >= 300 && borg_skill[BI_MAXSP] <= 350)
+            value -= (((cur_wgt - max_wgt) / 10) * 400L);
+        if (borg_skill[BI_MAXSP] >= 200 && borg_skill[BI_MAXSP] <= 299)
+            value -= (((cur_wgt - max_wgt) / 10) * 800L);
+        if (borg_skill[BI_MAXSP] >= 100 && borg_skill[BI_MAXSP] <= 199)
+            value -= (((cur_wgt - max_wgt) / 10) * 1600L);
+        if (borg_skill[BI_MAXSP] >= 1 && borg_skill[BI_MAXSP] <= 99)
+            value -= (((cur_wgt - max_wgt) / 10) * 3200L);
+    }
+
+    /*** Borg_worship_ variables ***/
+
+    /* borg_worships_damage */
+    if (borg_worships_damage)
+    {
+        value += ((borg_skill[BI_TOHIT] + borg_items[INVEN_WIELD].to_h)*25L);
+
+        value += borg_items[INVEN_WIELD].dd *
+                 borg_items[INVEN_WIELD].ds * 20L *
+                 2 * borg_skill[BI_BLOWS];
+    }
+
+    /* borg_worships_speed */
+    if (borg_worships_speed)
+    {
+            value += (((borg_skill[BI_SPEED] - 110) * 1500L));
+    }
+
+    /* borg_worships_hp */
+    if (borg_worships_hp && my_stat_ind[A_CON] <= 37)
+    {
+        value += (my_stat_ind[A_CON] * 250L);
+    }
+
+    /* borg_worships_mana */
+    if (borg_worships_mana)
+    {
+        /* Priests / paladins */
+        if (cp_ptr->spell_book == TV_PRAYER_BOOK &&
+            my_stat_ind[A_WIS] <= 37 )
+            {
+                value += (my_stat_ind[A_WIS] * 250L);
+            }
+         /* Mages / Rogues / Rangers */
+        if (cp_ptr->spell_book == TV_MAGIC_BOOK &&
+            my_stat_ind[A_INT] <= 37 )
+            {
+                value += (my_stat_ind[A_INT] * 250L);
+            }
+    }
+
+    /* borg_worships_ac */
+    if (borg_worships_ac) value += ((borg_skill[BI_ARMOR]) * 2500L);
+
+    /* Fudge factors for normalizing the AC-Reward curve */
+    if (borg_skill[BI_ARMOR] >= 16 && borg_skill[BI_ARMOR] <=74) value += 28250L;
+    if (borg_skill[BI_ARMOR] >= 75) value += 73750L;
+
+    /* borg_worships_gold */
+    /* does not need an entry.  It deals
+     * with how the borg handles/sells items
+     */
+
+    /* extra boost for high damage weapon deep dungeon */
+    if (borg_skill[BI_MAXDEPTH] >= 75)
+    {
+        value += ((borg_skill[BI_TOHIT] + borg_items[INVEN_WIELD].to_h)*15L);
+
+        value += borg_items[INVEN_WIELD].dd *
+                 borg_items[INVEN_WIELD].ds * 20L *
+                 2 * borg_skill[BI_BLOWS];
+    }
+
+    /*** Penalize bad magic ***/
+
+    /* Hack -- most gloves hurt magic for spell-casters */
+    if (cp_ptr->flags & CF_CUMBER_GLOVE && borg_class == CLASS_MAGE)
+    {
+        item = &borg_items[INVEN_HANDS];
+
+        /* Penalize non-usable gloves */
+        if (item->iqty &&
+            (!(item->flags3 & TR3_FREE_ACT)) &&
+            (!((item->flags1 & TR1_DEX) && (item->pval > 0))))
+        {
+            /* Hack -- Major penalty */
+            value -= 275000L;
+        }
+    }
+
+    /* Hack -- most gloves hurt magic for spell-casters */
+    if (cp_ptr->flags & CF_CUMBER_GLOVE && (borg_class == CLASS_RANGER ||
+        borg_class == CLASS_ROGUE))
+    {
+        item = &borg_items[INVEN_HANDS];
+
+        /* Penalize non-usable gloves */
+        if (item->iqty &&
+            (!(item->flags3 & TR3_FREE_ACT)) &&
+            (!((item->flags1 & TR1_DEX) && (item->pval > 0))))
+        {
+            /* Hack -- Major penalty */
+            value -= 15000L;
+        }
+    }
+
+    /* Hack -- most edged weapons hurt magic for priests */
+    if (cp_ptr->flags & CF_BLESS_WEAPON)
+    {
+        item = &borg_items[INVEN_WIELD];
+
+        /* Penalize non-blessed edged weapons */
+        if (((item->tval == TV_SWORD) || (item->tval == TV_POLEARM)) &&
+            (!(item->flags3 & TR3_BLESSED)))
+        {
+            /* Hack -- Major penalty */
+            value -= 275000L;
+
+            /* even bigger if End Game */
+            if (borg_skill[BI_MAXDEPTH] >= 80 && !borg_skill[BI_KING])
+            value -= 100000L;
+        }
+    }
+
+    /* Reward for multiple resists in a single item */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        int multibonus = 0;
+
+        item = &borg_items[i];
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Good to have one item with multiple high resists */
+        multibonus = (((item->flags2 & TR2_RES_POIS) != 0) +
+               ((item->flags2 & TR2_RES_LITE)!= 0) +
+               ((item->flags2 & TR2_RES_DARK)!= 0) +
+               ((item->flags2 & TR2_RES_BLIND)!= 0) +
+               ((item->flags2 & TR2_RES_CONFU)!= 0) +
+               ((item->flags2 & TR2_RES_SOUND)!= 0) +
+               ((item->flags2 & TR2_RES_SHARD)!= 0) +
+               ((item->flags2 & TR2_RES_NEXUS)!= 0) +
+               ((item->flags2 & TR2_RES_NETHR)!= 0) +
+               ((item->flags2 & TR2_RES_CHAOS)!= 0) +
+               ((item->flags2 & TR2_RES_DISEN)!= 0));
+
+        if (multibonus >= 2) value += 15000 * multibonus;
+    }
+
+    /* Not if starving! This consumes more food. Take it off in town.*/
+    if (item->flags3 & TR3_REGEN && borg_skill[BI_ISWEAK] && !borg_skill[BI_CDEPTH])
+    {
+        value -=20000L;
+    }
+
+    /* Special concern if Tarrasque is alive */
+    if (borg_skill[BI_MAXDEPTH] >= 75 &&
+       ((!borg_skill[BI_ICOLD] && weapon_swap_immune_cold) ||
+       (!borg_skill[BI_IFIRE] && weapon_swap_immune_fire)))
+    {
+       /* If Tarraseque is alive */
+       if (borg_race_death[539] == 0)
+       {
+          if (!borg_skill[BI_ICOLD] && weapon_swap_immune_cold) value  += 90000L;
+          if (!borg_skill[BI_IFIRE] && weapon_swap_immune_fire) value  += 90000L;
+       }
+    }
+
+
+    /* Reward fuel */
+
+    /* Reward food */
+
+    /* Prefere to buy HiCalorie foods over LowCalorie */
+    if (amt_food_hical <= 5) value += amt_food_hical * 50;
+
+    /* if hungry, food is THE top priority */
+    if ((borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) && borg_skill[BI_FOOD]) value += 100000;
+
+    /* Reward Cure Poison and Cuts*/
+    if ((borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) && borg_skill[BI_ACCW]) value +=100000;
+    if ((borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) && borg_skill[BI_AHEAL]) value +=50000;
+    if ((borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) && borg_skill[BI_ACSW])
+    {   /* usually takes more than one */
+        k = 0;
+        for (; k < 5 && k < borg_skill[BI_ACSW]; k++) value += 25000L;
+    }
+    if (borg_skill[BI_ISPOISONED] && borg_skill[BI_ACUREPOIS]) value +=15000;
+    if (borg_skill[BI_ISPOISONED] && amt_slow_poison) value +=5000;
+
+    /* Reward cure serious -- only reward serious if low on crits */
+    if (borg_skill[BI_ACCW] < 10 && (borg_skill[BI_CLEVEL] < 35 || !borg_skill[BI_RCONF]))
+    {
+        k = 0;
+        for (; k <  5 && k < borg_skill[BI_ACSW]; k++) value += 5000L;
+        for (; k < 10 && k < borg_skill[BI_ACSW]; k++) value += 200L;
+    }
+
+    /* Priests and Paladins tend to rely on Spell but should carry pots */
+    if ((borg_class == CLASS_PRIEST ||
+         borg_class == CLASS_PALADIN) && borg_skill[BI_CLEVEL] > 2)
+    {
+        k = 0;
+        for (; k < 3 && k < borg_has[242]; k++) value += 3000L;
+    }
+
+    /* Reward *Heal*, Life, and Heal pots only if we actually
+     * need them right now.  The borg would prefere to carry
+     * the 25 heals and 15 ez_heals as he collects more.  But
+     * if he does not have ICold the pots shatter too often,
+     * taking forever for him to gather more.  The goal here,
+     * is to have him store all the pots in the house until he
+     * is ready to take on Morgoth/Sauron.  Generally its not
+     * a problem but we cannot make it depth dependant since
+     * Sauron is on 99, and Morgoth on 100.
+     */
+    /* Collecting Potions, prepping for Morgoth fight */
+    if (borg_skill[BI_MAXDEPTH] >= 99)
+    {
+        /* Sauron is alive -- carry them all*/
+        if (borg_race_death[546] == 0)
+        {
+            k = 0;
+            for (; k < 99 && k < borg_has[242]; k++) value += 8000L;
+            k = 0;
+            for (; k < 99 && k < borg_skill[BI_AEZHEAL]; k++) value +=10000L;
+            k =0;
+            for (; k < 99 && k < borg_skill[BI_ASPEED]; k++) value +=8000L;
+            /* Restore Mana */
+            k = 0;
+            for (; k < 99 && k < borg_has[266]; k++) value += 5000L;
+
+        }
+        /* Sauron is dead -- store them unless I have enough */
+        if (borg_race_death[546] != 0)
+        {
+            /* Must know exact number of Potions  in home */
+            borg_notice_home(NULL, FALSE);
+
+            /* Must scum for more pots */
+            if ((num_heal_true + borg_has[242] +
+                 num_ez_heal_true + borg_skill[BI_AEZHEAL] < 45) ||
+                (num_ez_heal_true + borg_skill[BI_AEZHEAL] < 30) ||
+                (num_speed + borg_skill[BI_ASPEED] < 15))
+            {
+                /* leave these potions at home so they dont shatter */
+
+                /* dont carry around other stuff that should be saved
+                 * until he has all his potions.
+                 */
+
+            }
+            /* I have enough, carry all */
+            else
+            {
+
+                k = 0;
+                for (; k < 99 && k < borg_has[242]; k++) value += 8000L;
+                k = 0;
+                for (; k < 99 && k < borg_skill[BI_AEZHEAL]; k++) value +=10000L;
+                k =0;
+                for (; k < 99 && k < borg_skill[BI_ASPEED]; k++) value +=7000L;
+                /* Restore Mana */
+                k = 0;
+                for (; k < 99 && k < borg_has[266]; k++) value += 5000L;
+                /* Shrooms of Restoring */
+                k = 0;
+                for (; k < 35 && k < amt_fix_stat[6]; k++) value += 5000L;
+
+            }
+        }
+    }
+
+    /* Reward Speed ability */
+    if (borg_skill[BI_CDEPTH] <= 98)
+    {
+        k =0;
+        for (; k < 20 && k < borg_skill[BI_ASPEED]; k++) value += 5000L;
+    }
+    /* Reward cure serious -- Low Level Characters */
+    if (borg_skill[BI_CLEVEL] < 15)
+    {
+        k = 0;
+        for (; k <  5 && k < borg_skill[BI_ACSW]; k++) value += 5000L;
+        for (; k < 10 && k < borg_skill[BI_ACSW]; k++) value += 200L;
+    }
+
+    /* Hack -- Reward add stat */
+    if (amt_add_stat[A_STR]) value += 50000;
+    if (amt_add_stat[A_INT]) value += 20000;
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+        if (amt_add_stat[A_INT]) value += 75000;
+
+    if (amt_add_stat[A_WIS]) value += 20000;
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+        if (amt_add_stat[A_WIS]) value += 75000;
+    if (amt_add_stat[A_DEX]) value += 50000;
+    if (amt_add_stat[A_CON]) value += 50000;
+    if (amt_add_stat[A_CHR]) value += 10000;
+
+	/* Hack -- Reward stat potions */
+    if (amt_inc_stat[A_STR] && my_stat_cur[A_STR] < (18+100)) value += 550000;
+    if (amt_inc_stat[A_INT] && my_stat_cur[A_INT] < (18+100)) value += 520000;
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+        if (amt_inc_stat[A_INT] && my_stat_cur[A_INT] < (18+100)) value += 575000;
+    if (amt_inc_stat[A_WIS] && my_stat_cur[A_WIS] < (18+100)) value += 520000;
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+        if (amt_inc_stat[A_WIS] && my_stat_cur[A_WIS] < (18+100)) value += 575000;
+    if (amt_inc_stat[A_DEX] && my_stat_cur[A_DEX] < (18+100)) value += 550000;
+    if (amt_inc_stat[A_CON] && my_stat_cur[A_CON] < (18+100)) value += 550000;
+    if (amt_inc_stat[A_CHR] && my_stat_cur[A_CHR] < (18+100)) value += 510000;
+
+    /* Hack -- Reward fix stat */
+    if (amt_fix_stat[A_STR]) value += 10000;
+    if (amt_fix_stat[A_INT]) value += 10000;
+    if (amt_fix_stat[A_WIS]) value += 10000;
+    if (amt_fix_stat[A_DEX]) value += 10000;
+    if (amt_fix_stat[A_CON]) value += 10000;
+    if (amt_fix_stat[A_CHR]) value += 10000;
+
+    /* Reward Remove Curse */
+    if (borg_wearing_cursed)
+    {
+        if (borg_has[191]) value += 90000;
+        if (borg_has[180]) value += 90000;
+    }
+
+
+    /* Hack -- Restore experience */
+    if (amt_fix_exp)
+    {
+        value += 50000;
+    }
+
+    /*** Enchantment ***/
+
+    /* Reward enchant armor */
+    if (amt_enchant_to_a && my_need_enchant_to_a) value += 1400L;
+
+    /* Reward enchant weapon to hit */
+    if (amt_enchant_to_h && my_need_enchant_to_h) value += 2400L;
+
+    /* Reward enchant weapon to damage */
+    if (amt_enchant_to_d && my_need_enchant_to_d) value += 3000L;
+
+    /* Reward *enchant weapon* to damage */
+    if (amt_enchant_weapon) value += 5000L;
+
+    /* Reward *enchant armour*  */
+    if (amt_enchant_armor) value += 5000L;
+
+    /* Reward carrying a shovel if low dlevel */
+    /* if (borg_skill[BI_MAXDEPTH] <= 54 && borg_items[INVEN_WIELD].tval != TV_DIGGING   &&
+        amt_digger == 1 && borg_class != CLASS_WARRIOR) value += 5000L; */
+
+
+
+    /*** Hack -- books ***/
+
+    /* Reward low level books */
+    for (book = 0; book < 4; book++)
+    {
+        int what, when = 99;
+
+        /* No copies */
+        if (!amt_book[book]) continue;
+
+        /* Scan the spells */
+        for (what = 0; what < 9; what++)
+        {
+            borg_magic *as = &borg_magics[book][what];
+
+            /* Track minimum level */
+            if (as->level < when) when = as->level;
+        }
+        /* Hack -- Ignore "difficult" normal books */
+        if ((when > 5) && (when >= borg_skill[BI_MAXCLEVEL] + 2)) continue;
+
+        /* Reward the book */
+        k = 0;
+        for (; k < 1 && k < amt_book[book]; k++) value += 500000L;
+        if (borg_skill[BI_STR] > 15)
+            for (; k < 2 && k < amt_book[book]; k++) value += 10000L;
+        if (borg_skill[BI_MAXDEPTH] > 50)
+            for (; k < 3 && k < amt_book[book]; k++) value += 2500L;
+    }
+    /* Hack -- Apply "encumbrance" from weight */
+    /* Extract the current weight (in tenth pounds) */
+    inven_weight = p_ptr->total_weight;
+
+    /* Extract the "weight limit" (in tenth pounds) */
+    carry_capacity = adj_str_wgt[my_stat_ind[A_STR]] * 100;
+
+    /* XXX XXX XXX Apply "encumbrance" from weight */
+    if (inven_weight > carry_capacity/2) value -= ((inven_weight - (carry_capacity/2)) / (carry_capacity / 10) *1000L);
+
+    /* Reward empty slots (up to 5) */
+    k = 1;
+        for (; k < 6; k++)
+            if (!borg_items[INVEN_PACK-k].iqty)
+                value += 400L;
+
+	/* Hack-- Reward the borg for carrying a NON*ID* item
+	 * this way he will pull it from the house and *ID* it.
+	 */
+	if (amt_ego ||
+	    ((borg_items[INVEN_OUTER].name2 == EGO_AMAN ||
+	     borg_items[INVEN_OUTER].name2 == EGO_ELVENKIND) &&
+	     !borg_items[INVEN_OUTER].fully_identified)) value += 999999L;
+
+
+    /* Reward Teleport Level scrolls */
+	/* NOTE: this entry was not working in the borg.txt file
+	 * I have no idea why.  Once it is working delete this:
+	 */
+    k = 0;
+	for (; k <  5 && k < borg_skill[BI_ATELEPORTLVL]; k++) value += 5000L;
+
+    /* Return the value */
+    return (value);
+}
+
+
+/*
+ * Helper function -- calculate "power" of equipment
+ * Dynamic Calcs off
+ */
+static s32b borg_power_aux3(void)
+{
+    int         hold;
+    int         damage, dam;
+
+    int         i;
+
+    int         cur_wgt = 0;
+    int         max_wgt = 0;
+
+    s32b        value = 0L;
+
+    borg_item       *item;
+
+
+    /* Obtain the "hold" value (weight limit for weapons) */
+    hold = adj_str_hold[my_stat_ind[A_STR]];
+
+    /*** Analyze weapon ***/
+
+    /* Examine current weapon */
+    item = &borg_items[INVEN_WIELD];
+
+    /* Calculate "average" damage per "normal" blow  */
+    /* and assume we can enchant up to +8 if borg_skill[BI_CLEVEL] > 25 */
+    damage = (item->dd * item->ds * 20L);
+
+
+    /* Reward "damage" and increased blows per round*/
+    value += damage * (borg_skill[BI_BLOWS]+1);
+
+    /* Reward "bonus to hit" */
+    value += ((borg_skill[BI_TOHIT] + item->to_h)*100L );
+
+    /* Reward "bonus to dam" */
+    value += ((borg_skill[BI_TODAM] + item->to_d)*30L);
+
+    /* extra damage for some */
+    if (borg_worships_damage)
+    {
+        value += ((borg_skill[BI_TOHIT] + item->to_h)*15L);
+    }
+
+    /* extra boost for deep dungeon */
+    if (borg_skill[BI_MAXDEPTH] >= 75)
+    {
+        value += ((borg_skill[BI_TOHIT] + item->to_h)*15L);
+
+        value += item->dd *
+                 item->ds * 20L *
+                 2 * borg_skill[BI_BLOWS];
+    }
+
+    /* assume 2x base damage for x% of creatures */
+    dam = damage * 2 * borg_skill[BI_BLOWS];
+    if (borg_skill[BI_WS_ANIMAL]) value += (dam * 2) / 2;
+    if (borg_skill[BI_WS_EVIL])   value += (dam * 7) / 2;
+
+    /* extra damage for some */
+    if (borg_worships_damage)
+    {
+        value += (dam);
+    }
+
+    /* assume 3x base damage for x% of creatures */
+    dam = damage  * 3 * borg_skill[BI_BLOWS];
+    if (borg_skill[BI_WS_UNDEAD] && (!borg_skill[BI_WK_UNDEAD])) value += (dam * 5) / 2;
+    if (borg_skill[BI_WS_DEMON] && (!borg_skill[BI_WK_DEMON]))  value += (dam * 3) / 2;
+    if (borg_skill[BI_WS_DRAGON] && (!borg_skill[BI_WK_DRAGON])) value += (dam * 6) / 2;
+    if (borg_skill[BI_WS_GIANT])  value += (dam * 4) / 2;
+    if (borg_skill[BI_WB_ACID])  value += (dam * 4) / 2;
+    if (borg_skill[BI_WB_ELEC])  value += (dam * 5) / 2;
+    if (borg_skill[BI_WB_FIRE])  value += (dam * 3) / 2;
+    if (borg_skill[BI_WB_COLD])  value += (dam * 3) / 2;
+    /* SOrc and STroll get 1/2 of reward now */
+    if (borg_skill[BI_WS_ORC] )    value += (dam * 1) / 2;
+    if (borg_skill[BI_WS_TROLL] )  value += (dam * 2) / 2;
+    /* and the other 2/2 if SEvil not possesed */
+    if (borg_skill[BI_WS_ORC] && !borg_skill[BI_WS_EVIL])    value += (dam * 1) / 2;
+    if (borg_skill[BI_WS_TROLL] && !borg_skill[BI_WS_EVIL])  value += (dam * 1) / 2;
+
+    /* extra damage for some */
+    if (borg_worships_damage)
+    {
+        value += (dam);
+    }
+
+    /* assume 5x base damage for x% of creatures */
+    dam = damage  * 5 * borg_skill[BI_BLOWS];
+    if (borg_skill[BI_WK_UNDEAD]) value += (dam * 3) / 2;
+    if (borg_skill[BI_WK_DEMON]) value += (dam * 3) / 2;
+    if (borg_skill[BI_WK_DRAGON]) value += (dam * 5) / 2;
+    /* extra damage for some */
+    if (borg_worships_damage)
+    {
+        value += (dam);
+    }
+
+    /* It is only on Grond */
+    if (borg_skill[BI_W_IMPACT]) value += 5000L;
+
+    /* Hack -- It is hard to hold a heavy weapon */
+    if (borg_skill[BI_HEAVYWEPON]) value -= 500000L;
+
+    /* HACK -- Borg worships num_blow, even on broken swords. */
+    /* kind 47 is a broken sword usually 1d2 in damage */
+    if (item->kind == 47 || item->kind == 30 ||item->kind == 390 ) value -=90000L;
+
+
+	/* We want low level borgs to have high blows (dagger, whips) */
+	if (borg_skill[BI_CLEVEL] <= 10) value += borg_skill[BI_BLOWS] * 45000L;
+
+    /*** Analyze bow ***/
+
+    /* Examine current bow */
+    item = &borg_items[INVEN_BOW];
+
+    /* Calculate "average" damage per "normal" shot (times 2) */
+    if ( item->to_d > 8 || borg_skill[BI_CLEVEL] < 25 )
+        damage = ((my_ammo_sides) + (item->to_d)) * my_ammo_power;
+    else
+        damage = (my_ammo_sides + 8) * my_ammo_power;
+
+    /* Reward "damage" */
+    if (borg_worships_damage)
+    {
+        value += (borg_skill[BI_SHOTS] * damage * 11L);
+    }
+    else
+    {
+        value += (borg_skill[BI_SHOTS] * damage * 9L);
+    }
+
+	/* Extra bonus for low levels, they need a ranged weap */
+	if (borg_skill[BI_CLEVEL] < 15) value += (borg_skill[BI_SHOTS] * damage * 200L);
+
+
+    /* AJG - slings force you to carry heavy ammo.  Penalty for that unles you have lots of str  */
+    if (item->sval == SV_SLING &&
+        !item->name1 &&
+        my_stat_ind[A_STR] < 9)
+    {
+        value -= 5000L;
+    }
+
+
+    /* Reward "bonus to hit" */
+    value += ((borg_skill[BI_TOHIT] + item->to_h)*100L);;
+
+    /* extra damage for some */
+    if (borg_worships_damage)
+    {
+        value += ((borg_skill[BI_TOHIT] + item->to_h) * 25L);
+    }
+
+
+    /* Prefer bows */
+    if (cp_ptr->flags & CF_EXTRA_SHOT && my_ammo_tval == TV_ARROW) value += 30000L;
+
+    /* Hack -- It is hard to hold a heavy weapon */
+    if (hold < item->weight / 10) value -= 500000L;
+
+
+
+    /*** apw Analyze dragon armour  ***/
+
+    /* Examine current armor */
+    item = &borg_items[INVEN_BODY];
+
+    if (item->tval == TV_DRAG_ARMOR)
+      {
+          switch( item->sval)
+          {
+              case SV_DRAGON_BLACK:
+              case SV_DRAGON_BLUE:
+              case SV_DRAGON_WHITE:
+              case SV_DRAGON_RED:
+                  value += 1100;
+                  break;
+              case SV_DRAGON_GREEN:
+                  value += 2750;
+                  break;
+              case SV_DRAGON_MULTIHUED:
+                  value += 3250;
+                  break;
+              case SV_DRAGON_SHINING:
+              case SV_DRAGON_LAW:
+              case SV_DRAGON_BRONZE:
+              case SV_DRAGON_GOLD:
+              case SV_DRAGON_CHAOS:
+              case SV_DRAGON_BALANCE:
+              case SV_DRAGON_POWER:
+                  value += 5150;
+          }
+      }
+
+
+    /*** Reward various things ***/
+
+    /* Hack -- Reward light radius */
+    if (borg_skill[BI_CURLITE] <= 3) value += (borg_skill[BI_CURLITE] * 1000000L);
+    if (borg_skill[BI_CURLITE] > 3) value += (3000000L) + (borg_skill[BI_CURLITE] * 1000);
+
+
+
+    /* Hack -- Reward speed
+     * see if speed can be a bonus if good speed; not +3.
+     * reward higher for +10 than +50 speed (decreased return).
+     */
+    if (borg_worships_speed)
+    {
+        if (borg_skill[BI_SPEED] >= 150)
+            value += (((borg_skill[BI_SPEED] - 120) * 1500L) + 185000L);
+
+        if (borg_skill[BI_SPEED] >= 145 && borg_skill[BI_SPEED] <= 149)
+            value += (((borg_skill[BI_SPEED] - 120) * 1500L) + 180000L);
+
+        if (borg_skill[BI_SPEED] >= 140 && borg_skill[BI_SPEED] <= 144)
+            value += (((borg_skill[BI_SPEED] - 120) * 1500L) + 175000L);
+
+        if (borg_skill[BI_SPEED] >= 135 && borg_skill[BI_SPEED] <= 139)
+            value += (((borg_skill[BI_SPEED] - 120) * 1500L) + 175000L);
+
+        if (borg_skill[BI_SPEED] >= 130 && borg_skill[BI_SPEED] <= 134)
+            value += (((borg_skill[BI_SPEED] - 120) * 1500L) + 160000L);
+
+        if (borg_skill[BI_SPEED] >= 125 && borg_skill[BI_SPEED] <= 129)
+            value += (((borg_skill[BI_SPEED] - 110) * 1500L) + 135000L);
+
+        if (borg_skill[BI_SPEED] >= 120 && borg_skill[BI_SPEED] <= 124)
+            value += (((borg_skill[BI_SPEED] - 110) * 1500L) + 110000L);
+
+        if (borg_skill[BI_SPEED] >= 115 && borg_skill[BI_SPEED] <= 119)
+            value += (((borg_skill[BI_SPEED] - 110) * 1500L) +  85000L);
+
+        if (borg_skill[BI_SPEED] >= 110 && borg_skill[BI_SPEED] <= 114)
+            value += (((borg_skill[BI_SPEED] - 110) * 1500L) +  65000L);
+        else
+            value += (((borg_skill[BI_SPEED] -110) *2500L));
+    }
+    else
+    {
+        if (borg_skill[BI_SPEED] >= 150)
+            value += (((borg_skill[BI_SPEED] - 120) * 1000L) + 185000L);
+
+        if (borg_skill[BI_SPEED] >= 145 && borg_skill[BI_SPEED] <= 149)
+            value += (((borg_skill[BI_SPEED] - 120) * 1000L) + 180000L);
+
+        if (borg_skill[BI_SPEED] >= 140 && borg_skill[BI_SPEED] <= 144)
+            value += (((borg_skill[BI_SPEED] - 120) * 1000L) + 175000L);
+
+        if (borg_skill[BI_SPEED] >= 135 && borg_skill[BI_SPEED] <= 139)
+            value += (((borg_skill[BI_SPEED] - 120) * 1000L) + 165000L);
+
+        if (borg_skill[BI_SPEED] >= 130 && borg_skill[BI_SPEED] <= 134)
+            value += (((borg_skill[BI_SPEED] - 120) * 1000L) + 150000L);
+
+        if (borg_skill[BI_SPEED] >= 125 && borg_skill[BI_SPEED] <= 129)
+            value += (((borg_skill[BI_SPEED] - 110) * 1000L) + 125000L);
+
+        if (borg_skill[BI_SPEED] >= 120 && borg_skill[BI_SPEED] <= 124)
+            value += (((borg_skill[BI_SPEED] - 110) * 1000L) + 100000L);
+
+        if (borg_skill[BI_SPEED] >= 115 && borg_skill[BI_SPEED] <= 119)
+            value += (((borg_skill[BI_SPEED] - 110) * 1000L) +  75000L);
+
+        if (borg_skill[BI_SPEED] >= 110 && borg_skill[BI_SPEED] <= 114)
+            value += (((borg_skill[BI_SPEED] - 110) * 1000L) +  55000L);
+        else
+            value += (((borg_skill[BI_SPEED] -110) *2500L));
+    }
+
+
+    /* Hack -- Reward strength bonus */
+    value += (my_stat_ind[A_STR] * 100L);
+
+    /* Hack -- Reward intelligence bonus */
+    if ((cp_ptr->spell_book == TV_MAGIC_BOOK) &&
+        (my_stat_ind[A_INT] <= 37 ))
+    {
+        value += (my_stat_ind[A_INT] * 500L);
+
+        /* Bonus for sp. */
+        if (borg_worships_mana)
+        {
+            value += ((adj_mag_mana[my_stat_ind[A_INT]] * borg_skill[BI_CLEVEL]) / 2)  * 255L;
+        }
+        else
+        {
+            value += ((adj_mag_mana[my_stat_ind[A_INT]] * borg_skill[BI_CLEVEL]) / 2)  * 155L;
+        }
+
+        /* bonus for fail rate */
+        value += adj_mag_stat[my_stat_ind[A_INT]] * 5010L;
+
+        /* mage should try to get min fail to 0 */
+        if (cp_ptr->flags & CF_ZERO_FAIL)
+        {
+            /* other fail rates */
+            if (adj_mag_fail[my_stat_ind[A_INT]] < 1)
+                value += 90000L;
+        }
+    }
+
+    /* Hack -- Reward wisdom bonus */
+    if ((cp_ptr->spell_book == TV_PRAYER_BOOK) &&
+        (my_stat_ind[A_WIS] <= 37 ))
+    {
+        value += (my_stat_ind[A_WIS] * 200L);
+
+        /* Bonus for sp. */
+        value += ((adj_mag_mana[my_stat_ind[A_WIS]] * borg_skill[BI_CLEVEL]) / 2)  * 150L;
+
+        /* bonus for fail rate */
+        value += adj_mag_stat[my_stat_ind[A_WIS]] * 3000L;
+
+        /* priest should try to get min fail to 0 */
+        if (cp_ptr->flags & CF_ZERO_FAIL)
+        {
+            /* Bonus for priests to in order to keep Holy Word fail rate down */
+            if (borg_prayer_legal(3, 5)) value += my_stat_ind[A_WIS] * 35000L;
+
+            if (adj_mag_fail[my_stat_ind[A_WIS]] < 1)
+                value += 70000L;
+        }
+
+    }
+
+
+    /* Dexterity Bonus --good for attacking and ac*/
+    if (my_stat_ind[A_DEX] <= 37 )
+    {
+        /* Hack -- Reward bonus */
+        value += (my_stat_ind[A_DEX] * 120L);
+    }
+
+    /* Constitution Bonus */
+    if (my_stat_ind[A_CON] <= 37 )
+    {
+        int bonus_hp = (((adj_con_mhp[my_stat_ind[A_CON]] -128) * borg_skill[BI_MAXCLEVEL]) / 2);
+
+        if (borg_worships_hp)
+        {
+            value += (my_stat_ind[A_CON] * 250L);
+            /* Hack -- Reward hp bonus */
+            /*         This is a bit wierd because we are not really giving a bonus for */
+            /*         what hp you have, but for the 'bonus' hp you get */
+            /*         getting over 800hp is very important. */
+            if (bonus_hp < 800)
+                value += bonus_hp * 450L;
+            else
+                value += (bonus_hp-800) * 100L + (350L * 500);
+        }
+        else /*does not worship hp */
+        {
+            value += (my_stat_ind[A_CON] * 150L);
+            /* Hack -- Reward hp bonus */
+            /*         This is a bit wierd because we are not really giving a bonus for */
+            /*         what hp you have, but for the 'bonus' hp you get */
+            /*         getting over 500hp is very important. */
+            if (bonus_hp < 500)
+                value += bonus_hp * 350L;
+            else
+                value += (bonus_hp-500) * 100L + (350L * 500);
+        }
+
+    }
+
+
+    /* Hack -- Reward charisma bonus up to level 25 */
+    if (borg_skill[BI_CLEVEL] < 25)
+        value += (my_stat_ind[A_CHR] * 2L);
+
+
+
+    /* HACK - a small bonus for adding to stats even above max. */
+    /*        This will allow us to swap a ring of int +6 for */
+    /*        our ring of int +2 even though we are at max int because */
+    /*        we are wielding a weapon that has +4 int */
+    /*        later it might be nice to swap to a weapon that does not */
+    /*        have an int bonus */
+    for (i = 0; i < 6; i++) value += my_stat_add[i];
+
+
+    /*** Reward current skills ***/
+
+    /* Hack -- tiny rewards */
+    value += (borg_skill[BI_DIS] * 2L);
+    value += (borg_skill[BI_DEV] * 25L);
+    value += (borg_skill[BI_SAV] * 25L);
+    /* perfect saves are very nice */
+    if (borg_skill[BI_SAV] > 99)
+        value += 10000;
+    value += (borg_skill[BI_STL] * 2L);
+    value += (borg_skill[BI_SRCH] * 1L);
+    value += (borg_skill[BI_SRCHFREQ] * 1L);
+    value += (borg_skill[BI_THN] * 5L);
+    value += (borg_skill[BI_THB] * 35L);
+    value += (borg_skill[BI_THT] * 2L);
+    value += (borg_skill[BI_DIG] * 2L);
+
+
+    /*** Reward current flags ***/
+
+    /* Various flags */
+    if (borg_skill[BI_SDIG]) value  += 750L;
+
+    /* Feather Fall if low level is nice */
+    if (borg_skill[BI_MAXDEPTH] < 20)
+    {
+        if (borg_skill[BI_FEATH]) value    += 500L;
+    }
+    else
+    {
+        if (borg_skill[BI_FEATH]) value     +=50;
+    }
+
+    if (borg_skill[BI_LITE]) value         += 2000L;
+
+    if (borg_skill[BI_ESP])
+    {
+        if (borg_skill[BI_SINV]) value      += 500L;
+    }
+
+    if (!borg_skill[BI_DINV])
+    {
+		if (borg_skill[BI_SINV]) value      += 5000L;
+	}
+
+    if (borg_skill[BI_FRACT]) value     += 10000L;
+
+    /* after you max out you are pretty safe from drainers.*/
+    if (borg_skill[BI_MAXCLEVEL] < 50)
+    {
+        if (borg_skill[BI_HLIFE]) value    += 2000L;
+    }
+    else
+    {
+        if (borg_skill[BI_HLIFE]) value    += 200L;
+    }
+    if (borg_skill[BI_REG]) value   += 2000L;
+    if (borg_skill[BI_ESP]) value    += 80000L;
+
+    /* Immunity flags */
+    if (borg_skill[BI_ICOLD]) value  += 25000L;
+    if (borg_skill[BI_IELEC]) value  += 40000L;
+    if (borg_skill[BI_IFIRE]) value  += 60000L;
+    if (borg_skill[BI_IACID]) value  += 80000L;
+
+    /* Resistance flags */
+    if (borg_skill[BI_RCOLD]) value  += 3000L;
+    if (borg_skill[BI_RELEC]) value  += 4000L;
+    if (borg_skill[BI_RACID]) value  += 6000L;
+    if (borg_skill[BI_RFIRE]) value  += 8000L;
+    /* extra bonus for getting all basic resist */
+    if (borg_skill[BI_RFIRE] &&
+        borg_skill[BI_RACID] &&
+        borg_skill[BI_RELEC] &&
+        borg_skill[BI_RCOLD]) value +=  10000L;
+    if (borg_skill[BI_RPOIS]) value  += 20000L;
+    if (borg_skill[BI_RSND]) value += 3500L;
+    if (borg_skill[BI_RLITE]) value  += 800L;
+    if (borg_skill[BI_RDARK]) value  += 800L;
+    if (borg_skill[BI_RKAOS]) value += 5000L;
+
+    /* this is way boosted to avoid carrying stuff you don't need */
+    if (borg_skill[BI_RCONF]) value  += 80000L;
+
+    /* mages need a slight boost for this */
+    if (borg_class == CLASS_MAGE && borg_skill[BI_RCONF]) value +=2000L;
+    if (borg_skill[BI_RDIS]) value += 5000L;
+    if (borg_skill[BI_RSHRD]) value += 100L;
+    if (borg_skill[BI_RNXUS]) value += 100L;
+    if (borg_skill[BI_RBLIND]) value += 5000L;
+    if (borg_skill[BI_RNTHR]) value  += 5500L;
+    if (borg_skill[BI_RFEAR]) value  += 2000L;
+
+    /* Sustain flags */
+    if (borg_skill[BI_SSTR]) value += 50L;
+    if (borg_skill[BI_SINT]) value += 50L;
+    if (borg_skill[BI_SWIS]) value += 50L;
+    if (borg_skill[BI_SCON]) value += 50L;
+    if (borg_skill[BI_SDEX]) value += 50L;
+    /* boost for getting them all */
+    if (borg_skill[BI_SSTR] &&
+        borg_skill[BI_SINT] &&
+        borg_skill[BI_SWIS] &&
+        borg_skill[BI_SDEX] &&
+        borg_skill[BI_SCON])  value += 1000L;
+
+
+    /*** XXX XXX XXX Reward "necessary" flags ***/
+
+    /* Mega-Hack -- See invisible (level 10) */
+    if ((borg_skill[BI_SINV] || borg_skill[BI_ESP]) && (borg_skill[BI_MAXDEPTH]+1 >= 10)) value += 100000L;
+
+
+    /* Mega-Hack -- Free action (level 20) */
+    if (borg_skill[BI_FRACT] && (borg_skill[BI_MAXDEPTH]+1 >= 20)) value += 100000L;
+
+
+    /*  Mega-Hack -- resists (level 25) */
+    if (borg_skill[BI_RFIRE] && (borg_skill[BI_MAXDEPTH]+1 >= 25)) value += 100000L;
+
+
+    /*  Mega-Hack -- resists (level 40) */
+    if (borg_skill[BI_RPOIS] && (borg_skill[BI_MAXDEPTH]+1 >= 40)) value += 100000L;
+    if (borg_skill[BI_RELEC] && (borg_skill[BI_MAXDEPTH]+1 >= 40)) value += 100000L;
+    if (borg_skill[BI_RACID] && (borg_skill[BI_MAXDEPTH]+1 >= 40)) value += 100000L;
+    if (borg_skill[BI_RCOLD] && (borg_skill[BI_MAXDEPTH]+1 >= 40)) value += 100000L;
+
+
+    /* APW Mega-Hack -- Speed / Hold Life (level 46) and maxed out */
+    if ((borg_skill[BI_HLIFE] && (borg_skill[BI_MAXDEPTH]+1 >= 46) && (borg_skill[BI_MAXCLEVEL] < 50))) value += 100000L;
+    if ((borg_skill[BI_SPEED] >= 115) && (borg_skill[BI_MAXDEPTH]+1 >=46)) value +=100000L;
+    if (borg_skill[BI_RCONF] && (borg_skill[BI_MAXDEPTH]+1 >= 46)) value += 100000L;
+
+    /*  Mega-Hack -- resist Nether is -very- nice to have at level 50 */
+    if (borg_skill[BI_RNTHR]  && (borg_skill[BI_MAXDEPTH]+1 >= 50)) value += 55000L;
+
+    /*  Mega-Hack -- resist Sound to avoid being KO'd */
+    if (borg_skill[BI_RSND]  && (borg_skill[BI_MAXDEPTH]+1 >= 50)) value += 100000L;
+
+    /*  Mega-Hack -- resists & Telepathy (level 55) */
+    if (borg_skill[BI_RBLIND] && (borg_skill[BI_MAXDEPTH]+1 >= 55)) value += 100000L;
+    if (borg_skill[BI_ESP] && (borg_skill[BI_MAXDEPTH]+1 >= 55)) value += 100000L;
+    if (borg_skill[BI_RNTHR]  && (borg_skill[BI_MAXDEPTH]+1 >= 60)) value += 55000L;
+
+
+    /*  Mega-Hack -- resists & +10 speed (level 60) */
+    if (borg_skill[BI_RKAOS] && (borg_skill[BI_MAXDEPTH]+1 >= 60)) value += 104000L;
+    if (borg_skill[BI_RDIS] && (borg_skill[BI_MAXDEPTH]+1 >= 60)) value += 90000L;
+    if ((borg_skill[BI_SPEED] >= 120) && (borg_skill[BI_MAXDEPTH]+1 >=60)) value +=100000L;
+
+    /*  Must have +20 speed (level 80) */
+    if ((borg_skill[BI_SPEED] >= 130) && (borg_skill[BI_MAXDEPTH]+1 >=80)) value +=100000L;
+
+    /* Not Req, but a good idea:
+     * Extra boost to Nether deeper down
+     * RDark for deeper uniques
+     * Good to have +30 speed
+     */
+    if (borg_skill[BI_RNTHR] && (borg_skill[BI_MAXDEPTH]+1 >= 80)) value += 15000L;
+    if (borg_skill[BI_RDARK] && (borg_skill[BI_MAXDEPTH]+1 >= 80)) value += 25000L;
+    if ((borg_skill[BI_SPEED] >= 140) && (borg_skill[BI_MAXDEPTH]+1 >=80) &&
+        borg_class == CLASS_WARRIOR)                value += 100000L;
+
+
+    /*** Reward powerful armor ***/
+
+    /* Reward armor */
+    if (borg_worships_ac)
+    {
+        if (borg_skill[BI_ARMOR] < 15) value += ((borg_skill[BI_ARMOR]) * 2500L);
+        if (borg_skill[BI_ARMOR] >= 15 && borg_skill[BI_ARMOR] < 75) value += ((borg_skill[BI_ARMOR]) * 2000L) + 28250L;
+        if (borg_skill[BI_ARMOR] >= 75) value += ((borg_skill[BI_ARMOR]) * 1500L) + 73750L;
+    }
+    else
+    {
+        if (borg_skill[BI_ARMOR] < 15)   value += ((borg_skill[BI_ARMOR]) * 2000L);
+        if (borg_skill[BI_ARMOR] >= 15 &&
+            borg_skill[BI_ARMOR] < 75)   value += ((borg_skill[BI_ARMOR]) * 500L) + 28350L;
+        if (borg_skill[BI_ARMOR] >= 75) value += ((borg_skill[BI_ARMOR]) * 100L) + 73750L;
+    }
+
+
+	/* Hack-- Reward the borg for carrying a NON*ID* item
+	 * this way he will pull it from the house and *ID* it.
+	 */
+	if (amt_ego ||
+	    ((borg_items[INVEN_OUTER].name2 == EGO_AMAN ||
+	     borg_items[INVEN_OUTER].name2 == EGO_ELVENKIND) &&
+	     !borg_items[INVEN_OUTER].fully_identified)) value += 999999L;
+
+
+    /*** Penalize various things ***/
+
+    /* Penalize various flags */
+    if (borg_skill[BI_CRSTELE]) value -= 100000L;
+    if (borg_class == CLASS_MAGE && borg_skill[BI_CRSAGRV]) value -= 8000L;
+    else if (borg_skill[BI_CRSAGRV]) value -= 80000L;
+
+
+    /*** Penalize armor weight ***/
+    if (my_stat_ind[A_STR] < 15)
+    {
+        if (borg_items[INVEN_BODY].weight > 200)
+            value -= (borg_items[INVEN_BODY].weight - 200) * 15;
+        if (borg_items[INVEN_HEAD].weight > 30)
+            value -= 250;
+        if (borg_items[INVEN_ARM].weight > 10)
+            value -= 250;
+        if (borg_items[INVEN_FEET].weight > 50)
+            value -= 250;
+    }
+
+    /* Compute the total armor weight */
+    cur_wgt += borg_items[INVEN_BODY].weight;
+    cur_wgt += borg_items[INVEN_HEAD].weight;
+    cur_wgt += borg_items[INVEN_ARM].weight;
+    cur_wgt += borg_items[INVEN_OUTER].weight;
+    cur_wgt += borg_items[INVEN_HANDS].weight;
+    cur_wgt += borg_items[INVEN_FEET].weight;
+
+    /* Determine the weight allowance */
+    max_wgt = cp_ptr->spell_weight;
+
+    /* Hack -- heavy armor hurts magic */
+    if (cp_ptr->spell_book &&
+        (((cur_wgt - max_wgt) / 10) > 0) &&
+        ((adj_mag_mana[my_stat_ind[A_INT]] * borg_skill[BI_CLEVEL]) / 2) < 150)
+    {
+        /* Mega-Hack -- Penalize heavy armor which hurts mana */
+        if (borg_skill[BI_MAXSP] >= 300 && borg_skill[BI_MAXSP] <= 350)
+            value -= (((cur_wgt - max_wgt) / 10) * 400L);
+        if (borg_skill[BI_MAXSP] >= 200 && borg_skill[BI_MAXSP] <= 299)
+            value -= (((cur_wgt - max_wgt) / 10) * 800L);
+        if (borg_skill[BI_MAXSP] >= 100 && borg_skill[BI_MAXSP] <= 199)
+            value -= (((cur_wgt - max_wgt) / 10) * 1600L);
+        if (borg_skill[BI_MAXSP] >= 1 && borg_skill[BI_MAXSP] <= 99)
+            value -= (((cur_wgt - max_wgt) / 10) * 3200L);
+    }
+
+
+    /*** Penalize bad magic ***/
+
+    /* Hack -- most gloves hurt magic for spell-casters */
+    if (cp_ptr->flags & CF_CUMBER_GLOVE && borg_class == CLASS_MAGE)
+    {
+        item = &borg_items[INVEN_HANDS];
+
+        /* Penalize non-usable gloves */
+        if (item->iqty &&
+            (!(item->flags3 & TR3_FREE_ACT)) &&
+            (!((item->flags1 & TR1_DEX) && (item->pval > 0))))
+        {
+            /* Hack -- Major penalty */
+            value -= 275000L;
+        }
+    }
+
+    /* apw Hack -- most edged weapons hurt magic for priests */
+    if (cp_ptr->flags & CF_BLESS_WEAPON)
+    {
+        item = &borg_items[INVEN_WIELD];
+
+        /* Penalize non-blessed edged weapons */
+        if (((item->tval == TV_SWORD) || (item->tval == TV_POLEARM)) &&
+            (!(item->flags3 & TR3_BLESSED)))
+        {
+            /* Hack -- Major penalty */
+            value -= 75000L;
+        }
+    }
+
+
+#if 0 /* I wonder if this causes the borg to change his gear so radically at depth 99 */
+	/* HUGE MEGA MONDO HACK! prepare for the big fight */
+    /* go after Morgoth new priorities. */
+    if ((borg_skill[BI_MAXDEPTH]+1 == 100 || borg_skill[BI_CDEPTH] == 100) && (!borg_skill[BI_KING]))
+    {
+        /* protect from stat drain */
+        if (borg_skill[BI_SSTR]) value += 35000L;
+        /* extra bonus for spell casters */
+        if (cp_ptr->spell_book == TV_MAGIC_BOOK && borg_skill[BI_SINT]) value += 45000L;
+        /* extra bonus for spell casters */
+        if (cp_ptr->spell_book == TV_PRAYER_BOOK && borg_skill[BI_SWIS]) value += 35000L;
+        if (borg_skill[BI_SCON]) value += 55000L;
+        if (borg_skill[BI_SDEX]) value += 15000L;
+        if (borg_skill[BI_WS_EVIL])  value += 15000L;
+
+        /* Another bonus for resist nether, poison and base four */
+        if (borg_skill[BI_RNTHR]) value +=  15000L;
+        if (borg_skill[BI_RDIS]) value += 15000L;
+
+        /* to protect against summoned baddies */
+        if (borg_skill[BI_RPOIS]) value +=  100000L;
+        if (borg_skill[BI_RFIRE] &&
+            borg_skill[BI_RACID] &&
+            borg_skill[BI_RELEC] &&
+            borg_skill[BI_RCOLD]) value += 100000L;
+    }
+#endif
+
+    /* Reward for activatable Artifacts in inventory */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        int multibonus = 0;
+        item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Good to have one item with multiple high resists */
+        multibonus = (((item->flags2 & TR2_RES_POIS) != 0) +
+               ((item->flags2 & TR2_RES_LITE)!= 0) +
+               ((item->flags2 & TR2_RES_DARK)!= 0) +
+               ((item->flags2 & TR2_RES_BLIND)!= 0) +
+               ((item->flags2 & TR2_RES_CONFU)!= 0) +
+               ((item->flags2 & TR2_RES_SOUND)!= 0) +
+               ((item->flags2 & TR2_RES_SHARD)!= 0) +
+               ((item->flags2 & TR2_RES_NEXUS)!= 0) +
+               ((item->flags2 & TR2_RES_NETHR)!= 0) +
+               ((item->flags2 & TR2_RES_CHAOS)!= 0) +
+               ((item->flags2 & TR2_RES_DISEN)!= 0));
+
+        if (multibonus >= 2) value += 15000 * multibonus;
+
+        /* This needs to be changed */
+        switch (item->activation)
+        {
+        /* Artifact -- Narthanc- fire bolt 9d8*/
+        /* Artifact -- Paurhach- fire bolt 9d8 */
+        case ACT_FIRE1:
+        value +=(500+(9*(8+1)/2));
+        break;
+
+        /* Artifact -- Nimthanc- frost bolt 6d8*/
+        /* Artifact -- Paurnimmen- frost bolt 6d8 */
+        case ACT_FROST1:
+        value +=(500+(6*(8+1)/2));
+        break;
+
+        /* Artifact -- Dethanc- electric bolt 4d8*/
+        /* Artifact -- Pauraegen- lightning bolt 4d8 */
+        case ACT_LIGHTNING_BOLT:
+        value +=(500+(4*(8+1)/2));
+        break;
+
+
+        /* Artifact -- Rilia- poison gas 12*/
+        case ACT_STINKING_CLOUD:
+        value +=(500+(24));
+        break;
+
+        /* Artifact -- Belangil- frost ball 48*/
+        case ACT_FROST2:
+        value +=(500+(96));
+        break;
+
+
+        /* Artifact -- Arunruth- frost bolt 12d8*/
+        case ACT_FROST4:
+        value +=(500+(12*(8+1)/2));
+        break;
+
+
+        /* Artifact -- Ringil- frost ball 100*/
+        /* Artifact -- Aeglos- frost ball 100*/
+        case ACT_FROST3:
+        value +=(500+(200));
+        /* extra boost for speed */
+        if (!adult_rand_artifacts &&
+            !birth_rand_artifacts)
+            value +=25000L;
+        break;
+
+
+        /* Artifact -- Anduril- fire ball 72*/
+        /* Artifact -- Firestar- fire ball 72 */
+        case ACT_FIRE2:
+        value +=(500+(144));
+        break;
+
+
+        /* Artifact -- Theoden- drain Life 120*/
+        case ACT_DRAIN_LIFE2:
+        value +=(500+120);
+        break;
+
+
+        /* Artifact -- Totila- confusion */
+        case ACT_CONFUSE:
+        value +=(500+(200));
+        break;
+
+        /* Artifact -- TURMIL- drain life 90 */
+        case ACT_DRAIN_LIFE1:
+        value +=(500+90);
+        break;
+
+
+        /* Artifact -- Razorback- spikes 150 */
+        /* Artifact -- FINGOLFIN- MISSILE 150 (bonus for TH TD)*/
+        case ACT_ARROW:
+        value +=(500+(300));
+        break;
+
+
+        /* Artifact -- Cammithrim- Magic Missile 2d6 */
+        case ACT_MISSILE:
+        value +=(500+(2*(6+1)/2));
+        break;
+
+        /* Artifact -- PaurNEN- ACID bolt 5d8 */
+        case ACT_ACID1:
+        value +=(500+(5*(8+1)/2));
+        break;
+
+        /* Artifact -- INGWE- DISPEL EVIL X5 */
+        case ACT_DISP_EVIL:
+        value +=(500+(10 + (borg_skill[BI_CLEVEL]*5)/2));
+        break;
+
+        /* Artifact -- NARYA- FIRE BALL 120 */
+        case ACT_FIRE3:
+        value +=(500+(240));
+        break;
+
+        /* Artifact -- NENYA- COLD BALL 200 */
+        case ACT_FROST5:
+        value +=(500+(400));
+        break;
+
+        /* Artifact -- VILYA- ELEC BALL 250 */
+        case ACT_ELEC2:
+        value +=(500+(500));
+        break;
+
+        /* Artifact -- POWER One Ring-*/
+        case ACT_BIZZARE:
+        value +=(999999);
+        break;
+
+        /* Artifact -- Ulmo- tele way */
+        case ACT_TELE_AWAY:
+        if (borg_class == CLASS_MAGE)
+        {
+            value +=500;
+        }
+        else
+            value +=(500+(500));
+        break;
+
+        /* Artifact -- Colluin - bladturner Resistance */
+        case ACT_RESIST:
+        value +=(500+(150));
+        /* extra bonus for the non spell guys */
+        if (borg_class == CLASS_WARRIOR || borg_class == CLASS_ROGUE ||
+            borg_class == CLASS_PALADIN) value +=25000;
+        break;
+
+        /* Artifact -- Holcolleth -- Sleep II */
+        case ACT_SLEEP:
+        if ((borg_class == CLASS_MAGE) || (borg_class == CLASS_PRIEST) )
+        {
+            value +=500;
+        }
+        else
+            value +=(500+(200));
+        break;
+
+        /* Artifact -- Thingol recharge */
+        case ACT_RECHARGE1:
+        if (borg_class == CLASS_MAGE)
+        {
+            value +=500;
+        }
+        else
+            value +=(500+(100));
+        break;
+
+        /* Artifact -- Holehenth detection */
+
+        /* Artifact -- Dal fear and poison */
+        case ACT_REM_FEAR_POIS:
+        if (borg_class == CLASS_MAGE || borg_class == CLASS_PRIEST)
+        {
+            value +=500;
+        }
+        else
+            value +=(500+(200));
+        break;
+
+        /* Artifact -- Carlammas PFE*/
+
+        /* Artifact -- Lotharang- cure light */
+
+        /* Artifact -- Eriril id */
+
+        /* Artifact -- Cubragol brand bolts, bonus for speed */
+        case ACT_FIREBRAND:
+        value +=(500+(300));
+        /* extra boost for speed */
+        if (!adult_rand_artifacts &&
+            !birth_rand_artifacts)
+            value +=25000L;
+        break;
+
+        /* Artifact -- Avavir WoR */
+
+        /* Artifact -- Taratol, feanor, tulkas speed */
+
+        /* Artifact -- Soulkeeper, Gondor heal */
+
+        /* Artifact -- Belegonnon   phase */
+
+        /* Artifact -- Colannon teleport */
+
+        /* Artifact -- Luthien RLL */
+
+        /* Artifact -- Phial */
+
+        /* Artifact -- Star */
+        case ACT_MAGIC_MAP:
+        value +=(1200);
+        break;
+
+        /* Artifact -- Arkstone */
+        }
+
+    }
+
+
+    /* Result */
+    return (value);
+}
+
+
+
+/*
+ * Helper function -- calculate power of inventory
+ * Dynamic Calcs off
+ */
+static s32b borg_power_aux4(void)
+{
+    int         k, carry_capacity, inven_weight, book;
+
+    s32b        value = 0L;
+
+
+    /*** Basic abilities ***/
+
+    /* apw
+     * In here, we must subtract out the bonus granted from certain
+     * Artifacts.  They grant amt_x = 1000 then the power is increased
+     * by 1000 times whatever bonus.  In the case of Gondor.  This is
+     * 1000 heals times 4000 points per heal.
+     *
+     */
+
+    /* Reward fuel */
+    k = 0;
+    for (; k < 5 && k < borg_skill[BI_AFUEL]; k++) value += 60000L;
+    if (borg_skill[BI_STR] >= 15)
+    {
+		for (; k < 10 && k < borg_skill[BI_AFUEL]; k++) value += 6000L;
+	}
+
+    /* Reward Food */
+    /* if hungry, food is THE top priority */
+    if ((borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) && borg_skill[BI_FOOD]) value += 100000;
+    k = 0;
+    for (; k < 7 && k < borg_skill[BI_FOOD]; k++) value += 50000L;
+    if (borg_skill[BI_STR] >= 15)
+    {
+	    for (; k < 10 && k < borg_skill[BI_FOOD]; k++) value += 200L;
+	}
+    if (borg_skill[BI_REG] && borg_skill[BI_CLEVEL] <=15)
+    {
+        k=0;
+        for (; k < 15 && k < borg_skill[BI_FOOD]; k++) value += 700L;
+    }
+    /* Prefere to buy HiCalorie foods over LowCalorie */
+    if (amt_food_hical <= 5) value += amt_food_hical * 50;
+
+    /* Reward Cure Poison and Cuts*/
+    if ((borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) && borg_skill[BI_ACCW]) value +=100000;
+    if ((borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) && borg_skill[BI_AHEAL]) value +=50000;
+    if ((borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) && borg_skill[BI_ACSW])
+    {   /* usually takes more than one */
+        k = 0;
+        for (; k < 5 && k < borg_skill[BI_ACSW]; k++) value += 25000L;
+    }
+    if (borg_skill[BI_ISPOISONED] && borg_skill[BI_ACUREPOIS]) value +=15000;
+    if (borg_skill[BI_ISPOISONED] && amt_slow_poison) value +=5000;
+
+    /* Reward Resistance Potions for Warriors */
+    if (borg_class == CLASS_WARRIOR)
+    {
+        k = 0;
+        /* collect pots if not immune */
+        if (!borg_skill[BI_IFIRE])
+        {
+			for (; k <  4 && k < borg_skill[BI_ARESHEAT]; k++) value += 500L;
+		}
+        k = 0;
+        /* collect pots if not immune */
+        if (!borg_skill[BI_ICOLD])
+		{
+			for (; k <  4 && k < borg_skill[BI_ARESCOLD]; k++) value += 500L;
+		}
+    }
+
+    /* Reward ident */
+    k = 0;
+    for (; k < 5 && k < borg_skill[BI_AID]; k++) value += 6000L;
+    if (borg_skill[BI_STR] >= 15)
+    {
+	    for (; k < 15 && k < borg_skill[BI_AID]; k++) value += 600L;
+	}
+
+    /*  Reward *id* apw carry lots of these*/
+    k = 0;
+    for (; k < 8 && k < borg_has[177]; k++) value += 10000L;
+    for (; k < 15 && k < borg_has[177]; k++) value += 2000L;
+
+    /*  Reward PFE  carry lots of these*/
+    k = 0;
+    for (; k < 10 && k < borg_skill[BI_APFE]; k++) value += 10000L;
+    for (; k < 25 && k < borg_skill[BI_APFE]; k++) value += 2000L;
+
+    /*  Reward Glyph- Rune of Protection-  carry lots of these*/
+    k = 0;
+    for (; k < 10 && k < borg_skill[BI_AGLYPH]; k++) value += 10000L;
+    for (; k < 25 && k < borg_skill[BI_AGLYPH]; k++) value += 2000L;
+    if (borg_skill[BI_MAXDEPTH] >= 100)
+    {
+        k = 0;
+        for (; k < 10 && k < borg_skill[BI_AGLYPH]; k++) value += 2500L;
+        for (; k < 75 && k < borg_skill[BI_AGLYPH]; k++) value += 2500L;
+    }
+
+    /* Reward recall */
+    k = 0;
+    for (; k < 3 && k < borg_skill[BI_RECALL]; k++) value += 50000L;
+    if (borg_skill[BI_STR] >= 15)
+    {
+	    for (; k < 7 && k < borg_skill[BI_RECALL]; k++) value += 5000L;
+	}
+    /* Reward phase */
+    k = 1;
+    /* first phase door is very important */
+    if (borg_skill[BI_APHASE]) value += 50000;
+	for (; k < 8 && k < borg_skill[BI_APHASE]; k++) value += 500L;
+    if (borg_skill[BI_STR] >= 15)
+    {
+	    for (; k < 15 && k < borg_skill[BI_APHASE]; k++) value += 500L;
+	}
+
+    /* Reward escape (staff of teleport or artifact */
+    k = 0;
+    for (; k < 5 && k < borg_skill[BI_AESCAPE]; k++) value += 10000L;
+    if (borg_skill[BI_CDEPTH] > 70)
+    {
+	    k = 0;
+        for (; k < 10 && k < borg_skill[BI_AESCAPE]; k++) value += 10000L;
+    }
+
+    /* Reward teleport scroll*/
+    k = 0;
+    for (; k < 5 && k < borg_skill[BI_ATELEPORT]; k++) value += 10000L;
+    if (borg_skill[BI_STR] >= 15)
+    {
+    	for (; k < 10 && k < borg_skill[BI_ATELEPORT]; k++) value += 10000L;
+	}
+
+    /* Reward Teleport Level scrolls */
+    k = 0;
+	for (; k <  5 && k < borg_skill[BI_ATELEPORTLVL]; k++) value += 5000L;
+
+
+    /*** Healing ***/
+    if (borg_class == CLASS_WARRIOR || borg_class == CLASS_ROGUE)
+    {
+        k = 0;
+        for (; k < 15 && k < borg_skill[BI_AHEAL]; k++) value += 8000L;
+
+        k = 0; /* carry a couple for emergency. Store the rest. */
+        for (; k < 2 && k < borg_has[419]; k++) value +=10000L;
+        if (borg_has[419] == 0)
+        {
+            k = 0; /* carry a couple for emergency. Store the rest. */
+            for (; k < 2 && k < borg_has[420]; k++) value +=10000L;
+        }
+
+        /* These guys need to carry the rods more, town runs low on supply. */
+        k = 0;
+        for (; k < 4 && k < borg_has[374]; k++) value +=20000L;
+    }
+    else
+    if (borg_class == CLASS_RANGER || borg_class == CLASS_PALADIN ||
+        borg_class == CLASS_MAGE)
+    {
+        k = 0;
+        for (; k < 10 && k < borg_skill[BI_AHEAL]; k++) value += 4000L;
+
+        k = 0; /* carry a couple for emergency. Store the rest. */
+        for (; k < 2 && k < borg_has[419]; k++) value +=9000L;
+        if (borg_has[419] == 0)
+        {
+            k = 0; /* carry a couple for emergency. Store the rest. */
+            for (; k < 2 && k < borg_has[420]; k++) value +=9000L;
+        }
+
+        if (borg_class == CLASS_PALADIN)
+        {
+            /* Reward heal potions */
+            k = 0;
+            for (; k < 3 && k < borg_has[242]; k++) value += 5000L;
+        }
+
+        /* These guys need to carry the rods more, town runs low on supply. */
+        k = 0;
+        for (; k < 2 && k < borg_has[374]; k++) value +=20000L;
+
+    }
+    else if (borg_class == CLASS_PRIEST)
+    {
+        /* Level 1 priests are given a Potion of Healing.  It is better
+         * for them to sell that potion and buy equipment or several
+         * Cure Crits with it.
+         */
+        if (borg_skill[BI_CLEVEL] == 1)
+        {
+            k = 0;
+            for (; k < 10 && k < borg_has[242]; k++) value -= 2000L;
+        }
+        /* Reward heal potions */
+        k = 0;
+        for (; k < 5 && k < borg_has[242]; k++) value += 2000L;
+
+        k = 0; /* carry a couple for emergency. Store the rest. */
+        for (; k < 2 && k < borg_has[419]; k++) value +=9000L;
+        if (borg_has[419] == 0)
+        {
+            k = 0; /* carry a couple for emergency. Store the rest. */
+            for (; k < 2 && k < borg_has[420]; k++) value +=9000L;
+        }
+    }
+
+
+    /* Collecting Potions, prepping for Morgoth/Sauron fight */
+    if (borg_skill[BI_MAXDEPTH] >= 99)
+    {
+        /* Sauron is alive -- carry them all*/
+        if (borg_race_death[546] == 0)
+        {
+            k = 0;
+            for (; k < 99 && k < borg_has[242]; k++) value += 8000L;
+            k = 0;
+            for (; k < 99 && k < borg_skill[BI_AEZHEAL]; k++) value +=10000L;
+            k = 0;
+            for (; k < 99 && k < borg_skill[BI_ASPEED]; k++) value += 8000L;
+            /* Restore Mana */
+            k = 0;
+            for (; k < 99 && k < borg_has[266]; k++) value += 5000L;
+
+        }
+        /* Sauron is dead -- store them unless I have enough */
+        if (borg_race_death[546] != 0)
+        {
+            /* Must scum for more pots */
+            if ((num_heal_true + borg_has[242] + num_ez_heal_true + borg_skill[BI_AEZHEAL] < 45) ||
+                (num_ez_heal_true + borg_skill[BI_AEZHEAL] < 30) ||
+                (num_speed + borg_skill[BI_ASPEED] < 15))
+            {
+                /* leave pots at home so they dont shatter */
+            }
+            /* I have enough, carry all pots, and other good stuff. */
+            else
+            {
+                k = 0;
+                for (; k < 99 && k < borg_has[242]; k++) value += 8000L;
+                k = 0;
+                for (; k < 99 && k < borg_skill[BI_AEZHEAL]; k++) value +=10000L;
+                k = 0;
+                for (; k < 99 && k < borg_skill[BI_ASPEED]; k++) value +=8000L;
+                k = 0;
+                for (; k < 99 && k < borg_has[266]; k++) value += 5000L; /* Restore Mana */
+                /* Shrooms of Restoring */
+                k = 0;
+                for (; k < 35 && k < amt_fix_stat[6]; k++) value += 5000L;
+            }
+        }
+    }
+
+    /* Restore Mana */
+    if (borg_skill[BI_MAXSP] > 100)
+    {
+        k = 0;
+        for (; k < 10 && k < borg_has[266]; k++) value += 4000L;
+        k = 0;
+        for (; k < 100 && k < borg_skill[BI_ASTFMAGI]; k++) value += 4000L;
+    }
+
+    /* Reward cure critical.  Heavy reward on first 5 */
+    if (borg_skill[BI_CLEVEL] < 35  || !borg_skill[BI_RCONF])
+    {
+        k = 0;
+        for (; k < 5 && k < borg_skill[BI_ACCW]; k++) value += 5000L;
+		if (borg_skill[BI_STR] > 15)
+		{
+			for (; k < 15 && k < borg_skill[BI_ACCW]; k++) value += 500L;
+		}
+    }
+    else
+    {
+        /* Reward cure critical.  Later on in game. */
+        k = 0;
+        for (; k <  10 && k < borg_skill[BI_ACCW]; k++) value += 5000L;
+    }
+
+    /* Reward cure serious -- only reward serious if low on crits */
+    if (borg_skill[BI_ACCW] < 10 && (borg_skill[BI_CLEVEL] < 35 || !borg_skill[BI_RCONF]))
+    {
+        k = 0;
+        for (; k <  5 && k < borg_skill[BI_ACSW]; k++) value += 50L;
+		if (borg_skill[BI_STR] > 15)
+		{
+	        for (; k < 10 && k < borg_skill[BI_ACSW]; k++) value += 5L;
+		}
+    }
+
+    /* Reward cure serious -- Low Level Characters */
+    if (borg_skill[BI_CLEVEL] < 15)
+    {
+        k = 0;
+        for (; k <  5 && k < borg_skill[BI_ACSW]; k++) value += 250L;
+		if (borg_skill[BI_STR] > 15)
+		{
+	        for (; k < 10 && k < borg_skill[BI_ACSW]; k++) value += 55L;
+		}
+    }
+
+    /* Reward Cures */
+    if (!borg_skill[BI_RCONF])
+    {
+        k = 0;
+        for (; k < 10 && k < amt_cure_confusion; k++) value += 400L;
+    }
+    if (!borg_skill[BI_RBLIND])
+    {
+        k = 0;
+        for (; k < 5 && k < amt_cure_blind; k++) value += 300L;
+    }
+    if (!borg_skill[BI_RPOIS])
+    {
+        k = 0;
+        for (; k < 5 && k < borg_skill[BI_ACUREPOIS]; k++) value += 250L;
+    }
+    /*** Detection ***/
+
+    /* Reward detect trap */
+    k = 0;
+    for (; k < 1 && k < borg_skill[BI_ADETTRAP]; k++) value += 4000L;
+
+    /* Reward detect door */
+    k = 0;
+    for (; k < 1 && k < borg_skill[BI_ADETDOOR]; k++) value += 2000L;
+
+    /* Reward detect evil for non spell caster guys */
+    if (!borg_skill[BI_ESP] && !borg_prayer_legal(0, 0) &&
+        !borg_spell_legal(0, 1))
+    {
+        k = 0;
+        for (; k < 1 && k < borg_skill[BI_ADETEVIL]; k++) value += 1000L;
+    }
+
+    /* Reward magic mapping */
+    k = 0;
+    for (; k < 1 && k < borg_skill[BI_AMAGICMAP]; k++) value += 4000L;
+
+    /* Reward call lite */
+    k = 0;
+    for (; k < 1 && k < borg_skill[BI_ALITE]; k++) value += 1000L;
+
+    /* Genocide scrolls. Just scrolls, mainly used for Morgoth */
+    if (borg_skill[BI_MAXDEPTH] >= 100)
+    {
+        k = 0;
+        for (; k < 10 && k < borg_has[207]; k++) value += 10000L;
+        for (; k < 25 && k < borg_has[207]; k++) value += 2000L;
+    }
+
+    /* Mass Genocide scrolls. Just scrolls, mainly used for Morgoth */
+    if (borg_skill[BI_MAXDEPTH] >= 100)
+    {
+        k = 0;
+        for (; k < 10 && k < borg_has[200]; k++) value += 10000L;
+        for (; k < 25 && k < borg_has[200]; k++) value += 2000L;
+    }
+
+    /* Reward speed potions/staves */
+    if (borg_skill[BI_MAXDEPTH] <= 98)
+    {
+        k = 0;
+        for (; k < 20 && k < borg_skill[BI_ASPEED]; k++) value += 5000L;
+    }
+
+    /* Reward Recharge ability */
+    k = 0;
+    for (; k < 5 && k < borg_skill[BI_ARECHARGE]; k++) value += 5000L;
+
+    /*** Missiles ***/
+
+    /* Reward missiles */
+    if (borg_class == CLASS_RANGER)
+    {
+        k = 0;
+        for (; k < 40 && k < borg_skill[BI_AMISSILES]; k++) value += 1000L;
+		if (borg_skill[BI_STR] > 15)
+		{
+	        for (; k < 80 && k < borg_skill[BI_AMISSILES]; k++) value += 100L;
+		}
+    }
+    else
+    {
+        k = 0;
+        for (; k < 20 && k < borg_skill[BI_AMISSILES]; k++) value += 1000L;
+		if (borg_skill[BI_STR] > 15)
+		{
+	        for (; k < 50 && k < borg_skill[BI_AMISSILES]; k++) value += 100L;
+		}
+    }
+	/* Potions of Detonations */
+    k = 0;
+    for (; k < 15 && k < borg_skill[BI_ADETONATE]; k++) value += 2000L;
+
+    /*** Various ***/
+
+    /* These staves are great but do not clutter inven with them */
+    /*  -- Reward carrying a staff of holiness/power */
+    if (amt_cool_staff) value += 2500L;
+    k=0;
+    for (; k < 3 && k < amt_cool_staff; k++) value += 500L;
+
+    /*  -- Reward carrying a staff of destruction. */
+    if (borg_has[307]) value += 5000L;
+    k=0;
+    for (; k < 3 && k < borg_has[307]; k++) value += 200L;
+
+    /*  -- Reward carrying a wand of Teleport Other. */
+    if (borg_has[BI_ATPORTOTHER]) value += 5000L;
+    /* Much greater reward for Warrior */
+    if (borg_class == CLASS_WARRIOR && borg_has[BI_ATPORTOTHER]) value += 50000L;
+    /* reward per charge */
+    k=0;
+    for (; k < 15 && k < borg_has[BI_ATPORTOTHER]; k++) value += 5000L;
+
+    /* Hack -- Reward add stat */
+    if (amt_add_stat[A_STR]) value += 50000;
+    if (amt_add_stat[A_INT]) value += 20000;
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+        if (amt_add_stat[A_INT]) value += 50000;
+
+    if (amt_add_stat[A_WIS]) value += 20000;
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+        if (amt_add_stat[A_WIS]) value += 50000;
+    if (amt_add_stat[A_DEX]) value += 50000;
+    if (amt_add_stat[A_CON]) value += 50000;
+    if (amt_add_stat[A_CHR]) value += 10000;
+
+    /* Hack -- Reward stat potions */
+    if (amt_inc_stat[A_STR] && my_stat_cur[A_STR] < (18+100)) value += 550000;
+    if (amt_inc_stat[A_INT] && my_stat_cur[A_INT] < (18+100)) value += 520000;
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+        if (amt_inc_stat[A_INT] && my_stat_cur[A_INT] < (18+100)) value += 575000;
+    if (amt_inc_stat[A_WIS] && my_stat_cur[A_WIS] < (18+100)) value += 520000;
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+        if (amt_inc_stat[A_WIS] && my_stat_cur[A_WIS] < (18+100)) value += 575000;
+    if (amt_inc_stat[A_DEX] && my_stat_cur[A_DEX] < (18+100)) value += 550000;
+    if (amt_inc_stat[A_CON] && my_stat_cur[A_CON] < (18+100)) value += 550000;
+    if (amt_inc_stat[A_CHR] && my_stat_cur[A_CHR] < (18+100)) value += 510000;
+
+    /* Hack -- Reward fix stat */
+    if (amt_fix_stat[A_STR]) value += 10000;
+    if (amt_fix_stat[A_INT]) value += 10000;
+    if (amt_fix_stat[A_WIS]) value += 10000;
+    if (amt_fix_stat[A_DEX]) value += 10000;
+    if (amt_fix_stat[A_CON]) value += 10000;
+    if (amt_fix_stat[A_CHR]) value += 10000;
+
+    /* Reward Remove Curse */
+    if (borg_wearing_cursed)
+    {
+        if (borg_has[191]) value += 90000;
+        if (borg_has[180]) value += 90000;
+    }
+
+    /* Hack -- Restore experience */
+    if (amt_fix_exp) value += 50000;
+
+    /*** Enchantment ***/
+
+    /* Reward enchant armor */
+    if (amt_enchant_to_a && my_need_enchant_to_a) value += 1400L;
+
+    /* Reward enchant weapon to hit */
+    if (amt_enchant_to_h && my_need_enchant_to_h) value += 2400L;
+
+    /* Reward enchant weapon to damage */
+    if (amt_enchant_to_d && my_need_enchant_to_d) value += 3000L;
+
+    /* Reward *enchant weapon* to damage */
+    if (amt_enchant_weapon) value += 5000L;
+
+    /* Reward *enchant armour*  */
+    if (amt_enchant_armor) value += 5000L;
+
+    /* Reward carrying a shovel if low level */
+/*    if (borg_skill[BI_MAXDEPTH] <= 54 && borg_items[INVEN_WIELD].tval != TV_DIGGING   &&
+        amt_digger == 1 && borg_class !=CLASS_WARRIOR) value += 5000L; */
+
+    /*** Hack -- books ***/
+
+    /* Reward books */
+    for (book = 0; book < 9; book++)
+    {
+        /* No copies */
+        if (!amt_book[book]) continue;
+
+        /* The "hard" books */
+        if (book >= 4)
+        {
+            /* Reward the book */
+            k = 0;
+            for (; k < 1 && k < amt_book[book]; k++) value += 300000L;
+        }
+
+        /* The "easy" books */
+        else
+        {
+            int what, when = 99;
+
+            /* Scan the spells */
+            for (what = 0; what < 9; what++)
+            {
+                borg_magic *as = &borg_magics[book][what];
+
+                /* Track minimum level */
+                if (as->level < when) when = as->level;
+            }
+
+            /* Hack -- Ignore "difficult" normal books */
+            if ((when > 5) && (when >= borg_skill[BI_MAXCLEVEL] + 2)) continue;
+
+            /* Reward the book */
+            k = 0;
+            for (; k < 1 && k < amt_book[book]; k++) value += 500000L;
+            if (borg_skill[BI_STR] > 5)
+                for (; k < 2 && k < amt_book[book]; k++) value += 10000L;
+            if (borg_skill[BI_MAXDEPTH] > 50)
+                for (; k < 3 && k < amt_book[book]; k++) value += 2500L;
+        }
+    }
+
+    /* apw Hack -- Apply "encumbrance" from weight */
+    /* Extract the current weight (in tenth pounds) */
+    inven_weight = p_ptr->total_weight;
+
+    /* Extract the "weight limit" (in tenth pounds) */
+    carry_capacity = adj_str_wgt[my_stat_ind[A_STR]] * 100;
+
+    /* XXX XXX XXX Apply "encumbrance" from weight */
+    if (inven_weight > carry_capacity/2) value -= ((inven_weight - (carry_capacity/2)) / (carry_capacity / 10) *1000L);
+
+    /* Reward empty slots (up to 5) */
+    k = 1;
+        for (; k < 6; k++)
+            if (!borg_items[INVEN_PACK-k].iqty)
+                value += 400L;
+
+    /* Return the value */
+    return (value);
+}
+
+
+/*
+ * Calculate the "power" of the Borg
+ */
+s32b borg_power(void)
+{
+    int i = 1;
+    s32b value = 0L;
+
+    if (borg_uses_calcs)
+    {
+        /* Process the equipment */
+        value += borg_power_aux1();
+
+        /* Process the inventory */
+        value += borg_power_aux2();
+    }
+    else
+    {
+        /* Process the equipment */
+        value += borg_power_aux3();
+
+        /* Process the inventory */
+        value += borg_power_aux4();
+    }
+
+    /* Add a bonus for deep level prep */
+    /* Dump prep codes */
+	if (borg_skill[BI_MAXDEPTH] <= 20)
+	{   /* Scan from surface to deep , stop when not preped */
+	    for (i = 1; i <= borg_skill[BI_MAXDEPTH]+50; i++)
+	    {
+	        /* Dump fear code*/
+	        if ((cptr)NULL != borg_prepared(i)) break;
+	    }
+    	value +=((i-1) * 40000L);
+	}
+	else /* This is faster for deeper in dungeon */
+	{
+    	for (i = borg_skill[BI_MAXDEPTH]+50; i >= 1; i--)
+    	{
+    	    /* Dump fear code*/
+    	    if ((cptr)NULL == borg_prepared(i)) break;
+    	}
+    	value +=((i) * 40000L);
+	}
+
+    /* Add the value for the swap items */
+    value += weapon_swap_value;
+    value += armour_swap_value;
+
+
+    /* Return the value */
+    return (value);
+}
+
+/*
+ * Helper function -- calculate power of equipment in the home
+ */
+static s32b borg_power_home_aux1(void)
+{
+    s32b        value = 0L;
+
+    /* This would be better seperated by item type (so 1 bonus for resist cold armor */
+    /*   1 bonus for resist cold shield... but that would take a bunch more code. */
+
+    /* try to collect at least 2 of each resist/power (for swapping) */
+    /* This can be used to get rid of extra artifacts... */
+
+    /* spare lite sources.  Artifacts only */
+    if (num_lite == 1)
+        value += 150L;
+    else
+        if (num_lite == 2)
+            value += 170L;
+        else
+            if (num_lite > 2)
+                value += 170L + (num_lite - 2) * 5L;
+
+    if (num_slow_digest == 1)
+        value += 50L;
+    else
+        if (num_slow_digest == 2)
+            value += 70L;
+        else
+            if (num_slow_digest > 2)
+                value += 70L + (num_slow_digest - 2) * 5L;
+
+    if (num_regenerate == 1)
+        value += 75L;
+    else
+        if (num_regenerate == 2)
+            value += 100L;
+        else
+            if (num_regenerate > 2)
+                value += 100L + (num_regenerate - 2) * 10L;
+
+    if (num_telepathy == 1)
+        value += 1000L;
+    else
+        if (num_telepathy == 2)
+            value += 1500L;
+        else
+            if (num_telepathy > 2)
+                value += 1500L + (num_telepathy - 2) * 10L;
+
+    if (num_see_inv == 1)
+        value += 800L;
+    else
+        if (num_see_inv == 2)
+            value += 1200L;
+        else
+            if (num_see_inv > 2)
+                value += 1200L + (num_see_inv - 2) * 10L;
+
+    if (num_ffall == 1)
+        value += 10L;
+    else
+        if (num_ffall == 2)
+            value += 15L;
+        else
+            if (num_ffall > 2)
+                value += 15L + (num_ffall - 2) * 1L;
+
+
+    if (num_free_act == 1)
+        value += 1000L;
+    else
+        if (num_free_act == 2)
+            value += 1500L;
+        else
+            if (num_free_act > 2)
+                value += 1500L + (num_free_act - 2) * 10L;
+
+    if (num_hold_life == 1)
+        value += 1000L;
+    else
+        if (num_hold_life == 2)
+            value += 1500L;
+        else
+            if (num_hold_life > 2)
+                value += 1500L + (num_hold_life - 2) * 10L;
+
+    if (num_resist_acid == 1)
+        value += 1000L;
+    else
+        if (num_resist_acid == 2)
+            value += 1500L;
+        else
+            if (num_resist_acid > 2)
+                value += 1500L + (num_resist_acid - 2) * 1L;
+    if (num_immune_acid == 1)
+        value += 3000L;
+    else
+        if (num_immune_acid == 2)
+            value += 5000L;
+        else
+            if (num_immune_acid > 2)
+                value += 5000L + (num_immune_acid - 2) * 30L;
+
+    if (num_resist_elec == 1)
+        value += 1000L;
+    else
+        if (num_resist_elec == 2)
+            value += 1500L;
+        else
+            if (num_resist_elec > 2)
+                value += 1500L + (num_resist_elec - 2) * 1L;
+    if (num_immune_elec == 1)
+        value += 3000L;
+    else
+        if (num_immune_elec == 2)
+            value += 5000L;
+        else
+            if (num_immune_elec > 2)
+                value += 5000L + (num_immune_elec - 2) * 30L;
+
+    if (num_resist_fire == 1)
+        value += 1000L;
+    else
+        if (num_resist_fire == 2)
+            value += 1500L;
+        else
+            if (num_resist_fire > 2)
+                value += 1500L + (num_resist_fire - 2) * 1L;
+    if (num_immune_fire == 1)
+        value += 3000L;
+    else
+        if (num_immune_fire == 2)
+            value += 5000L;
+        else
+            if (num_immune_fire > 2)
+                value += 5000L + (num_immune_fire - 2) * 30L;
+
+    if (num_resist_cold == 1)
+        value += 1000L;
+    else
+        if (num_resist_cold == 2)
+            value += 1500L;
+        else
+            if (num_resist_cold > 2)
+                value += 1500L + (num_resist_cold - 2) * 1L;
+    if (num_immune_cold == 1)
+        value += 3000L;
+    else
+        if (num_immune_cold == 2)
+            value += 5000L;
+        else
+            if (num_immune_cold > 2)
+                value += 5000L + (num_immune_cold - 2) * 30L;
+
+    if (num_resist_pois == 1)
+        value += 5000L;
+    else
+        if (num_resist_pois == 2)
+             value += 9000L;
+        else
+            if (num_resist_pois > 2)
+                value += 9000L + (num_resist_pois - 2) * 40L;
+
+    if (num_resist_conf == 1)
+        value += 2000L;
+    else
+        if (num_resist_conf == 2)
+            value += 3500L;
+        else
+            if (num_resist_conf > 2)
+                value += 3500L + (num_resist_conf - 2) * 45L;
+
+    if (num_resist_sound == 1)
+        value += 500L;
+    else
+        if (num_resist_sound == 2)
+            value += 700L;
+        else
+            if (num_resist_sound > 2)
+                value += 700L + (num_resist_sound - 2) * 30L;
+
+    if (num_resist_lite == 1)
+        value += 100L;
+    else
+        if (num_resist_lite == 2)
+            value += 150L;
+        else
+            if (num_resist_lite > 2)
+                value += 150L + (num_resist_lite - 2) * 1L;
+
+    if (num_resist_dark == 1)
+        value += 100L;
+    else
+        if (num_resist_dark == 2)
+            value += 150L;
+        else
+            if (num_resist_dark > 2)
+                value += 150L + (num_resist_dark - 2) * 1L;
+
+    if (num_resist_chaos == 1)
+        value += 1000L;
+    else
+        if (num_resist_chaos == 2)
+            value += 1500L;
+        else
+            if (num_resist_chaos > 2)
+                value += 1500L + (num_resist_chaos - 2) * 10L;
+
+    if (num_resist_disen == 1)
+        value += 5000L;
+    else
+        if (num_resist_disen == 2)
+            value += 7000L;
+        else
+            if (num_resist_disen > 2)
+                value += 7000L + (num_resist_disen - 2) * 35L;
+
+    if (num_resist_shard == 1)
+        value += 100L;
+    else
+        if (num_resist_shard == 2)
+            value += 150L;
+        else
+            if (num_resist_shard > 2)
+                value += 150L + (num_resist_shard - 2) * 1L;
+
+    if (num_resist_nexus == 1)
+        value += 200L;
+    else
+        if (num_resist_nexus == 2)
+            value += 300L;
+        else
+            if (num_resist_nexus > 2)
+                value += 300L + (num_resist_nexus - 2) * 2L;
+
+    if (num_resist_blind == 1)
+        value += 500L;
+    else
+        if (num_resist_blind == 2)
+            value += 700L;
+        else
+            if (num_resist_blind > 2)
+                value += 700L + (num_resist_blind - 2) * 5L;
+
+    if (num_resist_neth == 1)
+        value += 5000L;
+    else
+        if (num_resist_neth == 2)
+            value += 7000L;
+        else
+            if (num_resist_neth > 2)
+                value += 7000L + (num_resist_neth - 2) * 45L;
+
+    /* stat gain items as well...(good to carry ring of dex +6 in */
+    /*                            house even if I don't need it right now) */
+    if (home_stat_add[A_STR] < 9)
+        value += home_stat_add[A_STR] * 300L;
+    else
+        if (home_stat_add[A_STR] < 15)
+            value += 9 * 300L + (home_stat_add[A_STR] - 9) * 200L;
+        else
+            value += 9 * 300L + 6 * 200L +
+                      (home_stat_add[A_STR] - 15) * 1L;
+
+    if (home_stat_add[A_DEX] < 9)
+        value += home_stat_add[A_DEX] * 300L;
+    else
+        if (home_stat_add[A_DEX] < 15)
+            value += 9 * 300L + (home_stat_add[A_DEX] - 9) * 200L;
+        else
+            value += 9 * 300L + 6 * 200L +
+                      (home_stat_add[A_DEX] - 15) * 1L;
+
+    /* HACK extra con for thorin and other such things */
+    if (home_stat_add[A_CON] < 15)
+        value += home_stat_add[A_CON] * 300L;
+    else
+        if (home_stat_add[A_CON] < 21)
+            value += 15 * 300L + (home_stat_add[A_CON] - 15) * 200L;
+        else
+            value += 15 * 300L + 6 * 200L + (home_stat_add[A_CON] - 21) * 1L;
+
+    /* int and wis are only bonused for spell casters. */
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+    {
+        if (home_stat_add[A_INT] < 20)
+            value += home_stat_add[A_INT] * 400L;
+        else
+            if (home_stat_add[A_INT] < 26)
+                value += 20 * 400L + (home_stat_add[A_INT] - 20) * 300L;
+            else
+                value += 20 * 100L + 6 * 300L +
+                         (home_stat_add[A_INT] - 26) * 5L;
+    }
+
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+    {
+        if (home_stat_add[A_WIS] < 20)
+            value += home_stat_add[A_WIS] * 400L;
+        else
+            if (home_stat_add[A_WIS] < 26)
+                value += 20 * 400L + (home_stat_add[A_WIS] - 20) * 300L;
+            else
+                value += 20 * 400L + 6 * 300L +
+                        (home_stat_add[A_WIS] - 26) * 3L;
+    }
+
+    /* Sustains */
+    if (num_sustain_str == 1)
+        value += 200L;
+    else
+        if (num_sustain_str == 2)
+            value += 250L;
+        else
+            if (num_sustain_str > 2)
+                value += 250L + (num_sustain_str - 2) * 1L;
+
+    if (num_sustain_int == 1)
+        value += 200L;
+    else
+        if (num_sustain_int == 2)
+            value += 250L;
+        else
+            if (num_sustain_int > 2)
+                value += 250L + (num_sustain_int - 2) * 1L;
+
+    if (num_sustain_wis == 1)
+        value += 200L;
+    else
+        if (num_sustain_wis == 2)
+            value += 250L;
+        else
+            if (num_sustain_wis > 2)
+                value += 250L + (num_sustain_wis - 2) * 1L;
+
+    if (num_sustain_con == 1)
+        value += 200L;
+    else
+        if (num_sustain_con == 2)
+            value += 250L;
+        else
+            if (num_sustain_con > 2)
+                value += 250L + (num_sustain_con - 2) * 1L;
+
+    if (num_sustain_dex == 1)
+        value += 200L;
+    else
+        if (num_sustain_dex == 2)
+            value += 250L;
+        else
+            if (num_sustain_dex > 2)
+                value += 250L + (num_sustain_dex - 2) * 1L;
+
+    if (num_sustain_all == 1)
+        value += 1000L;
+    else
+        if (num_sustain_all == 2)
+            value += 1500L;
+        else
+            if (num_sustain_all > 2)
+                value += 1500L + (num_sustain_all - 2) * 1L;
+
+    /* do a minus for too many duplicates.  This way we do not store */
+    /* useless items and spread out types of items. */
+    if (num_weapons > 5)
+        value -= (num_weapons - 5) * 2000L;
+    else
+        if (num_weapons > 1)
+            value -= (num_weapons - 1) * 100L;
+    if (num_bow > 2)
+        value -= (num_bow - 2) * 1000L;
+    if (num_rings > 6)
+        value -= (num_rings - 6) * 4000L;
+    else
+        if (num_rings > 4)
+            value -= (num_rings - 4) * 2000L;
+    if (num_neck > 3)
+        value -= (num_neck - 3) * 1500L;
+    else
+        if (num_neck > 2)
+            value -= (num_neck - 2) * 700L;
+    if (num_armor > 6)
+        value -= (num_armor - 6) * 1000L;
+    if (num_cloaks > 3)
+        value -= (num_cloaks - 3) * 1000L;
+    if (num_shields > 3)
+        value -= (num_shields - 3) * 1000L;
+    if (num_hats > 4)
+        value -= (num_hats - 4) * 1000L;
+    if (num_gloves > 3)
+        value -= (num_gloves - 3) * 1000L;
+    if (num_boots > 2)
+        value -= (num_boots - 2) * 1000L;
+
+
+    value += home_damage;
+
+    /* if edged and priest, dump it   */
+    value -= num_edged_weapon * 3000L;
+
+    /* if gloves and mage or ranger and not FA/Dex, dump it. */
+    value -= num_bad_gloves * 3000L;
+
+    /* do not allow duplication of items. */
+    value -= num_duplicate_items * 50000L;
+
+
+    /* Return the value */
+    return (value);
+}
+
+
+/*
+ * Helper function -- calculate power of items in the home
+ *
+ * The weird calculations help spread out the purchase order
+ */
+static s32b borg_power_home_aux2(void)
+{
+    int         k, book;
+
+    s32b        value = 0L;
+
+
+    /*** Basic abilities ***/
+
+    /* Collect food */
+	if (borg_skill[BI_MAXCLEVEL] < 10)
+	{
+		for (k = 0; k < 25 && k < num_food; k++) value += 8000L - k*10L;
+	}
+	else if (borg_skill[BI_MAXCLEVEL] < 35)
+	{
+		for (k = 0; k < 90 && k < num_food; k++) value += 8000L - k*10L;
+	}
+	else
+	{
+		for (k = 0; k < 90 && k < num_food; k++) value += 8000L - k*10L;
+	}
+	if (borg_skill[BI_MAXCLEVEL] > 35 && borg_class == CLASS_WARRIOR)
+	{
+		for (k = 0; k < 95 && k < num_food; k++) value += 8000L - k*2L;
+	}
+
+    /* Collect fuel */
+	if (borg_skill[BI_MAXCLEVEL] < 10)
+	{
+		for (k = 0; k < 25 && k < num_fuel; k++) value += 8000L - k*10L;
+	}
+	else if (borg_skill[BI_MAXCLEVEL] < 35)
+	{
+		for (k = 0; k < 50 && k < num_fuel; k++) value += 8000L - k*10L;
+	}
+	else
+	{
+		for (k = 0; k < 99 && k < num_fuel; k++) value += 8000L - k*10L;
+	}
+
+    /* Collect Molds as pets */
+    for (k = 0; k < 10 && k < num_mold; k++) value += 10L - k;
+
+    /* Collect ident */
+    for (k = 0; k < 50 && k < num_ident; k++) value += 2000L - k*10L;
+
+    /* Collect enchantments armour */
+	if (borg_skill[BI_CLEVEL] < 45)
+	{
+    	for (k = 0; k < 90 && k < num_enchant_to_a; k++) value += 2000L - k*10L;
+	}
+    /* Collect enchantments to hit */
+	if (borg_skill[BI_CLEVEL] < 45)
+    {
+    	for (k = 0; k < 90 && k < num_enchant_to_h; k++) value += 2000L - k*10L;
+	}
+    /* Collect enchantments to dam */
+	if (borg_skill[BI_CLEVEL] < 45)
+    {
+		for (k = 0; k < 90 && k < num_enchant_to_d; k++) value += 2000L - k*10L;
+	}
+
+    /* Collect *id*ent */
+    for (k = 0; k < 90 && k < num_star_ident; k++) value += 5000L - k*10L;
+
+    /* Collect pfe */
+    for (k = 0; k < 90 && k < num_pfe; k++) value += 5000L - k*10L;
+
+    /* Collect glyphs */
+    for (k = 0; k < 90 && k < num_glyph; k++) value += 5000L - k*10L;
+
+    /* Reward Genocide scrolls. Just scrolls, mainly used for Morgoth */
+    for (k = 0; k < 90 && k < num_genocide; k++) value += 5000L - k*10L;
+
+    /* Reward Mass Genocide scrolls. Just scrolls, mainly used for Morgoth */
+    for (k = 0; k < 90 && k < num_mass_genocide; k++) value += 5000L - k*10L;
+
+    /* Collect Recharge ability */
+    for (k = 0; k < 90 && k < num_recharge; k++) value += 5000L - k*10L;
+
+    /* Reward Resistance Potions for Warriors */
+    if (borg_class == CLASS_WARRIOR)
+    {
+        k = 0;
+        for (; k <  90 && k < num_pot_rheat; k++) value += 1000L - k*10L;
+        for (; k <  90 && k < num_pot_rcold; k++) value +=  1000L - k*10L;
+    }
+
+    /* Collect recall */
+    for (k = 0; k < 90 && k < num_recall; k++) value += 3000L;
+
+    /* Collect escape  (staff of teleport) */
+    for (k = 0; k < 85 && k < num_escape; k++) value += 2000L - k*10L;
+
+    /* Collect a maximal number of staves in the home */
+    for (k = 0; k < 90 && k < num_tele_staves; k++) value -= 50000L;
+
+    /* Collect teleport */
+    for (k = 0; k < 85 && k < num_teleport; k++) value += 5000L;
+
+    /* Collect phase */
+    for (k = 0; k < 90 && k < num_phase; k++) value += 5000L;
+
+    /* Collect teleport level scrolls*/
+    for (k = 0; k < 85 && k < num_teleport_level; k++) value += 5000L - k*8L;
+
+    /* Collect Speed */
+    for (k = 0; k < 85 && k < num_speed; k++) value += 5000L - k*10L;
+
+	/* Collect Potions of Detonations */
+    for (k = 0; k < 85 && k < num_detonate; k++) value += 5000L;
+
+    /* collect heal/mana/ */
+    for (k = 0; k < 90 && k < num_heal; k++) value += 3000L - k*8L;
+    for (k = 0; k < 198 && k < num_ez_heal; k++) value += 8000L - k*8L;
+    if (borg_skill[BI_MAXSP] > 1)
+    {
+        for (k = 0; k < 90 && k < num_mana; k++) value += 6000L - k*8L;
+    }
+
+    /* Level 1 priests are given a Potion of Healing.  It is better
+     * for them to sell that potion and buy equipment or several
+     * Cure Crits with it.
+     */
+    if (borg_skill[BI_CLEVEL] == 1)
+    {
+        k = 0;
+        for (; k < 10 && k < num_heal; k++) value -= 5000L;
+    }
+
+    /*** Healing ***/
+
+    /* Collect cure critical */
+    for (k = 0; k < 90 && k < num_cure_critical; k++) value += 1500L-k*10L;
+
+    /* junk cure serious if we have some in the home */
+    if (borg_skill[BI_CLEVEL] > 35)    /* dont bother keeping them if high level */
+        for (k = 0; k < 90 && k < num_cure_serious; k++) value -= 1500L-k*10L;
+
+    /*** Various ***/
+
+    /* Fixing Stats */
+    if (borg_skill[BI_CLEVEL] == 50 && num_fix_exp) value -= 7500L;
+    if (borg_skill[BI_CLEVEL] > 35 && borg_skill[BI_CLEVEL] <= 49)
+       for (k = 0; k < 70 && k < num_fix_exp; k++) value += 5000L - k*10L;
+    else if (borg_skill[BI_CLEVEL] <= 35)
+       for (k = 0; k < 5 && k < num_fix_exp; k++) value += 5000L - k*10L;
+
+    /* Keep shrooms in the house */
+    for (k = 0; k < 90 && k < num_fix_stat[6]; k++) value += 5000L;
+
+
+    /*** Hack -- books ***/
+
+    /* Reward books */
+    for (book = 0; book < 4; book++)
+    {
+
+        if (borg_skill[BI_CLEVEL] > 35)
+            /* Collect up to 20 copies of each normal book */
+            for (k = 0; k < 20 && k < num_book[book]; k++)
+            {
+                /* Hack -- only stockpile useful books */
+                if (num_book[book]) value += 5000L - k*10L;
+            }
+        else
+            /* Collect up to 5 copies of each normal book */
+            for (k = 0; k < 5 && k < num_book[book]; k++)
+            {
+                /* Hack -- only stockpile useful books */
+                if (num_book[book]) value += 5000L - k*10L;
+            }
+    }
+
+    /* Reward artifacts in the home */
+    value += num_artifact * 500L;
+
+    /* Reward certain types of egos in the home */
+    value += num_ego * 5000L;
+
+    /* Return the value */
+    return (value);
+}
+
+
+/*
+ * Calculate the "power" of the home
+ */
+s32b borg_power_home(void)
+{
+    s32b value = 0L;
+
+    /* Process the home equipment */
+    value += borg_power_home_aux1();
+
+    /* Process the home inventory */
+    value += borg_power_home_aux2();
+
+    /* Return the value */
+    return (value);
+}
+
+
+/*
+ * Calculate base danger from a monster's physical attacks
+ *
+ * We attempt to take account of various resistances, both in
+ * terms of actual damage, and special effects, as appropriate.
+ *
+ * We reduce the danger from distant "sleeping" monsters.
+ * apw. PFE reduces my fear of an area.
+ */
+static int borg_danger_aux1(int i)
+{
+    int k, n = 0;
+    int pfe = 0;
+    int power, chance;
+
+    s16b ac = borg_skill[BI_ARMOR];
+
+    borg_kill *kill = &borg_kills[i];
+
+    monster_race *r_ptr = &r_info[kill->r_idx];
+
+    /* shields gives +50 to ac and deflects some missiles and balls*/
+    if (borg_shield)
+        ac += 50;
+
+    /* apw PFE gives a protection.  */
+        /* Hack -- Apply "protection from evil" */
+        if ( (borg_prot_from_evil) &&
+            (r_ptr->flags3 & RF3_EVIL) &&
+            ((borg_skill[BI_CLEVEL]) >= r_ptr->level) )
+        {
+            pfe = 1;
+        }
+
+
+    /* Mega-Hack -- unknown monsters */
+    if (kill->r_idx >= z_info->r_max) return (1000);
+
+    /* Analyze each physical attack */
+    for (k = 0; k < 4; k++)
+    {
+        int z = 0;
+
+        monster_blow *b_ptr = &r_ptr->blow[k];
+
+        power = 0;
+
+        /* Done */
+        if (!b_ptr->method) break;
+
+        /* Analyze the attack */
+        switch (b_ptr->effect)
+        {
+            case RBE_HURT:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            z -= (z * ((ac < 150) ? ac : 150) / 250);
+            /* stun */
+            if ((b_ptr->d_side < 3) && (z > b_ptr->d_dice * b_ptr->d_side))
+            {
+				n += 200;
+            }
+            /* fudge- only mystics kick and they tend to KO.  Avoid close */
+            /* combat like the plauge */
+            if (b_ptr->method == RBM_KICK)
+            {
+                n += 400;
+			}
+            power = 60;
+            if ((pfe) && !borg_attacking)
+            {
+                z /= 2;
+			}
+            break;
+
+            case RBE_POISON:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 5;
+            if (borg_skill[BI_RPOIS]) break;
+            if (my_oppose_pois) break;
+            if (!borg_full_damage)
+                z += 10;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_UN_BONUS:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 20;
+            if (borg_skill[BI_RDIS]) break;
+            if (!borg_full_damage)
+                z += 500;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_UN_POWER:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (!borg_full_damage)
+                z += 20;
+            power = 15;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EAT_GOLD:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            /* if in town and low level avoid them stupid urchins */
+            if (borg_skill[BI_CLEVEL] < 5) z += 50;
+            power = 5;
+            if (100 <= adj_dex_safe[my_stat_ind[A_DEX]] + borg_skill[BI_CLEVEL]) break;
+            if (borg_gold < 100) break;
+            if (borg_gold > 100000) break;
+            if (!borg_full_damage)
+                z += 5;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EAT_ITEM:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 5;
+            if (100 <= adj_dex_safe[my_stat_ind[A_DEX]] + borg_skill[BI_CLEVEL]) break;
+            if (!borg_full_damage)
+                z += 20;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EAT_FOOD:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 5;
+            if (borg_skill[BI_FOOD] > 5) break;
+            if (!borg_full_damage)
+                z += 5;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EAT_LITE:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 5;
+            if (borg_skill[BI_CURLITE] == 0) break;
+            if (borg_skill[BI_AFUEL] > 5) break;
+            if (!borg_full_damage)
+                z += 20;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_ACID:
+            if (borg_skill[BI_IACID]) break;
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_RACID]) z = (z + 2) / 3;
+            if (my_oppose_acid) z = (z + 2) / 3;
+            if (!borg_full_damage)
+                z += 200; /* We dont want our armour corroded. */
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_ELEC:
+            if (borg_skill[BI_IELEC]) break;
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 10;
+            if (borg_skill[BI_RELEC]) z = (z + 2) / 3;
+            if (my_oppose_elec) z = (z + 2) / 3;
+            if (!borg_full_damage)
+                z += 10;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_FIRE:
+            if (borg_skill[BI_IFIRE]) break;
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 10;
+            if (borg_skill[BI_RFIRE]) z = (z + 2) / 3;
+            if (my_oppose_fire) z = (z + 2) / 3;
+            if (!borg_full_damage)
+                z += 20;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_COLD:
+            if (borg_skill[BI_ICOLD]) break;
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 10;
+            if (borg_skill[BI_RCOLD]) z = (z + 2) / 3;
+            if (my_oppose_cold) z = (z + 2) / 3;
+            if (!borg_full_damage)
+                z += 15;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_BLIND:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 2;
+            if (borg_skill[BI_RBLIND]) break;
+            if (!borg_full_damage)
+                z += 10;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_CONFUSE:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 10;
+            if (borg_skill[BI_RCONF]) break;
+            if (!borg_full_damage)
+                z += 200;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_TERRIFY:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 10;
+            if (borg_skill[BI_RFEAR]) break;
+            if (!borg_full_damage)
+                z += 10;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_PARALYZE:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 2;
+            if (borg_skill[BI_FRACT]) break;
+            z += 200;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_LOSE_STR:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_SSTR]) break;
+            if (borg_stat[A_STR] <= 3) break;
+            if (borg_prayer_legal(6, 3)) break;
+            z += 150;
+            /* extra scary to have str drain below 10 */
+            if (borg_stat[A_STR] < 10)
+                z += 350;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_LOSE_DEX:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_SDEX]) break;
+            if (borg_stat[A_DEX] <= 3) break;
+            if (borg_prayer_legal(6, 3)) break;
+            z += 150;
+            /* extra scary to have drain below 10 */
+            if (borg_stat[A_DEX] < 10)
+                z += 350;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_LOSE_CON:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_SCON]) break;
+            if (borg_stat[A_CON] <= 3) break;
+            if (borg_prayer_legal(6, 3)) break;
+            if (!borg_full_damage)
+            z += 150;
+            /* extra scary to have con drain below 8 */
+            if (borg_stat[A_STR] < 8)
+                z += 350;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_LOSE_INT:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_SINT]) break;
+            if (borg_stat[A_INT] <= 3) break;
+            if (borg_prayer_legal(6, 3)) break;
+            z += 150;
+            /* extra scary for spell caster */
+            if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+                z += 350;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_LOSE_WIS:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_SWIS]) break;
+            if (borg_stat[A_WIS] <= 3) break;
+            if (borg_prayer_legal(6, 3)) break;
+            z += 150;
+            /* extra scary for pray'er */
+            if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+                z += 350;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_LOSE_CHR:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_SCHR]) break;
+            if (borg_stat[A_CHR] <= 3) break;
+            if (borg_prayer_legal(6, 3)) break;
+            z += 50;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_LOSE_ALL:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            power = 2;
+            /* only morgoth. HACK to make it easier to fight him */
+            break;
+
+            case RBE_SHATTER:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            z -= (z * ((ac < 150) ? ac : 150) / 250);
+            power = 60;
+            if (!borg_full_damage)
+                z += 150;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EXP_10:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_HLIFE]) break;
+            /* do not worry about drain exp after level 50 */
+            if (borg_skill[BI_CLEVEL] == 50) break;
+            if (borg_prayer_legal(6, 4)) break;
+            if (!borg_full_damage)
+                z += 100;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EXP_20:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_HLIFE]) break;
+            /* do not worry about drain exp after level 50 */
+            if (borg_skill[BI_CLEVEL] >= 50) break;
+            if (borg_prayer_legal(6, 4)) break;
+            if (!borg_full_damage)
+                z += 150;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EXP_40:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_HLIFE]) break;
+            /* do not worry about drain exp after level 50 */
+            if (borg_skill[BI_CLEVEL] >= 50) break;
+            if (borg_prayer_legal(6, 4)) break;
+            if (!borg_full_damage)
+                z += 200;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+
+            case RBE_EXP_80:
+            z = (b_ptr->d_dice * b_ptr->d_side);
+            if (borg_skill[BI_HLIFE]) break;
+            /* do not worry about drain exp after level 50 */
+            if (borg_skill[BI_CLEVEL] >= 50) break;
+            if (borg_prayer_legal(6, 4)) break;
+            if (!borg_full_damage)
+                z += 250;
+            if ((pfe) && !borg_attacking)
+                z /= 2;
+            break;
+        }
+
+        /* if we are doing partial damage reduce for % chance that it will */
+        /* hit you. */
+        if (!borg_full_damage)
+        {
+            /* figure out chance that monster will hit you. */
+            /* add a 30% bonus in to account for bad luck. */
+            if ((r_ptr->level + power) > 0)
+                chance  = 130 - (((ac * 300) / 4) / ((r_ptr->level + power) * 3));
+            else
+                chance = -1;
+
+            /* always have a 5% chance of hitting. */
+            if (chance < 0)
+                z = (z * 5) / 100;
+
+            if (chance < 100)
+                z = (z * chance) / 100;
+        }
+
+        /* Add in damage */
+        n += z;
+    }
+
+    /* Danger */
+    return (n);
+}
+
+
+/*
+ * Calculate base danger from a monster's spell attacks
+ *
+ * We attempt to take account of various resistances, both in
+ * terms of actual damage, and special effects, as appropriate.
+ *
+ * We reduce the danger from distant "sleeping" monsters.
+ *
+ * We reduce the danger if the monster is immobile or not LOS
+ */
+static int borg_danger_aux2(int i, int y, int x, bool average)
+{
+    int q, k, n= 0, pfe =0, glyph= 0, glyph_check =0;
+
+    int spot_x, spot_y, spot_safe=1;
+
+    int lev, hp, total_dam = 0, av;
+
+    byte spell[96], num = 0;
+
+    borg_kill *kill = &borg_kills[i];
+
+    borg_grid   *ag;
+
+    monster_race *r_ptr = &r_info[kill->r_idx];
+
+    /* apw PFE gives a protection.  */
+        /* Hack -- Apply "protection from evil" */
+        if ( (borg_prot_from_evil) &&
+            (r_ptr->flags3 & RF3_EVIL) &&
+            ((borg_skill[BI_CLEVEL] ) >= r_ptr->level) )
+        {
+            pfe = 1;
+        }
+
+    /* glyph of warding rune of protection provides some small
+     * protection with some ranged atacks; mainly summon attacks.
+     * We should reduce the danger commensurate to the probability of the
+     * monster breaking the glyph as defined by melee2.c
+     */
+    if (borg_on_glyph)
+    {
+        glyph = 1;
+    }
+    else if (track_glyph_num)
+    {
+        /* Check all existing glyphs */
+        for (glyph_check = 0; glyph_check < track_glyph_num; glyph_check++)
+        {
+            if ((track_glyph_y[glyph_check] == y) && (track_glyph_x[glyph_check] == x))
+            {
+                /* Reduce the danger */
+                glyph = 1;
+            }
+        }
+    }
+
+    /* This is used to calculate the free squares next to us.
+     * This is important when dealing with summoners.
+     */
+    for (spot_x = -1; spot_x <= 1; spot_x++)
+    {
+        for (spot_y = -1; spot_y <= 1; spot_y++)
+        {
+            /* Acquire location */
+            x = spot_x + c_x;
+            y = spot_y + c_y;
+
+            ag = &borg_grids[y][x];
+
+            /* skip our own spot */
+            if (x == c_x && y == c_y) continue;
+
+            /* track spaces already protected */
+            if ( ag->feat == FEAT_GLYPH || ag->kill ||
+               ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_PERM_SOLID)))
+            {   /* track the safe areas for calculating danger */
+                spot_safe ++;
+
+                /* Just in case */
+                if (spot_safe == 0) spot_safe = 1;
+                if (spot_safe == 8) spot_safe = 100;
+				if (borg_morgoth_position) spot_safe = 1000;
+            }
+
+        }
+    }
+
+    /* Mega-Hack -- unknown monsters */
+    if (kill->r_idx >= z_info->r_max) return (1000);
+
+
+    /* Extract the "inate" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags4 & (1L << k)) spell[num++] = k + 32 * 3;
+    }
+
+    /* Extract the "normal" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags5 & (1L << k)) spell[num++] = k + 32 * 4;
+    }
+
+    /* Extract the "bizarre" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags6 & (1L << k)) spell[num++] = k + 32 * 5;
+    }
+
+    /* Paranoia -- Nothing to cast */
+    if (!num) return (0);
+
+
+    /* Extract the level */
+    lev = r_ptr->level;
+
+    /* Extract hit-points */
+    hp = kill->power;
+
+
+    /* Analyze the spells */
+    for (q = 0; q < num; q++)
+    {
+        int p = 0;
+
+        int z = 0;
+
+        /* Cast the spell. */
+        switch (spell[q])
+        {
+            case 96+0:    /* RF4_SHRIEK */
+            /* if looking at full damage, things that are just annoying */
+            /* do not count.*/
+            if (!borg_full_damage)
+                p += 10;
+            break;
+
+            case 96+1:    /* RF4_XXX2X4 */
+            /* this is now a failed spell attempt for monsters */
+            /* used to recognize invisible/ hidden monsters */
+                p += 10;
+            break;
+
+            case 96+2:    /* RF4_XXX3X4 */
+            break;
+
+            case 96+3:    /* RF4_XXX4X4 */
+            break;
+
+            case 96+4:    /* RF4_ARROW_1 */
+            z = (1 * 6);
+            break;
+
+            case 96+5:    /* RF4_ARROW_2 */
+            z = (3 * 6);
+            break;
+
+            case 96+6:    /* RF4_ARROW_3 */
+            z = (5 * 6);
+            break;
+
+            case 96+7:    /* RF4_ARROW_4 */
+            z = (7 * 6);
+            break;
+
+            case 96+8:    /* RF4_BR_ACID */
+            if (borg_skill[BI_IACID]) break;
+            z = (hp / 3);
+            /* max damage */
+            if (z > 1600)
+                z = 1600;
+            if (borg_skill[BI_RACID]) z = (z + 2) / 3;
+            if (my_oppose_acid) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count.*/
+            if (!borg_full_damage)
+                p += 40;
+            break;
+
+            case 96+9:    /* RF4_BR_ELEC */
+            if (borg_skill[BI_IELEC]) break;
+            z = (hp / 3);
+            /* max damage */
+            if (z > 1600)
+                z = 1600;
+            if (borg_skill[BI_RELEC]) z = (z + 2) / 3;
+            if (my_oppose_elec) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count.*/
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 96+10:    /* RF4_BR_FIRE */
+            if (borg_skill[BI_IFIRE]) break;
+            z = (hp / 3);
+            /* max damage */
+            if (z > 1600)
+                z = 1600;
+            if (borg_skill[BI_RFIRE]) z = (z + 2) / 3;
+            if (my_oppose_fire) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 40;
+            break;
+
+            case 96+11:    /* RF4_BR_COLD */
+            if (borg_skill[BI_ICOLD]) break;
+            z = (hp / 3);
+            /* max damage */
+            if (z > 1600)
+                z = 1600;
+            if (borg_skill[BI_RCOLD]) z = (z + 2) / 3;
+            if (my_oppose_cold) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 96+12:    /* RF4_BR_POIS */
+            z = (hp / 3);
+            /* max damage */
+            if (z > 800)
+                z = 800;
+            if (borg_skill[BI_RPOIS]) z = (z + 2) / 3;
+            if (my_oppose_pois) z = (z + 2) / 3;
+            if (my_oppose_pois) break;
+            if (borg_skill[BI_RPOIS]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 96+13:    /* RF4_BR_NETH */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 350)
+                z = 550;
+            if (borg_skill[BI_RNTHR])
+            {
+                z = (z*6)/9;
+                break;
+            }
+            if (!borg_full_damage)
+                p += 125;
+            break;
+
+            case 96+14:    /* RF4_BR_LITE */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 400)
+                z = 400;
+            if (borg_skill[BI_RLITE])
+            {
+                z = (z*2)/3;
+                break;
+            }
+            if (borg_skill[BI_RBLIND]) break;
+            p += 20;
+            break;
+
+            case 96+15:    /* RF4_BR_DARK */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 400)
+                z = 400;
+            if (borg_skill[BI_RDARK]) z = (z*2)/ 3;
+            if (borg_skill[BI_RDARK]) break;
+            if (borg_skill[BI_RBLIND]) break;
+            p += 20;
+            break;
+
+            case 96+16:    /* RF4_BR_CONF */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 400)
+                z = 400;
+            if (borg_skill[BI_RCONF]) z = z / 2;
+            if (borg_skill[BI_RCONF]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 300;
+            break;
+
+            case 96+17:    /* RF4_BR_SOUN */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 500)
+                z = 500;
+            if (borg_skill[BI_RSND]) z = (z*5)/9;
+            if (borg_skill[BI_RSND]) break;
+            /* if already stunned be REALLY nervous dangerousabout this */
+            if (borg_skill[BI_ISSTUN])
+                p += 500;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 1000;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 96+18:    /* RF4_BR_CHAO */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 500)
+                z = 500;
+            if (borg_skill[BI_RKAOS]) z = (z*6)/9;
+            if (!borg_full_damage)
+                p += 100;
+            if (borg_skill[BI_RKAOS]) break;
+            p += 200;
+            break;
+
+            case 96+19:    /* RF4_BR_DISE */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 500)
+                z = 500;
+            if (borg_skill[BI_RDIS]) z = (z*6)/10;
+            if (borg_skill[BI_RDIS]) break;
+            p += 500;
+            break;
+
+            case 96+20:    /* RF4_BR_NEXU */
+            z = (hp / 3);
+            /* max damage */
+            if (z > 400)
+                z = 400;
+            if (borg_skill[BI_RNXUS]) z = (z*6)/10;
+            if (borg_skill[BI_RNXUS]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 100;
+            break;
+
+            case 96+21:    /* RF4_BR_TIME */
+            z = (hp / 3);
+            /* max damage */
+            if (z > 150)
+                z = 150;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 250;
+            break;
+
+            case 96+22:    /* RF4_BR_INER */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 200)
+                z = 200;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 100;
+            break;
+
+            case 96+23:    /* RF4_BR_GRAV */
+            z = (hp / 3);
+            /* max damage */
+            if (z > 200)
+                z = 200;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 100;
+            if (borg_skill[BI_RSND]) break;
+            /* if already stunned be REALLY nervous about this */
+            if (borg_skill[BI_ISSTUN])
+                p += 500;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 1000;
+            break;
+
+            case 96+24:    /* RF4_BR_SHAR */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 500)
+                z = 500;
+            if (borg_skill[BI_RSHRD]) z = (z*6)/9;
+            if (borg_skill[BI_RSHRD]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 96+25:    /* RF4_BR_PLAS */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 150)
+                z = 150;
+            if (borg_skill[BI_RSND]) break;
+            /* Pump this up if you have goi so that the borg is sure */
+            /* to be made nervous */
+            p += 100;
+            /* if already stunned be REALLY nervous about this */
+            if (borg_skill[BI_ISSTUN])
+                p += 500;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 1000;
+            break;
+
+            case 96+26:    /* RF4_BR_WALL */
+            z = (hp / 6);
+            /* max damage */
+            if (z > 200)
+                z = 200;
+            if (borg_skill[BI_RSND]) break;
+            /* if already stunned be REALLY nervous about this */
+            if (borg_skill[BI_ISSTUN])
+                p += 100;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 500;
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 96+27:    /* RF4_BR_MANA */
+            /* XXX XXX XXX */
+            break;
+
+            case 96+28:    /* RF4_XXX5X4 */
+            break;
+
+            case 96+29:    /* RF4_XXX6X4 */
+            break;
+
+            case 96+30:    /* RF4_XXX7X4 */
+            break;
+
+            case 96+31:    /* RF4_BOULDER */
+            z = (1 + lev / 7) * 12 / 2;
+            break;
+
+            case 128+0:    /* RF5_BA_ACID */
+            if (borg_skill[BI_IACID]) break;
+            z = (lev * 3) / 2 + 15;
+            if (borg_skill[BI_RACID]) z = (z + 2) / 3;
+            if (my_oppose_acid) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 40;
+            break;
+
+            case 128+1:    /* RF5_BA_ELEC */
+            if (borg_skill[BI_IELEC]) break;
+            z = (lev * 3) / 2 + 8;
+            if (borg_skill[BI_RELEC]) z = (z + 2) / 3;
+            if (my_oppose_elec) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 128+2:    /* RF5_BA_FIRE */
+            if (borg_skill[BI_IFIRE]) break;
+            z = (lev * 7) / 2 + 10;
+            if (borg_skill[BI_RFIRE]) z = (z + 2) / 3;
+            if (my_oppose_fire) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 40;
+            break;
+
+            case 128+3:    /* RF5_BA_COLD */
+            if (borg_skill[BI_ICOLD]) break;
+            z = (lev * 3) / 2 + 10;
+            if (borg_skill[BI_RCOLD]) z = (z + 2) / 3;
+            if (my_oppose_cold) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 128+4:    /* RF5_BA_POIS */
+            z = (12 * 2);
+            if (borg_skill[BI_RPOIS]) z = (z + 2) / 3;
+            if (my_oppose_pois) z = (z + 2) / 3;
+            if (my_oppose_pois) break;
+            if (borg_skill[BI_RPOIS]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 128+5:    /* RF5_BA_NETH */
+            z = (50 +50 + (10 * 10) + lev);
+            if (borg_skill[BI_RNTHR]) z = (z*6)/8;
+            if (borg_skill[BI_RNTHR]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 250;
+            break;
+
+            case 128+6:    /* RF5_BA_WATE */
+            z = ((lev * 5) / 2) + 50;
+            if (borg_skill[BI_RSND]) break;
+            /* if already stunned be REALLY nervous about this */
+            if (borg_skill[BI_ISSTUN])
+                p += 500;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 1000;
+            if (borg_skill[BI_RCONF]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 128+7:    /* RF5_BA_MANA */
+            z = ((lev * 5) + 150);
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 128+8:    /* RF5_BA_DARK */
+            z = (((lev * 5)) + (50));
+            if (borg_skill[BI_RDARK]) z = (z*6)/9;
+            if (borg_skill[BI_RDARK]) break;
+            if (borg_skill[BI_RBLIND]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 128+9:    /* RF5_DRAIN_MANA */
+            if (borg_skill[BI_MAXSP]) p += 10;
+            break;
+
+            case 128+10:    /* RF5_MIND_BLAST */
+            if (borg_skill[BI_SAV] < 100)
+                z = 20;
+            break;
+
+            case 128+11:    /* RF5_BRAIN_SMASH */
+            z = (12 * 15);
+            p += 200 - 2 * borg_skill[BI_SAV];
+            if (p < 0) p =0;
+            break;
+
+            case 128+12:    /* RF5_CAUSE_1 */
+            if (borg_skill[BI_SAV] >= 100) break;
+            z = (3 * 8);
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                /* reduce by % chance of save  (add 20% for fudge) */
+                z = z * (120 - borg_skill[BI_SAV]) / 100;
+            break;
+
+            case 128+13:    /* RF5_CAUSE_2 */
+            if (borg_skill[BI_SAV] >= 100) break;
+            z = (8 * 8);
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                /* reduce by % chance of save  (add 20% for fudge) */
+                z = z * (120 - borg_skill[BI_SAV]) / 100;
+            break;
+
+            case 128+14:    /* RF5_CAUSE_3 */
+            if (borg_skill[BI_SAV] >= 100) break;
+            z = (10 * 15);
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                /* reduce by % chance of save  (add 20% for fudge) */
+                z = z * (120 - borg_skill[BI_SAV]) / 100;
+            break;
+
+            case 128+15:    /* RF5_CAUSE_4 */
+            if (borg_skill[BI_SAV] >= 100) break;
+            z = (15 * 15);
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                /* reduce by % chance of save  (add 40% for fudge) */
+                z = z * (120 - borg_skill[BI_SAV]) / 100;
+            break;
+
+            case 128+16:    /* RF5_BO_ACID */
+            if (borg_skill[BI_IACID]) break;
+            z = ((7 * 8) + (lev / 3));
+            if (borg_skill[BI_RACID]) z = (z + 2) / 3;
+            if (my_oppose_acid) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 40;
+            break;
+
+            case 128+17:    /* RF5_BO_ELEC */
+            if (borg_skill[BI_IELEC]) break;
+            z = ((4 * 8) + (lev / 3));
+            if (borg_skill[BI_RELEC]) z = (z + 2) / 3;
+            if (my_oppose_elec) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 128+18:    /* RF5_BO_FIRE */
+            if (borg_skill[BI_IFIRE]) break;
+            z = ((9 * 8) + (lev / 3));
+            if (borg_skill[BI_RFIRE]) z = (z + 2) / 3;
+            if (my_oppose_fire) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 40;
+            break;
+
+            case 128+19:    /* RF5_BO_COLD */
+            if (borg_skill[BI_ICOLD]) break;
+            z = ((6 * 8) + (lev / 3));
+            if (borg_skill[BI_RCOLD]) z = (z + 2) / 3;
+            if (my_oppose_cold) z = (z + 2) / 3;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 128+20:    /* RF5_BO_POIS */
+            /* XXX XXX XXX */
+            break;
+
+            case 128+21:    /* RF5_BO_NETH */
+            z = (50 + 30 + (5 * 5) + (lev * 3) / 2);
+            if (borg_skill[BI_RNTHR]) z = (z*6)/8;
+            if (borg_skill[BI_RNTHR]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 200;
+            break;
+
+            case 128+22:    /* RF5_BO_WATE */
+            z = ((10 * 10) + (lev));
+            if (borg_skill[BI_RSND]) break;
+            /* if already stunned be REALLY nervous about this */
+            if (borg_skill[BI_ISSTUN])
+                p += 500;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 1000;
+            if (borg_skill[BI_RCONF]) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 128+23:    /* RF5_BO_MANA */
+            z = ((lev * 7) / 2) + 50;
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 128+24:    /* RF5_BO_PLAS */
+            z = (10 + (8 * 7) + (lev));
+            if (borg_skill[BI_RSND]) break;
+            /* if already stunned be REALLY nervous about this */
+            if (borg_skill[BI_ISSTUN])
+                p += 500;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 1000;
+            break;
+
+            case 128+25:    /* RF5_BO_ICEE */
+            z = ((6 * 6) + (lev));
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            if (borg_skill[BI_RSND]) break;
+            /* if already stunned be REALLY nervous about this */
+            if (borg_skill[BI_ISSTUN])
+                p += 50;
+            if (borg_skill[BI_ISHEAVYSTUN])
+                p += 1000;
+            break;
+
+            case 128+26:    /* RF5_MISSILE */
+            z = ((2 * 6) + (lev / 3));
+            break;
+
+            case 128+27:    /* RF5_SCARE */
+            if (borg_skill[BI_SAV] >= 100) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 10;
+            break;
+
+            case 128+28:    /* RF5_BLIND */
+            if (borg_skill[BI_SAV] >= 100) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 10;
+            break;
+
+            case 128+29:    /* RF5_CONF */
+            if (borg_skill[BI_SAV] >= 100) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 10;
+            break;
+
+            case 128+30:    /* RF5_SLOW */
+            if (borg_skill[BI_FRACT]) break;
+            if (borg_skill[BI_SAV] >= 100) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 5;
+            break;
+
+            case 128+31:    /* RF5_HOLD */
+            if (borg_skill[BI_FRACT]) break;
+            if (borg_skill[BI_SAV] >= 100) break;
+            p += 150;
+            break;
+
+            case 160+0:    /* RF6_HASTE */
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 10;
+            break;
+
+            case 160+1:    /* RF6_XXX1X6 */
+            break;
+
+            case 160+2:    /* RF6_HEAL */
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 10;
+            break;
+
+            case 160+3:    /* RF6_XXX2X6 */
+            break;
+
+            case 160+4:    /* RF6_BLINK */
+            break;
+
+            case 160+5:    /* RF6_TPORT */
+            break;
+
+            case 160+6:    /* RF6_XXX3X6 */
+            break;
+
+            case 160+7:    /* RF6_XXX4X6 */
+            break;
+
+            case 160+8:    /* RF6_TELE_TO */
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 20;
+            break;
+
+            case 160+9:    /* RF6_TELE_AWAY */
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 10;
+            break;
+
+            case 160+10:    /* RF6_TELE_LEVEL */
+            if (borg_skill[BI_SAV] >= 100) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 160+11:    /* RF6_XXX5 */
+            break;
+
+            case 160+12:    /* RF6_DARKNESS */
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 5;
+            break;
+
+            case 160+13:    /* RF6_TRAPS */
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+                p += 50;
+            break;
+
+            case 160+14:    /* RF6_FORGET */
+            if (borg_skill[BI_SAV] >= 100) break;
+            /* if looking at full damage, things that are just annoying */
+            /* do not count. */
+            if (!borg_full_damage)
+            {
+                /* if you have lots of cash (like you will at level 35) */
+                /* this is not very scary... just re-ID. */
+                if (borg_skill[BI_CLEVEL] < 35)
+                {
+                    p += 500;
+                }
+                else
+                {
+                    p += 50;
+                }
+            }
+            break;
+
+            case 160+15:    /* RF6_XXX6X6 */
+            break;
+
+            /* Summoning is only as dangerous as the monster that is
+             * actually summoned but the monsters that summon are a priority
+             * to kill.  PFE reduces danger from some evil summoned monsters
+             * One Problem with GOI and Create Door is that the GOI reduces
+             * the fear so much that the borg won't cast the Create Door,
+             * eventhough it would be a good idea.
+             */
+
+            case 160+16:    /* S_KIN */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 3;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 7;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+
+            break;
+
+            case 160+17:    /* S_HI_DEMON */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 6;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 12;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+
+            case 160+18:    /* RF6_S_MONSTER */
+            if (pfe || glyph || borg_create_door || borg_fighting_unique)
+                p +=0;
+            else
+            {    p += (lev) * 5;
+                p = p / spot_safe;
+            }
+            break;
+
+            case 160+19:    /* RF6_S_MONSTERS */
+            if (pfe || glyph || borg_create_door || borg_fighting_unique)
+                p +=0;
+            else
+            {    p += (lev) * 7;
+                 p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+20:   /* RF6_S_ANIMAL */
+            if (pfe || glyph || borg_create_door || borg_fighting_unique)
+                p +=0;
+            else
+            {   p += (lev) * 5;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+21:    /* RF6_S_SPIDER */
+            if (pfe || glyph || borg_create_door || borg_fighting_unique)
+                p +=0;
+            else
+            {   p += (lev) * 5;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+22:    /* RF6_S_HOUND */
+            if (pfe || glyph || borg_create_door || borg_fighting_unique)
+                p +=0;
+            else
+            {    p += (lev) * 5;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+23:    /* RF6_S_HYDRA */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {   p +=(lev) * 2;
+                p = p / spot_safe;
+            }
+            else
+            {   p += (lev) * 5;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+24:    /* RF6_S_ANGEL */
+            if (pfe  || borg_fighting_unique)
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev)* 3;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 7;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+25:    /* RF6_S_DEMON */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 3;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 7;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+26:    /* RF6_S_UNDEAD */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 3;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 7;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+27:    /* RF6_S_DRAGON */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 3;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 7;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+28:    /* RF6_S_HI_UNDEAD */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 6;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 12;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+29:    /* RF6_S_HI_DRAGON */
+            if (pfe )
+            {
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 6;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 12;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+30:    /* RF6_S_WRAITH */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door || borg_fighting_unique)
+            {    p +=(lev) * 6;
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 12;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+
+            case 160+31:    /* RF6_S_UNIQUE */
+            if (pfe )
+            {    p +=(lev);
+                p = p / spot_safe;
+            }
+            else if (glyph || borg_create_door)
+            {    p +=(lev) * 3;    /* slightly reduced danger for unique */
+                p = p / spot_safe;
+            }
+            else
+            {    p += (lev) * 6;
+                p = p / spot_safe;
+            }
+            /* reduce the fear if it is a unique */
+            if (r_info->flags1 & RF1_UNIQUE) p = p * 75/100;
+            break;
+        }
+
+        /* Notice damage */
+        p += z;
+
+        /* Track the most dangerous spell */
+        if (p > n) n = p;
+
+        /* Track the damage of all the spells, used in averaging */
+        total_dam +=p;
+    }
+
+	/* Slightly decrease the danger if the borg is sitting in
+	 * a sea of runes.
+	 */
+	if (borg_morgoth_position) total_dam = total_dam * 7 / 10;
+
+    /* Average damage of all the spells & compare to most dangerous spell */
+    av = total_dam / num;
+
+    /* If the most dangerous spell is alot bigger than the average,
+     * then return the dangerous one.
+     *
+     * There is a problem when dealing with defence manuevers.
+     * If the borg is considering casting a spell like
+     * Resistance and the monster also has a non
+     * resistable attack (like Disenchant) then the damage
+     * returned will be for that spell, since the danger of the
+     * others (like fire, cold) will be greatly reduced by the
+     * proposed defence spell.  The result will be the borg will
+     * not cast the resistance spell eventhough it may be a very
+     * good idea.
+     *
+     * Example: a monster has three breath attacks (Fire, Ice,
+     * Disenchant) and each hits for 800 pts of damage.  The
+     * borg currently resists all three, so the danger would be
+     * 500. If the borg were to use a Res Heat Potion that would
+     * decrease the danger to:
+     * Fire:  333
+     * Ice:   500
+     * Disen: 500
+     * Now the Average is 444.  Not really worth it, nominal change.
+     * But if the resistance spell was both Fire and Ice, then
+     * it would be:
+     * Fire:  333
+     * Ice:   333
+     * Disen: 500
+     * With an average of 388. Probably worth it, but the borg
+     * would see that the Disen attack is a quite dangerous and
+     * would return the result of 500.
+     *
+     * To fix this, the flag 'average' is added to the
+     * borg_danger() to skip this check and return the average
+     * damage.  If the flag is FALSE then the formula below is
+     * SKIPPED and the value returned with be the average.
+     * If the flag is TRUE, then the formula below will be used
+     * to determine the returned value.  Currently the elemental
+     * resistance spells and PFE have the flag set as FALSE.
+     *
+     */
+    if (!average) return (av);
+    if (n >= av * 15/10 || n > borg_skill[BI_CURHP] * 8/10) return (n);
+    else
+    /* Average Danger */
+    return (av);
+}
+
+
+/*
+ * Calculate the danger to a grid from a monster  XXX XXX XXX
+ *
+ * Note that we are paranoid, especially about "monster speed",
+ * since even if a monster is slower than us, it will occasionally
+ * get one full turn to attack us.
+ *
+ * Note that we assume that monsters can walk through walls and
+ * other monsters to get to the player.  XXX XXX XXX
+ *
+ * This function ignores possibilities such as movement plus
+ * spell attacks, physical attacks and spell attacks together,
+ * and other similar situations.  XXX XXX XXX
+ *
+ * Currently we assume that "sleeping" monsters are less dangerous
+ * unless you get near them, which may wake them up.
+ *
+ * We attempt to take into account things like monsters which sometimes
+ * "stumble", and monsters which only "sometimes" use powerful spells.
+ */
+int borg_danger_aux(int y, int x, int c, int i, bool average)
+{
+    borg_kill *kill = &borg_kills[i];
+
+    monster_race *r_ptr = &r_info[kill->r_idx];
+
+    int x9 = kill->x;
+    int y9 = kill->y;
+
+    int ax, ay, d;
+
+    int q=0, r, p, v1=0, v2=0;
+
+    int glyph =0;
+
+    int fake_speed = borg_skill[BI_SPEED];
+    int monster_speed = kill->speed;
+    int t, e;
+
+	int ii;
+
+    /* Paranoia */
+    if (!kill->r_idx) return (0);
+
+	/* Skip certain monster indexes.
+	 * These have been listed mainly in Teleport Other
+	 * checks in borg6.c in the defence maneuvers.
+	 */
+	if (borg_simulate)
+	{
+		for (ii = 1; ii <= borg_tp_other_n; ii++)
+		{
+			/* Is the current danger check same as a saved monster index? */
+			if (i == borg_tp_other_index[ii])
+			{
+				return (0);
+			}
+		}
+	}
+
+
+    /* Distance components */
+    ax = (x9 > x) ? (x9 - x) : (x - x9);
+    ay = (y9 > y) ? (y9 - y) : (y - y9);
+
+    /* Distance */
+    d = MAX(ax, ay);
+
+    /* Minimal distance */
+    if (d < 1) d = 1;
+
+    /* Minimal distance */
+    if (d > 20) return (0);
+
+    /* A very speedy borg will miscalculate danger of some monsters */
+    if (borg_skill[BI_SPEED] >=135) fake_speed = (borg_fighting_unique ? 120 : 125);
+
+    /* Consider the character haste and slow monster spells */
+    if (borg_speed)
+        fake_speed += 10;
+    if (borg_slow_spell)
+        monster_speed -= 10;
+
+    /* Assume monsters are a little fast when you are low level */
+    if (borg_skill[BI_MAXHP] < 20 && borg_skill[BI_CDEPTH])
+        monster_speed += 3;
+
+
+    /* Player energy per game turn  */
+    e = extract_energy[(fake_speed)];
+
+    /* Game turns per player move  */
+    t = (100 + (e - 1)) / e;
+
+    /*  Monster energy per game turn  */
+    e = extract_energy[monster_speed];
+
+    /* Monster moves */
+    q = c * ((t * e) / 10);
+
+    /* allow partial hits when not caculating full possible damage */
+    if (borg_full_damage)
+        q = (int)((q+9)/10)*10;
+
+    /* Minimal energy.  Monsters get at least some energy.
+     * If the borg is very fast relative to a monster, then the
+     * monster danger is artifically low due to the way the borg
+     * will calculate the danger and energy.  So the monsters must
+     * be given some base energy to equate the borg's.
+     * ie:  the borg with speed +40 (speed = 150) is attacking
+     * a monster with normal speed (speed = 110).  One would
+     * think that the borg gets 4 attacks per turn over the monster.
+     * and this does happen.  What if the monster can deal out
+     * 1000 damage pts per monster attack turn?  The borg will
+     * reduce the danger to 250 because the borg is 4x faster
+     * than the monster.  But eventually the borg will get hit
+     * by that 1000 pt damage attack.  And when it does, its
+     * going to hurt.
+     * So we make sure the monster is at least as fast as us.
+     * But the monster is allowed to be faster than us.
+     */
+	if (q <= 10) q = 10;
+
+    /** Danger from physical attacks **/
+
+    /* Physical attacks */
+    v1 = borg_danger_aux1(i);
+
+    /* Hack -- Under Stressful Situation.
+     */
+    if (time_this_panel > 1200 || borg_t > 25000)
+    {
+        /* he might be stuck and could overflow */
+        v1 = v1 / 5;
+    }
+
+    /* No attacks for some monsters */
+    if (r_ptr->flags1 & RF1_NEVER_BLOW)
+    {
+        v1 = 0;
+    }
+
+    /* No movement for some monsters */
+    if ((r_ptr->flags1 & RF1_NEVER_MOVE) && (d > 1))
+    {
+        v1 = 0;
+    }
+
+    /* Hack -- Physical attacks require proximity */
+    /* If the monster is next to us and gets a partial hit, count it. */
+    if (q > 10 || d != 1)
+    {
+        if (q < (d * 10)  && borg_skill[BI_CLEVEL] > 20)
+        {
+            v1 = 0;
+        }
+        else if (q < (d * 10) && borg_skill[BI_CLEVEL] <= 20)
+        {   /* reduce damage to 20% if we are weak */
+            v1 = (v1 * 2/10);
+        }
+    }
+
+    /* multipliers yeild some trouble when I am weak */
+    if ((r_ptr->flags2 & RF2_MULTIPLY) && (borg_skill[BI_CLEVEL] < 20))
+    {   /* extra 50% */
+        v1 = v1 + (v1 *15/10);
+    }
+
+    /* Friends yeild some trouble when I am weak */
+    if ((r_ptr->flags1 & RF1_FRIENDS || r_ptr->flags1 & RF1_ESCORTS) &&
+        (borg_skill[BI_CLEVEL] < 20))
+    {
+        if (borg_skill[BI_CLEVEL] < 15)
+        {
+            /* extra 80% */
+            v1 = v1 + (v1 *18/10);
+        }
+        else
+        {
+            /* extra 30% */
+            v1 = v1 + (v1 *13/10);
+        }
+
+    }
+
+	if (streq(VERSION_STRING, "3.0.5"))
+	{
+	    /* Glyph of Protection */
+	    /* NOTE Angband 3.0.4 does not provide protection with Glyph of Warding */
+	    if (track_glyph_num)
+	    {
+	        /* Check all existing glyphs */
+	        for (glyph = 0; glyph < track_glyph_num; glyph++)
+	        {
+	            if ((track_glyph_y[glyph] == y) && (track_glyph_x[glyph] == x) &&
+	                 y != c_y && x != c_x)
+	            {
+	                /* Reduce the danger */
+	                v1 = 0;
+	            }
+	        }
+	    }
+	}
+
+    /* Reduce danger from sleeping monsters */
+    if ((!kill->awake) && (d > 1))
+    {
+        /* Normal reduction of fear */
+        if (borg_skill[BI_CLEVEL] >= 10 )
+        {
+             v1 = v1 / d;
+        }
+        else
+        {
+            /* low clevel weaklings should still fear alot*/
+            v1 = v1 * 8/10;
+        }
+    }
+     /* Reduce danger from sleeping monsters with the sleep 2 spell*/
+    if (borg_sleep_spell_ii)
+    {
+        if  ( (d == 1) &&
+             (kill->awake) &&
+             (!(r_ptr->flags3 & RF3_NO_SLEEP)) &&
+             (!(r_ptr->flags1 & RF1_UNIQUE)) &&
+             (kill->level <= (borg_skill[BI_CLEVEL] - 15)))
+        {
+              v1 = v1 / 3;
+        }
+    }
+     /* Reduce danger from sleeping monsters with the sleep 1,3 spell*/
+    if (borg_sleep_spell)
+    {
+        v1 = v1 / (d+2);
+    }
+    /* Reduce danger from confused monsters */
+    if (kill->confused)
+    {
+       v1 = v1 / 2;
+    }
+    if (kill->stunned)
+    {
+       v1 = v1 * 10 / 13;
+    }
+     if (borg_confuse_spell)
+    {
+        v1 = v1 / 6;
+    }
+     /* Perceive a reduce danger from scared monsters */
+    if (borg_fear_mon_spell)
+    {
+        v1 = 0;
+    }
+
+    /* Tweak danger based on the "alertness" of the monster */
+    if (!kill->awake)
+    {
+        /* increase the danger for light sleepers */
+        int inc = r_ptr->sleep + 5;
+
+        v1 = v1 + (v1*inc/100);
+    }
+
+    /* Danger */
+    if (v1)
+    {
+        /* Attacks after movement */
+        r = (q - ((d-1) * 10));
+
+         /* XXX XXX XXX */
+        if (c > 1)
+        {
+            /* Hack -- stumble sometimes XXX XXX XXX */
+            if (r_ptr->flags1 & (RF1_RAND_25 | RF1_RAND_50)) r -= (r / 4);
+        }
+         /* Total danger */
+        v1 = v1 * r / 10;
+
+    }
+
+    /** Ranged Attacks **/
+
+   /* Never cast spells */
+    if (!r_ptr->freq_innate && !r_ptr->freq_spell)
+    {
+        v2 = 0;
+    }
+
+    /* Hack -- verify distance */
+    else if (distance(y9, x9, y, x) > MAX_RANGE)
+    {
+        v2 = 0;
+    }
+
+    /* Hack -- verify line of sight (both ways)*/
+    else if (!borg_projectable(y9, x9, y, x) && !borg_projectable(y, x, y9, x9))
+    {
+        v2 = 0;
+    }
+
+    /* Danger from spell attacks */
+    else
+    {
+        int chance;
+
+        /* Spell attacks */
+        v2 = borg_danger_aux2(i,y,x,average);
+
+        /* Hack -- Under Stressful Situation.
+         */
+        if (time_this_panel > 1200 || borg_t > 25000)
+        {
+            /* he might be stuck and could overflow */
+            v2 = v2 / 5;
+        }
+
+        /* multipliers yeild some trouble when I am weak */
+        if ((r_ptr->flags2 & RF2_MULTIPLY) && (borg_skill[BI_CLEVEL] < 20))
+        {
+            v2 = v2 + (v2 *12/10);
+        }
+
+        /* Friends yeild some trouble when I am weak */
+        if ((r_ptr->flags1 & RF1_FRIENDS || r_ptr->flags1 & RF1_ESCORTS) &&
+            (borg_skill[BI_CLEVEL] < 20))
+        {
+            v2 = v2 + (v2 *12/10);
+        }
+
+        /* Reduce danger from sleeping monsters */
+        if ((!kill->awake) && (d > 1))
+        {
+            /* weaklings and should still fear */
+            if (borg_skill[BI_CLEVEL] >= 10 )
+            {
+                 v2 = v2 / d;
+            }
+            else
+            {
+                /* only subract 10% of the danger */
+                v2 = v2 *9/ 10;
+            }
+        }
+
+        /* Reduce danger from sleeping monsters with the sleep 2 spell*/
+        if (borg_sleep_spell_ii)
+        {
+
+            if  ( (d == 1) &&
+                  (kill->awake) &&
+                  (!(r_ptr->flags3 & RF3_NO_SLEEP)) &&
+                  (!(r_ptr->flags1 & RF1_UNIQUE)) &&
+                  (kill->level <= ((borg_skill[BI_CLEVEL] < 15)  ? borg_skill[BI_CLEVEL] : (((borg_skill[BI_CLEVEL]-10)/4)*3) + 10) ))
+            {
+                  v2 = v2 / 3;
+            }
+        }
+
+        /* Reduce danger from sleeping monsters with the sleep 1,3 spell*/
+        if (borg_sleep_spell)
+        {
+            v2 = v2 / (d+2);
+        }
+        /* Reduce danger from confused monsters */
+        if (kill->confused)
+        {
+           v2 = v2 / 2;
+        }
+        /* Reduce danger from stunnned monsters  */
+        if (kill->stunned)
+        {
+           v2 = v2 *10/13;
+        }
+        if (borg_confuse_spell)
+        {
+            v2 = v2 / 6;
+        }
+
+#if 0 /* They still cast spells, they are still dangerous */
+        /* Reduce danger from scared monsters */
+        if (borg_fear_mon_spell)
+        {
+            v2 = v2 * 8/10;
+        }
+        if (kill->afraid)
+        {
+            v2 = v2 * 8/10;
+        }
+#endif
+        /* Tweak danger based on the "alertness" of the monster */
+        if (!kill->awake)
+        {
+            /* increase the danger for light sleepers */
+            int inc = r_ptr->sleep + 5;
+
+            v2 = v2 + (v2*inc/100);
+        }
+
+        if (!borg_full_damage)
+        {
+            /* reduce for frequency. */
+            chance = (r_ptr->freq_innate + r_ptr->freq_spell)/2;
+            if (chance < 11)
+                v2 = ((v2 * 4) / 10);
+            else
+            if (chance < 26)
+                v2 = ((v2 * 6) / 10);
+            else
+            if (chance < 51)
+                v2 = ((v2 * 8) / 10) ;
+        }
+
+        /* Danger */
+        if (v2)
+        {
+            /* Full power */
+            r = q;
+
+            /* Total danger */
+            v2 = v2 * r / 10;
+        }
+    }
+
+
+    /* Maximal danger */
+    p = MAX(v1, v2);
+	if (p > 2000) p = 2000;
+
+    /* Result */
+    return (p);
+}
+
+
+/*
+ * Hack -- Calculate the "danger" of the given grid.
+ *
+ * Currently based on the physical power of nearby monsters, as well
+ * as the spell power of monsters which can target the given grid.
+ *
+ * This function is extremely expensive, mostly due to the number of
+ * times it is called, and also to the fact that it calls its helper
+ * functions about thirty times each per call.
+ *
+ * We need to do more intelligent processing with the "c" parameter,
+ * since currently the Borg does not realize that backing into a
+ * hallway is a good idea, since as far as he can tell, many of
+ * the nearby monsters can "squeeze" into a single grid.
+ *
+ * Note that we also take account of the danger of the "region" in
+ * which the grid is located, which allows us to apply some "fear"
+ * of invisible monsters and things of that nature.
+ *
+ * Generally bool Average is TRUE.
+ */
+int borg_danger(int y, int x, int c, bool average)
+{
+    int i, p=0;
+
+    /* do twice.  Once to get full damage and once to get partial. */
+/* !FIX this is very slow.  I need to find a better way of doing this */
+/*      perhaps I should calc both at the same time and pass back */
+/*      the right one.  AJG */
+
+    /* Base danger (from regional fear) */
+	 p += borg_fear_region[y/11][x/11] * c;
+
+	/* Reduce regional fear on Depth 100 */
+	if (borg_skill[BI_CDEPTH] == 100 && p >= 300) p = 400;
+
+    /* Added danger (from a lot of monsters).
+     * But do not add it if we have been sitting on
+     * this panel for too long.  The fear_monsters[][]
+     * can induce some bouncy behavior.
+     */
+    if (time_this_panel <= 200) p += borg_fear_monsters[y][x] * c;
+
+    borg_full_damage = TRUE;
+
+    /* Examine all the monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Collect danger from monster */
+        p += borg_danger_aux(y, x, c, i, average);
+    }
+    borg_full_damage = FALSE;
+
+    /* if I can't be killed in one round (or severely wounded) use probablilities */
+    if (p < (avoidance*85/100) && p != 0)
+    {
+        /* Base danger (from fear) */
+        p = borg_fear_region[y/11][x/11] * c;
+
+	    /* Base danger (from fear) */
+	    p = borg_fear_monsters[y][x] * c;
+
+        /* Examine all the monsters */
+        for (i = 1; i < borg_kills_nxt; i++)
+        {
+            borg_kill *kill = &borg_kills[i];
+
+            /* Skip dead monsters */
+            if (!kill->r_idx) continue;
+
+            /* Collect danger from monster */
+            p += borg_danger_aux(y, x, c, i, average);
+        }
+    }
+
+    /* Return the danger */
+    return (p > 2000 ? 2000 : p);
+}
+
+
+
+
+/*
+ * Determine if the Borg is out of "crucial" supplies.
+ *
+ * Note that we ignore "restock" issues for the first several turns
+ * on each level, to prevent repeated "level bouncing".
+ */
+cptr borg_restock(int depth)
+{
+
+    /* We are now looking at our preparedness */
+    if ( -1 == borg_ready_morgoth)
+        borg_ready_morgoth = 0;
+
+    /* Always ready for the town */
+    if (!depth) return ((cptr)NULL);
+
+    /* Always spend time on a level unless 100*/
+    if (borg_t - borg_began < 100 && borg_skill[BI_CDEPTH] != 100) return ((cptr)NULL);
+
+
+    /*** Level 1 ***/
+
+    /* Must have some lite */
+    if (borg_skill[BI_CURLITE] < 1) return ("rs my_CURLITE");
+
+    /* Must have "fuel" */
+    if (borg_skill[BI_AFUEL] < 1 && !borg_skill[BI_LITE]) return ("rs amt_fuel");
+
+    /* Must have "food" */
+    if (borg_skill[BI_FOOD] < 1) return ("rs amt_food");
+
+    /* Assume happy at level 1 */
+    if (depth <= 1) return ((cptr)NULL);
+
+    /*** Level 2 and 3 ***/
+
+    /* Must have good lite */
+    if (borg_skill[BI_CURLITE] < 2) return ("rs lite+1");
+
+    /* Must have "fuel" */
+    if (borg_skill[BI_AFUEL] < 3 && !borg_skill[BI_LITE]) return ("rs fuel+2");
+
+    /* Must have "food" */
+    if (borg_skill[BI_FOOD] < 3) return ("rs food+2");
+
+    /* Must have "recall" */
+    if (borg_skill[BI_RECALL] < 2) return ("rs recall");
+
+    /* Assume happy at level 3 */
+    if (depth <= 3) return ((cptr)NULL);
+
+    /*** Level 3 to 5 ***/
+
+    if (depth <= 5) return ((cptr)NULL);
+
+    /*** Level 6 to 9 ***/
+
+    /* Must have "phase" */
+    if (borg_skill[BI_APHASE] < 1) return ("rs phase");
+
+    /* Potions of Critical Wounds */
+    if (borg_skill[BI_ACCW] < 1 &&
+        (!borg_skill[BI_RBLIND] || !borg_skill[BI_RCONF])) return ("rs cure crit");
+
+    /* Assume happy at level 9 */
+    if (depth <= 9) return ((cptr)NULL);
+
+
+    /*** Level 10 - 19  ***/
+
+    /* Must have "cure" */
+    if ((borg_skill[BI_MAXCLEVEL] < 30) && borg_skill[BI_ACSW] + borg_skill[BI_ACCW] < 2) return ("rs cure");
+
+    /* Must have "teleport" */
+    if (borg_skill[BI_ATELEPORT] + borg_skill[BI_AESCAPE] < 2) return ("rs tele&esc(1)");
+
+    /* Assume happy at level 19 */
+    if (depth <= 19) return ((cptr)NULL);
+
+
+    /*** Level 20 - 35  ***/
+
+    /* Must have "cure" */
+    if ((borg_skill[BI_MAXCLEVEL] < 30) && borg_skill[BI_ACSW] + borg_skill[BI_ACCW] < 4) return ("rs cure");
+
+    /* Must have "teleport" or Staff */
+    if (borg_skill[BI_ATELEPORT] + borg_skill[BI_AESCAPE] < 4) return ("rs tele&esc(4)");
+
+    /* Assume happy at level 44 */
+    if (depth <= 35) return ((cptr)NULL);
+
+
+    /*** Level 36 - 45  ***/
+
+    /* Must have Scroll of Teleport (or good 2nd choice) */
+    if (borg_skill[BI_ATELEPORT] + borg_skill[BI_ATELEPORTLVL] < 2) return ("rs teleport(1)");
+
+    /* Assume happy at level 44 */
+    if (depth <= 45) return ((cptr)NULL);
+
+
+    /*** Level 46 - 64  ***/
+
+    /* Assume happy at level 65 */
+    if (depth <= 64) return ((cptr)NULL);
+
+    /*** Level 65 - 99  ***/
+
+    /* Must have "Heal" */
+    if (borg_skill[BI_AHEAL] + borg_has[374] + borg_skill[BI_AEZHEAL] < 1) return ("rs heal");
+
+    /* Assume happy at level 99 */
+    if (depth <= 99) return ((cptr)NULL);
+
+    /*** Level 100  ***/
+
+    /* Must have "Heal" */
+    /* If I just got to dlevel 100 and low on heals, get out now. */
+    if (borg_t - borg_began < 10 && borg_skill[BI_AEZHEAL] < 15) return ("rs *heal*");
+
+    /* Assume happy */
+    return ((cptr)NULL);
+}
+
+/*
+ * Determine if the Borg meets the "minimum" requirements for a level
+ */
+static cptr borg_prepared_aux(int depth)
+{
+    int iEntry, nEntrys;
+    req_item* Req_item;
+    static char ret_string[2000]; /* hack.  big ass string to return 'why things are bad' string */
+
+    if ( -1 == borg_ready_morgoth)
+        borg_ready_morgoth = 0;
+
+    if (borg_skill[BI_KING])
+    {
+        borg_ready_morgoth = 1;
+        return ((cptr)NULL);
+    }
+
+    /* Always ready for the town */
+    if (!depth) return ((cptr)NULL);
+
+    borg_skill[BI_DEPTH] = depth;
+    borg_skill[BI_CDEPTH] = borg_skill[BI_CDEPTH];
+
+	/*** Require his Clevel to be greater than or equal to Depth */
+	if (borg_skill[BI_MAXCLEVEL] < depth && borg_skill[BI_MAXCLEVEL] < 50) return ("Clevel < depth");
+
+    nEntrys = n_req[borg_class];
+    for (iEntry = 0; iEntry < nEntrys; iEntry++)
+    {
+        Req_item = &borg_required_item[borg_class][iEntry];
+        if (Req_item->depth > depth)
+            break;
+
+
+
+
+        if (Req_item->item == -1)
+        {
+                if (!borg_calc_formula(formula[Req_item->number]))
+                {
+                    /* Some formulas from borg.txt deal with clevel and
+                     * depth of preparedness.  The option borg_plays_risky
+                     * will remove those requirements.  So those formulas
+                     * need to be removed here if that flag is set.
+                     */
+                    if (borg_plays_risky &&
+                        strstr(borg_prt_formula(formula[Req_item->number]), "CLEVEL"))
+                    {
+                        continue;
+                    }
+
+                    if (borg_slow_return)
+                        sprintf(ret_string,
+                            "Formula [%s] failed",
+                            borg_prt_formula(formula[Req_item->number]));
+                    else
+                        sprintf(ret_string, "Formula failed FORMULA%03d", Req_item->number);
+                    return ret_string;
+                }
+                continue;
+            }
+        if (borg_has[Req_item->item] < Req_item->number)
+        {
+            /* Some formulas from borg.txt deal with clevel and
+             * depth of preparedness.  The option borg_plays_risky
+             * will remove those requirements.  So those formulas
+             * need to be removed here if that flag is set.
+             */
+             if (borg_plays_risky &&
+                 strstr(borg_prt_item(Req_item->item), "CLEVEL"))
+             {
+                  continue;
+             }
+
+            sprintf(ret_string, "Number of %s < %d",
+                    borg_prt_item(Req_item->item), Req_item->number);
+            return ret_string;
+        }
+    }
+
+    return ((cptr)NULL);
+}
+
+/*
+ * Determine if the Borg meets the "minimum" requirements for a level
+ */
+static cptr borg_prepared_aux2(int depth)
+{
+    if ( -1 == borg_ready_morgoth)
+        borg_ready_morgoth = 0;
+    if (borg_skill[BI_KING])
+        {
+            borg_ready_morgoth = 1;
+            return ((cptr)NULL);
+        }
+
+    /* Always ready for the town */
+    if (!depth) return ((cptr)NULL);
+
+
+	/*** Require his Clevel to be greater than or equal to Depth */
+	if (borg_skill[BI_MAXCLEVEL] < depth && borg_skill[BI_MAXCLEVEL] < 50) return ("Clevel < depth");
+
+
+    /*** Essential Items for Level 1 ***/
+
+    /* Require lite (any) */
+    if (borg_skill[BI_CURLITE] < 1) return ("1 Lite");
+
+    /* Require food */
+    if (borg_skill[BI_FOOD] < 5) return ("5 Food");
+
+    /* Usually ready for level 1 */
+    if (depth <= 1) return ((cptr)NULL);
+
+
+    /*** Essential Items for Level 2 ***/
+
+    /* Require lite (radius two) */
+    if (borg_skill[BI_CURLITE] < 2) return ("2 Lite");
+
+    /* Require fuel */
+    if (borg_skill[BI_AFUEL] < 5 && !borg_skill[BI_LITE]) return ("5 Fuel");
+
+    /* Require recall */
+    if (borg_skill[BI_RECALL] < 1) return ("1 recall");
+
+    if (!borg_plays_risky)
+    {
+        /* Require 30 hp */
+        if (borg_skill[BI_MAXHP] < 30) return ("30 hp");
+    }
+
+    /* Usually ready for level 2 */
+    if (depth <= 2) return ((cptr)NULL);
+
+    /*** Essential Items for Level 3 and 4 ***/
+
+    if (!borg_plays_risky)
+    {
+        /* class specific requirement */
+        switch (borg_class)
+        {
+            case CLASS_WARRIOR:
+                if (borg_skill[BI_MAXHP] < 50) return ("50 hp");
+                if (borg_skill[BI_MAXCLEVEL] < 4) return ("4 clevel");
+                break;
+            case CLASS_ROGUE:
+                if (borg_skill[BI_MAXHP] < 50) return ("50 hp");
+                if (borg_skill[BI_MAXCLEVEL] < 8) return ("8 clevel");
+                break;
+            case CLASS_PRIEST:
+                if (borg_skill[BI_MAXHP] < 40) return ("40 hp");
+                if (borg_skill[BI_MAXCLEVEL] < 9) return ("9 level");
+                break;
+            case CLASS_PALADIN:
+                if (borg_skill[BI_MAXHP] < 50) return ("50 hp");
+                if (borg_skill[BI_MAXCLEVEL] < 4) return ("4 clevel");
+                break;
+            case CLASS_RANGER:
+                if (borg_skill[BI_MAXHP] < 50) return ("50 hp");
+                if (borg_skill[BI_MAXCLEVEL] < 4) return ("4 clevel");
+                break;
+            case CLASS_MAGE:
+                if (borg_skill[BI_MAXHP] < 60) return ("60 hp");
+                if (borg_skill[BI_MAXCLEVEL] < 11) return ("11 clevel");
+                break;
+        }
+    }
+
+    /* Potions of Cure Serious Wounds */
+    if ((borg_skill[BI_MAXCLEVEL] < 30) && borg_skill[BI_ACSW] + borg_skill[BI_ACCW] < 2) return ("2 cure");
+#if 0
+    /* Scrolls of Identify */
+    if (amt_ident < 2 && (borg_skill[BI_CDEPTH])) return ("2 ident");
+#endif
+    /* Usually ready for level 3 and 4 */
+    if (depth <= 4) return ((cptr)NULL);
+
+
+    /*** Essential Items for Level 5 to 9 ***/
+
+    if (!borg_plays_risky)
+    {
+        /* class specific requirement */
+        if (borg_skill[BI_CDEPTH])
+        {
+            switch (borg_class)
+            {
+                case CLASS_WARRIOR:
+                    if (borg_skill[BI_MAXHP] < 60) return ("60 hp");
+                    if (borg_skill[BI_MAXCLEVEL] < 6) return ("6 clevel");
+                    break;
+                case CLASS_ROGUE:
+                    if (borg_skill[BI_MAXHP] < 60) return ("60 hp");
+                    if (borg_skill[BI_MAXCLEVEL] < 10) return ("10 clevel");
+                    break;
+                case CLASS_PRIEST:
+                    if (borg_skill[BI_MAXHP] < 60) return ("60 hp");
+                    if (borg_skill[BI_MAXCLEVEL] < 15) return ("15 clevel");
+                    break;
+                case CLASS_PALADIN:
+                    if (borg_skill[BI_MAXHP] < 60) return ("60 hp");
+                    if (borg_skill[BI_MAXCLEVEL] < 6) return ("6 clevel");
+                    break;
+                case CLASS_RANGER:
+                    if (borg_skill[BI_MAXHP] < 60) return ("60 hp");
+                    if (borg_skill[BI_MAXCLEVEL] < 6) return ("6 clevel");
+                    break;
+                case CLASS_MAGE:
+                    if (borg_skill[BI_MAXHP] < 80) return ("80 hp");
+                    if (borg_skill[BI_MAXCLEVEL] < 15) return ("15 level");
+                    break;
+            }
+        }
+    }
+#if 0
+    /* Scrolls of Identify */
+    if (amt_ident < 5 && (borg_skill[BI_CDEPTH])) return ("5 idents");
+#endif
+    /* Potions of Cure Serious/Critical Wounds */
+    if ((borg_skill[BI_MAXCLEVEL] < 30) && borg_skill[BI_ACSW] + borg_skill[BI_ACCW] < 2) return ("2 cures");
+
+    /* Scrolls of Word of Recall */
+    if (borg_skill[BI_RECALL] < 2) return ("2 recall");
+
+    /* Usually ready for level 5 to 9 */
+    if (depth <= 9) return ((cptr)NULL);
+
+
+    /*** Essential Items for Level 10 to 19 ***/
+
+
+    /* Escape or Teleport */
+    if (borg_skill[BI_ATELEPORT] + borg_skill[BI_AESCAPE] < 2) return ("2 tele&esc");
+
+    if (!borg_plays_risky)
+    {
+        /* class specific requirement */
+        switch (borg_class)
+        {
+            case CLASS_WARRIOR:
+                if (borg_skill[BI_MAXCLEVEL] < (depth - 4) && depth <= 19)
+                    return ("dlevel - 4 >= clevel");
+                break;
+            case CLASS_ROGUE:
+                if (borg_skill[BI_MAXCLEVEL] < depth && depth <= 19) return ("dlevel >= clevel" );
+                break;
+            case CLASS_PRIEST:
+                if (borg_skill[BI_MAXCLEVEL] < depth && depth <= 19) return ("dlevel >= clevel" );
+                break;
+            case CLASS_PALADIN:
+                if (borg_skill[BI_MAXCLEVEL] < depth && depth <= 19) return ("dlevel >= clevel" );
+                break;
+            case CLASS_RANGER:
+                if (borg_skill[BI_MAXCLEVEL] < depth && depth <= 19) return ("dlevel >= clevel" );
+                break;
+            case CLASS_MAGE:
+                if (borg_skill[BI_MAXCLEVEL] < (depth + 5) && borg_skill[BI_MAXCLEVEL] <= 28)
+                    return ("dlevel + 5 > = clevel" );
+                break;
+        }
+    }
+#if 0
+    /* Identify */
+    if (amt_ident < 10) return ("ident10");
+#endif
+    /* Potions of Cure Critical Wounds */
+    if ((borg_skill[BI_MAXCLEVEL] < 30) && borg_skill[BI_ACCW] < 3) return ("cure crit3");
+
+    /* See invisible */
+    /* or telepathy */
+    if ((!borg_skill[BI_SINV] && !borg_skill[BI_DINV] &&
+         !borg_skill[BI_ESP])) return ("See Invis : ESP");
+
+    /* Usually ready for level 10 to 19 */
+    if (depth <= 19) return ((cptr)NULL);
+
+
+    /*** Essential Items for Level 20 ***/
+
+
+    /* Free action */
+    if (!borg_skill[BI_FRACT]) return ("FA");
+
+    /* ready for level 20 */
+    if (depth <= 20) return ((cptr)NULL);
+
+
+    /*** Essential Items for Level 25 ***/
+
+    /* must have fire + 2 other basic resists */
+    if (!borg_skill[BI_SRFIRE]) return ("RF");
+    {
+        int basics = borg_skill[BI_RACID] + borg_skill[BI_RCOLD] + borg_skill[BI_RELEC];
+
+        if (basics < 2) return ("basic resist2");
+    }
+    /* have some minimal stats */
+    if (borg_stat[A_STR] < 7) return ("low STR");
+
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+    {
+        if (borg_stat[A_INT] < 7) return ("low INT");
+    }
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+    {
+        if (borg_stat[A_WIS] < 7) return ("low WIS");
+    }
+    if (borg_stat[A_DEX] < 7) return ("low DEX");
+    if (borg_stat[A_CON] < 7) return ("low CON");
+
+    if (!borg_plays_risky)
+    {
+        /* class specific requirement */
+        switch (borg_class)
+        {
+            case CLASS_WARRIOR:
+                if (borg_skill[BI_MAXCLEVEL] < (depth + 5) && borg_skill[BI_MAXCLEVEL] <= 38)
+                    return ("dlevel + 5 >= clevel" );
+                break;
+            case CLASS_ROGUE:
+                if (borg_skill[BI_MAXCLEVEL] < (depth + 10) && borg_skill[BI_MAXCLEVEL] <= 43)
+                    return ("dlevel + 10 >= clevel" );
+                break;
+            case CLASS_PRIEST:
+                if (borg_skill[BI_MAXCLEVEL] < (depth + 13) && borg_skill[BI_MAXCLEVEL] <= 46)
+                    return ("dlevel + 13 >= clevel" );
+                break;
+            case CLASS_PALADIN:
+                if (borg_skill[BI_MAXCLEVEL] < (depth + 7) && borg_skill[BI_MAXCLEVEL] <= 40)
+                    return ("dlevel + 7 >= clevel" );
+                break;
+            case CLASS_RANGER:
+                if (borg_skill[BI_MAXCLEVEL] < (depth + 8) && borg_skill[BI_MAXCLEVEL] <= 41 && borg_skill[BI_MAXCLEVEL] > 28)
+                    return ("dlevel + 8 >= clevel" );
+                break;
+            case CLASS_MAGE:
+                if (borg_skill[BI_MAXCLEVEL] < (depth + 8) && borg_skill[BI_MAXCLEVEL] <= 38)
+                    return ("dlevel + 8 >= clevel" );
+                if (((borg_skill[BI_MAXCLEVEL]-38) * 2 + 30) < depth &&
+                    borg_skill[BI_MAXCLEVEL] <= 44 &&
+                    borg_skill[BI_MAXCLEVEL] > 38)
+                    return ("(clevel-38)*2+30 < dlevel" );
+                break;
+        }
+    }
+
+    /* Ready for level 25 */
+    if (depth <= 25) return ((cptr)NULL);
+
+
+/*** Essential Items for Level 25 to 39 ***/
+
+    /* All Basic resistance*/
+    if (!borg_skill[BI_SRCOLD]) return ("RC");
+    if (!borg_skill[BI_SRELEC]) return ("RE");
+    if (!borg_skill[BI_SRACID]) return ("RA");
+
+    /* Escape and Teleport */
+    if (borg_skill[BI_ATELEPORT] + borg_skill[BI_AESCAPE] < 6) return ("tell&esc6");
+
+    /* Cure Critical Wounds */
+    if ((borg_skill[BI_MAXCLEVEL] < 30) && (borg_skill[BI_ACCW] + borg_skill[BI_ACSW]) < 10) return ("cure10");
+
+    /* Ready for level 33 */
+    if (depth <= 33) return ((cptr)NULL);
+
+    /* Minimal level */
+    if (borg_skill[BI_MAXCLEVEL] < 40  && !borg_plays_risky) return ("level 40");
+
+    /* Usually ready for level 20 to 39 */
+    if (depth <= 39) return ((cptr)NULL);
+
+
+
+/*** Essential Items for Level 40 to 45 ***/
+
+    /* Resist */
+    if (!borg_skill[BI_SRPOIS]) return ("RPois");
+    if (!borg_skill[BI_SRCONF])  return ("RConf");
+
+    if (borg_stat[A_STR] < 16) return ("low STR");
+
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+    {
+        if (borg_stat[A_INT] < 16) return ("low INT");
+    }
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+    {
+        if (borg_stat[A_WIS] < 16) return ("low WIS");
+    }
+    if (borg_stat[A_DEX] < 16) return ("low DEX");
+    if (borg_stat[A_CON] < 16) return ("low CON");
+
+
+	/* Ok to continue */
+    if (depth <= 45) return ((cptr)NULL);
+
+
+/*** Essential Items for Level 46 to 55 ***/
+
+    /*  Must have +5 speed after level 46 */
+    if (borg_skill[BI_SPEED] < 115) return ("+5 speed");
+
+    /* Potions of heal */
+    if (borg_skill[BI_AHEAL] < 1 && (borg_skill[BI_AEZHEAL] < 1) ) return ("1heal");
+
+    if (!borg_plays_risky)
+    {
+        /* Minimal hitpoints */
+        if (borg_skill[BI_MAXHP] < 500) return ("HP 500");
+    }
+
+    /* High stats XXX XXX XXX */
+    if (borg_stat[A_STR] < 18+40) return ("low STR");
+
+    if (cp_ptr->spell_book == TV_MAGIC_BOOK)
+    {
+        if (borg_stat[A_INT] < 18+100) return ("low INT");
+    }
+    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+    {
+        if (borg_stat[A_WIS] < 18+100) return ("low WIS");
+    }
+    if (borg_stat[A_DEX] < 18+60) return ("low DEX");
+    if (borg_stat[A_CON] < 18+60) return ("low CON");
+
+    /* Hold Life */
+    if ((!borg_skill[BI_HLIFE] && !weapon_swap_hold_life &&
+        !armour_swap_hold_life) && (borg_skill[BI_MAXCLEVEL] < 50) ) return ("hold life");
+
+    /* Usually ready for level 46 to 55 */
+    if (depth <= 55) return ((cptr)NULL);
+
+/*** Essential Items for Level 55 to 59 ***/
+
+    /* Potions of heal */
+    if (borg_skill[BI_AHEAL] < 2 && borg_skill[BI_AEZHEAL] < 1) return ("2heal");
+
+    /* Resists */
+    if (!borg_skill[BI_SRBLIND]) return ("RBlind");
+
+    /* Must have resist nether */
+/*    if (!borg_plays_risky && !borg_skill[BI_SRNTHR]) return ("RNeth"); */
+
+
+    /* Telepathy, better have it by now */
+    if (!borg_skill[BI_ESP]) return ("ESP");
+
+    /* Usually ready for level 55 to 59 */
+    if (depth <= 59) return ((cptr)NULL);
+
+
+
+/*** Essential Items for Level 61 to 80 ***/
+
+    /* Must have +10 speed */
+    if (borg_skill[BI_SPEED] < 120) return ("+10 speed");
+
+
+    /* Resists */
+    if (!borg_skill[BI_SRKAOS]) return ("RChaos");
+    if (!borg_skill[BI_SRDIS]) return ("RDisen");
+
+    /* Usually ready for level 61 to 80 */
+    if (depth <= 80) return ((cptr)NULL);
+
+/*** Essential Items for Level 81-85 ***/
+    /* Minimal Speed */
+    if (borg_skill[BI_SPEED] < 130) return ("+20 Speed");
+
+    /* Usually ready for level 81 to 85 */
+    if (depth <= 85) return ((cptr)NULL);
+
+
+/*** Essential Items for Level 86-99 ***/
+
+
+    /* Usually ready for level 86 to 99 */
+    if (depth <= 99) return ((cptr)NULL);
+
+/*** Essential Items for Level 100 ***/
+
+    /* must have lots of restore mana to go after MORGOTH */
+    if (!borg_skill[BI_KING])
+    {
+        if ((borg_skill[BI_MAXSP] > 100) && (borg_has[266] < 15)) return ("10ResMana");
+
+        /* must have lots of heal */
+        if (borg_has[242] < 15) return ("15Heal");
+        else if (borg_has[242] < 25) return ("25Heal");
+
+        /* must have lots of ez-heal */
+        if (borg_skill[BI_AEZHEAL] < 15) return ("15EZHeal");
+
+        /* must have lots of speed */
+        if (borg_skill[BI_ASPEED] < 10) return ("10Speed");
+
+      }
+
+    /* Its good to be the king */
+    if (depth <= 127) return ((cptr)NULL);
+
+    /* all bases covered */
+    return ((cptr)NULL);
+}
+
+/* buffer for borg_prepared mesage
+ */
+#define MAX_REASON 1024
+static char borg_prepared_buffer[MAX_REASON];
+
+/*
+ * Determine if the Borg is "prepared" for the given level
+ *
+ * This routine does not help him decide how to get ready for the
+ * given level, so it must work closely with "borg_power()".
+ *
+ * Note that we ignore any "town fear", and we allow fear of one
+ * level up to and including the relevant depth.
+ *
+ * This now returns a string with the reason you are not prepared.
+ *
+ */
+cptr borg_prepared(int depth)
+{
+    cptr reason;
+
+    /* -1 is unknown. */
+    borg_ready_morgoth = -1;
+
+    /* Town and First level */
+    if (depth == 1) return ((cptr)NULL);
+
+    /* Not prepared if I need to restock */
+    if ((reason = borg_restock(depth)))	return (reason);
+
+	/* Must meet minimal requirements */
+	if (depth <= 99)
+	{
+
+    	if (borg_uses_calcs)
+    	{
+    	    if ((reason = borg_prepared_aux(depth))) return (reason);
+    	}
+
+    	if (!borg_uses_calcs)
+    	{
+    	    if ((reason = borg_prepared_aux2(depth))) return (reason);
+    	}
+	}
+
+	/* Not if No_Deeper is set */
+	if (depth >= borg_no_deeper)
+	{
+       	strnfmt(borg_prepared_buffer, MAX_REASON, "No deeper %d.", borg_no_deeper);
+       	return (borg_prepared_buffer);
+	}
+
+
+    /* Once Morgoth is dead */
+    if (borg_skill[BI_KING])
+    {
+        return ((cptr)NULL);
+    }
+
+    /* Always okay from town */
+    if (!borg_skill[BI_CDEPTH])	return (reason);
+
+	/* Scum on depth 80-81 for some *heal* potions */
+	if (depth >= 82 && (num_ez_heal < 10 && borg_skill[BI_AEZHEAL] < 10))
+	{
+        /* Must know exact number of Potions  in home */
+        borg_notice_home(NULL, FALSE);
+
+       	strnfmt(borg_prepared_buffer, MAX_REASON, "Scumming *Heal* potions (%d to go).", 10-num_ez_heal);
+       	return (borg_prepared_buffer);
+	}
+
+    /* Scum on depth 80-81 for lots of *Heal* potions preparatory for Endgame */
+    if (depth >= 82 && borg_skill[BI_MAXDEPTH] >= 97)
+    {
+        /* Must know exact number of Potions  in home */
+        borg_notice_home(NULL, FALSE);
+
+        /* Scum for 50*/
+        if (num_ez_heal_true + borg_skill[BI_AEZHEAL] < 50)
+        {
+       		strnfmt(borg_prepared_buffer, MAX_REASON, "Scumming *Heal* potions (%d to go).", 50-
+       		        (num_ez_heal_true + borg_skill[BI_AEZHEAL]));
+       		return (borg_prepared_buffer);
+        }
+	}
+
+    /* Check to make sure the borg does not go below where 2 living */
+    /* uniques are. */
+    if (borg_skill[BI_MAXDEPTH] <= 98)
+    {
+          monster_race *r_ptr = &r_info[borg_living_unique_index];
+
+		/* are too many uniques alive */
+        if (borg_numb_live_unique < 3 || borg_plays_risky ||
+        	borg_skill[BI_CLEVEL] == 50) return ((cptr)NULL);
+
+		/* Check for the dlevel of the unique */
+		if (depth < borg_unique_depth) return ((cptr)NULL);
+
+      	/* scum for the uniques and report */
+      	if (borg_scums_uniques && borg_skill[BI_MAXCLEVEL] >= 35) auto_scum = TRUE;
+
+       	/* To avoid double calls to format() */
+ 	   	/* Reset our description for not diving */
+       	strnfmt(borg_prepared_buffer, MAX_REASON, "Must kill %s.", r_name + r_ptr->name);
+       	return (borg_prepared_buffer);
+
+    }
+    else /* Deep Dungeon */
+      /* check to make sure the borg does not go to level 100 */
+      /* unless all the uniques are dead. */
+    {
+          monster_race *r_ptr;
+
+		  /* Access the living unique obtained from borg_update() */
+          r_ptr = &r_info[borg_living_unique_index];
+
+          if (borg_numb_live_unique < 1 ||
+              borg_living_unique_index == 547) /* Morgoth */
+          {
+            	if (depth >= 99) borg_ready_morgoth = 1;
+            	return ((cptr)NULL);
+          }
+
+          /* Under special cases allow the borg to dive to 99 then quickly
+           * get his butt to dlevel 98
+           */
+          if (borg_skill[BI_MAXDEPTH] == 99 && depth <= 98 &&
+              (rand_int(100) < 3 ||
+               borg_prayer_okay_fail(4, 3, 20) || /* Teleport Level */
+               borg_spell_okay_fail(6, 2, 20) || /* Teleport Level */
+               borg_skill[BI_ATELEPORTLVL] >= 1)) /* Teleport Level scroll */
+          {
+              if (borg_scums_uniques) auto_scum = TRUE;
+              return ((cptr)NULL);
+          }
+
+		/* Scum and Report */
+      	if (borg_scums_uniques) auto_scum = TRUE;
+
+      	/* To avoid double calls to format() */
+      	strnfmt(borg_prepared_buffer, MAX_REASON, "%s still alive!", r_name + r_ptr->name);
+      	return (borg_prepared_buffer);
+
+    }
+
+}
+
+/*
+ * Initialize this file
+ */
+void borg_init_4(void)
+{
+    /* Do nothing? */
+}
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg4.h angband-3.0.6-borg/src/borg4.h
--- angband-3.0.6/src/borg4.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg4.h	2001-11-09 22:14:56.000000000 -0800
@@ -0,0 +1,82 @@
+
+/* File: borg4.h */
+
+/* Purpose: Header file for "borg4.c" -BEN- */
+
+#ifndef INCLUDED_BORG4_H
+#define INCLUDED_BORG4_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg4.c".
+ */
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+
+
+
+/*
+ * Extract various bonuses
+ */
+extern void borg_notice(bool notice_swap);
+
+/*
+ * Extract the bonuses for items in the home.
+ *
+ * in_item is passed in if you want to pretent that in_item is
+ *          the only item in the home.
+ * no_items is passed in as TRUE if you want to pretend that the
+ *          home is empty.
+ */
+extern void borg_notice_home(borg_item *in_item, bool no_items);
+
+
+/*
+ * Calculate the basic "power"
+ */
+extern s32b borg_power(void);
+
+/*
+ * Calculate the basic "power" of the home
+ */
+extern s32b borg_power_home(void);
+
+
+
+/*
+ * Calculate danger to a grid from a monster
+ */
+extern int borg_danger_aux(int y, int x, int c, int i, bool average);
+
+/*
+ * Hack -- Calculate the "danger" of the given grid.
+ */
+extern int borg_danger(int y, int x, int c, bool average);
+
+
+/*
+ * Determine if the Borg is out of "crucial" supplies.
+ */
+extern cptr borg_restock(int depth);
+
+/*
+ * Determine if the Borg is "prepared" for the given level
+ */
+extern cptr borg_prepared(int depth);
+
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_4(void);
+
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg5.c angband-3.0.6-borg/src/borg5.c
--- angband-3.0.6/src/borg5.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg5.c	2005-10-25 19:42:44.000000000 -0700
@@ -0,0 +1,5363 @@
+/* File: borg5.c */
+/* Purpose: Medium level stuff for the Borg -BEN- */
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg4.h"
+#include "borg5.h"
+
+
+
+/*
+ * This file is responsible for the "borg_update" routine, which is used
+ * to notice changes in the world, and to keep track of terrain features,
+ * objects, monsters, both from visual changes, and from world messages.
+ *
+ * One big thing this file does is "object/monster tracking", which
+ * attempts to gather information about the objects and monsters in
+ * the dungeon, including their identity, location, and state, and
+ * to "follow" them if they "move", and to delete them when they die.
+ *
+ * Information about terrain is used to help plan "flow" paths.  Info
+ * about objects and monsters is used to optimize planning paths to
+ * those objects and monsters.  Info about monsters is also used for
+ * the "danger" functions, which help avoid dangerous situations.
+ *
+ * Notes:
+ *   We assume that monsters/objects can never appear in walls/doors
+ *   We count the occurance of invisible or offscreen monsters
+ *   We treat "mimics" and "trappers" as "invisible" monsters
+ *
+ * To Do:
+ *   Track approximate monster hitpoints (min/max hitpoints?)
+ *   If so, factor in regeneration and various spell attacks
+ *   Take account of monster "fear" when "following" monsters
+ *
+ * Bugs:
+ *   Groups of monsters may induce faulty monster matching
+ *   Teleporting monsters may induce faulty monster matching
+ *   Monsters which appear singly and in groups are "weird"
+ *   The timestamps are not quite in sync properly (?)
+ */
+
+
+/*
+ * Old values
+ */
+
+static int o_w_x = -1;      /* Old panel */
+static int o_w_y = -1;      /* Old panel */
+
+static int o_c_x = -1;      /* Old location */
+static int o_c_y = -1;      /* Old location */
+
+
+/*
+ * Hack -- message memory
+ */
+
+static s16b borg_msg_len;
+
+static s16b borg_msg_siz;
+
+static char *borg_msg_buf;
+
+static s16b borg_msg_num;
+
+static s16b borg_msg_max;
+
+static s16b *borg_msg_pos;
+
+static s16b *borg_msg_use;
+
+
+/*
+ * Hack -- help identify "unique" monster names
+ */
+
+static int borg_unique_size;        /* Number of uniques */
+static s16b *borg_unique_what;      /* Indexes of uniques */
+static cptr *borg_unique_text;      /* Names of uniques */
+
+/*
+ * Hack -- help identify "normal" monster names
+ */
+
+static int borg_normal_size;        /* Number of normals */
+static s16b *borg_normal_what;      /* Indexes of normals */
+static cptr *borg_normal_text;      /* Names of normals */
+
+
+
+/*
+ * Hack -- monster/object tracking grids
+ */
+
+typedef struct borg_wank borg_wank;
+
+struct borg_wank
+{
+    byte x;
+    byte y;
+
+    byte t_a;
+    char t_c;
+
+    bool is_take;
+    bool is_kill;
+};
+
+
+
+/*
+ * Hack -- object/monster tracking array
+ */
+
+static int borg_wank_num = 0;
+
+static borg_wank *borg_wanks;
+
+
+
+
+/*
+ * Attempt to guess what kind of object is at the given location.
+ *
+ * This routine should rarely, if ever, return "zero".
+ *
+ * Hack -- we use "base level" instead of "allocation levels".
+ */
+static int borg_guess_kind(byte a, char c,int y,int x)
+{
+    /* ok, this is an real cheat.  he ought to use the look command
+     * in order to correctly id the object.  But I am passing that up for
+     * the sake of speed and accuracy
+     */
+
+    /* Cheat the Actual item */
+    s16b k_idx;
+    object_type *o_ptr;
+    k_idx = cave_o_idx[y][x];
+    o_ptr= &o_list[k_idx];
+    return (o_ptr->k_idx);
+#if 0
+/* The rest here is the original code.  It made several mistakes */
+    /* Actual item */
+    {
+    int i, s;
+
+    int b_i = 0, b_s = 0;
+    /* Find an "acceptable" object */
+
+    for (i = 1; i < z_info->k_max; i++)
+    {
+        object_kind *k_ptr = &k_info[i];
+
+        /* Skip non-objects */
+        if (!k_ptr->name) continue;
+
+
+        /* Base score */
+        s = 10000;
+
+
+        /* Hack -- penalize "extremely" out of depth */
+        if (k_ptr->level > borg_skill[BI_CDEPTH] + 50) s = s - 500;
+
+        /* Hack -- penalize "very" out of depth */
+        if (k_ptr->level > borg_skill[BI_CDEPTH] + 15) s = s - 100;
+
+        /* Hack -- penalize "rather" out of depth */
+        if (k_ptr->level > borg_skill[BI_CDEPTH] + 5) s = s - 50;
+
+        /* Hack -- penalize "somewhat" out of depth */
+        if (k_ptr->level > borg_skill[BI_CDEPTH]) s = s - 10;
+
+        /* Hack -- Penalize "depth miss" */
+        s = s - ABS(k_ptr->level - borg_skill[BI_CDEPTH]);
+
+
+        /* Hack -- Penalize INSTA_ART items */
+        if (k_ptr->flags3 & TR3_INSTA_ART) s = s - 1000;
+
+
+        /* Hack -- Penalize CURSED items */
+        if (k_ptr->flags3 & TR3_LIGHT_CURSE) s = s - 5000;
+
+        /* Hack -- Penalize BROKEN items */
+        if (k_ptr->cost <= 0) s = s - 5000;
+
+
+        /* Verify char */
+        if (c != k_ptr->d_char) continue;
+
+
+        /* Flavored objects */
+        if (k_ptr->flavor)
+        {
+            /* Hack -- penalize "flavored" objects */
+            s = s - 20;
+        }
+
+        /* Normal objects */
+        else
+        {
+            /* Verify attr */
+              if (a != k_ptr->d_attr) continue;
+        }
+
+
+        /* Desire "best" possible score */
+        if (b_i && (s < b_s)) continue;
+
+        /* Track it */
+        b_i = i; b_s = s;
+    }
+
+    /* Result */
+    return (b_i);
+}
+#endif
+}
+
+
+/*
+ * Delete an old "object" record
+ */
+void borg_delete_take(int i)
+{
+    borg_grid *ag;
+
+    borg_take *take = &borg_takes[i];
+
+    /* Paranoia -- Already wiped */
+    if (!take->k_idx) return;
+
+    /* Note */
+    borg_note(format("# Forgetting an object '%s' at (%d,%d)",
+                     (k_name + k_info[take->k_idx].name),
+                     take->y, take->x));
+
+    /* Access the grid */
+    ag = &borg_grids[take->y][take->x];
+
+    /* Forget it */
+    ag->take = 0;
+
+    /* Kill the object */
+    WIPE(take, borg_take);
+
+    /* One less object */
+    borg_takes_cnt--;
+
+    /* Wipe goals */
+    if (goal == GOAL_TAKE) goal = 0;
+}
+
+
+/*
+ * Determine if an object should be "viewable"
+ */
+static bool borg_follow_take_aux(int i, int y, int x)
+{
+    borg_grid *ag;
+
+
+    /* Access the grid */
+    ag = &borg_grids[y][x];
+
+    /* Not on-screen */
+    if (!(ag->info & BORG_OKAY)) return (FALSE);
+
+    /* Assume viewable */
+    return (TRUE);
+}
+
+
+/*
+ * Attempt to "follow" a missing object
+ *
+ * This routine is not called when the player is blind or hallucinating.
+ *
+ * This function just deletes objects which have disappeared.
+ *
+ * We assume that a monster walking onto an object destroys the object.
+ */
+static void borg_follow_take(int i)
+{
+    int ox, oy;
+
+    borg_take *take = &borg_takes[i];
+
+
+    /* Paranoia */
+    if (!take->k_idx) return;
+
+
+    /* Old location */
+    ox = take->x;
+    oy = take->y;
+
+    /* delete them if they are under me */
+    if (take->y == c_y && take->x == c_x)
+    {
+        borg_delete_take(i);
+    }
+
+    /* Out of sight */
+    if (!borg_follow_take_aux(i, oy, ox)) return;
+
+
+    /* Note */
+    borg_note(format("# There was an object '%s' at (%d,%d)",
+                     (k_name + k_info[take->k_idx].name),
+                     ox, oy));
+
+
+    /* Kill the object */
+    borg_delete_take(i);
+}
+
+
+
+/*
+ * Obtain a new "take" index
+ */
+static int borg_new_take(int k_idx, int y, int x)
+{
+    int i, n = -1;
+
+    borg_take *take;
+
+    borg_grid *ag = &borg_grids[y][x];
+
+
+    /* Look for a "dead" object */
+    for (i = 1; (n < 0) && (i < borg_takes_nxt); i++)
+    {
+        /* Reuse "dead" objects */
+        if (!borg_takes[i].k_idx) n = i;
+    }
+
+    /* Allocate a new object */
+    if ((n < 0) && (borg_takes_nxt < 256))
+    {
+        /* Acquire the entry, advance */
+        n = borg_takes_nxt++;
+    }
+
+    /* Hack -- steal an old object */
+    if (n < 0)
+    {
+        /* Note */
+        borg_note("# Too many objects");
+
+        /* Hack -- Pick a random object */
+        n = rand_int(borg_takes_nxt-1) + 1;
+
+        /* Delete it */
+        borg_delete_take(n);
+    }
+
+
+    /* Count new object */
+    borg_takes_cnt++;
+
+    /* Obtain the object */
+    take = &borg_takes[n];
+
+    /* Save the kind */
+    take->k_idx = k_idx;
+
+    /* Save the location */
+    take->x = x;
+    take->y = y;
+
+    /* Save the index */
+    ag->take = n;
+
+    /* Timestamp */
+    take->when = borg_t;
+
+    /* Note */
+    borg_note(format("# Creating an object '%s' at (%d,%d)",
+                     (k_name + k_info[take->k_idx].name),
+                     take->x, take->y));
+
+    /* Wipe goals only if I have some light source */
+    if (borg_skill[BI_CURLITE]) goal = 0;
+
+	/* Hack -- Force the object to sit on a floor grid */
+	ag->feat = FEAT_FLOOR;
+
+    /* Result */
+    return (n);
+}
+
+
+
+/*
+ * Attempt to notice a changing "take"
+ */
+static bool observe_take_diff(int y, int x, byte a, char c)
+{
+    int i, k_idx;
+
+    borg_take *take;
+
+    /* Guess the kind */
+    k_idx = borg_guess_kind(a, c,y,x);
+
+    /* Oops */
+    if (!k_idx) return (FALSE);
+
+    /* no new takes if hallucinations */
+    if (borg_skill[BI_ISIMAGE]) return (FALSE);
+
+    /* Make a new object */
+    i = borg_new_take(k_idx, y, x);
+
+    /* Get the object */
+    take = &borg_takes[i];
+
+    /* Timestamp */
+    take->when = borg_t;
+
+    /* Okay */
+    return (TRUE);
+}
+
+
+/*
+ * Attempt to "track" a "take" at the given location
+ * Assume that the object has not moved more than "d" grids
+ * Note that, of course, objects are never supposed to move,
+ * but we may want to take account of "falling" missiles later.
+ */
+static bool observe_take_move(int y, int x, int d, byte a, char c)
+{
+    int i, z, ox, oy;
+
+    object_kind *k_ptr;
+
+    /* Scan the objects */
+    for (i = 1; i < borg_takes_nxt; i++)
+    {
+        borg_take *take = &borg_takes[i];
+
+        /* Skip dead objects */
+        if (!take->k_idx) continue;
+
+        /* Skip assigned objects */
+        if (take->seen) continue;
+
+        /* Extract old location */
+        ox = take->x;
+        oy = take->y;
+
+        /* Calculate distance */
+        z = distance(oy, ox, y, x);
+
+        /* Possible match */
+        if (z > d) continue;
+
+        /* Access the kind */
+        k_ptr = &k_info[take->k_idx];
+
+        /* Require matching char if not hallucinating*/
+        if (!borg_skill[BI_ISIMAGE] && c != k_ptr->d_char) continue;
+
+        /* Require matching attr if not hallucinating rr9*/
+        if (!borg_skill[BI_ISIMAGE] && a != k_ptr->d_attr  &&
+            (k_ptr->d_attr != 11 && k_ptr->d_char == '!')
+            /* There are serious bugs
+            with Flasks of Oil not having the attr set
+            correctly */)
+        {
+            /* Ignore "flavored" colors */
+            if (!k_ptr->flavor) continue;
+        }
+
+        /* Actual movement (?) */
+        if (z)
+        {
+            /* Update the grids */
+            borg_grids[take->y][take->x].take = 0;
+
+            /* Track it */
+            take->x = x;
+            take->y = y;
+
+            /* Update the grids */
+            borg_grids[take->y][take->x].take = i;
+
+            /* Note */
+            borg_note(format("# Tracking an object '%s' at (%d,%d) from (%d,%d)",
+                             (k_name + k_ptr->name),
+                             take->y, take->x, ox, oy));
+
+            /* Clear goals */
+            if (goal == GOAL_TAKE) goal = 0;
+        }
+
+        /* Timestamp */
+        take->when = borg_t;
+
+        /* Mark as seen */
+        take->seen = TRUE;
+
+		/* Mark floor underneath */
+		borg_grids[take->y][take->x].feat = FEAT_FLOOR;
+
+        /* Done */
+        return (TRUE);
+    }
+
+    /* Oops */
+    return (FALSE);
+}
+
+
+
+
+/*
+ * Attempt to guess what type of monster is at the given location.
+ *
+ * If we are unable to think of any monster that could be at the
+ * given location, we will assume the monster is a player ghost.
+ * This is a total hack, but may prevent crashes.
+ *
+ * The guess can be improved by the judicious use of a specialized
+ * "attr/char" mapping, especially for unique monsters.  Currently,
+ * the Borg does not stoop to such redefinitions.
+ *
+ * We will probably fail to identify "trapper" and "lurker" monsters,
+ * since they look like whatever they are standing on.  Now we will
+ * probably just assume they are player ghosts.  XXX XXX XXX
+ *
+ * Note that "town" monsters may only appear in town, and in "town",
+ * only "town" monsters may appear, unless we summon or polymorph
+ * a monster while in town, which should never happen.
+ *
+ * To guess which monster is at the given location, we consider every
+ * possible race, keeping the race (if any) with the best "score".
+ *
+ * Certain monster races are "impossible", including town monsters
+ * in the dungeon, dungeon monsters in the town, unique monsters
+ * known to be dead, monsters more than 50 levels out of depth,
+ * and monsters with an impossible char, or an impossible attr.
+ *
+ * Certain aspects of a monster race are penalized, including extreme
+ * out of depth, minor out of depth, clear/multihued attrs.
+ *
+ * Certain aspects of a monster race are rewarded, including monsters
+ * that appear in groups, monsters that reproduce, monsters that have
+ * been seen on this level a lot.
+ *
+ * We are never called for "trapper", "lurker", or "mimic" monsters.
+ *
+ * The actual rewards and penalties probably need some tweaking.
+ *
+ * Hack -- try not to choose "unique" monsters, or we will flee a lot.
+ */
+static int borg_guess_race(byte a, char c, bool multi, int y, int x)
+{
+    /* apw ok, this is an real cheat.  he ought to use the look command
+     * in order to correctly id the monster.  but i am passing that up for
+     * the sake of speed
+     */
+#if 0
+    int i, s, n;
+    int b_i = 0, b_s = 0;
+#endif
+
+    s16b m_idx;
+    monster_type   *m_ptr;
+    m_idx = cave_m_idx[y][x];
+    m_ptr= &mon_list[m_idx];
+    /* Actual monsters */
+    return (m_ptr->r_idx);
+
+#if 0
+    /* If I cannot locate it, then use the old routine to id the monster */
+    /* Find an "acceptable" monster */
+    for (i = 1; i < z_info->r_max-1; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+
+        /* Skip non-monsters */
+        if (!r_ptr->name) continue;
+
+
+        /* Base score */
+        s = 10000;
+
+
+        /* Verify char rr9*/
+        if (c != r_ptr->d_char) continue;
+
+        /* Clear or multi-hued monsters */
+        if (r_ptr->flags1 & (RF1_ATTR_MULTI | RF1_ATTR_CLEAR))
+        {
+            /* Penalize "weird" monsters */
+            if (!multi) s = s - 1000;
+        }
+
+        /* Normal monsters */
+        else
+        {
+            /* Verify multi */
+            if (multi) continue;
+
+            /* Verify attr */
+            if (a != r_ptr->d_attr) continue;
+        }
+
+
+        /* Check uniques */
+        if (r_ptr->flags1 & RF1_UNIQUE)
+        {
+            /* Hack -- Dead uniques stay dead */
+            if (borg_race_death[i] > 0) continue;
+
+            /* Prefer normals */
+            s = s - 10;
+        }
+
+
+        /* Hack -- penalize "extremely" out of depth */
+        if (r_ptr->level > borg_skill[BI_CDEPTH] + 50) continue;
+
+        /* Hack -- penalize "very" out of depth */
+        if (r_ptr->level > borg_skill[BI_CDEPTH] + 15) s = s - 100;
+
+        /* Hack -- penalize "rather" out of depth */
+        if (r_ptr->level > borg_skill[BI_CDEPTH] + 5) s = s - 50;
+
+        /* Hack -- penalize "somewhat" out of depth */
+        if (r_ptr->level > borg_skill[BI_CDEPTH]) s = s - 10;
+
+        /* Penalize "depth miss" */
+        s = s - ABS(r_ptr->level - borg_skill[BI_CDEPTH]);
+
+
+        /* Hack -- Reward group monsters */
+        if (r_ptr->flags1 & (RF1_FRIEND | RF1_FRIENDS)) s = s + 5;
+
+        /* Hack -- Reward multiplying monsters */
+        if (r_ptr->flags2 & RF2_MULTIPLY) s = s + 10;
+
+
+        /* Count occurances */
+        n = borg_race_count[i];
+
+        /* Mega-Hack -- Reward occurances XXX XXX XXX */
+        s = s + (n / 100) + (((n < 100) ? n : 100) / 10) + ((n < 10) ? n : 10);
+
+
+        /* Desire "best" possible score */
+        if (b_i && (s < b_s)) continue;
+
+        /* Track it */
+        b_i = i; b_s = s;
+    }
+
+    /* Success */
+    if (b_i) return (b_i);
+
+
+    /* Message */
+    borg_note(format("# Assuming player ghost (char %d, attr %d)", c, a));
+
+    /* Assume player ghost */
+    return (z_info->r_max - 1);
+#endif
+}
+
+
+/*
+ * Attempt to convert a monster name into a race index
+ *
+ * First we check for all possible "unique" monsters, including
+ * ones we have killed, and even if the monster name is "prefixed"
+ * (as in "The Tarrasque" and "The Lernean Hydra").  Since we use
+ * a fast binary search, this is acceptable.
+ *
+ * Otherwise, if the monster is NOT named "The xxx", we assume it
+ * must be a "player ghost" (which is impossible).
+ *
+ * Then, we do a binary search on all "normal" monster names, using
+ * a search which is known to find the last matching entry, if one
+ * exists, and otherwise to find an entry which would follow the
+ * matching entry if there was one, unless the matching entry would
+ * follow all the existing entries, in which case it will find the
+ * final entry in the list.  Thus, we can search *backwards* from
+ * the result of the search, and know that we will access all of
+ * the matching entries, as long as we stop once we find an entry
+ * which does not match, since this will catch all cases above.
+ *
+ * Finally, we assume the monster must be a "player ghost" (which
+ * as noted above is impossible), which is a hack, but may prevent
+ * crashes, even if it does induce strange behavior.
+ */
+static int borg_guess_race_name(cptr who)
+{
+    int k, m, n;
+
+    int i, b_i = 0;
+    int s, b_s = 0;
+
+    monster_race *r_ptr;
+
+    char partial[160];
+
+    int len = strlen(who);
+
+    /* Start the search */
+    m = 0; n = borg_unique_size;
+
+    /* Binary search */
+    while (m < n - 1)
+    {
+        /* Pick a "middle" entry */
+        i = (m + n) / 2;
+
+        /* Search to the right (or here) */
+        if (strcmp(borg_unique_text[i], who) <= 0)
+        {
+            m = i;
+        }
+
+        /* Search to the left */
+        else
+        {
+            n = i;
+        }
+    }
+
+    /* Check for equality */
+    if (streq(who, borg_unique_text[m]))
+    {
+        /* Use this monster */
+        return (borg_unique_what[m]);
+    }
+
+
+    /* Assume player ghost */
+    if (!prefix(who, "The "))
+    {
+        /* Message */
+        borg_note(format("# Assuming player ghost (%s)", who));
+
+        /* Oops */
+        return (z_info->r_max-1);
+    }
+
+    /* Hack -- handle "offscreen" */
+    if (suffix(who, " (offscreen)"))
+    {
+        /* Remove the suffix */
+        strcpy(partial, who);
+        partial[len - 12] = '\0';
+        who = partial;
+
+        /* Message */
+        borg_note(format("# Handling offscreen monster (%s)", who));
+    }
+
+    /* Skip the prefix */
+    who += 4;
+
+
+    /* Start the search */
+    m = 0; n = borg_normal_size;
+
+    /* Binary search */
+    while (m < n - 1)
+    {
+        /* Pick a "middle" entry */
+        i = (m + n) / 2;
+        /* Search to the right (or here) */
+        if (strcmp(borg_normal_text[i], who) <= 0)
+        {
+            m = i;
+        }
+
+        /* Search to the left */
+        else
+        {
+            n = i;
+        }
+    }
+
+    /* Scan possibilities */
+    for (k = m; k >= 0; k--)
+    {
+        /* Stop when done */
+        if (!streq(who, borg_normal_text[k])) break;
+
+        /* Extract the monster */
+        i = borg_normal_what[k];
+
+        /* Access the monster */
+        r_ptr = &r_info[i];
+
+        /* Basic score */
+        s = 1000;
+
+        /* Penalize "depth miss" */
+        s = s - ABS(r_ptr->level - borg_skill[BI_CDEPTH]);
+
+        /* Track best */
+        if (b_i && (s < b_s)) continue;
+
+        /* Track it */
+        b_i = i; b_s = s;
+    }
+
+    /* Success */
+
+
+    if (b_i) return (b_i);
+
+
+    /* Message */
+    borg_note(format("# Assuming player ghost (%s)", who));
+
+    /* Oops */
+    return (z_info->r_max-1);
+}
+
+/*
+ * Increase the "grid danger" from lots of monsters
+ *   ###################
+ *   #54433333333333445#  Each monster gives some danger.
+ *   #54433222222233445#  The danger decreases as you move out.
+ *   #54433222222233445#
+ *   #54433221112233445#
+ *   #54433221@12233445#
+ *   #54433221112233445#
+ *   #54433222222233445#
+ *   #54433222222233445#
+ *   #54433333333333445#
+ *   ###################
+ */
+static void borg_fear_grid(cptr who, int y, int x, uint k)
+{
+	int x1=0, y1=0;
+
+	/* Not in town */
+	if (borg_skill[BI_CDEPTH] == 0) return;
+
+	/* In a Sea of Runes, no worry */
+	if (borg_morgoth_position) return;
+
+	/* Level 50 borgs have greatly reduced Monster Fear */
+	if (borg_skill[BI_CLEVEL] == 50) k = k * 5 / 10;
+
+    /* Collect "fear", spread around */
+	for (x1= -6; x1 <=  6; x1 ++)
+	{
+		for (y1= -6; y1 <= 6; y1 ++)
+		{
+			/* careful */
+			if (x+x1 <= 0 || x1+x >= AUTO_MAX_X) continue;
+			if (y+y1 <= 0 || y1+y >= AUTO_MAX_Y) continue;
+
+
+			/* Very Weak Fear at this range */
+    		borg_fear_monsters[y + y1][x + x1] += (k / 8) + 1;
+
+			/* Next range set */
+			if (x1 <= -5 || x1 >= 5) continue;
+			if (y1 <= -5 || y1 >= 5) continue;
+
+			/* Weak Fear at this range */
+    		borg_fear_monsters[y + y1][x + x1] += (k / 5) + 1;
+
+
+			/* Next range set */
+			if (x1 <= -3 || x1 >= 3) continue;
+			if (y1 <= -3 || y1 >= 3) continue;
+
+			/* Fear at this range */
+    		borg_fear_monsters[y + y1][x + x1] += (k / 3) + 1;
+
+
+			/* Next range set */
+			if (x1 <= -2 || x1 >= 2) continue;
+			if (y1 <= -2 || y1 >= 2) continue;
+
+			/* Mild Fear at this range */
+    		borg_fear_monsters[y + y1][x + x1] += (k / 2) + 1;
+
+
+			/* Next range set */
+			if (x1 <= -1 || x1 >= 1) continue;
+			if (y1 <= -1 || y1 >= 1) continue;
+
+
+			/* Full fear close to this monster */
+    		borg_fear_monsters[y + y1][x + x1] += k + 1;
+
+		}
+	}
+}
+
+/*
+ * Increase the "region danger"
+ */
+static void borg_fear_regional(cptr who, int y, int x, uint k, bool seen_guy)
+{
+    int x0, y0, x1, x2, y1, y2;
+
+    /* Messages */
+    if (seen_guy)
+    {
+        borg_note(format("#   Fearing region value %d.", k));
+    }
+    else
+    {
+        borg_note(format("# Fearing region (%d,%d) value %d because of a non-LOS %s",
+                        y, x, k, who));
+    }
+
+    /* Current region */
+    y0 = (y/11);
+    x0 = (x/11);
+
+    /* Nearby regions */
+    y1 = (y0 > 0) ? (y0 - 1) : 0;
+    x1 = (x0 > 0) ? (x0 - 1) : 0;
+    y2 = (x0 < 5) ? (x0 + 1) : 5;
+    x2 = (x0 < 17) ? (x0 + 1) : 17;
+
+
+    /* Collect "fear", spread around */
+    borg_fear_region[y0][x0] += k;
+    borg_fear_region[y0][x1] += k;
+    borg_fear_region[y0][x2] += k;
+    borg_fear_region[y1][x0] += k / 2;
+    borg_fear_region[y2][x0] += k / 2;
+    borg_fear_region[y1][x1] += k / 2;
+    borg_fear_region[y1][x2] += k / 3;
+    borg_fear_region[y2][x1] += k / 3;
+    borg_fear_region[y2][x2] += k / 3;
+
+
+}
+
+/*
+ * Hack -- Update a "new" monster
+ */
+static void borg_update_kill_new(int i)
+{
+    int k= 0;
+	int j= 0;
+    int num =0;
+
+    byte spell[96];
+    borg_kill *kill = &borg_kills[i];
+
+    monster_type    *m_ptr = &mon_list[cave_m_idx[kill->y][kill->x]];
+    monster_race    *r_ptr = &r_info[kill->r_idx];
+
+    /* Extract the monster speed */
+    kill->speed = (m_ptr->mspeed);
+
+#if 0
+    /* Hack -- assume optimal racial variety */
+    if (!(r_ptr->flags1 & RF1_UNIQUE))
+    {
+        /* Hack -- Assume full speed bonus */
+        kill->speed += (extract_energy[kill->speed] / 10);
+    }
+#endif
+
+
+    /* Extract max hitpoints */
+    /* This is a cheat.  Borg does not look
+     * at the bar at the bottom and frankly that would take a lot of code.
+     * It would involve targeting every monster to read their individual bar.
+     * then keeping track of it.  When the borg has telepathy this would
+     * cripple him down and be tremendously slow.
+     *
+     * This cheat is not too bad.  A human could draw the same info from
+     * from the screen.
+     *
+     * Basically the borg is cheating the real hit points of the monster then
+     * using that information to calculate the estimated hp of the monster.
+     * Its the same basic tactict that we would use.
+     *
+     * Kill->power is used a lot in borg_danger,
+     * for calculating damage from breath attacks.
+     */
+#if 0
+    if (m_ptr->maxhp)
+    {
+        /* Cheat the "percent" of health */
+        pct = 100L * m_ptr->hp / (m_ptr->maxhp > 1) ? m_ptr->maxhp : 1;
+    }
+    else
+    {
+        pct = 100;
+    }
+
+    /* Compute estimated HP based on number of * in monster health bar */
+    kill->power = (m_ptr->maxhp * pct) /  100;
+#endif
+    kill->power = m_ptr->hp;
+
+    /* Extract the Level*/
+    kill->level = r_ptr->level;
+
+    /* Some monsters never move */
+    if (r_ptr->flags1 & RF1_NEVER_MOVE) kill->awake = TRUE;
+
+    /* Is it sleeping apw*/
+    if (m_ptr->csleep == 0) kill->awake = TRUE;
+    else kill->awake = FALSE;
+
+    /* Is it afraid apw*/
+    if (m_ptr->monfear == 0) kill->afraid = FALSE;
+    else kill->afraid = TRUE;
+
+    /* Is it confused apw*/
+    if (m_ptr->confused == 0) kill->confused = FALSE;
+    else kill->confused = TRUE;
+
+    /* Is it stunned*/
+    if (m_ptr->stunned == 0) kill->stunned = FALSE;
+    else kill->stunned = TRUE;
+
+    /* Can it attack from a distance? */
+    /* Extract the "inate" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags4 & (1L << k)) spell[num++] = k + 32 * 3;
+    }
+
+    /* Extract the "normal" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags5 & (1L << k)) spell[num++] = k + 32 * 4;
+    }
+
+    /* Extract the "bizarre" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags6 & (1L << k)) spell[num++] = k + 32 * 5;
+    }
+
+    /* We want to remember Morgy's panel */
+    if (kill->r_idx == 547)
+    {
+	    j = ((kill->y - PANEL_HGT / 2) / PANEL_HGT) * PANEL_HGT;
+	    if (j < 0) j = 0;
+	    if (j > DUNGEON_HGT - SCREEN_HGT) j = DUNGEON_HGT - SCREEN_HGT;
+	    morgy_panel_y = j;
+
+	    j = ((kill->x - PANEL_WID / 2) / PANEL_WID) * PANEL_WID;
+	    if (j < 0) j = 0;
+	    if (j > DUNGEON_WID - SCREEN_WID) j = DUNGEON_WID - SCREEN_WID;
+	    morgy_panel_x = j;
+	}
+
+    /* to cast or not to cast, that is the question*/
+    if (num)
+    {
+        kill->ranged_attack = TRUE;
+    }
+    else kill->ranged_attack = FALSE;
+
+}
+
+
+/*
+ * Hack -- Update a "old" monster
+ *
+ * We round the player speed down, and the monster speed up,
+ * and we assume maximum racial speed for each monster.
+ */
+static void borg_update_kill_old(int i)
+{
+    int t, e;
+    int k= 0;
+    int num =0;
+	int j = 0;
+
+    byte spell[96];
+    borg_kill *kill = &borg_kills[i];
+
+    monster_type    *m_ptr = &mon_list[cave_m_idx[kill->y][kill->x]];
+    monster_race *r_ptr = &r_info[kill->r_idx];
+
+        /* Extract max hitpoints */
+        /* Extract actual Hitpoints, this is a cheat.  Borg does not look
+         * at the bar at the bottom and frankly that would take a lot of code.
+         * It would involve targeting every monster to read their individual bar.
+         * then keeping track of it.  When the borg has telepathy this would
+         * cripple him down and be tremendously slow.
+         *
+         * This cheat is not too bad.  A human could draw the same info from
+         * from the screen.
+         *
+         * Basically the borg is cheating the real hit points of the monster then
+         * using that information to calculate the estimated hp of the monster.
+         * Its the same basic tactict that we would use.
+         *
+         * Kill->power is used a lot in borg_danger,
+         * for calculating damage from breath attacks.
+         */
+
+#if 0
+    if (m_ptr->maxhp)
+    {
+        /* Cheat the "percent" of health */
+        pct = 100L * m_ptr->hp / (m_ptr->maxhp > 1) ? m_ptr->maxhp : 1;
+    }
+    else
+    {
+        pct = 100;
+    }
+
+    /* Compute estimated HP based on number of * in monster health bar */
+    kill->power = (m_ptr->maxhp * pct) /  100;
+#endif
+    kill->power = m_ptr->hp;
+
+    /* Is it sleeping apw*/
+    if (m_ptr->csleep == 0) kill->awake = TRUE;
+    else kill->awake = FALSE;
+
+    /* Is it afraid apw*/
+    if (m_ptr->monfear == 0) kill->afraid = FALSE;
+    else kill->afraid = TRUE;
+
+    /* Is it confused apw*/
+    if (m_ptr->confused == 0) kill->confused = FALSE;
+    else kill->confused = TRUE;
+
+    /* Is it stunned*/
+    if (m_ptr->stunned == 0) kill->stunned = FALSE;
+    else kill->stunned = TRUE;
+
+    /* Extract the monster speed */
+    kill->speed = (m_ptr->mspeed);
+
+    /* Player energy per game turn */
+    e = extract_energy[borg_skill[BI_SPEED]];
+
+    /* Game turns per player move */
+    t = (100 + (e - 1)) / e;
+
+    /* Monster energy per game turn */
+    e = extract_energy[kill->speed];
+
+    /* Monster moves (times ten) */
+    kill->moves = (t * e) / 10;
+
+    /* Can it attack from a distance? */
+    /* Extract the "inate" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags4 & (1L << k)) spell[num++] = k + 32 * 3;
+    }
+
+    /* Extract the "normal" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags5 & (1L << k)) spell[num++] = k + 32 * 4;
+    }
+
+    /* Extract the "bizarre" spells */
+    for (k = 0; k < 32; k++)
+    {
+        if (r_ptr->flags6 & (1L << k)) spell[num++] = k + 32 * 5;
+    }
+
+    /* to cast or not to cast, that is the question*/
+    if (num)
+    {
+        kill->ranged_attack = TRUE;
+    }
+    else
+    {
+        kill->ranged_attack = FALSE;
+    }
+
+    /* Special check on uniques, sometimes the death
+     * is not caught so he thinks they are still running
+     * around
+     */
+    if ((r_ptr->flags1 & RF1_UNIQUE) &&
+        r_ptr->max_num == 0) borg_race_death[i] = 1;
+
+    /* We want to remember Morgy's panel */
+    if (kill->r_idx == 547)
+    {
+	    j = ((kill->y - PANEL_HGT / 2) / PANEL_HGT) * PANEL_HGT;
+	    if (j < 0) j = 0;
+	    if (j > DUNGEON_HGT - SCREEN_HGT) j = DUNGEON_HGT - SCREEN_HGT;
+	    morgy_panel_y = j;
+
+	    j = ((kill->x - PANEL_WID / 2) / PANEL_WID) * PANEL_WID;
+	    if (j < 0) j = 0;
+	    if (j > DUNGEON_WID - SCREEN_WID) j = DUNGEON_WID - SCREEN_WID;
+	    morgy_panel_x = j;
+	}
+
+}
+
+
+/*
+ * Delete an old "kill" record
+ */
+void borg_delete_kill(int i)
+{
+    borg_kill *kill = &borg_kills[i];
+
+    /* Paranoia -- Already wiped */
+    if (!kill->r_idx) return;
+
+    /* Note */
+    borg_note(format("# Forgetting a monster '%s' at (%d,%d)",
+                     (r_name + r_info[kill->r_idx].name),
+                     kill->y, kill->x));
+
+    /* Update the grids */
+    borg_grids[kill->y][kill->x].kill = 0;
+
+    /* save a time stamp of when the last multiplier was killed */
+    if (r_info[kill->r_idx].flags2 & RF2_MULTIPLY)
+        when_last_kill_mult = borg_t;
+
+    /* Kill the monster */
+    WIPE(kill, borg_kill);
+
+    /* One less monster */
+    borg_kills_cnt--;
+
+    /* Recalculate danger */
+    borg_danger_wipe = TRUE;
+
+
+    /* Wipe goals */
+    goal = 0;
+}
+
+/*
+ * Force sleep onto a "kill" record
+ * ??? Since this check is done at update_kill should I have it here?
+ */
+static void borg_sleep_kill(int i)
+{
+    borg_kill *kill = &borg_kills[i];
+
+    /* Paranoia -- Already wiped */
+    if (!kill->r_idx) return;
+
+    /* Note */
+    borg_note(format("# Noting sleep on a monster '%s' at (%d,%d)",
+                     (r_name + r_info[kill->r_idx].name),
+                     kill->y, kill->x));
+
+    /* note sleep */
+    kill->awake = FALSE;
+
+    /* Recalculate danger */
+    borg_danger_wipe = TRUE;
+}
+
+
+/*
+ * Determine if a monster should be "viewable"
+ */
+static bool borg_follow_kill_aux(int i, int y, int x)
+{
+    int d;
+
+    borg_grid *ag;
+
+    borg_kill *kill = &borg_kills[i];
+
+    monster_race *r_ptr = &r_info[kill->r_idx];
+
+
+    /* Distance to player */
+    d = distance(c_y, c_x, y, x);
+
+    /* Too far away */
+    if (d > MAX_SIGHT) return (FALSE);
+
+
+    /* Access the grid */
+    ag = &borg_grids[y][x];
+
+    /* Not on-screen */
+    if (!(ag->info & BORG_OKAY)) return (FALSE);
+
+
+    /* Line of sight */
+    if (ag->info & BORG_VIEW)
+    {
+        /* Use "illumination" */
+        if (ag->info & (BORG_LITE | BORG_GLOW))
+        {
+            /* We can see invisible */
+            if (borg_skill[BI_SINV] || borg_see_inv) return (TRUE);
+
+            /* Monster is not invisible */
+            if (!(r_ptr->flags2 & RF2_INVISIBLE)) return (TRUE);
+        }
+
+        /* Use "infravision" */
+        if (d <= borg_skill[BI_INFRA])
+        {
+            /* Infravision works on "warm" creatures */
+            if (!(r_ptr->flags2 & RF2_COLD_BLOOD)) return (TRUE);
+        }
+    }
+
+
+    /* Telepathy requires "telepathy" */
+    if (borg_skill[BI_ESP])
+    {
+        /* Telepathy fails on "strange" monsters */
+        if (r_ptr->flags2 & RF2_EMPTY_MIND) return (FALSE);
+        if (r_ptr->flags2 & RF2_WEIRD_MIND) return (FALSE);
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Attempt to "follow" a missing monster
+ *
+ * This routine is not called when the player is blind or hallucinating.
+ *
+ * Currently this function is a total hack, but handles the case of only
+ * one possible location (taking it), two adjacent possible locations
+ * (taking the diagonal one), and three adjacent locations with the
+ * central one being a diagonal (taking the diagonal one).
+ *
+ * We should perhaps handle the case of three adjacent locations with
+ * the central one being a non-diagonal (taking the non-diagonal one).
+ *
+ * We should perhaps attempt to take into account "last known direction",
+ * which would allow us to "predict" motion up to walls, and we should
+ * perhaps attempt to take into account the "standard" flee algorithm,
+ * though that feels a little like cheating.
+ */
+static void borg_follow_kill(int i)
+{
+    int j;
+    int x, y;
+    int ox, oy;
+
+    int dx, b_dx = 0;
+    int dy, b_dy = 0;
+
+    borg_grid *ag;
+
+    borg_kill *kill = &borg_kills[i];
+
+
+    /* Paranoia */
+    if (!kill->r_idx) return;
+
+
+    /* Old location */
+    ox = kill->x;
+    oy = kill->y;
+
+
+    /* Out of sight */
+    if (!borg_follow_kill_aux(i, oy, ox)) return;
+
+
+    /* Note */
+    borg_note(format("# There was a monster '%s' at (%d,%d)",
+                     (r_name + r_info[kill->r_idx].name),
+                     oy, ox));
+
+
+    /* Prevent silliness */
+    if (!borg_cave_floor_bold(oy, ox))
+    {
+        /* Delete the monster */
+        borg_delete_kill(i);
+
+        /* Done */
+        return;
+    }
+
+    /* Prevent loops */
+    if (rand_int(100) < 1)
+    {
+        /* Just delete the monster */
+        borg_delete_kill(i);
+
+        /* Done */
+        return;
+    }
+
+    /* prevent overflows */
+    if (borg_t > 20000)
+    {
+        /* Just delete the monster */
+        borg_delete_kill(i);
+
+        /* Done */
+        return;
+    }
+
+    /* Some never move, no reason to follow them */
+    if ((r_info[kill->r_idx].flags1 & RF1_NEVER_MOVE) ||
+        /* Some are sleeping and don't move, no reason to follow them */
+        (kill->awake == FALSE))
+    {
+        /* delete them if they are under me */
+        if (kill->y == c_y && kill->x == c_x)
+        {
+            borg_delete_kill(i);
+        }
+        /* Dont 'forget' certain ones */
+        return;
+    }
+
+    /* Scan locations */
+    for (j = 0; j < 8; j++)
+    {
+        /* Access offset */
+        dx = ddx_ddd[j];
+        dy = ddy_ddd[j];
+
+        /* Access location */
+        x = ox + dx;
+        y = oy + dy;
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+        /* Skip known walls and doors */
+        if (!borg_cave_floor_grid(ag)) continue;
+
+        /* Skip known monsters */
+        if (ag->kill) continue;
+
+        /* Skip visible grids */
+        if (borg_follow_kill_aux(i, y, x)) continue;
+
+        /* Collect the offsets */
+        b_dx += dx;
+        b_dy += dy;
+    }
+
+
+    /* Don't go too far */
+    if (b_dx < -1) b_dx = -1;
+    else if (b_dx > 1) b_dx = 1;
+
+    /* Don't go too far */
+    if (b_dy < -1) b_dy = -1;
+    else if (b_dy > 1) b_dy = 1;
+
+
+    /* Access location */
+    x = ox + b_dx;
+    y = oy + b_dy;
+
+    /* Access the grid */
+    ag = &borg_grids[y][x];
+
+    /* Avoid walls and doors */
+    if (!borg_cave_floor_grid(ag))
+    {
+        /* Just delete the monster */
+        borg_delete_kill(i);
+
+        /* Done */
+        return;
+    }
+
+    /* Avoid monsters */
+    if (ag->kill)
+    {
+        /* Just delete the monster */
+        borg_delete_kill(i);
+
+        /* Done */
+        return;
+    }
+
+
+    /* Update the grids */
+    borg_grids[kill->y][kill->x].kill = 0;
+
+    /* Save the old Location */
+    kill->ox = ox;
+    kill->oy = oy;
+
+    /* Save the Location */
+    kill->x = ox + b_dx;
+    kill->y = oy + b_dy;
+
+    /* Update the grids */
+    borg_grids[kill->y][kill->x].kill = i;
+
+    /* Note */
+    borg_note(format("# Following a monster '%s' to (%d,%d) from (%d,%d)",
+                     (r_name + r_info[kill->r_idx].name),
+                     kill->y, kill->x, oy, ox));
+
+    /* Recalculate danger */
+    borg_danger_wipe = TRUE;
+
+    /* Clear goals */
+    goal = 0;
+}
+
+
+
+/*
+ * Obtain a new "kill" index
+ */
+static int borg_new_kill(int r_idx, int y, int x)
+{
+    int i, n = -1;
+    int p;
+
+    borg_kill *kill;
+	borg_grid *ag;
+    monster_race *r_ptr;
+
+    /* Look for a "dead" monster */
+    for (i = 1; (n < 0) && (i < borg_kills_nxt); i++)
+    {
+        /* Skip real entries */
+        if (!borg_kills[i].r_idx) n = i;
+    }
+
+    /* Allocate a new monster */
+    if ((n < 0) && (borg_kills_nxt < 256))
+    {
+        /* Acquire the entry, advance */
+        n = borg_kills_nxt++;
+    }
+
+    /* Hack -- steal an old monster */
+    if (n < 0)
+    {
+        /* Note */
+        borg_note("# Too many monsters");
+
+        /* Hack -- Pick a random monster */
+        n = rand_int(borg_kills_nxt-1) + 1;
+
+        /* Kill it */
+        borg_delete_kill(n);
+    }
+
+
+    /* Count the monsters */
+    borg_kills_cnt++;
+
+    /* Access the monster */
+    kill = &borg_kills[n];
+    r_ptr = &r_info[kill->r_idx];
+	ag = &borg_grids[y][x];
+
+    /* Save the race */
+    kill->r_idx = r_idx;
+
+    /* Location */
+    kill->ox = kill->x = x;
+    kill->oy = kill->y = y;
+
+    /* Update the grids */
+    borg_grids[kill->y][kill->x].kill = n;
+
+    /* Timestamp */
+    kill->when = borg_t;
+
+	/* Mark the Morgoth time stamp if needed */
+	if (kill->r_idx == 547) borg_t_morgoth = borg_t;
+
+    /* Update the monster */
+    borg_update_kill_new(n);
+
+    /* Update the monster */
+    borg_update_kill_old(n);
+
+    /* Danger of this monster to its grid (used later) */
+    p = borg_danger(kill->y, kill->x, 1, FALSE);
+
+    /* Note */
+    borg_note(format("# Creating a monster '%s' at (%d,%d), danger: %d, HP: %d, Time: %d, Index: %d",
+                     (r_name + r_info[kill->r_idx].name),
+                     kill->y, kill->x, p, kill->power, kill->when, kill->r_idx));
+
+    /* Recalculate danger */
+    borg_danger_wipe = TRUE;
+
+    /* Wipe goals only if I have some light source */
+    if (borg_skill[BI_CURLITE]) goal = 0;
+
+	/* Hack -- Force the monster to be sitting on a floor
+	 * grid unless that monster can pass through walls
+	 */
+    if (!(r_ptr->flags2 & RF2_PASS_WALL))
+    {
+		ag->feat = FEAT_FLOOR;
+	}
+
+    /* Count Hounds */
+    if (r_ptr->d_char == 'Z') borg_hound_count ++;
+
+    /* Count Angels */
+    if (r_ptr->d_char == 'A') borg_angel_count ++;
+
+    /* Count Demons */
+    if (r_ptr->d_char == 'U') borg_demon_count ++;
+
+    /* Count Liches */
+    if (r_ptr->d_char == 'L') borg_lich_count ++;
+
+    /* Count Wights */
+    if (r_ptr->d_char == 'W') borg_lich_count ++;
+
+    /* Return the monster */
+    return (n);
+}
+
+
+
+/*
+ * Attempt to notice a changing "kill"
+ */
+static bool observe_kill_diff(int y, int x, byte a, char c)
+{
+    int i, r_idx;
+
+    borg_kill *kill;
+
+    /* Guess the race */
+    r_idx = borg_guess_race(a, c, FALSE, y ,x);
+
+    /* Oops */
+    /* if (!r_idx) return (FALSE); */
+
+    /* no new monsters if hallucinations */
+    if (borg_skill[BI_ISIMAGE]) return (FALSE);
+
+    /* Create a new monster */
+    i = borg_new_kill(r_idx, y, x);
+
+    /* Get the object */
+    kill = &borg_kills[i];
+
+    /* Timestamp */
+    kill->when = borg_t;
+
+	/* Mark the Morgoth time stamp if needed */
+	if (kill->r_idx == 547) borg_t_morgoth = borg_t;
+
+    /* Done */
+    return (TRUE);
+}
+
+
+/*
+ * Attempt to "track" a "kill" at the given location
+ * Assume that the monster moved at most 'd' grids.
+ * If "flag" is TRUE, allow monster "conversion"
+ */
+static bool observe_kill_move(int y, int x, int d, byte a, char c, bool flag)
+{
+    int i, z, ox, oy;
+    int r_idx;
+    borg_kill *kill;
+    monster_race *r_ptr;
+
+    bool flicker = FALSE;
+
+    /* Look at the monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Skip assigned monsters */
+        if (kill->seen) continue;
+
+        /* Old location */
+        ox = kill->x;
+        oy = kill->y;
+
+        /* Calculate distance */
+        z = distance(oy, ox, y, x);
+
+        /* Access the monster race */
+        r_ptr = &r_info[kill->r_idx];
+
+		/* Double the distance for uniques so the borg does not create 2 of the same unique
+		 * monster on the level */
+		if (r_ptr->flags1 & RF1_UNIQUE) d = d * 2;
+
+        /* Verify distance */
+        if (z > d) continue;
+
+        /* Verify "reasonable" motion, if allowed */
+        if (!flag && (z > (kill->moves / 10) + 1)) continue;
+
+
+        /* Verify matching char so long as not hallucinating */
+        if (!borg_skill[BI_ISIMAGE] && c != r_ptr->d_char) continue;
+
+        /* Verify matching attr so long as not hallucinating */
+        if (a != r_ptr->d_attr || borg_skill[BI_ISIMAGE])
+        {
+            /* Require matching attr (for normal monsters) */
+            if (!(r_ptr->flags1 & (RF1_ATTR_MULTI | RF1_ATTR_CLEAR)))
+            {
+                /* Require flag */
+                if (!flag) continue;
+
+                /* Never flicker known monsters */
+                if (kill->known) continue;
+
+                /* Find a multi-hued monster */
+                r_idx = borg_guess_race(a, c, TRUE, y , x);
+
+                /* Handle failure */
+                if (r_idx == z_info->r_max - 1) continue;
+
+                /* Note */
+                borg_note(format("# Flickering monster '%s' at (%d,%d)",
+                                 (r_name + r_info[r_idx].name),
+                                 y, x));
+
+                /* Note */
+                borg_note(format("# Converting a monster '%s' at (%d,%d)",
+                                 (r_name + r_info[kill->r_idx].name),
+                                 kill->y, kill->x));
+
+                /* Change the race */
+                kill->r_idx = r_idx;
+
+                /* Monster flickers */
+                flicker = TRUE;
+
+                /* Recalculate danger */
+                borg_danger_wipe = TRUE;
+
+                /* Clear monster flow goals */
+                goal = 0;
+            }
+        }
+
+        /* Actual movement */
+        if (z)
+        {
+
+            /* Update the grids */
+            borg_grids[kill->y][kill->x].kill = 0;
+
+            /* Save the old Location */
+            kill->ox = kill->x;
+            kill->oy = kill->y;
+
+            /* Save the Location */
+            kill->x = x;
+            kill->y = y;
+
+            /* Update the grids */
+            borg_grids[kill->y][kill->x].kill = i;
+
+            /* Note */
+            borg_note(format("# Tracking a monster '%s' at (%d,%d) from (%d,%d)",
+                             (r_name + r_ptr->name),
+                             kill->y, kill->x, ox, oy));
+
+            /* Recalculate danger */
+            borg_danger_wipe = TRUE;
+
+            /* Clear goals */
+            if (goal == GOAL_KILL) goal = 0;
+        }
+
+        /* Note when last seen */
+        kill->when = borg_t;
+
+		/* Mark the Morgoth time stamp if needed */
+		if (kill->r_idx == 547) borg_t_morgoth = borg_t;
+
+        /* Monster flickered */
+        if (flicker)
+        {
+            /* Update the monster */
+            borg_update_kill_new(i);
+        }
+
+        /* Update the monster */
+        borg_update_kill_old(i);
+
+        /* Mark as seen */
+        kill->seen = TRUE;
+
+        /* Done */
+        return (TRUE);
+    }
+
+    /* Oops */
+    return (FALSE);
+}
+
+
+
+/*
+ * Calculate base danger from a spell attack by an invisible monster
+ *
+ * We attempt to take account of various resistances, both in
+ * terms of actual damage, and special effects, as appropriate.
+ */
+static int borg_fear_spell(int i)
+{
+    int z = 0;
+    int p = 0;
+
+    int ouch = 0;
+
+
+    /* Damage taken */
+    if (borg_oldchp > borg_skill[BI_CURHP]) ouch = (borg_oldchp - borg_skill[BI_CURHP]) * 2;
+
+
+    /* Check the spell */
+    switch (i)
+    {
+        case 0:    /* RF4_SHRIEK */
+        p += 10;
+
+        /* If low level borg.  Get off the level now. */
+        if (borg_skill[BI_CLEVEL] <= 5) goal_fleeing = goal_leaving = TRUE;
+        break;
+
+        case 1:    /* RF4_FAILED spell by monster.  Fear it! */
+                      /* It could be a unique like Azriel */
+        p += borg_skill[BI_CDEPTH];
+        break;
+
+        case 2:    /* RF4_XXX3X4 */
+        break;
+
+        case 3:    /* RF4_XXX4X4 */
+        break;
+
+        case 4:    /* RF4_ARROW_1 */
+        z = (1 * 6);
+        break;
+
+        case 5:    /* RF4_ARROW_2 */
+        z = (3 * 6);
+        break;
+
+        case 6:    /* RF4_ARROW_3 */
+        z = (5 * 6);
+        break;
+
+        case 7:    /* RF4_ARROW_4 */
+        z = (7 * 6);
+        break;
+
+        case 8:    /* RF4_BR_ACID */
+        if (borg_skill[BI_IACID]) break;
+        z = ouch;
+        p += 40;
+        break;
+
+        case 9:    /* RF4_BR_ELEC */
+        if (borg_skill[BI_IELEC]) break;
+        z = ouch;
+        p += 20;
+        break;
+
+        case 10:    /* RF4_BR_FIRE */
+        if (borg_skill[BI_IFIRE]) break;
+        z = ouch;
+        p += 40;
+        break;
+
+        case 11:    /* RF4_BR_COLD */
+        if (borg_skill[BI_ICOLD]) break;
+        z = ouch;
+        p += 20;
+        break;
+
+        case 12:    /* RF4_BR_POIS */
+        z = ouch;
+        if (borg_skill[BI_RPOIS]) break;
+        if (my_oppose_pois) break;
+        p += 20;
+        break;
+
+        case 13:    /* RF4_BR_NETH */
+        z = ouch + 100;
+        if (borg_skill[BI_RNTHR]) break;
+        p += 50;
+        if (borg_skill[BI_HLIFE]) break;
+        /* do not worry about drain exp after level 50 */
+        if (borg_skill[BI_CLEVEL] >= 50) break;
+        p += 150;
+        break;
+
+        case 14:    /* RF4_BR_LITE */
+        z = ouch;
+        if (borg_skill[BI_RLITE]) break;
+        if (borg_skill[BI_RBLIND]) break;
+        p += 20;
+        break;
+
+        case 15:    /* RF4_BR_DARK */
+        z = ouch;
+        if (borg_skill[BI_RDARK]) break;
+        if (borg_skill[BI_RBLIND]) break;
+        p += 20;
+        break;
+
+        case 16:    /* RF4_BR_CONF */
+        z = ouch;
+        if (borg_skill[BI_RCONF]) break;
+        p += 100;
+        break;
+
+        case 17:    /* RF4_BR_SOUN */
+        z = ouch;
+        if (borg_skill[BI_RSND]) break;
+        p += 50;
+        break;
+
+        case 18:    /* RF4_BR_CHAO */
+        z = ouch;
+        if (borg_skill[BI_RKAOS]) break;
+        p += 200;
+        if (!borg_skill[BI_RNTHR]) p += 50;
+        if (!borg_skill[BI_HLIFE]) p += 50;
+        if (!borg_skill[BI_RCONF]) p += 50;
+        if (borg_skill[BI_CLEVEL] == 50) break;
+        p += 100;
+        break;
+
+        case 19:    /* RF4_BR_DISE */
+        z = ouch;
+        if (borg_skill[BI_RDIS]) break;
+        p += 500;
+        break;
+
+        case 20:    /* RF4_BR_NEXU */
+        z = ouch;
+        if (borg_skill[BI_RNXUS]) break;
+        p += 100;
+        break;
+
+        case 21:    /* RF4_BR_TIME */
+        z = ouch;
+        p += 200;
+        break;
+
+        case 22:    /* RF4_BR_INER */
+        z = ouch;
+        p += 50;
+        break;
+
+        case 23:    /* RF4_BR_GRAV */
+        z = ouch;
+        p += 50;
+        if (borg_skill[BI_RSND]) break;
+        p += 50;
+        break;
+
+        case 24:    /* RF4_BR_SHAR */
+        z = ouch;
+        if (borg_skill[BI_RSHRD]) break;
+        p += 50;
+        break;
+
+        case 25:    /* RF4_BR_PLAS */
+        z = ouch;
+        if (borg_skill[BI_RSND]) break;
+        p += 50;
+        break;
+
+        case 26:    /* RF4_BR_WALL */
+        z = ouch;
+        if (borg_skill[BI_RSND]) break;
+        p += 50;
+        break;
+
+        case 27:    /* RF4_BR_MANA */
+        /* XXX XXX XXX */
+        break;
+
+        case 28:    /* RF4_XXX5X4 */
+        break;
+
+        case 29:    /* RF4_XXX6X4 */
+        break;
+
+        case 30:    /* RF4_XXX7X4 */
+        break;
+
+        case 31:    /* RF4_BOULDER */
+        z = ouch;
+        p +=40;
+        break;
+
+        case 32:    /* RF5_BA_ACID */
+        if (borg_skill[BI_IACID]) break;
+        z = ouch;
+        p += 40;
+        break;
+
+        case 33:    /* RF5_BA_ELEC */
+        if (borg_skill[BI_IELEC]) break;
+        z = ouch;
+        p += 20;
+        break;
+
+        case 34:    /* RF5_BA_FIRE */
+        if (borg_skill[BI_IFIRE]) break;
+        z = ouch;
+        p += 40;
+        break;
+
+        case 35:    /* RF5_BA_COLD */
+        if (borg_skill[BI_ICOLD]) break;
+        z = ouch;
+        p += 20;
+        break;
+
+        case 36:    /* RF5_BA_POIS */
+        z = ouch;
+        if (borg_skill[BI_RPOIS]) break;
+        p += 20;
+        break;
+
+        case 37:    /* RF5_BA_NETH */
+        z = ouch + 100;
+        if (borg_skill[BI_RNTHR]) break;
+        p += 300;
+        break;
+
+        case 38:    /* RF5_BA_WATE */
+        z = ouch;
+        p += 50;
+        break;
+
+        case 39:    /* RF5_BA_MANA */
+        z = ouch;
+        break;
+
+        case 40:    /* RF5_BA_DARK */
+        z = ouch;
+        if (borg_skill[BI_RDARK]) break;
+        if (borg_skill[BI_RBLIND]) break;
+        p += 20;
+        break;
+
+        case 41:    /* RF5_DRAIN_MANA */
+        if (borg_skill[BI_MAXSP]) p += 10;
+        break;
+
+        case 42:    /* RF5_MIND_BLAST */
+        z = 20;
+        break;
+
+        case 43:    /* RF5_BRAIN_SMASH */
+        z = (12 * 15);
+        p += 100;
+        break;
+
+        case 44:    /* RF5_CAUSE_1 */
+        z = (3 * 8);
+        break;
+
+        case 45:    /* RF5_CAUSE_2 */
+        z = (8 * 8);
+        break;
+
+        case 46:    /* RF5_CAUSE_3 */
+        z = (10 * 15);
+        break;
+
+        case 47:    /* RF5_CAUSE_4 */
+        z = (15 * 15);
+        p += 50;
+        break;
+
+        case 48:    /* RF5_BO_ACID */
+        if (borg_skill[BI_IACID]) break;
+        z = ouch;
+        p += 40;
+        break;
+
+        case 49:    /* RF5_BO_ELEC */
+        if (borg_skill[BI_IELEC]) break;
+        z = ouch;
+        p += 20;
+        break;
+
+        case 50:    /* RF5_BO_FIRE */
+        if (borg_skill[BI_IFIRE]) break;
+        z = ouch;
+        p += 40;
+        break;
+
+        case 51:    /* RF5_BO_COLD */
+        if (borg_skill[BI_ICOLD]) break;
+        z = ouch;
+        p += 20;
+        break;
+
+        case 52:    /* RF5_BO_POIS */
+        /* XXX XXX XXX */
+        break;
+
+        case 53:    /* RF5_BO_NETH */
+        z = ouch + 100;
+        if (borg_skill[BI_RNTHR]) break;
+        p += 200;
+        break;
+
+        case 54:    /* RF5_BO_WATE */
+        z = ouch;
+        p += 20;
+        break;
+
+        case 55:    /* RF5_BO_MANA */
+        z = ouch;
+        break;
+
+        case 56:    /* RF5_BO_PLAS */
+        z = ouch;
+        p += 20;
+        break;
+
+        case 57:    /* RF5_BO_ICEE */
+        z = ouch;
+        p += 20;
+        break;
+
+        case 58:    /* RF5_MISSILE */
+        z = ouch;
+        break;
+
+        case 59:    /* RF5_SCARE */
+        p += 10;
+        break;
+
+        case 60:    /* RF5_BLIND */
+        p += 10;
+        break;
+
+        case 61:    /* RF5_CONF */
+        p += 10;
+        break;
+
+        case 62:    /* RF5_SLOW */
+        p += 5;
+        break;
+
+        case 63:    /* RF5_HOLD */
+        p += 20;
+        break;
+
+        case 64:    /* RF6_HASTE */
+        p += 10+ borg_skill[BI_CDEPTH];
+        break;
+
+        case 65:    /* RF6_XXX1X6 */
+        break;
+
+        case 66:    /* RF6_HEAL */
+        p += 10;
+        break;
+
+        case 67:    /* RF6_XXX2X6 */
+        break;
+
+        case 68:    /* RF6_XXX3X6 */
+        break;
+
+        case 69:    /* RF6_XXX4X6 */
+        break;
+
+        case 70:    /* RF6_TELE_TO */
+        p += 20 + borg_skill[BI_CDEPTH];
+        break;
+
+        case 71:    /* RF6_TELE_AWAY */
+        p += 10;
+        break;
+
+        case 72:    /* RF6_TELE_LEVEL */
+        p += 50;
+        break;
+
+        case 73:    /* RF6_XXX5 */
+        break;
+
+        case 74:    /* RF6_DARKNESS */
+        break;
+
+        case 75:    /* RF6_TRAPS */
+        p += 50;
+        break;
+
+        case 76:    /* RF6_FORGET */
+        /* if you have lots of cash this is not very scary... just re-ID.*/
+        if (borg_skill[BI_CLEVEL] < 35)
+            p += 500;
+        else
+            p += 50;
+        break;
+
+        case 77:    /* RF6_XXX6X6 */
+        break;
+
+        case 78:    /* RF6_XXX7X6 */
+        break;
+
+        case 79:    /* RF6_XXX8X6 */
+        break;
+
+        /* Summoning is only as dangerious as the monster that is */
+        /* attually summoned.  This helps borgs kill summoners */
+
+        case 80:    /* RF6_S_MONSTER */
+        p +=55;
+        break;
+
+        case 81:    /* RF6_S_MONSTERS */
+        p += 30;
+        break;
+
+        case 82:    /* RF6_S_ANIMAL */
+        p +=15;
+        break;
+
+        case 83:    /* RF6_S_SPIDER */
+        p +=25;
+        break;
+
+        case 84:    /* RF6_S_HOUND */
+        p +=45;
+        break;
+
+        case 85:    /* RF6_S_HYDRA */
+        p += 70;
+        break;
+
+        case 86:    /* RF6_S_ANGEL */
+        p += 80;
+        break;
+
+        case 87:    /* RF6_S_DEMON */
+        p += 80;
+        break;
+
+        case 88:    /* RF6_S_UNDEAD */
+        p += 80;
+        break;
+
+        case 89:    /* RF6_S_DRAGON */
+        p += 80;
+        break;
+
+        case 90:    /* RF6_S_HI_UNDEAD */
+        p += 95;
+        break;
+
+        case 91:    /* RF6_S_HI_DRAGON */
+        p += 95;
+        break;
+
+        case 92:    /* RF6_S_WRAITH */
+        p += 95;
+        break;
+
+        case 93:    /* RF6_S_UNIQUE */
+        p += 50;
+        break;
+    }
+
+    /* Things which hurt us alot need to be a concern */
+    if (ouch >= borg_skill[BI_CURHP] / 2) ouch = ouch * 2;
+
+    /* Notice damage */
+    return (p + z + (borg_skill[BI_DEPTH] * 2));
+}
+
+
+
+
+/*
+ * Attempt to locate a monster which could explain a message involving
+ * the given monster name, near the given location, up to the given
+ * distance from the given location.
+ *
+ * Invisible monsters, bizarre monsters, and unexplainable monsters are
+ * all treated the same way, and should eventually contribute some amount
+ * of basic "fear" to the current region.
+ *
+ * First, we attempt to convert "similar" objects into the desired monster,
+ * then we attempt to convert "similar" monsters into the desired monster,
+ * then we attempt to match an existing monster, and finally, we give up.
+ *
+ * XXX XXX XXX Hack -- To prevent fatal situations, every time we think
+ * there may be a monster nearby, we look for a nearby object which could
+ * be the indicated monster, and convert it into that monster.  This allows
+ * us to correctly handle a room full of multiplying clear mushrooms.
+ *
+ * XXX XXX XXX When surrounded by multiple monsters of the same type,
+ * we will ascribe most messages to one of those monsters, and ignore
+ * the existance of all the other similar monsters.
+ *
+ * XXX XXX XXX Currently, confusion may cause messages to be ignored.
+ */
+static int borg_locate_kill(cptr who, int y, int x, int r)
+{
+    int i, d, r_idx;
+
+    int b_i, b_d;
+
+    borg_take *take;
+    borg_kill *kill;
+
+    object_kind *k_ptr;
+
+    monster_race *r_ptr;
+
+    /* Handle invisible monsters */
+    if (streq(who, "It") ||
+        streq(who, "Someone") ||
+        streq(who, "Something"))
+    {
+        /* Note */
+        borg_note("# Invisible monster nearby.");
+        /* if I can, cast detect inviso--time stamp it
+         * We stamp it now if we can, or later if we just did the spell
+         * That way we dont loop casting the spell.    APW
+         */
+        /* detect invis spell not working right, for now just shift panel
+         * and cast a light beam if in a hallway and we have see_inv*/
+        if (need_see_inviso < (borg_t))
+        {
+            need_see_inviso = (borg_t);
+        }
+
+
+        /* Ignore */
+        return (0);
+    }
+
+    /* Handle offsreen monsters */
+    if (suffix(who, " (offscreen)"))
+    {
+        /* Note */
+        borg_note("# Offscreen monster nearby");
+
+        /* Shift the panel */
+        need_shift_panel = TRUE;
+
+        /* Ignore */
+        return (0);
+    }
+
+    /* Guess the monster race */
+    r_idx = borg_guess_race_name(who);
+
+    /* Access the monster race */
+    r_ptr = &r_info[r_idx];
+
+    /* Note */
+    borg_note(format("# There is a monster '%s' within %d grids of %d,%d",
+                     (r_name + r_ptr->name),
+                     r, y, x));
+
+    /* Hack -- count racial appearances */
+    if (borg_race_count[r_idx] < MAX_SHORT) borg_race_count[r_idx]++;
+
+
+    /* Handle trappers and lurkers and mimics */
+    if (r_ptr->flags1 & (RF1_CHAR_CLEAR | RF1_CHAR_MULTI))
+    {
+        /* Note */
+        borg_note("# Bizarre monster nearby");
+    }
+
+
+    /*** Hack -- Find a similar object ***/
+
+    /* Nothing yet */
+    b_i = -1; b_d = 999;
+
+    /* Scan the objects */
+    for (i = 1; i < borg_takes_nxt; i++)
+    {
+        take = &borg_takes[i];
+
+        /* Skip "dead" objects */
+        if (!take->k_idx) continue;
+
+        /* Access kind */
+        k_ptr = &k_info[take->k_idx];
+
+        /* Verify char */
+        if (k_ptr->d_char != r_ptr->d_char) continue;
+
+        /* Verify attr (unless clear or multi-hued) */
+        if (!(r_ptr->flags1 & (RF1_ATTR_MULTI | RF1_ATTR_CLEAR)))
+        {
+            /* Verify attr (unless flavored) */
+            if (!(k_ptr->flavor))
+            {
+                /* Verify attr */
+                if (k_ptr->d_attr != r_ptr->d_attr) continue;
+            }
+        }
+
+        /* Calculate distance */
+        d = distance(take->y, take->x, y, x);
+
+        /* Skip "wrong" objects */
+        if (d > r) continue;
+
+        /* Track closest one */
+        if (d > b_d) continue;
+
+        /* Track it */
+        b_i = i; b_d = d;
+    }
+
+    /* Found one */
+    if (b_i >= 0)
+    {
+        take = &borg_takes[b_i];
+
+        /* Access kind */
+        k_ptr = &k_info[take->k_idx];
+
+        /* Note */
+        borg_note(format("# Converting an object '%s' at (%d,%d)",
+                         (k_name + k_ptr->name),
+                         take->y, take->x));
+
+        /* Save location */
+        x = take->x;
+        y = take->y;
+
+        /* Delete the object */
+        borg_delete_take(b_i);
+
+        /* Make a new monster */
+        b_i = borg_new_kill(r_idx, y, x);
+
+        /* Get the monster */
+        kill = &borg_kills[b_i];
+
+        /* Timestamp */
+        kill->when = borg_t;
+
+		/* Mark the Morgoth time stamp if needed */
+		if (kill->r_idx == 547) borg_t_morgoth = borg_t;
+
+        /* Known identity */
+        if (!r) kill->known = TRUE;
+
+
+        /* Return the index */
+        return (b_i);
+    }
+
+
+    /*** Hack -- Find a similar monster ***/
+
+    /* Nothing yet */
+    b_i = -1; b_d = 999;
+
+    /* Scan the monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        kill = &borg_kills[i];
+
+        /* Skip "dead" monsters */
+        if (!kill->r_idx) continue;
+
+        /* Skip "matching" monsters */
+        if (kill->r_idx == r_idx) continue;
+
+        /* Verify char */
+        if (r_info[kill->r_idx].d_char != r_ptr->d_char) continue;
+
+        /* Verify attr (unless clear or multi-hued) */
+        if (!(r_ptr->flags1 & (RF1_ATTR_MULTI | RF1_ATTR_CLEAR)))
+        {
+            /* Verify attr */
+            if (r_info[kill->r_idx].d_attr != r_ptr->d_attr) continue;
+        }
+
+        /* Distance away */
+        d = distance(kill->y, kill->x, y, x);
+
+        /* Check distance */
+        if (d > r) continue;
+
+        /* Track closest one */
+        if (d > b_d) continue;
+
+        /* Track it */
+        b_i = i; b_d = d;
+    }
+
+    /* Found one */
+    if (b_i >= 0)
+    {
+        kill = &borg_kills[b_i];
+
+        /* Note */
+        borg_note(format("# Converting a monster '%s' at (%d,%d)",
+                         (r_name + r_info[kill->r_idx].name),
+                         kill->y, kill->x));
+
+        /* Change the race */
+        kill->r_idx = r_idx;
+
+        /* Update the monster */
+        borg_update_kill_new(b_i);
+
+        /* Update the monster */
+        borg_update_kill_old(b_i);
+
+        /* Known identity */
+        if (!r) kill->known = TRUE;
+
+
+        /* Recalculate danger */
+        borg_danger_wipe = TRUE;
+
+        /* Clear goals */
+        goal = 0;
+
+        /* Index */
+        return (b_i);
+    }
+
+
+    /*** Hack -- Find an existing monster ***/
+
+    /* Nothing yet */
+    b_i = -1; b_d = 999;
+
+    /* Scan the monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        kill = &borg_kills[i];
+
+        /* Skip "dead" monsters */
+        if (!kill->r_idx) continue;
+
+        /* Skip "different" monsters */
+        if (kill->r_idx != r_idx) continue;
+
+        /* Distance away */
+        d = distance(kill->y, kill->x, y, x);
+
+        /* Check distance */
+        if (d > r+3) continue;
+
+		/* Hopefully this will add fear to our grid */
+        if (!borg_projectable(kill->y,kill->x,y,x)) continue;
+
+        /* Track closest one */
+        if (d > b_d) continue;
+
+        /* Track it */
+        b_i = i; b_d = d;
+    }
+
+    /*** Hack -- Find an existing monster Last Chance ***/
+    /* Note:
+     * There can be some problems with monsters that use melee
+     * attack.  The range (r) will be 1.  But the known monster
+     * may be a few paces further and moved closely and attacked
+     * in the same round.  If this is the case, we miss them the
+     * first pass then end up Ignoring them.
+     */
+    if (b_i == -1)
+    {
+	    /* Nothing yet */
+		b_i = -1; b_d = 999;
+
+	    /* Scan the monsters */
+	    for (i = 1; i < borg_kills_nxt; i++)
+	    {
+	        kill = &borg_kills[i];
+
+	        /* Skip "dead" monsters */
+	        if (!kill->r_idx) continue;
+
+	        /* Skip "different" monsters */
+	        if (kill->r_idx != r_idx) continue;
+
+	        /* Distance away */
+	        d = distance(kill->y, kill->x, y, x);
+
+	        /* Check distance */
+	        /* Note:
+	         * There can be some problems with monsters that use melee
+	         * attack.  The range (r) will be 1.  But the known monster
+	         * may be a few paces further and moved closely and attacked
+	         * in the same round.  If this is the case, we miss them the
+	         * first pass then end up Ignoring them.
+	         * We extend the range of the search*/
+	        if (d > r + 20) continue;
+
+	        /* Track closest one */
+	        if (d > b_d) continue;
+
+	        /* Track it */
+	        b_i = i; b_d = d;
+	    }
+	}
+
+    /* Found one */
+    if (b_i >= 0)
+    {
+        kill = &borg_kills[b_i];
+
+        /* Note */
+        borg_note(format("# Matched a monster '%s' at (%d,%d) for the parsed msg.",
+                         (r_name + r_info[kill->r_idx].name),
+                         kill->y, kill->x));
+
+        /* Known identity */
+        if (!r) kill->known = TRUE;
+
+
+        /* Index */
+        return (b_i);
+    }
+
+
+    /*** Oops ***/
+
+    /* Note */
+    borg_note(format("# Unable to locate monster '%s' near (%d,%d), which generated the msg.",
+                     (r_name + r_ptr->name),
+                     y, x));
+
+    /* Oops */
+    /* this is the case where we know the name of the monster */
+    /* but cannot locate it on the monster list. */
+    return (-1);
+}
+
+
+
+
+/*
+ * Notice the "death" of a monster
+ */
+static void borg_count_death(int i)
+{
+    int r_idx;
+
+    borg_kill *kill = &borg_kills[i];
+
+    /* Access race */
+    r_idx = kill->r_idx;
+
+    /* Hack -- count racial deaths */
+    if (borg_race_death[r_idx] < MAX_SHORT) borg_race_death[r_idx]++;
+
+    /* if it was a unique then remove the unique_on_level flag */
+    if (r_info[kill->r_idx].flags1 & RF1_UNIQUE) unique_on_level = 0;
+
+}
+
+
+
+
+/*
+ * Handle "detection" spells and "call lite"
+ *
+ * Note that we must use the "old" player location
+ */
+static bool borg_handle_self(cptr str)
+{
+    int i;
+
+    int q_x, q_y;
+	int y,x;
+
+    /* Extract panel */
+    q_x = o_w_x / PANEL_WID;
+    q_y = o_w_y / PANEL_HGT;
+
+
+    /* Handle failure */
+    if (borg_failure)
+    {
+        borg_note("# Something failed");
+    }
+
+    /* Handle "call lite" */
+    else if (prefix(str, "lite"))
+    {
+        /* Message */
+        borg_note(format("# Called lite at (%d,%d)",
+                         o_c_y, o_c_x));
+
+		/* If not holding a lite, then glow adjacent grids */
+		if (!borg_skill[BI_CURLITE])
+		{
+	        /* Scan the "local" grids (5x5) 2 same as torch grid
+	         * The spells do some goofy radius thing.
+	         */
+	        for (y = c_y - 1; y <= c_y + 1; y++)
+	        {
+	            /* Scan the "local" grids (5x5) */
+	            for (x = c_x - 1; x <= c_x + 1; x++)
+	            {
+		            /* Get the grid */
+		            borg_grid *ag = &borg_grids[y][x];
+
+		            /* Mark as perma-lit */
+		            ag->info |= BORG_GLOW;
+
+		            /* Mark as not dark */
+		            ag->info &= ~BORG_DARK;
+				}
+	        }
+
+	    }
+
+        /* Hack -- convert torch-lit grids to perma-lit grids */
+        for (i = 0; i < borg_lite_n; i++)
+        {
+            int x = borg_lite_x[i];
+            int y = borg_lite_y[i];
+
+            /* Get the grid */
+            borg_grid *ag = &borg_grids[y][x];
+
+            /* Mark as perma-lit */
+            ag->info |= BORG_GLOW;
+
+            /* Mark as not dark */
+            ag->info &= ~BORG_DARK;
+
+        }
+
+    }
+
+
+    /* Handle "detect walls" */
+    else if (prefix(str, "wall"))
+    {
+        /* Message */
+        borg_note(format("# Detected walls (%d,%d to %d,%d)",
+                         q_y, q_x, q_y+1, q_x+1));
+
+        /* Mark detected walls */
+        borg_detect_wall[q_y+0][q_x+0] = TRUE;
+        borg_detect_wall[q_y+0][q_x+1] = TRUE;
+        borg_detect_wall[q_y+1][q_x+0] = TRUE;
+        borg_detect_wall[q_y+1][q_x+1] = TRUE;
+    }
+
+    /* Handle "detect traps" */
+    else if (prefix(str, "trap"))
+    {
+        /* Message */
+        borg_note(format("# Detected traps (%d,%d to %d,%d)",
+                         q_y, q_x, q_y+1, q_x+1));
+
+        /* Mark detected traps */
+        borg_detect_trap[q_y+0][q_x+0] = TRUE;
+        borg_detect_trap[q_y+0][q_x+1] = TRUE;
+        borg_detect_trap[q_y+1][q_x+0] = TRUE;
+        borg_detect_trap[q_y+1][q_x+1] = TRUE;
+    }
+
+    /* Handle "detect doors" */
+    else if (prefix(str, "door"))
+    {
+        /* Message */
+        borg_note(format("# Detected doors (%d,%d to %d,%d)",
+                         q_y, q_x, q_y+1, q_x+1));
+
+        /* Mark detected doors */
+        borg_detect_door[q_y+0][q_x+0] = TRUE;
+        borg_detect_door[q_y+0][q_x+1] = TRUE;
+        borg_detect_door[q_y+1][q_x+0] = TRUE;
+        borg_detect_door[q_y+1][q_x+1] = TRUE;
+    }
+
+    /* Handle "detect traps and doors" */
+    else if (prefix(str, "both"))
+    {
+        /* Message */
+        borg_note(format("# Detected traps and doors (%d,%d to %d,%d)",
+                         q_y, q_x, q_y+1, q_x+1));
+
+        /* Mark detected traps */
+        borg_detect_trap[q_y+0][q_x+0] = TRUE;
+        borg_detect_trap[q_y+0][q_x+1] = TRUE;
+        borg_detect_trap[q_y+1][q_x+0] = TRUE;
+        borg_detect_trap[q_y+1][q_x+1] = TRUE;
+
+        /* Mark detected doors */
+        borg_detect_door[q_y+0][q_x+0] = TRUE;
+        borg_detect_door[q_y+0][q_x+1] = TRUE;
+        borg_detect_door[q_y+1][q_x+0] = TRUE;
+        borg_detect_door[q_y+1][q_x+1] = TRUE;
+    }
+
+    /* Handle "detect traps and doors and evil" */
+    else if (prefix(str, "TDE"))
+    {
+        /* Message */
+        borg_note(format("# Detected traps, doors & evil (%d,%d to %d,%d)",
+                         q_y, q_x, q_y+1, q_x+1));
+
+        /* Mark detected traps */
+        borg_detect_trap[q_y+0][q_x+0] = TRUE;
+        borg_detect_trap[q_y+0][q_x+1] = TRUE;
+        borg_detect_trap[q_y+1][q_x+0] = TRUE;
+        borg_detect_trap[q_y+1][q_x+1] = TRUE;
+
+        /* Mark detected doors */
+        borg_detect_door[q_y+0][q_x+0] = TRUE;
+        borg_detect_door[q_y+0][q_x+1] = TRUE;
+        borg_detect_door[q_y+1][q_x+0] = TRUE;
+        borg_detect_door[q_y+1][q_x+1] = TRUE;
+
+        /* Mark detected evil */
+        borg_detect_evil[q_y+0][q_x+0] = TRUE;
+        borg_detect_evil[q_y+0][q_x+1] = TRUE;
+        borg_detect_evil[q_y+1][q_x+0] = TRUE;
+        borg_detect_evil[q_y+1][q_x+1] = TRUE;
+    }
+
+    /* Handle "detect evil" */
+    else if (prefix(str, "evil"))
+    {
+        /* Message */
+        borg_note(format("# Detected evil (%d,%d to %d,%d)",
+                         q_y, q_x, q_y+1, q_x+1));
+
+        /* Mark detected evil */
+        borg_detect_evil[q_y+0][q_x+0] = TRUE;
+        borg_detect_evil[q_y+0][q_x+1] = TRUE;
+        borg_detect_evil[q_y+1][q_x+0] = TRUE;
+        borg_detect_evil[q_y+1][q_x+1] = TRUE;
+    }
+
+    /* Done */
+    return (TRUE);
+}
+
+
+
+/*
+ * Update the Borg based on the current "map"
+ */
+static void borg_forget_map(void)
+{
+    int x, y;
+
+    borg_grid *ag;
+
+
+    /* Clean up the grids */
+    for (y = 0; y < AUTO_MAX_Y; y++)
+    {
+        for (x = 0; x < AUTO_MAX_X; x++)
+        {
+            /* Access the grid */
+            ag = &borg_grids[y][x];
+
+            /* Wipe it */
+            WIPE(ag, borg_grid);
+
+            /* Lay down the outer walls */
+            ag->feat = FEAT_PERM_SOLID;
+        }
+    }
+
+    /* Clean up the grids */
+    for (y = 1; y < AUTO_MAX_Y-1; y++)
+    {
+        for (x = 1; x < AUTO_MAX_X-1; x++)
+        {
+            /* Access the grid */
+            ag = &borg_grids[y][x];
+
+            /* Forget the contents */
+            ag->feat = FEAT_NONE;
+
+            /* Hack -- prepare the town */
+            if (!borg_skill[BI_CDEPTH]) ag->feat = FEAT_FLOOR;
+        }
+    }
+
+
+    /* Reset "borg_data_cost" */
+    COPY(borg_data_cost, borg_data_hard, borg_data);
+
+    /* Reset "borg_data_flow" */
+    COPY(borg_data_flow, borg_data_hard, borg_data);
+
+
+    /* Clear "borg_data_know" */
+    WIPE(borg_data_know, borg_data);
+
+    /* Clear "borg_data_icky" */
+    WIPE(borg_data_icky, borg_data);
+
+
+    /* Forget the view */
+    borg_forget_view();
+}
+
+static byte Get_f_info_number[256];
+
+/*
+ * Update the "map" based on visual info on the screen
+ *
+ * Note that we make assumptions about the grid under the player,
+ * to prevent painful situations such as seeming to be standing
+ * in a wall, or on a trap, etc.
+ *
+ * In general, we use the same "feat" codes as the game itself, but
+ * sometimes we are just guessing (as with "visible traps"), and we
+ * use some special codes, explained below.
+ *
+ * Note that we use the "feat" code of "FEAT_NONE" for grids which
+ * have never been seen, or which, when seen, have always contained
+ * an object or monster.  These grids are probably walls, unless
+ * they contain a monster or object, in which case they are probably
+ * floors, unless they contain a monster which passes through walls,
+ * in which case they are probably walls.
+ *
+ * Note that we use the "feat" code of "FEAT_FLOOR" for grids which
+ * were a normal floor last time we checked.  These grids may have
+ * changed into non-floor grids recently (via earthquake?), unless
+ * the grid is on the current panel, and is currently "lit" in some
+ * manner, and does not contain a monster.
+ *
+ * Note that we use the "feat" code of "FEAT_INVIS" for grids which
+ * once contained a wall/door, but then contained a monster or object.
+ * These grids are probably floors, unless the grid contains a monster
+ * which can pass through walls, in which case note that missiles and
+ * spells may not affect a monster in the grid.
+ *
+ * Note that we use the other "feat" codes for grids which probably
+ * contain the given feature type, unless several feature types use
+ * the same symbol, in which case we use some "default" code, changing
+ * our guess when messages provide us with more information.  This is
+ * especially necessary for distinguishing magma from quartz, and for
+ * distinguishing normal doors from locked doors from jammed doors.
+ * Note that most "feat" codes, even if they are not "guesses", may
+ * not be valid unless the grid is on the current panel.
+ *
+ * We use the "BORG_MARK" flag to mark a grid as having been "observed",
+ * though this may or may not indicate that the "feature" code is known,
+ * since observations of monsters or objects via telepathy and/or remote
+ * detection may trigger this flag.
+ *
+ * We use the "BORG_OKAY" flag to mark a grid as being on the current
+ * panel, which is used for various things, including verifying that
+ * a grid can be used as the destination of a target, and to allow us
+ * to assume that off-panel monsters are not "visible".
+ *
+ * Note the "interesting" code used to learn which floor grids are "dark"
+ * and which are "perma-lit", by tracking those floor grids which appear
+ * to be "lit", and then marking all of these grids which do not appear
+ * to be lit by the torch as "known" to be illuminated, and by marking
+ * any grids which "disappear" or which are displayed as "dark floors"
+ * as "known" to be "dark".  This leaves many grids, especially those
+ * lit by the torch, as being neither lit nor dark.
+ *
+ * The basic problem is that, especially with no special options set,
+ * the player has very little direct information about which grids
+ * are perma-lit, since all non-floor grids are memorized when they
+ * are seen, and torch-lit floor grids look just like perma-lit
+ * floor grids.  Also, monsters hide any object or feature in their
+ * grid, and objects hide any feature in their grid, and objects are
+ * memorized when they are seen, and monsters can be detected by a
+ * variety of methods, including infravision and telepathy.
+ *
+ * So we ignore most non-floor grids, and we mark any floor grids which
+ * are "known" to be perma-lit as "BORG_GLOW", and any which are "known"
+ * to be dark as "BORG_DARK".  These flags are used for many purposes,
+ * most importantly, to determine when "call lite" would be useful, and
+ * to help determine when a monster is standing in a viewable perma-lit
+ * grid, and should thus be "visible", and to determine when the player
+ * has "lite", even though his torch has gone out.
+ *
+ * When a "call lite" spell succeeds, we mark the grids around the
+ * player as "BORG_GLOW" and not "BORG_DARK", but we do not attempt
+ * to "spread" the lite to the entire room, since, in general, it is
+ * not possible to know what grids are in the "room".
+ *
+ * Note that we assume that normally, when the player steps onto
+ * something, it disappears, and turns into a normal floor, unless
+ * the player is stepping onto a grid which is normally "permanent"
+ * (floors, stairs, store doors), in which case it does not change.
+ *
+ * Note that when we encounter a grid which blocks motion, but which
+ * was previously thought to not block motion, we must be sure to
+ * remove it from any "flow" which might be in progress, to prevent
+ * nasty situations in which we attempt to flow into a wall grid
+ * which was thought to be something else, like an unknown grid.
+ *
+ */
+static void borg_update_map(void)
+{
+    int i, x, y, dx, dy;
+
+    borg_grid *ag;
+
+    byte t_a;
+    byte t_c;
+
+    /* Analyze the current map panel */
+    for (dy = 0; dy < SCREEN_HGT; dy++)
+    {
+#ifndef BORG_TK
+
+        /* Direct access XXX XXX XXX */
+        byte *aa = &(Term->scr->a[dy+1][13]);
+        char *cc = &(Term->scr->c[dy+1][13]);
+
+#ifdef ALLOW_BORG_GRAPHICS
+       byte a_trans;
+       char c_trans;
+#endif /* ALLOW_BORG_GRAPHICS */
+
+#endif /* not BORG_TK */
+
+        /* Scan the row */
+        for (dx = 0; dx < SCREEN_WID; dx++)
+        {
+            bool old_wall;
+            bool new_wall;
+
+
+            /* Obtain the map location */
+            x = w_x + dx;
+            y = w_y + dy;
+
+#ifdef BORG_TK
+
+            map_info(y, x, &t_a, &t_c);
+
+#else /* not BORG_TK */
+            /* Save contents */
+            t_a = *aa++;
+            t_c = *cc++;
+#ifdef ALLOW_BORG_GRAPHICS
+
+           /* Translate the glyph into an ASCII char */
+           a_trans = translate_visuals[(byte)t_a][(byte)t_c].d_attr;
+           c_trans = translate_visuals[(byte)t_a][(byte)t_c].d_char;
+
+           if ((a_trans != 0) || (c_trans != 0))
+           {
+               /* Translation found */
+               t_a = a_trans;
+               t_c = c_trans;
+           }
+
+#endif /* ALLOW_BORG_GRAPHICS */
+#endif /* not BORG_TK */
+
+            /* Get the borg_grid */
+            ag = &borg_grids[y][x];
+
+            /* Notice "on-screen" */
+            ag->info |= BORG_OKAY;
+
+            /* Notice "knowledge" */
+            if (t_c != ' ') ag->info |= BORG_MARK;
+
+
+            /* Notice the player */
+            if (t_c == '@')
+            {
+                /* Memorize player location */
+                c_x = x;
+                c_y = y;
+
+                /* Hack -- white */
+                t_a = TERM_WHITE;
+
+                /* mark the borg_grid if stair under me */
+                /* I might be standing on a stair */
+                if (borg_on_dnstairs)
+                {
+                    ag->feat = FEAT_MORE;
+                    borg_on_dnstairs = FALSE;
+                }
+                if (borg_on_upstairs)
+                {
+                    ag->feat = FEAT_LESS;
+                    borg_on_upstairs = FALSE;
+                }
+
+                /* Mark this grid as having been stepped on */
+                    track_step_x[track_step_num] = x;
+                    track_step_y[track_step_num] = y;
+                    track_step_num++;
+
+                /* Hack - Clean the steps every so often */
+                if (track_step_num > 75)
+                {
+                    for (i = 0; i < 75; i++)
+                    {
+                        /* Move each step down one position */
+                        track_step_x[i] = track_step_x[i + 1];
+                        track_step_y[i] = track_step_y[i + 1];
+                    }
+                    /* reset the count */
+                    track_step_num = 75;
+                }
+
+                /* AJG Just get the char from the features array */
+                if (ag->feat != FEAT_NONE)
+                    t_c = f_info[ag->feat].d_char;
+                else
+                    t_c = f_info[FEAT_FLOOR].d_char;
+            }
+
+
+            /* Save the old "wall" or "door" */
+            old_wall = !borg_cave_floor_grid(ag);
+
+            /* Analyze symbol */
+            /* AJG Adjust for funky graphics */
+            switch (Get_f_info_number[t_c])
+            {
+                /* Darkness */
+                case FEAT_NONE:
+                {
+                    /* The grid is not lit */
+                    ag->info &= ~BORG_GLOW;
+
+                    /* Known grids must be dark floors */
+                    if (ag->feat != FEAT_NONE) ag->info |= BORG_DARK;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Floors */
+                case FEAT_FLOOR:
+                {
+                    /* Handle "blind" */
+                    if (borg_skill[BI_ISBLIND])
+                    {
+                        /* Nothing */
+                    }
+
+                    /* Handle "dark" floors */
+                    else if (t_a == TERM_L_DARK)
+                    {
+                        /* Dark floor grid */
+                        ag->info |= BORG_DARK;
+                        ag->info &= ~BORG_GLOW;
+                    }
+
+                    /* Handle "lit" floors */
+                    else
+                    {
+                        /* Track "lit" floors */
+                        borg_temp_lit_y[borg_temp_lit_n] = y;
+                        borg_temp_lit_x[borg_temp_lit_n] = x;
+                        borg_temp_lit_n++;
+                    }
+
+                    /* Known floor */
+                    ag->feat = FEAT_FLOOR;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Open doors */
+                case FEAT_OPEN:
+                case FEAT_BROKEN:
+                {
+                    /* The borg cannot distinguish at a glance which is
+                       which so the actual cave_feat is plugged in */
+                    byte feat = cave_feat[y][x];
+
+                    /* Accept broken */
+                    if (ag->feat == FEAT_BROKEN) break;
+
+                    /* Hack- cheat the broken into memory */
+                    if (feat == FEAT_BROKEN)
+                    {
+                        ag->feat = FEAT_BROKEN;
+                        break;
+                    }
+
+                    /* Assume normal */
+                    ag->feat = FEAT_OPEN;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Walls */
+                case FEAT_WALL_EXTRA:
+                case FEAT_WALL_INNER:
+                case FEAT_WALL_OUTER:
+                case FEAT_WALL_SOLID:
+                case FEAT_PERM_SOLID:
+                case FEAT_PERM_EXTRA:
+                case FEAT_PERM_INNER:
+                case FEAT_PERM_OUTER:
+                {
+                    /* ok this is a humongo cheat.  He is pulling the
+                     * grid information from the game rather than from
+                     * his memory.  He is going to see if the wall is perm.
+                     * This is a cheat. May the Lord have mercy on my soul.
+                     *
+                     * The only other option is to have him "dig" on each
+                     * and every granite wall to see if it is perm.  Then he
+                     * can mark it as a non-perm.  However, he would only have
+                     * to dig once and only in a range of spaces near the
+                     * center of the map.  Since perma-walls are located in
+                     * vaults and vaults have a minimum size.  So he can avoid
+                     * digging on walls that are, say, 10 spaces from the edge
+                     * of the map.  He can also limit the dig by his depth.
+                     * Vaults are found below certain levels and with certain
+                     * "feelings."  Can be told not to dig on boring levels
+                     * and not before level 50 or whatever.
+                     *
+                     * Since the code to dig slows the borg down a lot.
+                     * (Found in borg6.c in _flow_dark_interesting()) We will
+                     * limit his capacity to search.  We will set a flag on
+                     * the level is perma grids are found.
+                     */
+                    byte feat = cave_feat[y][x];
+
+                    /* forget previously located walls */
+                    if (ag->feat == FEAT_PERM_INNER) break;
+
+                    /* is it a perma grid? */
+                    if (feat == FEAT_PERM_INNER)
+                    {
+                        ag->feat = FEAT_PERM_INNER;
+                        vault_on_level = TRUE;
+                        break;
+                    }
+                    /* is it a non perma grid? */
+                    if (feat >= FEAT_PERM_EXTRA)
+                    {
+                        ag->feat = FEAT_PERM_SOLID;
+                        break;
+                    }
+                    /* Accept non-granite */
+                    if (ag->feat >= FEAT_WALL_EXTRA &&
+                        ag->feat <= FEAT_PERM_EXTRA) break;
+
+                    /* Assume granite */
+                    ag->feat = FEAT_WALL_EXTRA;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Seams */
+                case FEAT_MAGMA:
+                case FEAT_QUARTZ:
+				{
+                    /* Accept quartz */
+                    if (ag->feat == FEAT_QUARTZ) break;
+
+                    /* Assume magma */
+                    ag->feat = FEAT_MAGMA;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Hidden */
+                case FEAT_MAGMA_K:
+                case FEAT_QUARTZ_K:
+                {
+                    /* Accept quartz */
+                    if (ag->feat == FEAT_QUARTZ_K) break;
+
+                    /* Assume magma */
+                    ag->feat = FEAT_MAGMA_K;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Rubble */
+                case FEAT_RUBBLE:
+                {
+                    /* Assume rubble */
+                    ag->feat = FEAT_RUBBLE;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Doors */
+                case FEAT_DOOR_HEAD:
+                case FEAT_DOOR_HEAD+1:
+                case FEAT_DOOR_HEAD+2:
+                case FEAT_DOOR_HEAD+3:
+                case FEAT_DOOR_HEAD+4:
+                case FEAT_DOOR_HEAD+5:
+                case FEAT_DOOR_HEAD+6:
+                case FEAT_DOOR_HEAD+7:
+                case FEAT_DOOR_HEAD+8:
+                case FEAT_DOOR_HEAD+9:
+                case FEAT_DOOR_HEAD+10:
+                case FEAT_DOOR_HEAD+11:
+                case FEAT_DOOR_HEAD+12:
+                case FEAT_DOOR_HEAD+13:
+                case FEAT_DOOR_HEAD+14:
+                case FEAT_DOOR_TAIL:
+                {
+					/* Only while low level */
+					if (borg_skill[BI_CLEVEL] <= 5)
+					{
+                    	/* Check for an existing door */
+                    	for (i = 0; i < track_closed_num; i++)
+                    	{
+                    	    /* Stop if we already new about this door */
+                    	    if ((track_closed_x[i] == x) && (track_closed_y[i] == y)) break;
+                    	}
+
+                    	/* Track the newly discovered door */
+                    	if ((i == track_closed_num) && (i < track_closed_size))
+                    	{
+                    	    track_closed_x[i] = x;
+                    	    track_closed_y[i] = y;
+                    	    track_closed_num++;
+
+							/* do not overflow */
+							if (track_closed_num > 254) track_closed_num = 254;
+						}
+					}
+
+                  	/* Accept jammed ones defined in borg9.c*/
+                    if ((ag->feat >= FEAT_DOOR_HEAD + 0x08) && (ag->feat <= FEAT_DOOR_TAIL)) break;
+
+                    /* Accept closed and locked */
+                    if ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_DOOR_HEAD + 0x07)) break;
+
+					/* Assume easy until we learn its Jammed */
+                   	ag->feat = FEAT_DOOR_HEAD + 0x00;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Traps */
+                case FEAT_TRAP_HEAD:
+                case FEAT_TRAP_HEAD+1:
+                case FEAT_TRAP_HEAD+2:
+                case FEAT_TRAP_HEAD+3:
+                case FEAT_TRAP_HEAD+4:
+                case FEAT_TRAP_HEAD+5:
+                case FEAT_TRAP_HEAD+6:
+                case FEAT_TRAP_HEAD+7:
+                case FEAT_TRAP_HEAD+8:
+                case FEAT_TRAP_HEAD+9:
+                case FEAT_TRAP_HEAD+10:
+                case FEAT_TRAP_HEAD+11:
+                case FEAT_TRAP_HEAD+12:
+                case FEAT_TRAP_HEAD+13:
+                case FEAT_TRAP_HEAD+14:
+                case FEAT_TRAP_TAIL:
+                {
+
+                    /* Minor cheat for the borg.  If the borg is running
+                     * in the graphics mode (not the AdamBolt Tiles) he will
+                     * mis-id the glyph of warding as a trap
+                     */
+                    byte feat = cave_feat[y][x];
+                    if (feat == FEAT_GLYPH)
+                    {
+                        ag->feat = FEAT_GLYPH;
+                        /* Check for an existing glyph */
+                        for (i = 0; i < track_glyph_num; i++)
+                        {
+                            /* Stop if we already new about this glyph */
+                            if ((track_glyph_x[i] == x) && (track_glyph_y[i] == y)) break;
+                        }
+
+                        /* Track the newly discovered glyph */
+                        if ((i == track_glyph_num) && (i < track_glyph_size))
+                        {
+                            track_glyph_x[i] = x;
+                            track_glyph_y[i] = y;
+                            track_glyph_num++;
+                        }
+
+                        /* done */
+                        break;
+                    }
+
+                    /* Assume trap door */
+                    ag->feat = FEAT_TRAP_HEAD + 0x00;
+
+                    /* Done */
+                    break;
+                }
+
+                /* glyph of warding stuff here, apw */
+                case FEAT_GLYPH:
+                {
+                    ag->feat = FEAT_GLYPH;
+
+                    /* Check for an existing glyph */
+                    for (i = 0; i < track_glyph_num; i++)
+                    {
+                        /* Stop if we already new about this glyph */
+                        if ((track_glyph_x[i] == x) && (track_glyph_y[i] == y)) break;
+                    }
+
+                    /* Track the newly discovered glyph */
+                    if ((i == track_glyph_num) && (i < track_glyph_size))
+                    {
+                        track_glyph_x[i] = x;
+                        track_glyph_y[i] = y;
+                        track_glyph_num++;
+                    }
+
+                    /* done */
+                    break;
+                }
+
+                /* Up stairs */
+                case FEAT_LESS:
+                {
+                    /* Obvious */
+                    ag->feat = FEAT_LESS;
+
+                    /* Check for an existing "up stairs" */
+                    for (i = 0; i < track_less_num; i++)
+                    {
+                        /* Stop if we already new about these stairs */
+                        if ((track_less_x[i] == x) && (track_less_y[i] == y)) break;
+                    }
+
+                    /* Track the newly discovered "up stairs" */
+                    if ((i == track_less_num) && (i < track_less_size))
+                    {
+                        track_less_x[i] = x;
+                        track_less_y[i] = y;
+                        track_less_num++;
+                    }
+                    /* Done */
+                    break;
+                }
+
+                /* Down stairs */
+                case FEAT_MORE:
+                {
+                    /* Obvious */
+                    ag->feat = FEAT_MORE;
+
+                    /* Check for an existing "down stairs" */
+                    for (i = 0; i < track_more_num; i++)
+                    {
+                        /* We already knew about that one */
+                        if ((track_more_x[i] == x) && (track_more_y[i] == y)) break;
+
+                    }
+
+                    /* Track the newly discovered "down stairs" */
+                    if ((i == track_more_num) && (i < track_more_size))
+                    {
+                        track_more_x[i] = x;
+                        track_more_y[i] = y;
+                        track_more_num++;
+                    }
+
+                    /* Done */
+                    break;
+                }
+
+                /* Store doors */
+                case FEAT_SHOP_HEAD:
+                case FEAT_SHOP_HEAD+1:
+                case FEAT_SHOP_HEAD+2:
+                case FEAT_SHOP_HEAD+3:
+                case FEAT_SHOP_HEAD+4:
+                case FEAT_SHOP_HEAD+5:
+                case FEAT_SHOP_HEAD+6:
+                case FEAT_SHOP_TAIL:
+
+                {
+                    /* Shop type */
+                    i = D2I(t_c) - 1;
+
+                    /* Obvious */
+                    ag->feat = FEAT_SHOP_HEAD + i;
+
+                    /* Save new information */
+                    track_shop_x[i] = x;
+                    track_shop_y[i] = y;
+
+                    /* Done */
+                    break;
+                }
+
+                /* Monsters/Objects */
+                default:
+                {
+                    borg_wank *wank;
+
+                     /* Check for memory overflow */
+                    if (borg_wank_num == AUTO_VIEW_MAX)
+                    {
+						borg_note(format("# Wank problem at grid (%d,%d) ta:%d, tc:%d, borg at (%d,%d)",y,x,t_a,t_c,c_y,c_x));
+                        borg_oops("too many objects...");
+					}
+
+                    /* Access next wank, advance */
+                    wank = &borg_wanks[borg_wank_num++];
+
+                    /* Save some information */
+                    wank->x = x;
+                    wank->y = y;
+                    wank->t_a = t_a;
+                    wank->t_c = t_c;
+                    wank->is_take = borg_is_take[(byte)(t_c)];
+                    wank->is_kill = borg_is_kill[(byte)(t_c)];
+
+                    /* mark old unknown squares as possible floor grids */
+                    if (ag->feat == FEAT_NONE)
+                        ag->feat = FEAT_INVIS;
+
+                    /* Mark old wall/door grids as probable floor grids */
+                    if (!borg_cave_floor_grid(ag))
+                        ag->feat = FEAT_INVIS;
+
+                    /* Done */
+                    break;
+                }
+            }
+
+            /* Save the new "wall" or "door" */
+            new_wall = !borg_cave_floor_grid(ag);
+
+            /* Notice wall changes */
+            if (old_wall != new_wall)
+            {
+                /* Remove this grid from any flow */
+                if (new_wall) borg_data_flow->data[y][x] = 255;
+
+                /* Remove this grid from any flow */
+                borg_data_know->data[y][x] = FALSE;
+
+                /* Remove this grid from any flow */
+                borg_data_icky->data[y][x] = FALSE;
+
+                /* Recalculate the view (if needed) */
+                if (ag->info & BORG_VIEW) borg_do_update_view = TRUE;
+
+                /* Recalculate the lite (if needed) */
+                if (ag->info & BORG_LITE) borg_do_update_lite = TRUE;
+            }
+        }
+    }
+}
+
+
+
+/*
+ * Look at the screen and update the borg
+ *
+ * Uses the "panel" info (w_x, w_y) obtained earlier
+ *
+ * Note that all the "important" messages that occured after our last
+ * action have been "queued" in a usable form.  We must attempt to use
+ * these messages to update our knowledge about the world, keeping in
+ * mind that the world may have changed in drastic ways.
+ *
+ * Note that the "borg_t" variable corresponds *roughly* to player turns,
+ * except that resting and "repeated" commands count as a single turn,
+ * and "free" moves (including "illegal" moves, such as attempted moves
+ * into walls, or tunneling into monsters) are counted as turns.
+ *
+ * Also note that "borg_t" is not incremented until the Borg is about to
+ * do something, so nothing ever has a time-stamp of the current time.
+ *
+ * We rely on the fact that all "perma-lit" grids are memorized when
+ * they are seen, so any grid on the current panel that appears "dark"
+ * must not be perma-lit.
+ *
+ * We rely on the fact that all "objects" are memorized when they are
+ * seen, so any grid on the current panel that appears "dark" must not
+ * have an object in it.  But it could have a monster which looks like
+ * an object, but this is very rare.  XXX XXX XXX
+ *
+ * XXX XXX XXX The basic problem with timestamping the monsters
+ * and objects is that we often get a message about a monster, and so
+ * we want to timestamp it, but then we cannot use the timestamp to
+ * indicate that the monster has not been "checked" yet.  Perhaps
+ * we need to do something like give each monster a "moved" flag,
+ * and clear all the flags to FALSE each turn before tracking. (?)
+ *
+ * Note that when two monsters of the same race are standing next to
+ * each other, and they both move, such that the second monster ends
+ * up where the first one began, we will incorrectly assume that the
+ * first monster stayed still, and either the second monster moved
+ * two spaces, or the second monster disappeared and a third monster
+ * appeared, which is technically possible, if the first monster ate
+ * the second, and then cloned the third.
+ *
+ * There is a problem with monsters which look like objects, namely,
+ * they are assumed to be objects, and then if they leave line of
+ * sight, they disappear, and the Borg assumes that they are gone,
+ * when really they should be identified as monsters.
+ *
+ * XXX XXX Hack -- note the fast direct access to the screen.
+ */
+void borg_update(void)
+{
+    int i, ii, k, x, y, dx, dy;
+
+    int hit_dist;
+
+    cptr msg;
+
+    cptr what;
+
+    borg_grid *ag;
+
+    bool reset = FALSE;
+
+	int j;
+	int floor_glyphed = 0;
+	bool monster_in_vault = FALSE;
+
+    /*** Process objects/monsters ***/
+
+    /* Scan monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Clear flags */
+        kill->seen = FALSE;
+        kill->used = FALSE;
+
+        /* Skip recently seen monsters except if hallucinating */
+        if (borg_t - kill->when < 2000 &&
+            !borg_skill[BI_ISIMAGE]) continue;
+
+        /* Note */
+        borg_note(format("# Expiring a monster '%s' (%d) at (%d,%d)",
+                         (r_name + r_info[kill->r_idx].name), kill->r_idx,
+                         kill->y, kill->x));
+
+        /* Kill the monster */
+        borg_delete_kill(i);
+    }
+
+    /* Scan objects */
+    for (i = 1; i < borg_takes_nxt; i++)
+    {
+        borg_take *take = &borg_takes[i];
+
+        /* Skip dead objects */
+        if (!take->k_idx) continue;
+
+        /* Clear flags */
+        take->seen = FALSE;
+
+	    /* delete them if they are under me
+	     * of if I am Hallucinating
+	     */
+	    if ((take->y == c_y && take->x == c_x) ||
+	    	(take->y == o_c_y && take->x == o_c_x) ||
+	    	borg_skill[BI_ISIMAGE])
+	    {
+	        borg_delete_take(i);
+	        continue;
+	    }
+
+        /* Skip recently seen objects */
+        if (borg_t - take->when < 2000) continue;
+
+        /* Note */
+        borg_note(format("# Expiring an object '%s' (%d) at (%d,%d)",
+                         (k_name + k_info[take->k_idx].name), take->k_idx,
+                         take->y, take->x));
+
+        /* Kill the object */
+        borg_delete_take(i);
+    }
+
+    /*** Handle messages ***/
+
+    /* Process messages */
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* Note the message */
+        borg_note(format("# %s (+)", msg));
+    }
+
+    /* Process messages */
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Skip parsed messages */
+        if (borg_msg_use[i]) continue;
+
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* Get the arguments */
+        what = strchr(msg, ':') + 1;
+
+        /* Hack -- Handle "SELF" info */
+        if (prefix(msg, "SELF:"))
+        {
+            (void)borg_handle_self(what);
+            borg_msg_use[i] = 1;
+        }
+
+        /* Handle "You feel..." */
+        else if (prefix(msg, "FEELING:"))
+        {
+            borg_feeling = atoi(what);
+            borg_msg_use[i] = 1;
+        }
+    }
+
+    /* Process messages */
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Skip parsed messages */
+        if (borg_msg_use[i]) continue;
+
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* Get the arguments */
+        what = strchr(msg, ':') + 1;
+
+        /* Handle "You hit xxx." */
+        if (prefix(msg, "HIT:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 0)) > 0)
+            {
+                borg_msg_use[i] = 2;
+            }
+        }
+
+        /* Handle "You miss xxx." */
+        else if (prefix(msg, "MISS:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 0)) > 0)
+            {
+                borg_msg_use[i] = 2;
+            }
+        }
+
+        /* Handle "You have killed xxx." */
+        else if (prefix(msg, "KILL:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 0)) > 0)
+            {
+                borg_count_death(k);
+
+                borg_delete_kill(k);
+                borg_msg_use[i] = 2;
+                /* reset the panel.  He's on a roll */
+                time_this_panel = 1;
+            }
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+
+        }
+
+        /* Handle "The xxx disappears!"  via teleport other, and blinks away */
+        else if (prefix(msg, "BLINK:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 0)) > 0)
+            {
+                borg_delete_kill(k);
+                borg_msg_use[i] = 2;
+                /* reset the panel.  He's on a roll */
+                time_this_panel = 1;
+            }
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+        }
+
+        /* Handle "xxx dies." */
+        else if (prefix(msg, "DIED:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 3)) > 0)
+            {
+                borg_count_death(k);
+                borg_delete_kill(k);
+                borg_msg_use[i] = 2;
+                /* reset the panel.  He's on a roll */
+                time_this_panel = 1;
+            }
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+        }
+
+        /* Handle "xxx screams in pain." */
+        else if (prefix(msg, "PAIN:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 3)) > 0)
+            {
+                borg_msg_use[i] = 2;
+            }
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE__FEAR:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 0)) > 0)
+            {
+                borg_msg_use[i] = 2;
+            }
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE__BOLD:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 0)) > 0)
+            {
+                borg_msg_use[i] = 2;
+            }
+        }
+        else if (prefix(msg, "STATE_SLEEP:"))
+        {
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+        }
+        else if (prefix(msg, "STATE__FEAR:"))
+        {
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+        }
+        else if (prefix(msg, "STATE_CONFUSED:"))
+        {
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+        }
+
+
+    }
+
+    /* Process messages */
+    /* getting distance to allow for 'hit's */
+    hit_dist = 1;
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Skip parsed messages */
+        if (borg_msg_use[i]) continue;
+
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* if you have moved then do not count the monsters as unknown */
+        /* unless they are very far away */
+        if (prefix(msg, "SPELL_70") ||
+            prefix(msg, "SPELL_71"))
+        {
+            hit_dist = 100;
+            break;
+        }
+
+        /* monsters move from earthquake */
+        if (prefix(msg, "QUAKE"))
+        {
+            hit_dist = 3;
+            break;
+        }
+    }
+
+    /* Process messages */
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Skip parsed messages */
+        if (borg_msg_use[i]) continue;
+
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* Get the arguments */
+        what = strchr(msg, ':') + 1;
+
+        /* Handle "You hit xxx." */
+        if (prefix(msg, "HIT:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, hit_dist)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Handle "You miss xxx." */
+        else if (prefix(msg, "MISS:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, hit_dist)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Handle "You have killed xxx." */
+        else if (prefix(msg, "KILL:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 1)) > 0)
+            {
+                borg_count_death(k);
+                borg_delete_kill(k);
+                borg_msg_use[i] = 3;
+                /* reset the panel.  He's on a roll */
+                time_this_panel = 1;
+            }
+        /* Shooting through darkness worked */
+        if (successful_target < 0) successful_target = 2;
+        }
+
+        /* Handle "The xxx disappears!"  via teleport other, and blinks away */
+        else if (prefix(msg, "BLINK:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, g_y, g_x, 1)) > 0)
+            {
+                borg_delete_kill(k);
+                borg_msg_use[i] = 3;
+                /* reset the panel.  He's on a roll */
+                time_this_panel = 1;
+            }
+        /* Shooting through darkness worked */
+        if (successful_target == -1) successful_target = 2;
+        }
+
+
+        /* Handle "xxx dies." */
+        else if (prefix(msg, "DIED:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 20)) > 0)
+            {
+                borg_count_death(k);
+                borg_delete_kill(k);
+                borg_msg_use[i] = 3;
+                /* reset the panel.  He's on a roll */
+                time_this_panel = 1;
+            }
+            /* Shooting through darkness worked */
+            if (successful_target < 0) successful_target = 2;
+        }
+
+        /* Handle "xxx screams in pain." */
+        else if (prefix(msg, "PAIN:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+
+        	/* Shooting through darkness worked */
+        	if (successful_target < 0) successful_target = 2;
+        }
+
+        /* Handle "xxx hits you." */
+        else if (prefix(msg, "HIT_BY:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 1)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Handle "xxx misses you." */
+        else if (prefix(msg, "MISS_BY:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 1)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE_SLEEP:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 20)) > 0)
+            {
+                borg_sleep_kill(k);
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Handle "awake" */
+        else if (prefix(msg, "STATE_AWAKE:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE__FEAR:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE__BOLD:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+        /* Hack -- Handle "spell" */
+        else if (prefix(msg, "SPELL_"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, o_c_y, o_c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 3;
+            }
+        }
+
+		/* Hack -- Handle "cackles evilly" */
+        if (prefix(msg, "SPELL_75"))
+        {
+			/* Remove the flag which tells borg that
+			 * Trap Detection was done here
+			 */
+	        borg_detect_trap[o_w_y / PANEL_HGT+0][o_w_x / PANEL_WID+0] = FALSE;
+	        borg_detect_trap[o_w_y / PANEL_HGT+0][o_w_x / PANEL_WID+1] = FALSE;
+	        borg_detect_trap[o_w_y / PANEL_HGT+1][o_w_x / PANEL_WID+0] = FALSE;
+	        borg_detect_trap[o_w_y / PANEL_HGT+1][o_w_x / PANEL_WID+1] = FALSE;
+
+			/* Leave a note */
+			borg_note("# Logging need for use of Detect Traps.");
+
+			/* Mark Adjacent grids to borg as Traps */
+	        for (ii = 0; ii < 8; ii++)
+	        {
+	            /* Grid in that direction */
+	            x = c_x + ddx_ddd[ii];
+	            y = c_y + ddy_ddd[ii];
+
+	            /* Access the grid */
+	            ag = &borg_grids[y][x];
+
+		        /* Skip unknown grids (important) */
+		        if (ag->feat == FEAT_NONE) continue;
+
+		        /* Mark known floor grids as trap */
+		        if (borg_cave_floor_grid(ag))
+		        {
+					ag->feat = FEAT_TRAP_HEAD;
+
+					/* Leave a note */
+					borg_note(format("# Assuming a Traps at (%d,%d).",y,x));
+				}
+			}
+		}
+     }
+
+    /* If we didn't successfully hit our target,
+       mark the first unknown in the path as a wall
+       If we mark a wall, let the borg shoot again */
+    if (successful_target < 0)
+    {
+        if (successful_target > -10)
+        {
+            successful_target -= 10;
+            if (borg_target_unknown_wall(g_y, g_x))
+                successful_target = 2;
+        }
+    }
+
+    /*** Handle new levels ***/
+
+    /* Hack -- note new levels */
+    if (old_depth != borg_skill[BI_CDEPTH])
+    {
+        /* if we are not leaving town increment time since town clock */
+        if (!old_depth)
+            borg_time_town = 0;
+        else
+            borg_time_town += borg_t - borg_began;
+
+        /* Hack -- Restart the clock */
+        borg_t = 1000;
+		borg_t_morgoth = 1;
+
+        /* reset our panel clock */
+        time_this_panel =1;
+
+        /* reset our vault/unique check */
+        vault_on_level = FALSE;
+        unique_on_level = 0;
+        scaryguy_on_level = FALSE;
+
+        /* reset our breeder flag */
+        breeder_level = FALSE;
+
+        /* reset our need to see inviso clock */
+        need_see_inviso = 1;
+
+        /* reset our 'shoot in the dark' flag */
+        successful_target = 0;
+
+        /* When level was begun */
+        borg_began = borg_t;
+
+        /* Not completed */
+        borg_completed = FALSE;
+
+        /* New danger thresh-hold */
+        avoidance = borg_skill[BI_CURHP];
+
+        /* Wipe the danger */
+        borg_danger_wipe = TRUE;
+
+        /* Clear our sold flags */
+        sold_item_tval = 0;
+        sold_item_pval = 0;
+        sold_item_tval = 0;
+        sold_item_sval = 0;
+        sold_item_pval = 0;
+        sold_item_store = 0;
+
+        /* Update some stuff */
+        borg_do_update_view = TRUE;
+        borg_do_update_lite = TRUE;
+
+        /* Examine the world */
+        borg_do_inven = TRUE;
+        borg_do_equip = TRUE;
+        borg_do_spell = TRUE;
+        borg_do_panel = TRUE;
+        borg_do_frame = TRUE;
+
+        /* Enable some functions */
+        borg_do_crush_junk = TRUE;
+        borg_do_crush_hole = TRUE;
+        borg_do_crush_slow = TRUE;
+
+        /* Mega-Hack -- Clear "call lite" stamp */
+        when_call_lite = 0;
+
+        /* Mega-Hack -- Clear "wizard lite" stamp */
+        when_wizard_lite = 0;
+
+        /* Mega-Hack -- Clear "detect traps" stamp */
+        when_detect_traps = 0;
+
+        /* Mega-Hack -- Clear "detect doors" stamp */
+        when_detect_doors = 0;
+
+        /* Mega-Hack -- Clear "detect walls" stamp */
+        when_detect_walls = 0;
+
+        /* Mega-Hack -- Clear "detect evil" stamp */
+        when_detect_evil = 0;
+
+		/* Log special events */
+		if (borg_skill[BI_CDEPTH] == 100)
+		{
+			borg_log_event(format("Arrived on depth 100 with %d heal, %d ez-heal.",
+			borg_skill[BI_AHEAL], borg_skill[BI_AEZHEAL]));
+		}
+
+        /* Hack -- Clear "panel" flags */
+        for (y = 0; y < 6; y++)
+        {
+            for (x = 0; x < 6; x++)
+            {
+                borg_detect_wall[y][x] = FALSE;
+                borg_detect_trap[y][x] = FALSE;
+                borg_detect_door[y][x] = FALSE;
+                borg_detect_evil[y][x] = FALSE;
+            }
+        }
+
+        /* Hack -- Clear "fear" */
+        for (y = 0; y < 6; y++)
+        {
+            for (x = 0; x < 18; x++)
+            {
+                borg_fear_region[y][x] = 0;
+            }
+        }
+
+        /* Remove regional fear from monsters, it gets added back in later. */
+        for (y = 0; y < AUTO_MAX_Y; y++)
+        {
+            for (x = 0; x < AUTO_MAX_X; x++)
+            {
+                borg_fear_monsters[y][x] = 0;
+            }
+        }
+
+        /* Hack -- Clear "shop visit" stamps */
+        for (i = 0; i < MAX_STORES; i++) borg_shops[i].when = 0;
+
+		/* If in the dungeon, no need for money_scum */
+		if (borg_money_scum_amount)
+		{
+			if (borg_skill[BI_CDEPTH])
+			{
+				/* Reset to zero, no scumming */
+				borg_money_scum_amount = 0;
+				borg_log_event("Money scum amount set to Zero, in the Dungeon.");
+			}
+		}
+
+
+        /* No goal yet */
+        goal = 0;
+
+        /* Hack -- Clear "shop" goals */
+        goal_shop = goal_ware = goal_item = -1;
+
+        /* Reset food&fuel in store */
+        borg_food_onsale = -1;
+        borg_fuel_onsale = -1;
+
+        /* Do not use any stairs */
+        stair_less = stair_more = FALSE;
+
+        /* Hack -- cannot rise past town */
+        if (!borg_skill[BI_CDEPTH]) goal_rising = FALSE;
+
+        /* Assume not leaving the level */
+        goal_leaving = FALSE;
+
+        /* Assume not fleeing the level */
+        goal_fleeing = FALSE;
+		goal_fleeing_lunal = FALSE;
+
+        /* Assume not ignoring monsters */
+        goal_ignoring = FALSE;
+
+        /* Assume not fleeing the level */
+        if (!borg_skill[BI_CDEPTH]) borg_fleeing_town = FALSE;
+		if (borg_skill[BI_CDEPTH] >= 2) borg_fleeing_town = FALSE;
+
+        /* No known stairs */
+        track_less_num = 0;
+        track_more_num = 0;
+
+        /* No known glyph */
+        track_glyph_num = 0;
+
+        /* No known steps */
+        track_step_num = 0;
+
+        /* No known doors */
+        track_door_num = 0;
+
+        /* No known doors */
+        track_closed_num = 0;
+
+        /* No objects here */
+        borg_takes_cnt = 0;
+        borg_takes_nxt = 1;
+
+        /* Forget old objects */
+        C_WIPE(borg_takes, 256, borg_take);
+
+        /* No monsters here */
+        borg_kills_cnt = 0;
+        borg_kills_nxt = 1;
+
+		/* Hack- Assume that Morgoth is on Level 100 unless
+		 * we know he is dead
+		 */
+		morgoth_on_level = FALSE;
+		if ((borg_skill[BI_CDEPTH] >= 100 && !borg_skill[BI_KING]) ||
+			(unique_on_level == 547))
+		{
+			/* We assume Morgoth is on this level */
+			morgoth_on_level = TRUE;
+		}
+
+		/* Must build a new sea of runes */
+		borg_needs_new_sea = TRUE;
+
+		/* Reset nasties */
+		borg_hound_count = 25; /* Assume some on level */
+		borg_lich_count = 0;
+		borg_demon_count = 0;
+		borg_angel_count = 0;
+		borg_wight_count = 0;
+
+        /* Forget old monsters */
+        C_WIPE(borg_kills, 256, borg_kill);
+
+        /* Hack -- Forget race counters */
+        C_WIPE(borg_race_count, z_info->r_max, s16b);
+
+        /* Hack -- Rarely, a Unique can die off screen and the borg will miss it.
+         * This check will cheat to see if uniques are dead.
+         */
+
+		/* Clear our Uniques vars */
+		borg_numb_live_unique = 0;
+		borg_living_unique_index = 0;
+		borg_unique_depth = 127;
+
+         /*Extract dead uniques and set some Prep code numbers */
+        for (i = 1; i < z_info->r_max-1; i++)
+        {
+            monster_race *r_ptr = &r_info[i];
+
+            /* Skip non-monsters */
+            if (!r_ptr->name) continue;
+
+            /* Skip non-uniques */
+            if (!(r_ptr->flags1 & RF1_UNIQUE)) continue;
+
+            /* Mega-Hack -- Access "dead unique" list */
+            if (r_ptr->max_num == 0) borg_race_death[i] = 1;
+
+            /* If any have been killed it is not a live unique */
+            if (borg_race_death[i] != 0) continue;
+
+            /* skip if deeper than max dlevel */
+            if (r_ptr->level > borg_skill[BI_MAXDEPTH]) continue;
+
+			/* skip certain questor Monsters */
+            if (r_ptr->flags1 & RF1_QUESTOR) continue;
+
+            /* Define some numbers used by Prep code */
+            borg_numb_live_unique ++;
+
+			/* Its important to know the depth of the most shallow guy */
+			if (r_ptr->level < borg_unique_depth) borg_unique_depth = r_ptr->level;
+
+            if (i < borg_living_unique_index ||
+               borg_living_unique_index == 0) borg_living_unique_index = i;
+        }
+
+
+        /* Forget the map */
+        borg_forget_map();
+
+        /* Reset */
+        reset = TRUE;
+
+        /* wipe out bad artifacts list */
+        for (i = 0; i < 50; i++)
+        {
+            bad_obj_x[i] = -1;
+            bad_obj_y[i] = -1;
+        }
+
+        /* save once per level, but not if Lunal Scumming */
+        if (borg_flag_save && !borg_lunal_mode) borg_save = TRUE;
+
+        /* Save new depth */
+        old_depth = borg_skill[BI_CDEPTH];
+
+        borg_times_twitch = 0;
+        borg_escapes = 0;
+
+    }
+
+    /* Handle old level */
+    else
+    {
+        /* reduce Resistance count. NOTE: do not reduce below 1.  That is done */
+        /* when the spell is cast. */
+        if (borg_resistance > 1)
+        {
+            borg_resistance -= borg_game_ratio;
+        }
+
+		/* reduce the No-resting-because-I-just-did-a-prep-spell */
+		if (borg_no_rest_prep > 1)
+		{
+			borg_no_rest_prep -= borg_game_ratio;
+		}
+
+        /* Count down to blast off */
+        if (goal_recalling > 1)
+        {
+            goal_recalling -= borg_game_ratio;
+
+            /* dont let it get to 0 or borg will recast the spell */
+            if (goal_recalling <= 0) goal_recalling = 1;
+        }
+
+		/* Lets make sure we did not miss read */
+		if (goal_recalling && !p_ptr->word_recall)
+		{
+			goal_recalling = 0;
+		}
+
+        /* when we need to cast this spell again */
+        if (borg_see_inv > 1)
+        {
+            borg_see_inv -= borg_game_ratio;
+        }
+
+		/* Hack- Assume that Morgoth is on Level 100
+		 */
+		morgoth_on_level = FALSE;
+		if ((borg_skill[BI_CDEPTH] >= 100 && !borg_skill[BI_KING]) ||
+			(unique_on_level == 547))
+		{
+			/* We assume Morgoth is on this level */
+			morgoth_on_level = TRUE;
+		}
+
+		/* If been sitting on level 100 for a long time and Morgoth
+		 * is a:
+		 * 1. no show,
+		 * 2. was here but has not been around in a very long time.
+		 * then assume he is not here so borg can continue to
+		 * explore the dungeon.
+		 */
+		if (morgoth_on_level && borg_t - borg_began >= 500)
+		{
+			/* Morgoth is a no show */
+			if (unique_on_level != 547)	morgoth_on_level = FALSE;
+
+			/* Morgoth has not been seen in a long time */
+			if (unique_on_level == 547 && (borg_t - borg_t_morgoth > 500))
+	        {
+					borg_note(format("# Morgoth has not been seen in %d turns.  Going to hunt him.", borg_t - borg_t_morgoth));
+					morgoth_on_level = FALSE;
+					unique_on_level = 0;
+			}
+		}
+
+		/* Slight Cheat for the borg.  He would like to keep an
+		 * eye on the Resist All spell.  The borg will check if
+		 * all resistances are on and if so, give himself the
+		 * flag, but not if the flag is already on.
+		 */
+		if (borg_resistance <= 0 && my_oppose_fire &&
+			my_oppose_elec && my_oppose_cold &&
+			my_oppose_acid && my_oppose_pois)
+		{
+			/* Set the flag on with some average count */
+			borg_resistance = 20000;
+		}
+
+		/* Slight safety check for borg to make sure he really
+		 * does resist all if he thinks he does.
+		 */
+		if (borg_resistance >= 1 && /* borg thinks it's on */
+			(my_oppose_fire +
+			 my_oppose_elec + my_oppose_cold +
+			 my_oppose_acid + my_oppose_pois != 5))
+		{
+			/* Set the flag on with some average count */
+			borg_resistance = 0;
+		}
+
+        /* Reduce fear over time */
+        if (!(borg_t % 10))
+        {
+            for (y = 0; y < 6; y++)
+            {
+                for (x = 0; x < 18; x++)
+                {
+                    if (borg_fear_region[y][x]) borg_fear_region[y][x]--;
+                }
+            }
+        }
+
+        /* Remove regional fear from monsters, it gets added back in later. */
+        for (y = 0; y < AUTO_MAX_Y; y++)
+        {
+            for (x = 0; x < AUTO_MAX_X; x++)
+            {
+                borg_fear_monsters[y][x] = 0;
+            }
+        }
+
+        /* Handle changing map panel */
+        if ((o_w_x != w_x) || (o_w_y != w_y))
+        {
+            /* Forget the previous map panel */
+            for (dy = 0; dy < SCREEN_HGT; dy++)
+            {
+                for (dx = 0; dx < SCREEN_WID; dx++)
+                {
+                    /* Access the actual location */
+                    x = o_w_x + dx;
+                    y = o_w_y + dy;
+
+                    /* Get the borg_grid */
+                    ag = &borg_grids[y][x];
+
+                    /* Clear the "okay" field */
+                    ag->info &= ~BORG_OKAY;
+                }
+            }
+
+            /* Time stamp this new panel-- to avoid a repeated motion bug */
+            time_this_panel = 1;
+
+        }
+
+        /* Examine the world while in town. */
+        if (!borg_skill[BI_CDEPTH]) borg_do_inven = TRUE;
+        if (!borg_skill[BI_CDEPTH]) borg_do_equip = TRUE;
+
+    }
+
+
+    /*** Update the map ***/
+
+    /* Track floors */
+    borg_temp_lit_n = 0;
+
+    /* Update the map */
+    borg_update_map();
+
+    /* Reset */
+    if (reset)
+    {
+        /* Fake old panel */
+        o_w_x = w_x;
+        o_w_y = w_y;
+
+        /* Fake old location */
+        o_c_x = c_x;
+        o_c_y = c_y;
+
+        /* Fake goal location */
+        g_x = c_x;
+        g_y = c_y;
+    }
+
+    /* Player moved */
+    if ((o_c_x != c_x) || (o_c_y != c_y))
+    {
+        /* Update view */
+        borg_do_update_view = TRUE;
+
+        /* Update lite */
+        borg_do_update_lite = TRUE;
+
+        /* Assume I can shoot here */
+        successful_target = 0;
+    }
+
+    /* Update the view */
+    if (borg_do_update_view)
+    {
+        /* Update the view */
+        borg_update_view();
+
+        /* Take note */
+        borg_do_update_view = FALSE;
+    }
+
+    /* Update the lite */
+    if (borg_do_update_lite)
+    {
+        /* Update the lite */
+        borg_update_lite();
+
+        /* Take note */
+        borg_do_update_lite = FALSE;
+    }
+
+    /* Examine "lit" grids */
+    for (i = 0; i < borg_temp_lit_n; i++)
+    {
+        /* Get location */
+        x = borg_temp_lit_x[i];
+        y = borg_temp_lit_y[i];
+
+        /* Get the borg_grid */
+        ag = &borg_grids[y][x];
+
+        /* Skip torch-lit grids */
+        if (ag->info & BORG_LITE) continue;
+
+        /* Assume not dark */
+        ag->info &= ~BORG_DARK;
+
+        /* Assume perma-lit */
+        if (y !=c_y && x != c_x) ag->info |= BORG_GLOW;
+    }
+
+    /* Convert necessary FEAT_INVIS grids to proper FEAT_FLOOR */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+
+        /* Monster */
+        kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Ignore monsters who can pass through walls  */
+        if ((r_info[kill->r_idx].flags2 & RF2_PASS_WALL )) continue;
+
+		/* Make sure this grid keeps Floor grid */
+		borg_grids[kill->y][kill->x].feat = FEAT_FLOOR;
+    }
+
+	/* Let me know if I am correctly positioned for special
+	 * Morgoth routines; sea of runes
+	 *
+	 * ############
+	 * #3.........#
+	 * #2..xxxxx..#
+	 * #1..xxxxx..#
+	 * #0..xx@xx..#
+	 * #1..xxxxx..#
+	 * #2..xxxxx..#
+	 * #3.........#
+	 * #4432101234#
+	 * ############
+	 */
+	borg_morgoth_position = FALSE;
+	if (!borg_skill[BI_KING] && morgoth_on_level)
+	{
+		/* Must be in a fairly central region */
+		if (c_y >= 15 && c_y <= AUTO_MAX_Y - 15 &&
+		    c_x >= 50 && c_x <= AUTO_MAX_X - 50)
+		{
+		    /* Scan neighbors */
+		    for (j = 0; j < 24; j++)
+		    {
+		        int y = c_y + borg_ddy_ddd[j];
+		        int x = c_x + borg_ddx_ddd[j];
+
+		        /* Get the grid */
+		        ag = &borg_grids[y][x];
+
+		        /* Skip unknown grids (important) */
+		        if (ag->feat == FEAT_GLYPH) floor_glyphed++;
+			}
+
+			/* Number of perfect grids */
+			if (floor_glyphed == 24) borg_morgoth_position = TRUE;
+
+		} /* Centrally located */
+	} /* on depth 100 not King */
+
+	/* Examine changing doors while shallow */
+	if (borg_skill[BI_CLEVEL] <= 5 && borg_skill[BI_CDEPTH] &&
+		track_closed_num)
+	{
+		/* Scan all known closed doors */
+		for (i = 0; i < track_closed_num; i++)
+		{
+	        /* Get location */
+	        x = track_closed_x[i];
+	        y = track_closed_y[i];
+
+	        /* Get the borg_grid */
+	        ag = &borg_grids[y][x];
+
+	        if (ag->feat == FEAT_OPEN ||
+	        	ag->feat == FEAT_BROKEN)
+        	{
+				/* This door was not opened by me */
+				borg_note(format("# Monster opened door at %d,%d.",y,x));
+	        	scaryguy_on_level = TRUE;
+			}
+		}
+	}
+
+    /*** Track objects and monsters ***/
+
+    /* Pass 1 -- stationary monsters */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track stationary monsters */
+        if (wank->is_kill &&
+            observe_kill_move(wank->y, wank->x, 0, wank->t_a, wank->t_c, FALSE))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+    /* Pass 2 -- stationary objects */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track stationary objects */
+        if (wank->is_take &&
+            observe_take_move(wank->y, wank->x, 0, wank->t_a, wank->t_c))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+    /* Pass 3a -- moving monsters (distance 1) */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track moving monsters */
+        if (wank->is_kill &&
+            observe_kill_move(wank->y, wank->x, 1, wank->t_a, wank->t_c, FALSE))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+    /* Pass 3b -- moving monsters (distance 2) */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track moving monsters */
+        if (wank->is_kill &&
+            observe_kill_move(wank->y, wank->x, 2, wank->t_a, wank->t_c, FALSE))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+    /* Pass 3c -- moving monsters (distance 3) */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track moving monsters */
+        if (wank->is_kill &&
+            observe_kill_move(wank->y, wank->x, 3, wank->t_a, wank->t_c, FALSE))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+    /* Pass 3d -- moving monsters (distance 3, allow changes) */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track moving monsters */
+        if (wank->is_kill &&
+            observe_kill_move(wank->y, wank->x, 3, wank->t_a, wank->t_c, TRUE))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+    /* Pass 4 -- new objects */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track new objects */
+        if (wank->is_take &&
+            observe_take_diff(wank->y, wank->x, wank->t_a, wank->t_c))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+    /* Pass 5 -- new monsters */
+    for (i = borg_wank_num - 1; i >= 0; i--)
+    {
+        borg_wank *wank = &borg_wanks[i];
+
+        /* Track new monsters */
+        if (wank->is_kill &&
+            observe_kill_diff(wank->y, wank->x, wank->t_a, wank->t_c))
+        {
+            /* Hack -- excise the entry */
+            borg_wanks[i] = borg_wanks[--borg_wank_num];
+        }
+    }
+
+
+    /*** Handle messages ***/
+
+    /* Process messages */
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Skip parsed messages */
+        if (borg_msg_use[i]) continue;
+
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* Get the arguments */
+        what = strchr(msg, ':') + 1;
+
+        /* Handle "xxx dies." */
+        if (prefix(msg, "DIED:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, 20)) > 0)
+            {
+                borg_count_death(k);
+                borg_delete_kill(k);
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Handle "xxx screams in pain." */
+        else if (prefix(msg, "PAIN:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Handle "xxx hits you." */
+        else if (prefix(msg, "HIT_BY:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, hit_dist)) > 0)
+            {
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Handle "xxx misses you." */
+        else if (prefix(msg, "MISS_BY:"))
+        {
+            /* Attempt to find the monster */
+
+            if ((k = borg_locate_kill(what, c_y, c_x, hit_dist)) > 0)
+            {
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE_SLEEP:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, 20)) > 0)
+            {
+                borg_sleep_kill(k);
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Handle "awake" */
+        else if (prefix(msg, "STATE_AWAKE:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE__FEAR:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Handle "sleep" */
+        else if (prefix(msg, "STATE__BOLD:"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 4;
+            }
+        }
+
+        /* Hack -- Handle "spell" */
+        else if (prefix(msg, "SPELL_"))
+        {
+            /* Attempt to find the monster */
+            if ((k = borg_locate_kill(what, c_y, c_x, 20)) > 0)
+            {
+                borg_msg_use[i] = 4;
+            }
+        }
+    }
+    /* Process messages */
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Skip parsed messages */
+        if (borg_msg_use[i]) continue;
+
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* Get the arguments */
+        what = strchr(msg, ':') + 1;
+
+        /* Handle "xxx hits you." */
+        if (prefix(msg, "HIT_BY:"))
+        {
+            borg_fear_regional(what, c_y, c_x, 4 * ((borg_skill[BI_CDEPTH] / 5) + 1), FALSE);
+            borg_msg_use[i] = 5;
+        }
+
+        /* Handle "xxx misses you." */
+        else if (prefix(msg, "MISS_BY:"))
+        {
+            borg_fear_regional(what, c_y, c_x, 2 * ((borg_skill[BI_CDEPTH] / 5) + 1), FALSE);
+            borg_msg_use[i] = 5;
+        }
+
+        /* Hack -- Handle "spell" */
+        else if (prefix(msg, "SPELL_"))
+        {
+            borg_fear_regional(what, c_y, c_x, borg_fear_spell(atoi(msg+6)), FALSE);
+            borg_msg_use[i] = 5;
+        }
+    }
+    /* Display messages */
+    for (i = 0; i < borg_msg_num; i++)
+    {
+        /* Get the message */
+        msg = borg_msg_buf + borg_msg_pos[i];
+
+        /* Final message */
+        borg_note(format("# %s (%d)", msg, borg_msg_use[i]));
+    }
+
+
+    /*** Notice missing monsters ***/
+    /* Scan the monster list */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Skip seen monsters */
+        if (kill->when == borg_t) continue;
+
+        /* Hack -- blind or hallucinating */
+        if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISIMAGE]) continue;
+
+        /* Predict the monster */
+        borg_follow_kill(i);
+    }
+
+    /* Update the fear_grid_monsters[][] with the monsters danger
+     * This will provide a 'regional' fear from the accumulated
+     * group of monsters.  One Orc wont be too dangerous, but 20
+     * of them can be deadly.
+     */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+		int p;
+
+	    borg_kill *kill = &borg_kills[i];
+
+	    monster_type    *m_ptr;
+	    monster_race 	*r_ptr;
+
+		/* Reset the 'vault monsters */
+		monster_in_vault = FALSE;
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+	    m_ptr = &mon_list[cave_m_idx[kill->y][kill->x]];
+	    r_ptr = &r_info[kill->r_idx];
+
+        /* Skip monsters that dont chase */
+	    if (r_ptr->flags1 & RF1_NEVER_MOVE) continue;
+
+        /* Skip monsters that are far away */
+	    if (distance(kill->y,kill->x, c_y, c_x) >= 20) continue;
+
+		/* Skip monsters in vaults */
+		if (vault_on_level)
+		{
+			/* Check adjacent grids to monster */
+	        for (ii = 0; ii < 8; ii++)
+	        {
+	            /* Grid in that direction */
+	            x = kill->x + ddx_ddd[ii];
+	            y = kill->y + ddy_ddd[ii];
+
+	            /* Access the grid */
+	            ag = &borg_grids[y][x];
+
+		        /* Skip unknown grids (important) */
+		        if (ag->feat == FEAT_NONE) continue;
+
+		        /* Mark this as a Vault monster */
+		        if (ag->feat >= FEAT_PERM_SOLID &&
+		            ag->feat <= FEAT_PERM_OUTER)
+		        {
+					monster_in_vault = TRUE;
+				}
+			}
+		}
+
+
+		/* Monster is probably in a vault, ignore the regional fear */
+		if (monster_in_vault == TRUE) continue;
+
+		/* Obtain some danger */
+	    p = (borg_danger(kill->y,kill->x, 1, FALSE) / 10)+1;
+
+		/* Apply the Fear */
+	    borg_fear_grid(r_name + r_info[kill->r_idx].name, kill->y, kill->x, p);
+	}
+
+
+    /*** Notice missing objects ***/
+
+    /* Scan the object list */
+    for (i = 1; i < borg_takes_nxt; i++)
+    {
+        borg_take *take = &borg_takes[i];
+
+        /* Skip dead objects */
+        if (!take->k_idx) continue;
+
+        /* Skip seen objects */
+        if (take->when >= borg_t - 2) continue;
+
+        /* Hack -- blind or hallucinating */
+        if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISIMAGE]) continue;
+
+        /* Follow the object */
+        borg_follow_take(i);
+    }
+
+    /*** Various things ***/
+
+    /* Forget goals while "impaired" in any way */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISAFRAID] || borg_skill[BI_ISIMAGE]) goal = 0;
+
+    /* Forget goals while "bleeding" in any way */
+    if (borg_skill[BI_ISWEAK] || borg_skill[BI_ISPOISONED] || borg_skill[BI_ISCUT] || borg_skill[BI_ISSTUN] || borg_skill[BI_ISHEAVYSTUN]) goal = 0;
+
+    /* Forget goals when HP or SP reduces */
+	/*    if ((borg_skill[BI_CURHP] < borg_oldchp) || (borg_skill[BI_CURSP] < borg_oldcsp)) goal = 0; */
+
+    /* Save the hit points */
+    borg_oldchp = borg_skill[BI_CURHP];
+
+    /* Save the spell points */
+    borg_oldcsp = borg_skill[BI_CURSP];
+
+    /* Forget failure */
+    borg_failure = FALSE;
+
+    /* Forget the messages */
+    borg_msg_len = 0;
+    borg_msg_num = 0;
+
+
+    /*** Save old info ***/
+
+    /* Save the old "location" */
+    o_c_x = c_x;
+    o_c_y = c_y;
+
+    /* Save the old "panel" */
+    o_w_x = w_x;
+    o_w_y = w_y;
+
+
+    /*** Defaults ***/
+
+    /* Default "goal" location */
+    g_x = c_x;
+    g_y = c_y;
+}
+
+
+/*
+ * Handle various "important" messages
+ *
+ * Actually, we simply "queue" them for later analysis
+ */
+void borg_react(cptr msg, cptr buf)
+{
+    int len;
+
+    if (borg_dont_react ||
+    	borg_skill[BI_ISPARALYZED])
+    {
+		borg_note("# Ignoring messages.");
+        return;
+	}
+
+    /* Note actual message */
+    borg_note(format("> Parsing Msg (%s)", msg));
+
+    /* Extract length of parsed message */
+    len = strlen(buf);
+
+    /* Verify space */
+    if (borg_msg_num + 1 > borg_msg_max)
+    {
+        borg_note("too many messages");
+        return;
+    }
+
+    /* Verify space */
+    if (borg_msg_len + len + 1 > borg_msg_siz)
+    {
+        borg_note("too much messages");
+        return;
+    }
+
+    /* Assume not used yet */
+    borg_msg_use[borg_msg_num] = 0;
+
+    /* Save the message position */
+    borg_msg_pos[borg_msg_num] = borg_msg_len;
+
+    /* Save the message text */
+    strcpy(borg_msg_buf + borg_msg_len, buf);
+
+    /* Advance the buf */
+    borg_msg_len += len + 1;
+
+    /* Advance the pos */
+    borg_msg_num++;
+}
+
+
+
+#ifdef BORG_TK
+void borg_forget_messages(void)
+{
+    borg_msg_len =0;
+    borg_msg_num = 0;
+}
+#endif /* borg_tk */
+
+
+/*
+ * Initialize this file
+ */
+void borg_init_5(void)
+{
+    int i;
+
+    int size;
+
+    s16b what[1024];
+    char* text[1024];
+
+
+    /*** Message tracking ***/
+
+    /* No chars saved yet */
+    borg_msg_len = 0;
+
+    /* Maximum buffer size */
+    borg_msg_siz = 4096;
+
+    /* Allocate a buffer */
+    C_MAKE(borg_msg_buf, borg_msg_siz, char);
+
+    /* No msg's saved yet */
+    borg_msg_num = 0;
+
+    /* Maximum number of messages */
+    borg_msg_max = 256;
+
+    /* Allocate array of positions */
+    C_MAKE(borg_msg_pos, borg_msg_max, s16b);
+
+    /* Allocate array of use-types */
+    C_MAKE(borg_msg_use, borg_msg_max, s16b);
+
+
+    /*** Object/Monster tracking ***/
+
+    /* Array of "wanks" */
+    C_MAKE(borg_wanks, AUTO_VIEW_MAX, borg_wank);
+
+
+    /*** Reset the map ***/
+
+    /* Forget the map */
+    borg_forget_map();
+
+
+    /*** Parse "unique" monster names ***/
+
+    /* Start over */
+    size = 0;
+
+    /* Collect "unique" monsters */
+    for (i = 1; i < z_info->r_max-1; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+
+        /* Skip non-monsters */
+        if (!r_ptr->name) continue;
+
+        /* Skip non-unique monsters */
+        if (!(r_ptr->flags1 & RF1_UNIQUE)) continue;
+
+        /* Use it */
+        text[size] = r_name + r_ptr->name;
+        what[size] = i;
+        size++;
+    }
+
+    /* Set the sort hooks */
+    borg_sort_comp = borg_sort_comp_hook;
+    borg_sort_swap = borg_sort_swap_hook;
+    /* Sort */
+    borg_sort(text, what, size);
+
+    /* Save the size */
+    borg_unique_size = size;
+
+    /* Allocate the arrays */
+    C_MAKE(borg_unique_text, borg_unique_size, cptr);
+    C_MAKE(borg_unique_what, borg_unique_size, s16b);
+
+    /* Save the entries */
+    for (i = 0; i < size; i++) borg_unique_text[i] = text[i];
+    for (i = 0; i < size; i++) borg_unique_what[i] = what[i];
+
+
+    /*** Parse "normal" monster names ***/
+
+    /* Start over */
+    size = 0;
+
+    /* Collect "normal" monsters */
+    for (i = 1; i < z_info->r_max-1; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+
+        /* Skip non-monsters */
+        if (!r_ptr->name) continue;
+
+        /* Skip unique monsters */
+        if (r_ptr->flags1 & RF1_UNIQUE) continue;
+
+        /* Use it */
+        text[size] = r_name + r_ptr->name;
+        what[size] = i;
+        size++;
+    }
+
+    /* Set the sort hooks */
+    borg_sort_comp = borg_sort_comp_hook;
+    borg_sort_swap = borg_sort_swap_hook;
+    /* Sort */
+    borg_sort(text, what, size);
+
+    /* Save the size */
+    borg_normal_size = size;
+
+    /* Allocate the arrays */
+    C_MAKE(borg_normal_text, borg_normal_size, cptr);
+    C_MAKE(borg_normal_what, borg_normal_size, s16b);
+
+    /* Save the entries */
+    for (i = 0; i < size; i++) borg_normal_text[i] = text[i];
+    for (i = 0; i < size; i++) borg_normal_what[i] = what[i];
+
+   /* Initialize */
+   for (i = 0; i < 256; i++) Get_f_info_number[i] = -1;
+
+   for (i = z_info->f_max - 1; i >= 0; i--)
+   {
+       if (i == FEAT_SECRET || i == FEAT_INVIS)
+           continue;
+
+       Get_f_info_number[f_info[i].d_char] = i;
+   }
+}
+
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg5.h angband-3.0.6-borg/src/borg5.h
--- angband-3.0.6/src/borg5.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg5.h	2003-11-24 20:27:22.000000000 -0800
@@ -0,0 +1,46 @@
+/* File: borg5.h */
+/* Purpose: Header file for "borg5.c" -BEN- */
+
+#ifndef INCLUDED_BORG5_H
+#define INCLUDED_BORG5_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg5.c".
+ */
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg6.h"
+
+
+/*
+ * Update state based on current "map"
+ */
+extern void borg_update(void);
+
+
+/*
+ * React to various "important" messages
+ */
+extern void borg_react(cptr msg, cptr buf);
+extern void borg_delete_kill(int i);
+extern void borg_delete_take(int i);
+
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_5(void);
+
+
+
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg6.c angband-3.0.6-borg/src/borg6.c
--- angband-3.0.6/src/borg6.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg6.c	2005-10-25 21:25:34.000000000 -0700
@@ -0,0 +1,17307 @@
+/* File: borg6.c */
+/* Purpose: Medium level stuff for the Borg -BEN- */
+
+#include "angband.h"
+
+#ifdef BORG_TK
+#include "tnb.h"
+#endif /* BORG_TK */
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg4.h"
+#include "borg5.h"
+#include "borg6.h"
+
+static bool borg_desperate = FALSE;
+
+
+/*
+ * This file is responsible for the low level dungeon goals.
+ *
+ * This includes calculating the danger from monsters, determining
+ * how and when to attack monsters, and calculating "flow" paths
+ * from place to place for various reasons.
+ *
+ * Notes:
+ *   We assume that invisible/offscreen monsters are dangerous
+ *   We consider physical attacks, missile attacks, spell attacks,
+ *     wand attacks, etc, as variations on a single theme.
+ *   We take account of monster resistances and susceptibilities
+ *   We try not to wake up sleeping monsters by throwing things
+ *
+ *
+ * Bugs:
+ */
+
+
+
+
+
+/*
+ * Given a "source" and "target" locations, extract a "direction",
+ * which will move one step from the "source" towards the "target".
+ *
+ * Note that we use "diagonal" motion whenever possible.
+ *
+ * We return "5" if no motion is needed.
+ */
+static int borg_extract_dir(int y1, int x1, int y2, int x2)
+{
+    /* No movement required */
+    if ((y1 == y2) && (x1 == x2)) return (5);
+
+    /* South or North */
+    if (x1 == x2) return ((y1 < y2) ? 2 : 8);
+
+    /* East or West */
+    if (y1 == y2) return ((x1 < x2) ? 6 : 4);
+
+    /* South-east or South-west */
+    if (y1 < y2) return ((x1 < x2) ? 3 : 1);
+
+    /* North-east or North-west */
+    if (y1 > y2) return ((x1 < x2) ? 9 : 7);
+
+    /* Paranoia */
+    return (5);
+}
+
+
+/*
+ * Given a "source" and "target" locations, extract a "direction",
+ * which will move one step from the "source" towards the "target".
+ *
+ * We prefer "non-diagonal" motion, which allows us to save the
+ * "diagonal" moves for avoiding pillars and other obstacles.
+ *
+ * If no "obvious" path is available, we use "borg_extract_dir()".
+ *
+ * We return "5" if no motion is needed.
+ */
+static int borg_goto_dir(int y1, int x1, int y2, int x2)
+{
+    int d, e;
+
+    int ay = (y2 > y1) ? (y2 - y1) : (y1 - y2);
+    int ax = (x2 > x1) ? (x2 - x1) : (x1 - x2);
+
+
+    /* Default direction */
+    e = borg_extract_dir(y1, x1, y2, x2);
+
+
+    /* Adjacent location, use default */
+    if ((ay <= 1) && (ay <= 1)) return (e);
+
+
+    /* Try south/north (primary) */
+    if (ay > ax)
+    {
+        d = (y1 < y2) ? 2 : 8;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+    }
+
+    /* Try east/west (primary) */
+    if (ay < ax)
+    {
+        d = (x1 < x2) ? 6 : 4;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+    }
+
+
+    /* Try diagonal */
+    d = borg_extract_dir(y1, x1, y2, x2);
+
+    /* Check for walls */
+    if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+
+
+    /* Try south/north (secondary) */
+    if (ay <= ax)
+    {
+        d = (y1 < y2) ? 2 : 8;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+    }
+
+    /* Try east/west (secondary) */
+    if (ay >= ax)
+    {
+        d = (x1 < x2) ? 6 : 4;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+    }
+
+
+    /* Circle obstacles */
+    if (!ay)
+    {
+        /* Circle to the south */
+        d = (x1 < x2) ? 3 : 1;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+
+        /* Circle to the north */
+        d = (x1 < x2) ? 9 : 7;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+    }
+
+    /* Circle obstacles */
+    if (!ax)
+    {
+        /* Circle to the east */
+        d = (y1 < y2) ? 3 : 9;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+
+        /* Circle to the west */
+        d = (y1 < y2) ? 1 : 7;
+        if (borg_cave_floor_bold(y1 + ddy[d], x1 + ddx[d])) return (d);
+    }
+
+
+    /* Oops */
+    return (e);
+}
+
+
+
+/*
+ * Clear the "flow" information
+ *
+ * This function was once a major bottleneck, so we now use several
+ * slightly bizarre, but highly optimized, memory copying methods.
+ */
+static void borg_flow_clear(void)
+{
+    /* Reset the "cost" fields */
+    COPY(borg_data_cost, borg_data_hard, borg_data);
+
+    /* Wipe costs and danger */
+    if (borg_danger_wipe)
+    {
+        /* Wipe the "know" flags */
+        WIPE(borg_data_know, borg_data);
+
+        /* Wipe the "icky" flags */
+        WIPE(borg_data_icky, borg_data);
+
+        /* Wipe complete */
+        borg_danger_wipe = FALSE;
+    }
+
+    /* Start over */
+    flow_head = 0;
+    flow_tail = 0;
+}
+
+
+
+
+/*
+ * Spread a "flow" from the "destination" grids outwards
+ *
+ * We fill in the "cost" field of every grid that the player can
+ * "reach" with the number of steps needed to reach that grid,
+ * if the grid is "reachable", and otherwise, with "255", which
+ * is the largest possible value that can be stored in a byte.
+ *
+ * Thus, certain grids which are actually "reachable" but only by
+ * a path which is at least 255 steps in length will thus appear
+ * to be "unreachable", but this is not a major concern.
+ *
+ * We use the "flow" array as a "circular queue", and thus we must
+ * be careful not to allow the "queue" to "overflow".  This could
+ * only happen with a large number of distinct destination points,
+ * each several units away from every other destination point, and
+ * in a dungeon with no walls and no dangerous monsters.  But this
+ * is technically possible, so we must check for it just in case.
+ *
+ * We do not need a "priority queue" because the cost from grid to
+ * grid is always "one" and we process them in order.  If we did
+ * use a priority queue, this function might become unusably slow,
+ * unless we reactivated the "room building" code.
+ *
+ * We handle both "walls" and "danger" by marking every grid which
+ * is "impassible", due to either walls, or danger, as "ICKY", and
+ * marking every grid which has been "checked" as "KNOW", allowing
+ * us to only check the wall/danger status of any grid once.  This
+ * provides some important optimization, since many "flows" can be
+ * done before the "ICKY" and "KNOW" flags must be reset.
+ *
+ * Note that the "borg_enqueue_grid()" function should refuse to
+ * enqueue "dangeous" destination grids, but does not need to set
+ * the "KNOW" or "ICKY" flags, since having a "cost" field of zero
+ * means that these grids will never be queued again.  In fact,
+ * the "borg_enqueue_grid()" function can be used to enqueue grids
+ * which are "walls", such as "doors" or "rubble".
+ *
+ * This function is extremely expensive, and is a major bottleneck
+ * in the code, due more to internal processing than to the use of
+ * the "borg_danger()" function, especially now that the use of the
+ * "borg_danger()" function has been optimized several times.
+ *
+ * The "optimize" flag allows this function to stop as soon as it
+ * finds any path which reaches the player, since in general we are
+ * looking for paths to destination grids which the player can take,
+ * and we can stop this function as soon as we find any usable path,
+ * since it will always be as short a path as possible.
+ *
+ * We queue the "children" in reverse order, to allow any "diagonal"
+ * neighbors to be processed first, since this may boost efficiency.
+ *
+ * Note that we should recalculate "danger", and reset all "flows"
+ * if we notice that a wall has disappeared, and if one appears, we
+ * must give it a maximal cost, and mark it as "icky", in case it
+ * was currently included in any flow.
+ *
+ * If a "depth" is given, then the flow will only be spread to that
+ * depth, note that the maximum legal value of "depth" is 250.
+ *
+ * "Avoid" flag means the borg will not move onto unknown grids,
+ * nor to Monster grids if borg_desperate or borg_lunal_mode are
+ * set.
+ *
+ */
+static void borg_flow_spread(int depth, bool optimize, bool avoid, bool tunneling)
+{
+    int i;
+    int n, o = 0;
+    int x1, y1;
+    int x, y;
+	int fear = 0;
+
+    /* Now process the queue */
+    while (flow_head != flow_tail)
+    {
+        /* Extract the next entry */
+        x1 = borg_flow_x[flow_tail];
+        y1 = borg_flow_y[flow_tail];
+
+        /* Circular queue -- dequeue the next entry */
+        if (++flow_tail == AUTO_FLOW_MAX) flow_tail = 0;
+
+
+        /* Cost (one per movement grid) */
+        n = borg_data_cost->data[y1][x1] + 1;
+
+        /* New depth */
+        if (n > o)
+        {
+            /* Optimize (if requested) */
+            if (optimize && (n > borg_data_cost->data[c_y][c_x])) break;
+
+            /* Limit depth */
+            if (n > depth) break;
+
+            /* Save */
+            o = n;
+        }
+
+        /* Queue the "children" */
+        for (i = 0; i < 8; i++)
+        {
+            int old_head;
+
+            borg_grid *ag;
+
+
+            /* Neighbor grid */
+            x = x1 + ddx_ddd[i];
+            y = y1 + ddy_ddd[i];
+
+
+            /* only on legal grids */
+            if (!in_bounds(y,x)) continue;
+
+            /* Skip "reached" grids */
+            if (borg_data_cost->data[y][x] <= n) continue;
+
+
+            /* Access the grid */
+            ag = &borg_grids[y][x];
+
+
+            /* Avoid "wall" grids (not doors) unless tunneling*/
+            if (!tunneling && ag->feat >= FEAT_SECRET) continue;
+
+            /* Avoid "perma-wall" grids */
+            if (ag->feat >= FEAT_PERM_EXTRA) continue;
+
+            /* Avoid unknown grids (if requested or retreating) */
+            if ((avoid || borg_desperate) && (ag->feat == FEAT_NONE)) continue;
+
+            /* Avoid Monsters if Desprerate */
+            if ((ag->kill) && (borg_desperate || borg_lunal_mode)) continue;
+
+            /* Avoid Traps if low level-- unless brave or scaryguy. */
+            if (ag->feat >= FEAT_TRAP_HEAD && ag->feat <= FEAT_TRAP_TAIL &&
+                avoidance <= borg_skill[BI_CURHP])
+           	{
+                /* Do not disarm when you could end up dead */
+                if (borg_skill[BI_CURHP] < 60) continue;
+
+                /* Do not disarm when clumsy */
+                if (borg_skill[BI_DIS] < 30 && borg_skill[BI_CLEVEL] < 20 ) continue;
+                if (borg_skill[BI_DIS] < 45 && borg_skill[BI_CLEVEL] < 10 ) continue;
+
+				/* NOTE:  Traps are tough to deal with as a low
+				 * level character.  If any modifications are made above,
+				 * then the same changes must be made to borg_flow_direct()
+				 * and borg_flow_interesting()
+				 */
+            }
+
+            /* Ignore "icky" grids */
+            if (borg_data_icky->data[y][x]) continue;
+
+
+            /* Analyze every grid once */
+            if (!borg_data_know->data[y][x])
+            {
+                int p;
+
+
+                /* Mark as known */
+                borg_data_know->data[y][x] = TRUE;
+
+                if (!borg_desperate && !borg_lunal_mode)
+                {
+                    /* Get the danger */
+                    p = borg_danger(y, x, 1, TRUE);
+
+					/* Increase bravery */
+					if (borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 5 / 10;
+					if (borg_skill[BI_MAXCLEVEL] != 50) fear = avoidance * 3 / 10;
+					if (scaryguy_on_level) fear = avoidance * 2;
+					if (unique_on_level && vault_on_level && borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 3;
+					if (scaryguy_on_level && borg_skill[BI_CLEVEL] <= 5) fear = avoidance * 3;
+					if (goal_ignoring) fear = avoidance * 5;
+					if (borg_t - borg_began > 5000) fear = avoidance * 25;
+					if (borg_skill[BI_FOOD] == 0) fear = avoidance * 100;
+
+					/* Normal in town */
+					if (borg_skill[BI_CLEVEL] == 0) fear = avoidance * 3/ 10;
+
+                    /* Dangerous grid */
+                    if (p > fear)
+                    {
+                        /* Mark as icky */
+                        borg_data_icky->data[y][x] = TRUE;
+
+                        /* Ignore this grid */
+                        continue;
+                    }
+                }
+            }
+
+
+            /* Save the flow cost */
+            borg_data_cost->data[y][x] = n;
+
+            /* Enqueue that entry */
+            borg_flow_x[flow_head] = x;
+            borg_flow_y[flow_head] = y;
+
+
+            /* Circular queue -- memorize head */
+            old_head = flow_head;
+
+            /* Circular queue -- insert with wrap */
+            if (++flow_head == AUTO_FLOW_MAX)
+                flow_head = 0;
+
+            /* Circular queue -- handle overflow (badly) */
+            if (flow_head == flow_tail)
+                flow_head = old_head;
+        }
+    }
+
+    /* Forget the flow info */
+    flow_head = flow_tail = 0;
+}
+
+
+
+/*
+ * Enqueue a fresh (legal) starting grid, if it is safe
+ */
+static void borg_flow_enqueue_grid(int y, int x)
+{
+    int old_head;
+	int fear;
+	int p;
+
+    /* Avoid icky grids */
+    if (borg_data_icky->data[y][x]) return;
+
+    /* Unknown */
+    if (!borg_data_know->data[y][x])
+    {
+        /* Mark as known */
+        borg_data_know->data[y][x] = TRUE;
+
+        /** Mark dangerous grids as icky **/
+
+        /* Get the danger */
+        p = borg_danger(y, x, 1, TRUE);
+
+		/* Increase bravery */
+		if (borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 5 / 10;
+		if (borg_skill[BI_MAXCLEVEL] != 50) fear = avoidance * 3 / 10;
+		if (scaryguy_on_level) fear = avoidance * 2;
+		if (unique_on_level && vault_on_level && borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 3;
+		if (scaryguy_on_level && borg_skill[BI_CLEVEL] <= 5) fear = avoidance * 3;
+		if (goal_ignoring) fear = avoidance * 5;
+		if (borg_t - borg_began > 5000) fear = avoidance * 25;
+		if (borg_skill[BI_FOOD] == 0) fear = avoidance * 100;
+
+		/* Normal in town */
+		if (borg_skill[BI_CLEVEL] == 0) fear = avoidance * 3/ 10;
+
+        /* Dangerous grid */
+        if ((p > fear) &&
+            !borg_desperate && !borg_lunal_mode)
+        {
+            /* Icky */
+            borg_data_icky->data[y][x] = TRUE;
+
+            /* Avoid */
+            return;
+        }
+    }
+
+
+    /* Only enqueue a grid once */
+    if (!borg_data_cost->data[y][x]) return;
+
+
+    /* Save the flow cost (zero) */
+    borg_data_cost->data[y][x] = 0;
+
+    /* Enqueue that entry */
+    borg_flow_y[flow_head] = y;
+    borg_flow_x[flow_head] = x;
+
+
+    /* Circular queue -- memorize head */
+    old_head = flow_head;
+
+    /* Circular queue -- insert with wrap */
+    if (++flow_head == AUTO_FLOW_MAX) flow_head = 0;
+
+    /* Circular queue -- handle overflow */
+    if (flow_head == flow_tail) flow_head = old_head;
+}
+
+
+
+/*
+ * Do a "reverse" flow from the player outwards
+ */
+static void borg_flow_reverse(void)
+{
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue the player's grid */
+    borg_flow_enqueue_grid(c_y, c_x);
+
+    /* Spread, but do NOT optimize */
+    borg_flow_spread(250, FALSE, FALSE, FALSE);
+}
+
+
+
+
+
+/*
+ * Attempt to induce "word of recall"
+ * artifact activations added throughout this code
+ */
+bool borg_recall(void)
+{
+
+
+    /* Multiple "recall" fails */
+    if (!goal_recalling)
+    {
+        /* Try to "recall" */
+        if (borg_zap_rod(SV_ROD_RECALL) ||
+            borg_activate_artifact(ACT_WOR, INVEN_WIELD) ||
+            borg_spell_fail(6, 3, 60) ||
+            borg_prayer_fail(4, 4, 60) ||
+            borg_read_scroll(SV_SCROLL_WORD_OF_RECALL))
+        {
+			/* Do reset depth at certain times. */
+			if (borg_skill[BI_CDEPTH] < borg_skill[BI_MAXDEPTH] &&
+			    borg_skill[BI_MAXDEPTH] >= 60 &&
+			    borg_skill[BI_CDEPTH] >= 40)
+		    {
+				/* Special check on deep levels */
+				if (borg_skill[BI_CDEPTH] >=96 && /* Deep */
+				    borg_race_death[546] != 0) /* Sauron is Dead */
+				{
+					/* Do Not Reset Depth.  He neeeds to be able to keep his depth
+					 * at 99 in order to make his final potion collection for
+					 * the fight with Morgoth
+					 */
+				}
+				else
+				{
+					/* Do reset Depth */
+					borg_note("# Resetting recall depth.");
+			    	borg_keypress('y');
+				}
+			}
+
+			/* reset recall depth in dungeon? */
+			else if (borg_skill[BI_CDEPTH] < borg_skill[BI_MAXDEPTH] &&
+				borg_skill[BI_CDEPTH] != 0)
+		    {
+				/* Do not reset Depth */
+				borg_note("# Not resetting recall depth.");
+			    borg_keypress('n');
+			}
+
+		    borg_keypress(ESCAPE);
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+    /* Nothing */
+    return (FALSE);
+}
+
+
+
+/*
+ * Prevent starvation by any means possible
+ */
+static bool borg_eat_food_any(void)
+{
+    int i;
+
+    /* Scan the inventory for "normal" food */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip unknown food */
+        if (!item->kind) continue;
+
+        /* Skip non-food */
+        if (item->tval != TV_FOOD) continue;
+
+        /* Skip "flavored" food */
+        if (item->sval < SV_FOOD_MIN_FOOD) continue;
+
+        /* Eat something of that type */
+        if (borg_eat_food(item->sval)) return (TRUE);
+    }
+
+    /* Scan the inventory for "okay" food */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip unknown food */
+        if (!item->kind) continue;
+
+        /* Skip non-food */
+        if (item->tval != TV_FOOD) continue;
+
+        /* Skip "icky" food */
+        if (item->sval < SV_FOOD_MIN_OKAY) continue;
+
+        /* Eat something of that type */
+        if (borg_eat_food(item->sval)) return (TRUE);
+    }
+
+    /* Scan the inventory for "potions" food */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip unknown food */
+        if (!item->kind) continue;
+
+        /* Skip non-food */
+        if (item->tval != TV_POTION) continue;
+
+        /* Consume in order, when hurting */
+        if ((borg_skill[BI_CURHP] < 4 ||
+             (borg_skill[BI_CURHP] <= borg_skill[BI_MAXHP])) &&
+            (borg_quaff_potion(SV_POTION_CURE_LIGHT) ||
+             borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+             borg_quaff_potion(SV_POTION_CURE_CRITICAL) ||
+             borg_quaff_potion(SV_POTION_RESTORE_MANA) ||
+             borg_quaff_potion(SV_POTION_HEALING) ||
+             borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+             borg_quaff_potion(SV_POTION_LIFE) ))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Nothing */
+    return (FALSE);
+}
+/*
+ * Hack -- evaluate the likelihood of the borg getting surrounded
+ * by a bunch of monsters.  This is called from borg_danger() when
+ * he looking for a strategic retreat.  It is hopeful that the borg
+ * will see that several monsters are approaching him and he may
+ * become surrouned then die.  This routine looks at near by monsters
+ * as determines the likelyhood of him getting surrouned.
+ */
+static bool borg_surrounded(void)
+{
+    borg_kill *kill;
+    monster_race *r_ptr;
+
+    int safe_grids = 8;
+    int non_safe_grids = 0;
+    int monsters = 0;
+    int adjacent_monsters = 0;
+
+    int x9, y9, ax, ay, d;
+    int i;
+
+    /* Evaluate the local monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        kill = &borg_kills[i];
+        r_ptr = &r_info[kill->r_idx];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        x9 = kill->x;
+        y9 = kill->y;
+
+        /* Distance components */
+        ax = (x9 > c_x) ? (x9 - c_x) : (c_x - x9);
+        ay = (y9 > c_y) ? (y9 - c_y) : (c_y - y9);
+
+        /* Distance */
+        d = MAX(ax, ay);
+
+        /* if the monster is too far then skip it. */
+        if (d > 3) continue;
+
+        /* if he cant see me then forget it.*/
+        if (!borg_los(c_y, c_x, y9, x9)) continue;
+
+        /* if asleep, don't consider this one */
+        if (!kill->awake) continue;
+
+        /* Monsters with Pass Wall are dangerous, no escape from them */
+        if (r_ptr->flags2 & RF2_PASS_WALL) continue;
+        if (r_ptr->flags2 & RF2_KILL_WALL) continue;
+
+        /* Monsters who never move cant surround */
+        if (r_ptr->flags1 & RF1_NEVER_MOVE) continue;
+
+        /* keep track of monsters touching me */
+        if (d == 1) adjacent_monsters ++;
+
+        /* Add them up. */
+        monsters ++;
+
+    }
+
+    /* Evaluate the Non Safe Grids, (walls, closed doors, traps, monsters) */
+    for (i = 0; i < 8; i++)
+    {
+        int x = c_x + ddx_ddd[i];
+        int y = c_y + ddy_ddd[i];
+
+        /* Access the grid */
+        borg_grid *ag = &borg_grids[y][x];
+
+        /* Skip walls/doors */
+        if (!borg_cave_floor_grid(ag)) non_safe_grids ++;
+
+        /* Skip unknown grids */
+        if (ag->feat == FEAT_NONE) non_safe_grids ++;
+
+        /* Skip monster grids */
+        if (ag->kill) non_safe_grids ++;
+
+        /* Mega-Hack -- skip stores XXX XXX XXX */
+        if ((ag->feat >= FEAT_SHOP_HEAD) && (ag->feat <= FEAT_SHOP_TAIL)) non_safe_grids ++;
+
+        /* Mega-Hack -- skip traps XXX XXX XXX */
+        if ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL)) non_safe_grids ++;
+
+    }
+
+    /* Safe grids are decreased */
+    safe_grids = safe_grids - non_safe_grids;
+
+    /* Am I in hallway? If so don't worry about it */
+    if (safe_grids == 1 && adjacent_monsters == 1) return (FALSE);
+
+    /* I am likely to get surrouned */
+    if (monsters > safe_grids)
+    {
+        borg_note(format("# Possibility of being surrounded (%d/%d)",
+        monsters, safe_grids));
+
+        /* The borg can get trapped by breeders by continueing to flee
+         * into a dead-end.  So he needs to be able to trump this
+         * routine.
+         */
+        if (goal_ignoring) return (FALSE);
+        else return (TRUE);
+    }
+
+    /* Probably will not be surrouned */
+    return (FALSE);
+}
+
+/*
+ * Mega-Hack -- evaluate the "freedom" of the given location
+ *
+ * The theory is that often, two grids will have equal "danger",
+ * but one will be "safer" than the other, perhaps because it
+ * is closer to stairs, or because it is in a corridor, or has
+ * some other characteristic that makes it "safer".
+ *
+ * Then, if the Borg is in danger, say, from a normal speed monster
+ * which is standing next to him, he will know that walking away from
+ * the monster is "pointless", because the monster will follow him,
+ * but if the resulting location is "safer" for some reason, then
+ * he will consider it.  This will allow him to flee towards stairs
+ * in the town, and perhaps towards corridors in the dungeon.
+ *
+ * This method is used in town to chase the stairs.
+ *
+ * XXX XXX XXX We should attempt to walk "around" buildings.
+ */
+static int borg_freedom(int y, int x)
+{
+    int d, f = 0;
+
+    /* Hack -- chase down stairs in town */
+    if (!borg_skill[BI_CDEPTH] && track_more_num)
+    {
+        /* Love the stairs! */
+        d = double_distance(y, x, track_more_y[0], track_more_x[0]);
+
+        /* Proximity is good */
+        f += (1000 - d);
+
+        /* Close proximity is great */
+        if (d < 4) f += (2000 - (d * 500));
+    }
+
+    /* Hack -- chase Up Stairs in dungeon */
+    if (borg_skill[BI_CDEPTH] && track_less_num)
+    {
+        /* Love the stairs! */
+        d = double_distance(y, x, track_less_y[0], track_less_x[0]);
+
+        /* Proximity is good */
+        f += (1000 - d);
+
+        /* Close proximity is great */
+        if (d < 4) f += (2000 - (d * 500));
+    }
+
+    /* Freedom */
+    return (f);
+}
+
+
+/*
+ * Check a floor grid for "happy" status
+ *
+ * These grids are floor grids which contain stairs, or which
+ * are non-corners in corridors, or which are directly adjacent
+ * to pillars, or grids which we have stepped on before.
+ *  Stairs are good because they can be used to leave
+ * the level.  Corridors are good because you can back into them
+ * to avoid groups of monsters and because they can be used for
+ * escaping.  Pillars are good because while standing next to a
+ * pillar, you can walk "around" it in two different directions,
+ * allowing you to retreat from a single normal monster forever.
+ * Stepped on grids are good because they likely stem from an area
+ * which has been cleared of monsters.
+ */
+static bool borg_happy_grid_bold(int y, int x)
+{
+    int i;
+
+    borg_grid *ag = &borg_grids[y][x];
+
+
+    /* Accept stairs */
+    if (ag->feat == FEAT_LESS) return (TRUE);
+    if (ag->feat == FEAT_MORE) return (TRUE);
+    if (ag->feat == FEAT_GLYPH) return (TRUE);
+
+    /* Hack -- weak/dark is very unhappy */
+    if (borg_skill[BI_ISWEAK] || borg_skill[BI_CURLITE] == 0) return (FALSE);
+
+    /* Apply a control effect so that he does not get stuck in a loop */
+    if ((borg_t - borg_began) >= 2000)  return (FALSE);
+
+    /* Case 1a: north-south corridor */
+    if (borg_cave_floor_bold(y-1, x) && borg_cave_floor_bold(y+1, x) &&
+        !borg_cave_floor_bold(y, x-1) && !borg_cave_floor_bold(y, x+1) &&
+        !borg_cave_floor_bold(y+1, x-1) && !borg_cave_floor_bold(y+1, x+1) &&
+        !borg_cave_floor_bold(y-1, x-1) && !borg_cave_floor_bold(y-1, x+1))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+    /* Case 1b: east-west corridor */
+    if (borg_cave_floor_bold(y, x-1) && borg_cave_floor_bold(y, x+1) &&
+        !borg_cave_floor_bold(y-1, x) && !borg_cave_floor_bold(y+1, x) &&
+        !borg_cave_floor_bold(y+1, x-1) && !borg_cave_floor_bold(y+1, x+1) &&
+        !borg_cave_floor_bold(y-1, x-1) && !borg_cave_floor_bold(y-1, x+1))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+    /* Case 1aa: north-south doorway */
+    if (borg_cave_floor_bold(y-1, x) && borg_cave_floor_bold(y+1, x) &&
+        !borg_cave_floor_bold(y, x-1) && !borg_cave_floor_bold(y, x+1))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+    /* Case 1ba: east-west doorway */
+    if (borg_cave_floor_bold(y, x-1) && borg_cave_floor_bold(y, x+1) &&
+        !borg_cave_floor_bold(y-1, x) && !borg_cave_floor_bold(y+1, x))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+
+    /* Case 2a: north pillar */
+    if (!borg_cave_floor_bold(y-1, x) &&
+        borg_cave_floor_bold(y-1, x-1) &&
+        borg_cave_floor_bold(y-1, x+1) &&
+        borg_cave_floor_bold(y-2, x))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+    /* Case 2b: south pillar */
+    if (!borg_cave_floor_bold(y+1, x) &&
+        borg_cave_floor_bold(y+1, x-1) &&
+        borg_cave_floor_bold(y+1, x+1) &&
+        borg_cave_floor_bold(y+2, x))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+    /* Case 2c: east pillar */
+    if (!borg_cave_floor_bold(y, x+1) &&
+        borg_cave_floor_bold(y-1, x+1) &&
+        borg_cave_floor_bold(y+1, x+1) &&
+        borg_cave_floor_bold(y, x+2))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+    /* Case 2d: west pillar */
+    if (!borg_cave_floor_bold(y, x-1) &&
+        borg_cave_floor_bold(y-1, x-1) &&
+        borg_cave_floor_bold(y+1, x-1) &&
+        borg_cave_floor_bold(y, x-2))
+    {
+        /* Happy */
+        return (TRUE);
+    }
+
+    /* check for grids that have been stepped on before */
+    for (i = 0; i < track_step_num; i++)
+    {
+        /* Enqueue the grid */
+        if ((track_step_y[i] == y) &&
+            (track_step_x[i] == x))
+        {
+            /* Recent step is good */
+            if (i < 25)
+            {
+                return (TRUE);
+            }
+        }
+     }
+
+    /* Not happy */
+    return (FALSE);
+}
+
+/* This will look down a hallway and possibly light it up using
+ * the Light Beam mage spell.  This spell is mostly used when
+ * the borg is moving through the dungeon under boosted bravery.
+ * This will allow him to "see" if anyone is there.
+ *
+ * It might also come in handy if he's in a hallway and gets shot, or
+ * if resting in a hallway.  He may want to cast it to make
+ * sure no previously unknown monsters are in the hall.
+ * NOTE:  ESP will alter the value of this spell.
+ *
+ * Borg has a problem when not on map centering mode and casting the beam
+ * repeatedly, down or up when at the edge of a panel.
+ */
+bool borg_lite_beam(bool simulation)
+{
+    int dir = 5;
+    bool spell_ok = FALSE;
+
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+    /* Hack -- weak/dark is very unhappy */
+    if (borg_skill[BI_ISWEAK] || borg_skill[BI_CURLITE] == 0) return (FALSE);
+
+    /* Apply a control effect so that he does not get stuck in a loop */
+    if ((borg_t - borg_began) >= 2000)  return (FALSE);
+
+    /* Require the abilitdy */
+    if (borg_spell_okay_fail(1,6, 20) ||
+        (-1 != borg_slot(TV_WAND, SV_WAND_LITE) &&
+             borg_items[borg_slot(TV_WAND, SV_WAND_LITE)].pval) ||
+        borg_equips_rod(SV_ROD_LITE))
+        spell_ok = TRUE;
+
+    /* North */
+    switch (borg_skill[BI_CURLITE])
+    {
+
+    /* Torch */
+    case 1:
+        ag = &borg_grids[c_y- (borg_skill[BI_CURLITE] +1)][c_x];
+        if (borg_cave_floor_bold(c_y - 1,c_x) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 8;
+            break;
+        }
+    /* Lantern */
+    case 2:
+        ag = &borg_grids[c_y- (borg_skill[BI_CURLITE] +1)][c_x];
+        if (borg_cave_floor_bold(c_y - 1,c_x) &&
+        borg_cave_floor_bold(c_y - 2,c_x) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 8;
+            break;
+        }
+    /* Artifact */
+    case 3:
+        ag = &borg_grids[c_y- (borg_skill[BI_CURLITE] +1)][c_x];
+
+        if (borg_cave_floor_bold(c_y - 1,c_x) &&
+        borg_cave_floor_bold(c_y - 2,c_x) &&
+        borg_cave_floor_bold(c_y - 3,c_x) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 8;
+            break;
+        }
+    }
+
+    /* South */
+    switch (borg_skill[BI_CURLITE])
+    {
+    case 1:
+        ag = &borg_grids[c_y + (borg_skill[BI_CURLITE] +1)][c_x];
+        if (borg_cave_floor_bold(c_y + 1,c_x) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 2;
+            break;
+        }
+    /* Lantern */
+    case 2:
+        ag = &borg_grids[c_y + (borg_skill[BI_CURLITE] +1)][c_x];
+        if (borg_cave_floor_bold(c_y + 1,c_x) &&
+        borg_cave_floor_bold(c_y + 2,c_x) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 2;
+            break;
+        }
+    /* Artifact */
+    case 3:
+        ag = &borg_grids[c_y + (borg_skill[BI_CURLITE] +1)][c_x];
+        if (borg_cave_floor_bold(c_y + 1,c_x) &&
+        borg_cave_floor_bold(c_y + 2,c_x) &&
+        borg_cave_floor_bold(c_y + 3,c_x) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 2;
+            break;
+        }
+    }
+
+    /* East */
+    switch (borg_skill[BI_CURLITE])
+    {
+    /* Torch */
+    case 1:
+        ag = &borg_grids[c_y][c_x+(borg_skill[BI_CURLITE] +1)];
+        if (borg_cave_floor_bold(c_y ,c_x +1) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 6;
+            break;
+        }
+    /* Lantern */
+    case 2:
+        ag = &borg_grids[c_y][c_x+(borg_skill[BI_CURLITE] +1)];
+        if (borg_cave_floor_bold(c_y ,c_x + 1) &&
+        borg_cave_floor_bold(c_y,c_x + 2) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 6;
+            break;
+        }
+    /* Artifact */
+    case 3:
+        ag = &borg_grids[c_y][c_x+(borg_skill[BI_CURLITE] +1)];
+        if (borg_cave_floor_bold(c_y ,c_x + 1) &&
+        borg_cave_floor_bold(c_y ,c_x + 2) &&
+        borg_cave_floor_bold(c_y ,c_x + 3) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 6;
+            break;
+        }
+    }
+
+    /* West */
+    switch (borg_skill[BI_CURLITE])
+    {
+    /* Torch */
+    case 1:
+        ag = &borg_grids[c_y][c_x-(borg_skill[BI_CURLITE] +1)];
+        if (borg_cave_floor_bold(c_y ,c_x -1) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 4;
+            break;
+        }
+    /* Lantern */
+    case 2:
+        ag = &borg_grids[c_y][c_x-(borg_skill[BI_CURLITE] +1)];
+        if (borg_cave_floor_bold(c_y ,c_x - 1) &&
+        borg_cave_floor_bold(c_y,c_x - 2) &&
+        !ag->feat == FEAT_FLOOR  && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 4;
+            break;
+        }
+    /* Artifact */
+    case 3:
+        ag = &borg_grids[c_y][c_x-(borg_skill[BI_CURLITE] +1)];
+        if (borg_cave_floor_bold(c_y ,c_x - 1) &&
+        borg_cave_floor_bold(c_y ,c_x - 2) &&
+        borg_cave_floor_bold(c_y ,c_x - 3) &&
+        !ag->feat == FEAT_FLOOR && ag->feat < FEAT_DOOR_HEAD)
+        {
+            /* note the direction */
+            dir = 4;
+            break;
+        }
+    }
+
+    /* Dont do it if: */
+    if (dir == 5 || spell_ok == FALSE ||
+       (dir == 2 && (c_y == 18 || c_y == 19  ||
+                     c_y == 29 || c_y == 30  ||
+                     c_y == 40 || c_y == 41  ||
+                     c_y == 51 || c_y == 52))||
+       (dir == 8 && (c_y == 13 || c_y == 14  ||
+                     c_y == 24 || c_y == 25  ||
+                     c_y == 35 || c_y == 36  ||
+                     c_y == 46 || c_y == 47)))
+       return (FALSE);
+
+    /* simulation */
+    if (simulation) return (TRUE);
+
+    /* cast the light beam */
+    if (borg_spell_fail(1,6, 20) ||
+         borg_zap_rod(SV_ROD_LITE) ||
+         borg_aim_wand(SV_WAND_LITE))
+        {   /* apply the direction */
+            borg_keypress(I2D(dir));
+            borg_note("# Illuminating this hallway");
+            return(TRUE);
+        }
+
+    /* cant do it */
+    return (FALSE);
+}
+
+/*
+ * Scan the monster lists for certain types of monster that we
+ * should be concerned over.
+ * This only works for monsters we know about.  If one of the
+ * monsters around is misidentified then it may be a unique
+ * and we wouldn't know.  Special consideration is given to Morgoth
+ */
+static void borg_near_monster_type(int dist)
+{
+    borg_kill *kill;
+    monster_race *r_ptr;
+
+    int x9, y9, ax, ay, d;
+    int i;
+
+    /* reset the borg flags */
+    borg_fighting_summoner = FALSE;
+    borg_fighting_unique = 0;
+    borg_fighting_evil_unique = FALSE;
+    borg_kills_summoner = -1;
+
+    /* Scan the monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        kill = &borg_kills[i];
+        r_ptr = &r_info[kill->r_idx];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+
+     	/*** Scan for Scary Guys ***/
+
+		/* Do ScaryGuys now, before distance checks.  We are
+		 * Looking for scary guys on level, not scary guys
+		 * near me
+		 */
+
+ 	    /* run from certain scaries */
+        if (borg_skill[BI_CLEVEL] <= 5 &&
+            (strstr(r_name + r_ptr->name, "Squint"))) scaryguy_on_level = TRUE;
+
+		/* Mage and priest are extra fearful */
+        if (borg_skill[BI_CLEVEL] <= 6 &&
+        	(borg_class == CLASS_MAGE ||
+        	 borg_class == CLASS_PRIEST) &&
+            (strstr(r_name + r_ptr->name, "Squint"))) scaryguy_on_level = TRUE;
+
+        /* run from certain dungeon scaries */
+        if (borg_skill[BI_CLEVEL] <= 5 &&
+            (strstr(r_name + r_ptr->name, "Grip") ||
+             strstr(r_name + r_ptr->name, "Fang") ||
+             strstr(r_name + r_ptr->name, "Small kobold"))) scaryguy_on_level = TRUE;
+
+        /* run from certain scaries */
+        if (borg_skill[BI_CLEVEL] <= 8 &&
+            (strstr(r_name + r_ptr->name, "Novice") ||
+             strstr(r_name + r_ptr->name, "Kobold") ||
+             strstr(r_name + r_ptr->name, "Kobold archer") ||
+             strstr(r_name + r_ptr->name, "Jackal") ||
+             strstr(r_name + r_ptr->name, "Shrieker") ||
+             strstr(r_name + r_ptr->name, "Farmer Maggot") ||
+             strstr(r_name + r_ptr->name, "Filthy street urchin") ||
+             strstr(r_name + r_ptr->name, "Battle-scarred veteran") ||
+             strstr(r_name + r_ptr->name, "Mean-looking mercenary"))) scaryguy_on_level = TRUE;
+
+        if (borg_skill[BI_CLEVEL] <= 15 &&
+            (strstr(r_name + r_ptr->name, "Giant white mouse") ||
+             strstr(r_name + r_ptr->name, "White worm mass") ||
+             strstr(r_name + r_ptr->name, "Green worm mass"))) scaryguy_on_level = TRUE;
+
+        if (borg_skill[BI_CLEVEL] <= 20 &&
+            (strstr(r_name + r_ptr->name, "Cave spider") ||
+             strstr(r_name + r_ptr->name, "Yellow worm mass") ||
+             strstr(r_name + r_ptr->name, "Pink naga") ||
+             strstr(r_name + r_ptr->name, "Giant pink frog") ||
+             strstr(r_name + r_ptr->name, "Radiation eye"))) scaryguy_on_level = TRUE;
+
+		if (borg_skill[BI_CLEVEL] < 45 &&
+		    (strstr(r_name + r_ptr->name, "Gravity") ||
+		     strstr(r_name + r_ptr->name, "Inertia") ||
+		     strstr(r_name + r_ptr->name, "Ancient") ||
+		     strstr(r_name + r_ptr->name, "Beorn") ||
+		     strstr(r_name + r_ptr->name, "Dread") /* Appear in Groups */)) scaryguy_on_level = TRUE;
+
+        /* Nether breath is bad */
+        if (!borg_skill[BI_SRNTHR] &&
+            (strstr(r_name + r_ptr->name, "Azriel") ||
+             strstr(r_name + r_ptr->name, "Dracolich")||
+             strstr(r_name + r_ptr->name, "Dracolisk"))) scaryguy_on_level = TRUE;
+
+        /* Blindness is really bad */
+        if ((!borg_skill[BI_SRBLIND]) &&
+            ((strstr(r_name + r_ptr->name, "Light hound") && !borg_skill[BI_SRLITE]) ||
+             (strstr(r_name + r_ptr->name, "Dark hound") && !borg_skill[BI_SRDARK]))) scaryguy_on_level = TRUE;
+
+        /* Chaos and Confusion are really bad */
+        if ((!borg_skill[BI_SRKAOS] && !borg_skill[BI_SRCONF]) &&
+            (strstr(r_name + r_ptr->name, "Chaos"))) scaryguy_on_level = TRUE;
+        if (!borg_skill[BI_SRCONF] &&
+            (strstr(r_name + r_ptr->name, "Pukelman") ||
+             strstr(r_name + r_ptr->name, "Nightmare"))) scaryguy_on_level = TRUE;
+
+
+		/* Poison is really Bad */
+        if (!borg_skill[BI_RPOIS] && /* Note the RPois not SRPois */
+            (strstr(r_name + r_ptr->name, "Drolem"))) scaryguy_on_level = TRUE;
+
+
+		/* Now do distance considerations */
+        x9 = kill->x;
+        y9 = kill->y;
+
+        /* Distance components */
+        ax = (x9 > c_x) ? (x9 - c_x) : (c_x - x9);
+        ay = (y9 > c_y) ? (y9 - c_y) : (c_y - y9);
+
+        /* Distance */
+        d = MAX(ax, ay);
+
+        /* if the guy is too far then skip it unless in town. */
+        if (d > dist && borg_skill[BI_CDEPTH]) continue;
+
+		/* Special check here for Searching since we are
+		 * already scanning the monster list
+		 */
+		if (borg_needs_searching)
+		{
+			if (d < 7) borg_needs_searching = FALSE;
+		}
+
+        /*** Scan for Uniques ***/
+
+        /* this is a unique. */
+        if ((r_ptr->flags1 & RF1_UNIQUE))
+        {
+            /* Set a flag for use with certain types of spells */
+            unique_on_level = kill->r_idx;
+
+            /* return 1 if not Morgy, +10 if it is Morgy or Sauron */
+            if (r_ptr->flags1 & RF1_QUESTOR)
+            {
+                /* keep a battle log */
+                if (!borg_fff) borg_log_battle(TRUE);
+
+                borg_fighting_unique  += 10;
+            }
+
+            /* regular unique */
+            borg_fighting_unique ++;
+
+            /* Note that fighting a Questor would result in a 11 value */
+            if (r_ptr->flags3 & RF3_EVIL) borg_fighting_evil_unique = TRUE;
+
+        }
+
+
+        /*** Scan for Summoners ***/
+
+        if ( (r_ptr->flags6 & RF6_S_KIN) ||
+         (r_ptr->flags6 & RF6_S_HI_DEMON) ||
+         (r_ptr->flags6 & RF6_S_MONSTER) ||
+         (r_ptr->flags6 & RF6_S_MONSTERS) ||
+         (r_ptr->flags6 & RF6_S_ANIMAL) ||
+         (r_ptr->flags6 & RF6_S_SPIDER) ||
+         (r_ptr->flags6 & RF6_S_HOUND) ||
+         (r_ptr->flags6 & RF6_S_HYDRA) ||
+         (r_ptr->flags6 & RF6_S_ANGEL) ||
+         (r_ptr->flags6 & RF6_S_DEMON) ||
+         (r_ptr->flags6 & RF6_S_UNDEAD) ||
+         (r_ptr->flags6 & RF6_S_DRAGON) ||
+         (r_ptr->flags6 & RF6_S_HI_UNDEAD) ||
+         (r_ptr->flags6 & RF6_S_WRAITH) ||
+         (r_ptr->flags6 & RF6_S_UNIQUE) )
+         {
+             /* mark the flag */
+             borg_fighting_summoner = TRUE;
+
+             /* recheck the distance to see if close
+              * and mark the index for as-corridor
+              */
+             if (d < 8)
+             {
+                 borg_kills_summoner = i;
+             }
+         }
+    }
+}
+
+/*
+ * Help determine if "phase door" seems like a good idea
+ */
+bool borg_caution_phase(int emergency, int turns)
+{
+    int n, k, i, d, x, y, p;
+
+    int dis = 10;
+    int min = dis / 2;
+
+    borg_grid *ag= &borg_grids[c_y][c_x];
+
+
+	/* must have the ability */
+	if (!borg_skill[BI_APHASE]) return (FALSE);
+
+    /* Simulate 100 attempts */
+    for (n = k = 0; k < 100; k++)
+    {
+        /* Pick a location */
+        for (i = 0; i < 100; i++)
+        {
+            /* Pick a (possibly illegal) location */
+            while (1)
+            {
+                y = rand_spread(c_y, dis);
+                x = rand_spread(c_x, dis);
+                d = distance(c_y, c_x, y, x);
+                if ((d >= min) && (d <= dis)) break;
+            }
+
+            /* Ignore illegal locations */
+            if ((y <= 0) || (y >= AUTO_MAX_Y - 1)) continue;
+            if ((x <= 0) || (x >= AUTO_MAX_X - 1)) continue;
+
+            /* Access */
+            ag = &borg_grids[y][x];
+
+            /* Skip unknown grids */
+            if (ag->feat == FEAT_NONE) continue;
+
+            /* Skip weird grids */
+            if (ag->feat == FEAT_INVIS) continue;
+
+            /* Skip walls */
+            if (!borg_cave_floor_bold(y, x)) continue;
+
+            /* Skip monsters */
+            if (ag->kill) continue;
+
+            /* Stop looking */
+            break;
+        }
+
+        /* If low level, unknown squares are scary */
+        if (ag->feat == FEAT_NONE && borg_skill[BI_MAXHP] < 30)
+        {
+            n++;
+            continue;
+        }
+
+        /* No location */
+        /* in the real code it would keep trying but here we should */
+        /* assume that there is unknown spots that you would be able */
+        /* to go but may be dangerious. */
+        if (i >= 100)
+        {
+            n++;
+            continue;
+        }
+
+        /* Examine */
+        p = borg_danger(y, x, turns, TRUE);
+
+        /* if *very* scary, do not allow jumps at all */
+        if (p > borg_skill[BI_CURHP]) n++;
+    }
+
+    /* Too much danger */
+    /* in an emergency try with extra danger allowed */
+    if  (n > emergency)
+    {
+        borg_note(format("# No Phase. scary squares: %d", n));
+        return (FALSE);
+    }
+    else
+        borg_note(format("# Safe to Phase. scary squares: %d", n));
+
+    /* Okay */
+    return (TRUE);
+}
+/*
+ * Help determine if "phase door" with Shoot N Scoot seems like
+ * a good idea.
+ * Good Idea on two levels:
+ * 1.  We are the right class, we got some good ranged weapons
+ * 2.  The possible landing grids are ok.
+ * Almost a copy of the borg_caution_phase above.
+ * The emergency is the number of dangerous grids out of 100
+ * that we tolerate.  If we have 80, then we accept the risk
+ * of landing on a grid that is 80% likely to be bad.  A low
+ * number, like 20, means that we are less like to risk the
+ * phase door and we require more of the possible grids to be
+ * safe.
+ *
+ * The pattern of ShootN'Scoot works like this:
+ * 1. Shoot monster that is far away.
+ * 2. Monsters walks closer and closer each turn
+ * 3. Borg shoots monster each step it takes as it approaches.
+ * 4. Monster gets within 1 grid of the borg.
+ * 5. Borg phases away.
+ * 6. Go back to #1
+ */
+bool borg_shoot_scoot_safe(int emergency, int turns)
+{
+    int n, k, i, d, x, y, p, u;
+
+	int b_p;
+
+ 	int dis = 10;
+
+ 	int min = dis / 2;
+
+	bool adjacent_monster = FALSE;
+
+    borg_grid *ag;
+	borg_kill *kill;
+    monster_race *r_ptr;
+
+	/* no need if high level in town */
+	if (borg_skill[BI_CLEVEL] >= 8 &&
+	    borg_skill[BI_CDEPTH] == 0) return (FALSE);
+
+	/* must have the ability */
+	if (!borg_skill[BI_APHASE]) return (FALSE);
+
+	/* Not if No Light */
+	if (!borg_skill[BI_CURLITE]) return (FALSE);
+
+	/* Cheat the floor grid */
+	/* Not if in a vault since it throws us out of the vault */
+	if (cave_info[c_y][c_x] & (CAVE_ICKY)) return (FALSE);
+
+	/*** Need Missiles or cheap spells ***/
+
+	/* Mage Priest */
+	if (borg_class == CLASS_MAGE ||
+		borg_class == CLASS_PRIEST)
+	{
+		/* Low mana */
+		if (borg_skill[BI_CLEVEL] >= 45 &&
+		    borg_skill[BI_CURSP] < 15) return (FALSE);
+
+		/* Low mana, low level, generally OK */
+		if (borg_skill[BI_CLEVEL] < 45 &&
+		    borg_skill[BI_CURSP] < 5) return (FALSE);
+	}
+	else /* Other classes need some missiles */
+	{
+		if (borg_skill[BI_AMISSILES] < 5 || borg_skill[BI_CLEVEL] >= 45) return (FALSE);
+	}
+
+	/* Current danger of my grid */
+	b_p = borg_danger(c_y, c_x, turns, TRUE);
+
+    /* scan the adjacent grids for an awake monster */
+    for (i = 0; i < 8; i++)
+    {
+        /* Grid in that direction */
+        x = c_x + ddx_ddd[i];
+        y = c_y + ddy_ddd[i];
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+        /* Obtain the monster */
+        kill = &borg_kills[ag->kill];
+ 		r_ptr = &r_info[kill->r_idx];
+
+		/* If a qualifying monster is adjacent to me. */
+		if ((ag->kill && kill->awake) &&
+		    !(r_ptr->flags1 & RF1_NEVER_MOVE) &&
+		    !(r_ptr->flags2 & RF2_PASS_WALL) &&
+		    !(r_ptr->flags2 & RF2_KILL_WALL) &&
+		     (kill->power >= borg_skill[BI_CLEVEL]))
+		{
+			/* Spell casters shoot at everything */
+			if (borg_spell_okay(0, 0))
+			{
+				adjacent_monster = TRUE;
+			}
+			else if (borg_prayer_okay(2, 1))
+			{
+				adjacent_monster = TRUE;
+			}
+
+			/* All other borgs need to make sure he would shoot.
+			 * In an effort to conserve missiles, the borg will
+			 * not shoot at certain types of monsters.  That list
+			 * is defined in borg_launch_damage_one().
+			 *
+			 * We need this aforementioned list to match the one
+			 * following.  Otherwise Rogues and Warriors will
+			 * burn up Phases as he scoots away but never fire
+			 * the missiles.  That totally defeats the purpose
+			 * of this routine.
+			 *
+			 * The following criteria are exactly the same as the
+			 * list in borg_launch_damage_one()
+			 */
+    		else if ((borg_danger_aux(kill->y,kill->x,1,i, TRUE) >= avoidance * 3/10) ||
+    		    (r_ptr->flags1 & RF1_FRIENDS /* monster has friends*/ &&
+        	 	 kill->level >= borg_skill[BI_CLEVEL] - 5 /* close levels */) ||
+        		(kill->ranged_attack /* monster has a ranged attack */) ||
+        		(r_ptr->flags1 & RF1_UNIQUE) ||
+        		(r_ptr->flags2 & RF2_MULTIPLY) ||
+        		(borg_skill[BI_CLEVEL] <= 5 /* stil very weak */))
+			{
+				adjacent_monster = TRUE;
+			}
+		}
+	}
+
+	/* if No Adjacent_monster no need for it */
+	if (adjacent_monster == FALSE) return (FALSE);
+
+    /* Simulate 100 attempts */
+    for (n = k = 0; k < 100; k++)
+    {
+        /* Pick a location */
+        for (i = 0; i < 100; i++)
+        {
+            /* Pick a (possibly illegal) location */
+            while (1)
+            {
+                y = rand_spread(c_y, dis);
+                x = rand_spread(c_x, dis);
+                d = distance(c_y, c_x, y, x);
+                if ((d >= min) && (d <= dis)) break;
+            }
+
+            /* Ignore illegal locations */
+            if ((y <= 0) || (y >= AUTO_MAX_Y - 2)) continue;
+            if ((x <= 0) || (x >= AUTO_MAX_X - 2)) continue;
+
+            /* Access */
+            ag = &borg_grids[y][x];
+
+            /* Skip unknown grids */
+            if (ag->feat == FEAT_NONE) continue;
+
+            /* Skip weird grids */
+            if (ag->feat == FEAT_INVIS) continue;
+
+            /* Skip walls */
+            if (!borg_cave_floor_bold(y, x)) continue;
+
+            /* Skip monsters */
+            if (ag->kill) continue;
+
+
+            /* Stop looking.  Really, the game would keep
+             * looking for a grid.  The borg could check
+             * all the known grids but I dont think that
+             * is not a good idea, especially if the area is
+             * not fully explored.
+             */
+            break;
+        }
+
+        /* No location */
+        /* In the real code it would keep trying but here we should */
+        /* assume that there is unknown spots that you would be able */
+        /* to go but we define it as dangerous. */
+        if (i >= 100)
+        {
+            n++;
+            continue;
+        }
+
+        /* Examine danger of that grid */
+        p = borg_danger(y, x, turns, TRUE);
+
+        /* if more scary than my current one, do not allow jumps at all */
+        if (p > b_p)
+        {
+			n++;
+			continue;
+		}
+
+		/* Should not land next to a monster either.
+	     * Scan the adjacent grids for a monster.
+	     * Reuse the adjacent_monster variable.
+	     */
+	    for (u = 0; u < 8; u++)
+	    {
+	        /* Access the grid */
+	        ag = &borg_grids[y+ddy_ddd[u]][x+ddx_ddd[u]];
+
+	        /* Obtain the monster */
+	        kill = &borg_kills[ag->kill];
+
+			/* If monster adjacent to that grid...
+			 */
+			if (ag->kill && kill->awake) n++;
+		}
+
+    }
+
+    /* Too much danger */
+    /* in an emergency try with extra danger allowed */
+    if  (n > emergency)
+    {
+        borg_note(format("# No Shoot'N'Scoot. scary squares: %d/100", n));
+        return (FALSE);
+    }
+    else
+        borg_note(format("# Safe to Shoot'N'Scoot. scary squares: %d/100", n));
+
+    /* Okay */
+    return (TRUE);
+}
+/*
+ * Help determine if "Teleport" seems like a good idea
+ */
+bool borg_caution_teleport(int emergency, int turns)
+{
+    int n, k, i, d, x, y, p;
+
+    int dis = 100;
+    int min = dis / 2;
+    int q_x, q_y;
+
+
+    borg_grid *ag= &borg_grids[c_y][c_x];
+
+    /* Extract panel */
+    q_x = w_x / PANEL_WID;
+    q_y = w_y / PANEL_HGT;
+
+	/* must have the ability */
+	if (!borg_skill[BI_ATELEPORT]) return (FALSE);
+
+    /* Simulate 100 attempts */
+    for (n = k = 0; k < 100; k++)
+    {
+        /* Pick a location */
+        for (i = 0; i < 100; i++)
+        {
+            /* Pick a (possibly illegal) location */
+            while (1)
+            {
+                y = rand_spread(c_y, dis);
+                x = rand_spread(c_x, dis);
+                d = distance(c_y, c_x, y, x);
+                if ((d >= min) && (d <= dis)) break;
+            }
+
+            /* Ignore illegal locations */
+            if ((y <= 0) || (y >= AUTO_MAX_Y - 1)) continue;
+            if ((x <= 0) || (x >= AUTO_MAX_X - 1)) continue;
+
+            /* Access */
+            ag = &borg_grids[y][x];
+
+			/* Skip unknown grids if explored, or been on level for a while, otherwise, consider ok*/
+            if (ag->feat == FEAT_NONE &&
+                ((borg_detect_wall[q_y+0][q_x+0] == TRUE &&
+        		  borg_detect_wall[q_y+0][q_x+1] == TRUE &&
+        		  borg_detect_wall[q_y+1][q_x+0] == TRUE &&
+        		  borg_detect_wall[q_y+1][q_x+1] == TRUE) ||
+        		 borg_t > 2000)) continue;
+
+            /* Skip weird grids */
+            if (ag->feat == FEAT_INVIS) continue;
+
+            /* Skip walls */
+            if (!borg_cave_floor_bold(y, x)) continue;
+
+            /* Skip monsters */
+            if (ag->kill) continue;
+
+            /* Stop looking */
+            break;
+        }
+
+        /* If low level, unknown squares are scary */
+        if (ag->feat == FEAT_NONE && borg_skill[BI_MAXHP] < 30)
+        {
+            n++;
+            continue;
+        }
+
+        /* No location */
+        /* in the real code it would keep trying but here we should */
+        /* assume that there is unknown spots that you would be able */
+        /* to go but may be dangerious. */
+        if (i >= 100)
+        {
+            n++;
+            continue;
+        }
+
+        /* Examine */
+        p = borg_danger(y, x, turns, TRUE);
+
+        /* if *very* scary, do not allow jumps at all */
+        if (p > borg_skill[BI_CURHP]) n++;
+    }
+
+    /* Too much danger */
+    /* in an emergency try with extra danger allowed */
+    if  (n > emergency)
+    {
+        borg_note(format("# No Teleport. scary squares: %d", n));
+        return (FALSE);
+    }
+    /* Okay */
+    return (TRUE);
+}
+
+/*
+ * Try to phase door or teleport
+ * b_q is the danger of the least dangerious square around us.
+ */
+bool borg_escape(int b_q)
+{
+
+    int risky_boost = 0;
+	int j;
+	int glyphs = 0;
+
+	borg_grid *ag;
+
+    /* only escape with spell if fail is low */
+    int allow_fail = 25;
+    int sv_mana;
+
+    /* if very healthy, allow extra fail */
+    if (((borg_skill[BI_CURHP]*100)/borg_skill[BI_MAXHP]) > 70)
+         allow_fail = 10;
+
+    /* comprimised, get out of the fight */
+    if (borg_skill[BI_ISHEAVYSTUN])
+        allow_fail = 35;
+
+    /* for emergencies */
+    sv_mana = borg_skill[BI_CURSP];
+
+    /* Borgs who are bleeding to death or dying of poison may sometimes
+     * phase around the last two hit points right before they enter a
+     * shop.  He knows to make a bee-line for the temple but the danger
+     * trips this routine.  So we must bypass this routine for some
+     * particular circumstances.
+     */
+    if (!borg_skill[BI_CDEPTH] && (borg_skill[BI_ISPOISONED] || borg_skill[BI_ISWEAK] || borg_skill[BI_ISCUT])) return (FALSE);
+
+	/* Borgs who are in a sea of runes or trying to build one
+	 * and mostly healthy stay put
+	 */
+	if ((borg_skill[BI_CDEPTH] == 100) &&
+	    borg_skill[BI_CURHP] >= (borg_skill[BI_MAXHP]  * 5 / 10))
+	{
+		/* In a sea of runes */
+		if (borg_morgoth_position)
+	   		return (FALSE);
+
+	    /* Scan neighbors */
+	    for (j = 0; j < 8; j++)
+	    {
+	        int y = c_y + ddy_ddd[j];
+	        int x = c_x + ddx_ddd[j];
+
+	        /* Get the grid */
+	        ag = &borg_grids[y][x];
+
+	        /* Skip unknown grids (important) */
+	        if (ag->feat == FEAT_GLYPH) glyphs++;
+		}
+	   	/* Touching at least 3 glyphs */
+		if (glyphs >= 3) return (FALSE);
+	}
+
+	/* Hack -- If the borg is weak (no food, starving) on depth 1 and he has no idea where the stairs
+	 * may be, run the risk of diving deeper against the benefit of rising to town.
+	 */
+	if (borg_skill[BI_ISWEAK] && borg_skill[BI_CDEPTH] == 1)
+	{
+		if (borg_read_scroll(SV_SCROLL_TELEPORT_LEVEL))
+		{
+			borg_note("# Attempting to get to town immediately");
+			return (TRUE);
+		}
+	}
+
+	/* Hack -- If the borg is standing on a stair and is in some danger, just leave the level.
+	 * No need to hang around on that level, try conserving the teleport scrolls
+	 */
+    /* Take stairs up */
+    if (b_q >= avoidance && borg_skill[BI_CLEVEL] <= 49)
+    {
+        /* Current grid */
+        borg_grid *ag = &borg_grids[c_y][c_x];
+
+        /* Usable stairs */
+        if (ag->feat == FEAT_LESS)
+        {
+            if ((borg_skill[BI_MAXDEPTH] - 4) > borg_skill[BI_CDEPTH] && borg_skill[BI_MAXCLEVEL] >= 35)
+            {
+                borg_note("scumming");
+                auto_scum = TRUE;
+            }
+
+			/* Log it */
+			borg_note(format("# In a little tiny danger (%d), leaving level.",b_q));
+
+            /* Take the stairs */
+            if (dungeon_stair) borg_on_dnstairs = TRUE;
+            borg_keypress('<');
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+    /* Risky borgs are more likely to stay in a fight */
+    if (borg_plays_risky) risky_boost = 3;
+
+    /* 1. really scary, I'm about to die */
+    /* Try an emergency teleport, or phase door as last resort */
+    if ( borg_skill[BI_ISHEAVYSTUN] ||
+         (b_q >= avoidance * (45+risky_boost)/10) ||
+         ((b_q >= avoidance * (40+risky_boost)/10) && borg_fighting_unique >=10 && borg_skill[BI_CDEPTH] == 100 && borg_skill[BI_CURHP] < 600) ||
+         ((b_q >= avoidance * (30+risky_boost)/10) && borg_fighting_unique >=10 && borg_skill[BI_CDEPTH] == 99  && borg_skill[BI_CURHP] < 600) ||
+         ((b_q >= avoidance * (25+risky_boost)/10) && borg_fighting_unique >=1  && borg_fighting_unique <=8 && borg_skill[BI_CDEPTH] >= 95 && borg_skill[BI_CURHP] < 550)  ||
+         ((b_q >= avoidance * (17+risky_boost)/10) && borg_fighting_unique >=1  && borg_fighting_unique <=8 && borg_skill[BI_CDEPTH] < 95)  ||
+         ((b_q >= avoidance * (15+risky_boost)/10) && !borg_fighting_unique) )
+    {
+
+        int allow_fail = 11;
+
+        if (borg_spell_fail(1, 5, allow_fail-10) ||
+            borg_prayer_fail(1, 1, allow_fail-10) ||
+            borg_prayer_fail(4, 1, allow_fail-10) ||
+            borg_read_scroll(SV_SCROLL_TELEPORT) ||
+            borg_read_scroll(SV_SCROLL_TELEPORT_LEVEL) ||
+            borg_use_staff_fail(SV_STAFF_TELEPORTATION) ||
+            borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+            /* revisit spells, increased fail rate */
+            borg_spell_fail(1, 5, allow_fail + 9) ||
+            borg_prayer_fail(1, 1, allow_fail + 9) ||
+            borg_prayer_fail(4, 1, allow_fail + 9) ||
+            /* revisit teleport, increased fail rate */
+            borg_use_staff(SV_STAFF_TELEPORTATION) ||
+            /* Attempt Teleport Level */
+            borg_spell_fail(6, 2, allow_fail + 9) ||
+            borg_prayer_fail(4, 3, allow_fail + 9) ||
+            /* try phase at least */
+            (borg_caution_phase(50, 2) &&
+             (borg_read_scroll(SV_SCROLL_PHASE_DOOR) ||
+              borg_activate_artifact(ACT_PHASE,INVEN_BODY)||
+              borg_spell_fail(0, 2, allow_fail)  ||
+              borg_prayer_fail(4, 0, allow_fail))))
+        {
+            /* Flee! */
+           borg_note("# Danger Level 1.");
+           return (TRUE);
+        }
+
+        borg_skill[BI_CURSP] = borg_skill[BI_MAXSP];
+
+        /* try to teleport, get far away from here */
+        if (borg_skill[BI_CDEPTH] &&
+            (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] * 1 / 10)
+ 			 && (borg_prayer(1, 1) ||
+             borg_prayer(4, 1) ||
+             borg_spell(1, 5)))
+		{
+            /* verify use of spell */
+            /* borg_keypress('y');  */
+
+            /* Flee! */
+            borg_note("# Danger Level 1.1  Critical Attempt");
+            return (TRUE);
+        }
+
+        /* emergency phase spell */
+        if (borg_skill[BI_CDEPTH] &&
+            (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] * 1 / 10)
+            &&
+            (borg_activate_artifact(ACT_PHASE,INVEN_BODY) ||
+             (borg_caution_phase(80, 5) &&
+             (borg_read_scroll(SV_SCROLL_PHASE_DOOR)))))
+        {
+            /* Flee! */
+            borg_escapes--; /* a phase isn't really an escape */
+            borg_note("# Danger Level 1.2  Critical Phase");
+            return (TRUE);
+        }
+
+        /* emergency phase spell */
+        if (borg_skill[BI_CDEPTH] &&
+            (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] * 1 / 10)
+            &&
+            (borg_caution_phase(80, 5) && (borg_spell_fail(0, 2, 15)  ||
+             borg_prayer(4, 0))))
+ 		{
+            /* verify use of spell */
+            /* borg_keypress('y'); */
+
+            /* Flee! */
+            borg_note("# Danger Level 1.3  Critical Attempt");
+            return (TRUE);
+        }
+
+        /* Restore the real mana level */
+        borg_skill[BI_CURSP] = sv_mana;
+    }
+
+    /* If fighting a unique and at the end of the game try to stay and
+     * finish the fight.  Only bail out in extreme danger as above.
+     */
+     if (b_q < avoidance * (25+risky_boost)/10 &&
+         borg_fighting_unique >=1 &&
+         borg_fighting_unique <=3 &&
+         borg_skill[BI_CDEPTH] >= 97) return (FALSE);
+
+
+    /* 2 - a bit more scary/
+     * Attempt to teleport (usually)
+     * do not escape from uniques so quick
+     */
+    if ( borg_skill[BI_ISHEAVYSTUN] ||
+    	 ((b_q >= avoidance *  (3+risky_boost)/10) && borg_class == CLASS_MAGE && borg_skill[BI_CURSP] <= 20 && borg_skill[BI_MAXCLEVEL] >= 45) ||
+         ((b_q >= avoidance * (15+risky_boost)/10) && borg_fighting_unique >=1 && borg_fighting_unique <= 8 && borg_skill[BI_CDEPTH] != 99) ||
+         ((b_q >= avoidance * (13+risky_boost)/10) && !borg_fighting_unique) )
+    {
+
+        /* Try teleportation */
+        if ( borg_spell_fail(1, 5, allow_fail -10 ) ||
+             borg_prayer_fail(4, 1, allow_fail- 10) ||
+             borg_prayer_fail(1, 1, allow_fail - 10) ||
+             borg_use_staff_fail(SV_STAFF_TELEPORTATION) ||
+             borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+             borg_read_scroll(SV_SCROLL_TELEPORT) ||
+			 borg_read_scroll(SV_SCROLL_TELEPORT_LEVEL) ||
+             borg_spell_fail(1, 5, allow_fail) ||
+             borg_prayer_fail(4, 1, allow_fail) ||
+             borg_prayer_fail(1, 1, allow_fail) ||
+             borg_use_staff(SV_STAFF_TELEPORTATION))
+        {
+            /* Flee! */
+            borg_note("# Danger Level 2.1");
+
+            /* Success */
+            return (TRUE);
+        }
+        /* Phase door, if useful */
+        if (borg_caution_phase(50, 2) &&
+            (borg_spell(0, 2) ||
+             borg_prayer(4, 0) ||
+             borg_read_scroll(SV_SCROLL_PHASE_DOOR) ||
+             borg_activate_artifact(ACT_PHASE,INVEN_BODY)||
+             borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ))
+        {
+            /* Flee! */
+            borg_note("# Danger Level 2.2");
+            /* Success */
+            return (TRUE);
+        }
+
+    }
+
+    /* 3- not too bad */
+    /* also run if stunned or it is scary here */
+    if ( borg_skill[BI_ISHEAVYSTUN] ||
+         ((b_q >= avoidance * (13+risky_boost)/10) && borg_fighting_unique >=2 && borg_fighting_unique <= 8) ||
+         ((b_q >= avoidance * (10+risky_boost)/10) && !borg_fighting_unique) ||
+         ((b_q >= avoidance * (10+risky_boost)/10) && borg_skill[BI_ISAFRAID] && (borg_skill[BI_AMISSILES] <=0 &&
+           borg_class == CLASS_WARRIOR) ))
+    {
+        /* Phase door, if useful */
+        if (borg_caution_phase(25, 2) &&
+             (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail) ||
+              borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+              borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+              borg_read_scroll(SV_SCROLL_PHASE_DOOR)))
+        {
+            /* Flee! */
+            borg_escapes--; /* a phase isn't really an escape */
+            borg_note("# Danger Level 3.1");
+
+            /* Success */
+            return (TRUE);
+        }
+
+        /* Teleport via spell */
+        if ( borg_spell_fail(1, 5, allow_fail) ||
+             borg_prayer_fail(1, 1, allow_fail) ||
+             borg_prayer_fail(4, 1, allow_fail) ||
+             borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+             borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+             borg_use_staff_fail(SV_STAFF_TELEPORTATION) ||
+             borg_read_scroll(SV_SCROLL_TELEPORT))
+        {
+            /* Flee! */
+            borg_note("# Danger Level 3.2");
+
+            /* Success */
+            return (TRUE);
+        }
+        /* Phase door, if useful */
+        if (borg_caution_phase(65, 2) &&
+             (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail) ||
+              borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+              borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+              borg_read_scroll(SV_SCROLL_PHASE_DOOR)))
+        {
+            /* Flee! */
+            borg_escapes--; /* a phase isn't really an escape */
+            borg_note("# Danger Level 3.3");
+
+            /* Success */
+            return (TRUE);
+        }
+
+		/* Use Tport Level after the above attempts failed. */
+		if (borg_read_scroll(SV_SCROLL_TELEPORT_LEVEL))
+		{
+            /* Flee! */
+            borg_note("# Danger Level 3.4");
+
+            /* Success */
+            return (TRUE);
+        }
+
+        /* if we got this far we tried to escape but couldn't... */
+        /* time to flee */
+        if (!goal_fleeing && (!borg_fighting_unique || borg_skill[BI_CLEVEL] < 35) && !vault_on_level)
+        {
+            /* Note */
+            borg_note("# Fleeing (failed to teleport)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+
+        /* Flee now */
+        if (!goal_leaving && (!borg_fighting_unique || borg_skill[BI_CLEVEL] < 35) && !vault_on_level)
+        {
+            /* Flee! */
+            borg_note("# Leaving (failed to teleport)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+
+    }
+    /* 4- not too scary but I'm comprimized */
+    if ( (b_q >= avoidance * (8+risky_boost)/10 &&
+          (borg_skill[BI_CLEVEL] < 35 || borg_skill[BI_CURHP] <= borg_skill[BI_MAXHP] / 3)) ||
+         ((b_q >= avoidance * (9+risky_boost)/10) && borg_fighting_unique >=1 && borg_fighting_unique <= 8 &&
+           (borg_skill[BI_CLEVEL] < 35 || borg_skill[BI_CURHP] <= borg_skill[BI_MAXHP] /3 )) ||
+         ((b_q >= avoidance * (6+risky_boost)/10) && borg_skill[BI_CLEVEL] <= 20 && !borg_fighting_unique) ||
+         ((b_q >= avoidance * (6+risky_boost)/10) && borg_class == CLASS_MAGE && borg_skill[BI_CLEVEL] <= 35))
+    {
+        /* Phase door, if useful */
+        if (borg_caution_phase(20, 2) &&
+             (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail) ||
+              borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+              borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+              borg_read_scroll(SV_SCROLL_PHASE_DOOR) ))
+        {
+            /* Flee! */
+            borg_escapes--; /* a phase isn't really an escape */
+            borg_note("# Danger Level 4.1");
+            /* Success */
+            return (TRUE);
+        }
+
+        /* Teleport via spell */
+        if ( borg_spell_fail(1, 5, allow_fail) ||
+             borg_prayer_fail(1, 1, allow_fail) ||
+             borg_prayer_fail(4, 1, allow_fail) ||
+             borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+             borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+             borg_read_scroll(SV_SCROLL_TELEPORT) ||
+             borg_use_staff_fail(SV_STAFF_TELEPORTATION) )
+        {
+            /* Flee! */
+            borg_note("# Danger Level 4.2");
+
+            /* Success */
+            return (TRUE);
+        }
+
+        /* if we got this far we tried to escape but couldn't... */
+        /* time to flee */
+        if (!goal_fleeing && !borg_fighting_unique && borg_skill[BI_CLEVEL] < 25 && !vault_on_level)
+        {
+            /* Note */
+            borg_note("# Fleeing (failed to teleport)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+
+        /* Flee now */
+        if (!goal_leaving && !borg_fighting_unique && !vault_on_level)
+        {
+            /* Flee! */
+            borg_note("# Leaving (failed to teleport)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+        /* Emergency Phase door if a weak mage */
+        if ((borg_class == CLASS_MAGE && borg_skill[BI_CLEVEL] <=35 ) &&
+            borg_caution_phase(65, 2) &&
+             (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail) ||
+              borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+              borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+              borg_read_scroll(SV_SCROLL_PHASE_DOOR) ))
+        {
+            /* Flee! */
+            borg_escapes--; /* a phase isn't really an escape */
+            borg_note("# Danger Level 4.3");
+            /* Success */
+            return (TRUE);
+        }
+
+    }
+
+    /* 5- not too scary but I'm very low level  */
+    if ( borg_skill[BI_CLEVEL] < 10 &&
+         (b_q >= avoidance * (5+risky_boost) /10  ||
+         (b_q >= avoidance * (7+risky_boost)/10 && borg_fighting_unique >=1 && borg_fighting_unique <= 8)))
+    {
+        /* Phase door, if useful */
+        if (borg_caution_phase(20,2) &&
+             (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail) ||
+              borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+              borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+              borg_read_scroll(SV_SCROLL_PHASE_DOOR) ))
+        {
+            /* Flee! */
+            borg_note("# Danger Level 5.1");
+            /* Success */
+            return (TRUE);
+        }
+
+        /* Teleport via spell */
+        if ( borg_spell_fail(1, 5, allow_fail) ||
+             borg_prayer_fail(1, 1, allow_fail) ||
+             borg_prayer_fail(4, 1, allow_fail) ||
+             borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+             borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+             borg_read_scroll(SV_SCROLL_TELEPORT) ||
+             borg_use_staff_fail(SV_STAFF_TELEPORTATION) )
+        {
+            /* Flee! */
+            borg_note("# Danger Level 5.2");
+
+            /* Success */
+            return (TRUE);
+        }
+
+        /* if we got this far we tried to escape but couldn't... */
+        /* time to flee */
+        if (!goal_fleeing && !borg_fighting_unique)
+        {
+            /* Note */
+            borg_note("# Fleeing (failed to teleport)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+
+        /* Flee now */
+        if (!goal_leaving && !borg_fighting_unique)
+        {
+            /* Flee! */
+            borg_note("# Leaving (failed to teleport)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+        /* Emergency Phase door if a weak mage */
+        if ((borg_class == CLASS_MAGE && borg_skill[BI_CLEVEL] <=8 ) &&
+            borg_caution_phase(65, 2) &&
+             (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail) ||
+              borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+              borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+              borg_read_scroll(SV_SCROLL_PHASE_DOOR) ))
+        {
+            /* Flee! */
+            borg_escapes--; /* a phase isn't really an escape */
+            borg_note("# Danger Level 5.3");
+            /* Success */
+            return (TRUE);
+        }
+
+    }
+
+    /* 6- not too scary but I'm out of mana  */
+    if ( (borg_class == CLASS_MAGE || borg_class == CLASS_PRIEST) &&
+         (b_q >= avoidance * (6+risky_boost) /10  ||
+          (b_q >= avoidance * (8+risky_boost)/10 && borg_fighting_unique >=1 && borg_fighting_unique <= 8)) &&
+         (borg_skill[BI_CURSP] <= (borg_skill[BI_MAXSP] * 1 / 10) && borg_skill[BI_MAXSP] >= 100))
+    {
+        /* Phase door, if useful */
+        if (borg_caution_phase(20,2) &&
+             (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail) ||
+              borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+              borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+              borg_read_scroll(SV_SCROLL_PHASE_DOOR) ))
+        {
+            /* Flee! */
+            borg_note("# Danger Level 6.1");
+            /* Success */
+            return (TRUE);
+        }
+
+        /* Teleport via spell */
+        if ( borg_spell_fail(1, 5, allow_fail) ||
+             borg_prayer_fail(1, 1, allow_fail) ||
+             borg_prayer_fail(4, 1, allow_fail) ||
+             borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+             borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+             borg_read_scroll(SV_SCROLL_TELEPORT) ||
+             borg_use_staff_fail(SV_STAFF_TELEPORTATION) )
+        {
+            /* Flee! */
+            borg_note("# Danger Level 6.2");
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+    /* 7- Shoot N Scoot */
+    if ((borg_spell_okay_fail(0, 2, allow_fail) ||
+         borg_prayer_okay_fail(4, 0, allow_fail)) &&
+		borg_shoot_scoot_safe(20,2))
+    {
+        /* Phase door */
+        if (borg_spell_fail(0, 2, allow_fail) ||
+              borg_prayer_fail(4, 0, allow_fail))
+        {
+            /* Flee! */
+            borg_note("# Shoot N Scoot. (Danger Level 7.1)");
+            borg_escapes--; /* a phase isn't really an escape */
+
+            /* Success */
+            return (TRUE);
+        }
+	}
+
+    return (FALSE);
+}
+
+
+/*
+ * ** Try healing **
+ * this function tries to heal the borg before trying to flee.
+ * The ez_heal items (*Heal* and Life) are reserved for Morgoth.
+ * In severe emergencies the borg can drink an ez_heal item but that is
+ * checked in borg_caution().  He should bail out of the fight before
+ * using an ez_heal.
+ */
+static bool borg_heal(int danger )
+{
+    int hp_down;
+    int allow_fail = 15;
+    int chance;
+
+    int stats_needing_fix = 0;
+
+	bool rod_good = FALSE;
+
+    hp_down = borg_skill[BI_MAXHP] - borg_skill[BI_CURHP];
+
+	/* Quick check for rod success (used later on) */
+	if (borg_slot(TV_ROD, SV_ROD_HEALING) != -1)
+	{
+    	/* Reasonable chance of success */
+    	if (borg_skill[BI_DEV] -
+    	    borg_items[borg_slot(TV_ROD, SV_ROD_HEALING)].level > 7)
+			rod_good = TRUE;
+	}
+
+    /* when fighting Morgoth, we want the borg to use Life potion to fix his
+     * stats.  So we need to add up the ones that are dropped.
+     */
+     if (borg_skill[BI_ISFIXSTR]) stats_needing_fix ++;
+     if (borg_skill[BI_ISFIXINT]) stats_needing_fix ++;
+     if (borg_skill[BI_ISFIXWIS]) stats_needing_fix ++;
+     if (borg_skill[BI_ISFIXDEX]) stats_needing_fix ++;
+     if (borg_skill[BI_ISFIXCON]) stats_needing_fix ++;
+
+    /* Special cases get a second vote */
+    if (borg_class == CLASS_MAGE && borg_skill[BI_ISFIXINT]) stats_needing_fix ++;
+    if (borg_class == CLASS_PRIEST && borg_skill[BI_ISFIXWIS]) stats_needing_fix ++;
+    if (borg_class == CLASS_WARRIOR && borg_skill[BI_ISFIXCON]) stats_needing_fix ++;
+    if (borg_skill[BI_MAXHP] <= 850 && borg_skill[BI_ISFIXCON]) stats_needing_fix ++;
+    if (borg_skill[BI_MAXHP] <= 700 && borg_skill[BI_ISFIXCON]) stats_needing_fix += 3;
+    if (borg_class == CLASS_PRIEST && borg_skill[BI_MAXSP] < 100 && borg_skill[BI_ISFIXWIS])
+        stats_needing_fix +=5;
+    if (borg_class == CLASS_MAGE && borg_skill[BI_MAXSP] < 100 && borg_skill[BI_ISFIXINT])
+        stats_needing_fix +=5;
+
+
+    /*  Hack -- heal when confused. This is deadly.*/
+    /* This is checked twice, once, here, to see if he is in low danger
+     * and again at the end of borg_caution, when all other avenues have failed */
+    if (borg_skill[BI_ISCONFUSED])
+    {
+        if ((hp_down >= 300) && danger - 300 < borg_skill[BI_CURHP] &&
+            borg_quaff_potion(SV_POTION_HEALING))
+        {
+            borg_note("# Fixing Confusion. Level 1");
+            return (TRUE);
+        }
+        if ((hp_down >= 300) && danger >= borg_skill[BI_CURHP] * 2 &&
+            (borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+             borg_quaff_potion(SV_POTION_LIFE)))
+        {
+            borg_note("# Fixing Confusion. Level 1.a");
+            return (TRUE);
+        }
+        if (danger - 20 < borg_skill[BI_CURHP]  &&
+           (borg_eat_food(SV_FOOD_CURE_CONFUSION) ||
+            borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+            borg_quaff_crit(FALSE) ||
+            borg_quaff_potion(SV_POTION_HEALING) ||
+            borg_use_staff_fail(SV_STAFF_HEALING) ||
+            borg_use_staff_fail(SV_STAFF_CURING)))
+        {
+            borg_note("# Fixing Confusion. Level 2");
+            return (TRUE);
+        }
+
+        /* If my ability to use a teleport staff is really
+         * bad, then I should heal up then use the staff.
+         */
+        /* Check for a charged teleport staff */
+        if (borg_equips_staff_fail(SV_STAFF_TELEPORTATION))
+        {
+            /* check my skill, drink a potion */
+            if ((borg_skill[BI_DEV] - borg_items[borg_slot(TV_STAFF, SV_STAFF_TELEPORTATION)].level > 7) &&
+                (danger < (avoidance + 35) * 15 / 10) &&
+                (borg_quaff_crit(TRUE) ||
+                 borg_quaff_potion(SV_POTION_HEALING)))
+            {
+                borg_note("# Fixing Confusion. Level 3");
+                return (TRUE);
+            }
+            /* However, if I am in really big trouble and there is no way
+             * I am going to be able to
+             * survive another round, take my chances on the staff.
+             */
+            else if (danger >= avoidance * 15 / 10)
+            {
+                borg_note("# Too scary to fix Confusion. Level 4");
+                return (FALSE);
+            }
+
+        }
+		else
+		{
+			/* If I do not have a staff to teleport, take the potion
+			 * and try to fix the confusion
+			 */
+            if ((borg_quaff_crit(TRUE) ||
+                 borg_quaff_potion(SV_POTION_HEALING)))
+            {
+                borg_note("# Fixing Confusion. Level 5");
+                return (TRUE);
+            }
+		}
+    }
+    /*  Hack -- heal when blind. This is deadly.*/
+    if (borg_skill[BI_ISBLIND] && (rand_int(100) < 85))
+    {
+        /* if in extreme danger, use teleport then fix the
+         * blindness later.
+         */
+        if (danger > avoidance * 25/10)
+        {
+            /* Check for a charged teleport staff */
+            if (borg_equips_staff_fail(SV_STAFF_TELEPORTATION)) return (0);
+        }
+        if ((hp_down >= 300) && borg_quaff_potion(SV_POTION_HEALING))
+        {
+            return (TRUE);
+        }
+        /* Warriors with ESP won't need it so quickly */
+        if (!(borg_class == CLASS_WARRIOR && borg_skill[BI_CURHP] > borg_skill[BI_MAXHP] /4 &&
+             borg_skill[BI_ESP]))
+        {
+            if (borg_eat_food(SV_FOOD_CURE_BLINDNESS) ||
+                borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+                borg_quaff_crit(TRUE) ||
+                borg_quaff_potion(SV_POTION_HEALING) ||
+                borg_use_staff_fail(SV_STAFF_HEALING) ||
+                borg_use_staff_fail(SV_STAFF_CURING))
+            {
+                borg_note("# Fixing Blindness.");
+                return (TRUE);
+            }
+        }
+    }
+
+
+    /* We generally try to conserve ez-heal pots */
+    if ((borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) &&
+       ((hp_down >= 400) || (danger > borg_skill[BI_CURHP] *5 && hp_down > 100)) &&
+        borg_quaff_potion(SV_POTION_STAR_HEALING))
+    {
+        borg_note("# Fixing Confusion/Blind.");
+        return (TRUE);
+    }
+
+   /*  Hack -- rest until healed */
+    if ( (!borg_skill[BI_ISBLIND] && !borg_skill[BI_ISPOISONED] && !borg_skill[BI_ISCUT] &&
+          !borg_see_inv &&
+          !borg_skill[BI_ISWEAK] && !borg_skill[BI_ISHUNGRY] && danger < avoidance/5) &&
+         (borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE] || borg_skill[BI_ISAFRAID] || borg_skill[BI_ISSTUN] || borg_skill[BI_ISHEAVYSTUN] ||
+          borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] || borg_skill[BI_CURSP] < borg_skill[BI_MAXSP] * 6 / 10)  &&
+         borg_check_rest() && !scaryguy_on_level)
+    {
+        /* check for then call lite in dark room before resting */
+        if (!borg_check_lite_only())
+        {
+            /* Take note */
+            borg_note(format("# Resting to restore HP/SP..."));
+
+            /* Rest until done */
+            borg_keypress('R');
+            borg_keypress('&');
+            borg_keypress('\n');
+
+            /* Reset our panel clock, we need to be here */
+            time_this_panel =0;
+
+            /* reset the inviso clock to avoid loops */
+            need_see_inviso = borg_t - 50;
+
+            /* Done */
+            return (TRUE);
+        }
+        else
+        {
+            /* Must have been a dark room */
+            borg_note(format("# Lighted the darkened room instead of resting."));
+            return (TRUE);
+        }
+     }
+
+
+    /* Healing and fighting Morgoth. */
+    if (borg_fighting_unique >= 10 || borg_t - borg_t_morgoth <= 100)
+    {
+        if (borg_skill[BI_CURHP] <= 625 &&
+            ((borg_skill[BI_CURHP] > 250 && borg_prayer_fail(3,5, 14)) ||  /* Holy Word */
+            /* Choose Life over *Healing* to fix stats*/
+             (stats_needing_fix >= 5 && borg_quaff_potion(SV_POTION_LIFE)) ||
+            /* Choose Life over Healing if way down on pts*/
+             (hp_down > 500 && -1==borg_slot(TV_POTION, SV_POTION_STAR_HEALING) && borg_quaff_potion(SV_POTION_LIFE)) ||
+             borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+             borg_quaff_potion(SV_POTION_HEALING) ||
+             (borg_skill[BI_CURHP] < 250 && borg_prayer_fail(3,5, 5)) ||  /* Holy Word */
+             (borg_skill[BI_CURHP] > 550 && borg_prayer_fail(3,5, 15)) ||  /* Holy Word */
+             borg_prayer_fail(6, 2, 15) ||
+             borg_prayer_fail(3, 2, 15) ||
+             borg_quaff_potion(SV_POTION_LIFE) ||
+             borg_zap_rod(SV_ROD_HEALING)))
+        {
+            borg_note("# Healing in Questor Combat.");
+            return (TRUE);
+        }
+    }
+
+    /* restore Mana */
+    /* note, blow the staff charges easy because the staff will not last. */
+    if (borg_skill[BI_CURSP] < (borg_skill[BI_MAXSP] / 5) && (rand_int(100) < 50))
+    {
+        if (borg_use_staff_fail(SV_STAFF_THE_MAGI))
+        {
+            borg_note("# Use Magi Staff");
+            return (TRUE);
+        }
+    }
+    /* blowing potions is harder */
+    /* NOTE: must have enough mana to keep up or do a HEAL */
+    if (borg_skill[BI_CURSP] < (borg_skill[BI_MAXSP] / 10) ||
+       ((borg_skill[BI_CURSP] < 70 && borg_skill[BI_MAXSP] > 200) ) )
+    {
+        /*  use the potion if battling a unique and not too dangerous */
+        if (borg_fighting_unique >= 10 ||
+            (borg_fighting_unique && danger < avoidance *2) ||
+            (borg_skill[BI_ATELEPORT] == 0 && danger > avoidance))
+        {
+            if (borg_use_staff_fail(SV_STAFF_THE_MAGI) ||
+                borg_quaff_potion(SV_POTION_RESTORE_MANA))
+            {
+                borg_note("# Restored My Mana");
+                return (TRUE);
+            }
+        }
+    }
+
+    /* if unhurt no healing needed */
+    if (hp_down == 0)
+        return FALSE;
+
+    /* Don't bother healing if not in danger */
+    if (danger == 0 && !borg_skill[BI_ISPOISONED] && !borg_skill[BI_ISCUT])
+        return (FALSE);
+
+    /* Restoring while fighting Morgoth */
+    if (stats_needing_fix >=5 && borg_fighting_unique >= 10 &&
+        borg_skill[BI_CURHP] > 650 &&
+        borg_eat_food(SV_FOOD_RESTORING))
+    {
+        borg_note("# Trying to fix stats in combat.");
+        return(TRUE);
+    }
+
+    /* No further Healing considerations if fighting Questors */
+    if (borg_fighting_unique >= 10)
+    {
+        /* No further healing considerations right now */
+        return (FALSE);
+    }
+
+
+    /* Hack -- heal when wounded a percent of the time */
+    /* down 4/5 hp 0%                      */
+    /* 3/4 hp 2%                           */
+    /* 2/3 hp 20%                          */
+    /* 1/2 hp 50%                          */
+    /* 1/3 hp 75%                          */
+    /* 1/4 hp 100%                         */
+
+    chance = rand_int(100);
+
+    /* if we are fighting a unique increase the odds of healing */
+    if (borg_fighting_unique) chance -= 10;
+
+    /* if danger is close to the hp and healing will help, do it */
+    if (danger >= borg_skill[BI_CURHP] && danger < borg_skill[BI_MAXHP] )
+        chance -= 75;
+    else
+    {
+        if (borg_class != CLASS_PRIEST &&
+            borg_class != CLASS_PALADIN)
+            chance -= 25;
+    }
+
+
+    /* Risky Borgs are less likely to heal in the fight */
+    if (borg_plays_risky) chance += 2;
+
+    if (!(((borg_skill[BI_CURHP] <= ((borg_skill[BI_MAXHP] * 4) / 5)) && (chance < 0)) ||
+            ((borg_skill[BI_CURHP] <= ((borg_skill[BI_MAXHP] * 3) / 4)) && (chance < 2)) ||
+            ((borg_skill[BI_CURHP] <= ((borg_skill[BI_MAXHP] * 2) / 3)) && (chance < 20)) ||
+            ((borg_skill[BI_CURHP] <= (borg_skill[BI_MAXHP] / 2)) && (chance < 50)) ||
+            ((borg_skill[BI_CURHP] <= (borg_skill[BI_MAXHP] / 3)) && (chance < 75)) ||
+             (borg_skill[BI_CURHP] <= (borg_skill[BI_MAXHP] / 4)) ||
+             borg_skill[BI_ISHEAVYSTUN] || borg_skill[BI_ISSTUN] || borg_skill[BI_ISPOISONED] || borg_skill[BI_ISCUT]))
+            return FALSE;
+
+
+    /* Cure light Wounds (2d10) */
+    if ( hp_down < 10 &&
+         ((danger) < borg_skill[BI_CURHP] +6) &&
+         (borg_prayer_fail(0, 1, allow_fail) ||
+          borg_spell_fail(0,5,allow_fail) ||
+          borg_quaff_potion(SV_POTION_CURE_LIGHT) ||
+          borg_activate_artifact(ACT_CURE_WOUNDS,INVEN_WIELD) ) )
+    {
+        borg_note("# Healing Level 1.");
+        return (TRUE);
+    }
+    /* Cure Serious Wounds (4d10) */
+    if ( hp_down < 20 &&
+         ((danger) < borg_skill[BI_CURHP]+18) &&
+         (borg_prayer_fail(1, 2, allow_fail) ||
+          borg_quaff_potion(SV_POTION_CURE_SERIOUS)))
+    {
+        borg_note("# Healing Level 2.");
+        return (TRUE);
+    }
+
+    /* Cure Critical Wounds (6d10) */
+    if ( hp_down < 50 &&
+         ((danger) < borg_skill[BI_CURHP] + 35) &&
+         (borg_prayer_fail(2, 2, allow_fail) ||
+          borg_prayer_fail(6, 0, allow_fail) ||
+          borg_activate_artifact(ACT_CURE_WOUNDS, INVEN_HEAD) ||
+          borg_quaff_crit(FALSE)))
+    {
+        borg_note("# Healing Level 3.");
+        return (TRUE);
+    }
+
+    /* Cure Mortal Wounds (8d10) */
+    if ( hp_down < 120 &&
+         ((danger) < borg_skill[BI_CURHP] + 55) &&
+         (borg_prayer_fail(2, 7, allow_fail) ||
+          borg_prayer_fail(6, 1, allow_fail)/* ||
+          borg_quaff_crit(FALSE) don't want to CCW here, it would not help enough*/))
+    {
+        borg_note("# Healing Level 4.");
+        return (TRUE);
+    }
+
+    /* If in danger try  one more Cure Critical if it will help */
+    if (danger >= borg_skill[BI_CURHP] &&
+        danger < borg_skill[BI_MAXHP] &&
+        borg_skill[BI_CURHP] < 20 &&
+        danger < 30 &&
+        borg_quaff_crit(TRUE))
+    {
+        borg_note("# Healing Level 5.");
+        return (TRUE);
+    }
+
+
+
+    /* Generally continue to heal.  But if we are preparing for the end
+     * game uniques, then bail out here in order to save our heal pots.
+     * (unless morgoth is dead)
+     * Priests wont need to bail, they have good heal spells.
+     */
+    if (borg_skill[BI_MAXDEPTH] >=98 && !borg_skill[BI_KING] && !borg_fighting_unique &&
+        borg_class != CLASS_PRIEST)
+    {
+        /* Bail out to save the heal pots for Morgoth*/
+        return (FALSE);
+    }
+
+    /* Heal step one (200hp) */
+    if (hp_down < 250 &&
+        danger < borg_skill[BI_CURHP] + 200 &&
+        ( ((!borg_skill[BI_ATELEPORT] || rod_good ) &&
+          borg_zap_rod(SV_ROD_HEALING)) ||
+         borg_activate_artifact(ACT_HEAL1,INVEN_BODY) ||
+         borg_activate_artifact(ACT_HEAL2,INVEN_HEAD) ||
+         borg_use_staff_fail(SV_STAFF_HEALING) ||
+         borg_prayer_fail(3, 2, allow_fail) ||
+         borg_quaff_potion(SV_POTION_HEALING) ))
+    {
+        borg_note("# Healing Level 6.");
+        return (TRUE);
+    }
+
+    /* Heal step two (300hp) */
+    if (hp_down < 350 &&
+        danger < borg_skill[BI_CURHP] +300 &&
+        (borg_use_staff_fail(SV_STAFF_HEALING) ||
+         (borg_fighting_evil_unique && borg_prayer_fail(3,5, allow_fail)) || /* holy word */
+         borg_prayer_fail(3, 2, allow_fail) ||
+         ((!borg_skill[BI_ATELEPORT] || rod_good ) &&
+          borg_zap_rod(SV_ROD_HEALING)) ||
+         borg_zap_rod(SV_ROD_HEALING) ||
+         borg_quaff_potion(SV_POTION_HEALING) ))
+    {
+        borg_note("# Healing Level 7.");
+        return (TRUE);
+    }
+
+    /* Healing step three (300hp).  */
+    if (hp_down < 650 &&
+        danger < borg_skill[BI_CURHP]+300 &&
+        ((borg_fighting_evil_unique && borg_prayer_fail(3,5, allow_fail)) || /* holy word */
+         ((!borg_skill[BI_ATELEPORT] || rod_good)  &&
+           borg_zap_rod(SV_ROD_HEALING)) ||
+         borg_prayer_fail(6, 2, allow_fail) ||
+         borg_prayer_fail(3, 2, allow_fail) ||
+         borg_use_staff_fail(SV_STAFF_HEALING) ||
+         borg_quaff_potion(SV_POTION_HEALING) ||
+         borg_activate_artifact(ACT_HEAL1,INVEN_BODY) ||
+         borg_activate_artifact(ACT_HEAL2,INVEN_HEAD)) )
+    {
+        borg_note("# Healing Level 8.");
+        return (TRUE);
+    }
+
+    /* Healing final check.  Note that *heal* and Life potions are not
+     * wasted.  They are saved for Morgoth and emergencies.  The
+     * Emergency check is at the end of borg_caution().
+     */
+    if (hp_down >= 650 && (danger < borg_skill[BI_CURHP] +350)  &&
+        ((borg_fighting_evil_unique && borg_prayer_fail(3,5, allow_fail)) || /* holy word */
+         borg_prayer_fail(6, 2, allow_fail) ||
+         borg_prayer_fail(3, 2, allow_fail) ||
+         borg_use_staff_fail(SV_STAFF_HEALING) ||
+         ((!borg_skill[BI_ATELEPORT] || rod_good) &&
+          borg_zap_rod(SV_ROD_HEALING)) ||
+         borg_quaff_potion(SV_POTION_HEALING) ||
+         borg_activate_artifact(ACT_HEAL1,INVEN_BODY) ||
+         borg_activate_artifact(ACT_HEAL2,INVEN_HEAD) ||
+         (borg_fighting_unique &&
+          (borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+           borg_quaff_potion(SV_POTION_HEALING) ||
+           borg_quaff_potion(SV_POTION_LIFE)))))
+    {
+        borg_note("# Healing Level 9.");
+        return (TRUE);
+    }
+
+    /*** Cures ***/
+
+    /* Dont do these in the middle of a fight, teleport out then try it */
+    if (danger > avoidance * 2 / 10) return (FALSE);
+
+    /* Hack -- cure poison when poisoned
+     * This was moved from borg_caution.
+     */
+    if (borg_skill[BI_ISPOISONED] && (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 2))
+    {
+        if (borg_spell_fail(1, 3, 60) ||
+            borg_prayer_fail(2, 0, 60) ||
+            borg_quaff_potion(SV_POTION_CURE_POISON) ||
+            borg_activate_artifact(ACT_REM_FEAR_POIS,INVEN_FEET) ||
+            borg_use_staff(SV_STAFF_CURING) ||
+            borg_eat_food(SV_FOOD_CURE_POISON)||
+            /* buy time */
+            borg_quaff_crit(TRUE) ||
+            borg_prayer_fail(0,1,40) ||
+            borg_spell_fail(0,5,40) ||
+            borg_use_staff_fail(SV_STAFF_HEALING))
+        {
+            borg_note("# Curing.");
+            return (TRUE);
+        }
+
+        /* attempt to fix mana then poison on next round */
+        if ((borg_spell_legal(1, 3) ||
+             borg_prayer_legal(2, 0)) &&
+            (borg_quaff_potion(SV_POTION_RESTORE_MANA)))
+        {
+            borg_note("# Curing next round.");
+            return (TRUE);
+        }
+    }
+
+
+    /* Hack -- cure poison when poisoned CRITICAL CHECK
+     */
+    if (borg_skill[BI_ISPOISONED] && (borg_skill[BI_CURHP] < 2 || borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 20))
+    {
+        int sv_mana = borg_skill[BI_CURSP];
+
+        borg_skill[BI_CURSP] = borg_skill[BI_MAXSP];
+
+        if (borg_spell(1, 3) ||
+            borg_prayer(2, 0)||
+            borg_spell(0, 5))
+        {
+            /* verify use of spell */
+            /* borg_keypress('y'); */
+
+            /* Flee! */
+            borg_note("# Emergency Cure Poison! Gasp!!!....");
+
+            return (TRUE);
+        }
+        borg_skill[BI_CURSP] = sv_mana;
+
+        /* Quaff healing pots to buy some time- in this emergency.  */
+        if (borg_quaff_potion(SV_POTION_CURE_LIGHT) ||
+            borg_quaff_potion(SV_POTION_CURE_SERIOUS) ) return (TRUE);
+
+        /* Try to Restore Mana */
+        if (borg_quaff_potion(SV_POTION_RESTORE_MANA)) return (TRUE);
+
+        /* Emergency check on healing.  Borg_heal has already been checked but
+         * but we did not use our ez_heal potions.  All other attempts to save
+         * ourself have failed.  Use the ez_heal if I have it.
+         */
+        if (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP]/20 &&
+            (borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+             borg_quaff_potion(SV_POTION_LIFE) ||
+             borg_quaff_potion(SV_POTION_HEALING)))
+        {
+            borg_note("# Healing. Curing section.");
+            return (TRUE);
+        }
+
+        /* Quaff unknown potions in this emergency.  We might get luck */
+        if (borg_quaff_unknown()) return (TRUE);
+
+        /* Eat unknown mushroom in this emergency.  We might get luck */
+        if (borg_eat_unknown()) return (TRUE);
+
+        /* Use unknown Staff in this emergency.  We might get luck */
+        if (borg_use_unknown()) return (TRUE);
+
+    }
+
+    /* Hack -- cure wounds when bleeding, also critical check */
+    if (borg_skill[BI_ISCUT] && (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP]/3 || rand_int(100) < 20) )
+    {
+        if (borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+            borg_quaff_potion(SV_POTION_CURE_LIGHT) ||
+            borg_quaff_crit(borg_skill[BI_CURHP] < 10) ||
+            borg_spell(0,5) ||
+            borg_prayer(1,2) ||
+            borg_prayer(2,7) ||
+            borg_prayer(6,1) ||
+            borg_prayer(0,1))
+        {
+            return (TRUE);
+        }
+    }
+    /* bleeding and about to die CRITICAL CHECK*/
+    if (borg_skill[BI_ISCUT] && ((borg_skill[BI_CURHP] < 2) || borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 20))
+    {
+        int sv_mana = borg_skill[BI_CURSP];
+
+        borg_skill[BI_CURSP] = borg_skill[BI_MAXSP];
+
+        /* Quaff healing pots to buy some time- in this emergency.  */
+        if (borg_quaff_potion(SV_POTION_CURE_LIGHT) ||
+            borg_quaff_potion(SV_POTION_CURE_SERIOUS)) return (TRUE);
+
+        /* Try to Restore Mana */
+        if (borg_quaff_potion(SV_POTION_RESTORE_MANA)) return (TRUE);
+
+        /* Emergency check on healing.  Borg_heal has already been checked but
+         * but we did not use our ez_heal potions.  All other attempts to save
+         * ourself have failed.  Use the ez_heal if I have it.
+         */
+        if (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP]/20 &&
+            (borg_quaff_potion(SV_POTION_HEALING) ||
+            borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+            borg_quaff_potion(SV_POTION_LIFE) ))
+        {
+            borg_note("# Healing.  Bleeding.");
+            return (TRUE);
+        }
+
+        /* Cast a spell, go into negative mana */
+        if (borg_spell(0, 5) ||
+            borg_prayer(0,1) ||
+            borg_prayer(1, 2))
+        {
+            /* verify use of spell */
+            /* borg_keypress('y'); */
+
+            /* Flee! */
+            borg_note("# Emergency Wound Patch! Gasp!!!....");
+
+            return (TRUE);
+        }
+        borg_skill[BI_CURSP] = sv_mana;
+
+        /* Quaff unknown potions in this emergency.  We might get luck */
+        if (borg_quaff_unknown()) return (TRUE);
+
+        /* Eat unknown mushroom in this emergency.  We might get luck */
+        if (borg_eat_unknown()) return (TRUE);
+
+        /* Use unknown Staff in this emergency.  We might get luck */
+        if (borg_use_unknown()) return (TRUE);
+    }
+
+    /* nothing to do */
+    return (FALSE);
+
+}
+
+/*
+ * Be "cautious" and attempt to prevent death or dishonor.
+ *
+ * Strategy:
+ *
+ *   (1) Caution
+ *   (1a) Analyze the situation
+ *   (1a1) try to heal
+ *   (1a2) try a defence
+ *   (1b) Teleport from danger
+ *   (1c) Handle critical stuff
+ *   (1d) Retreat to happy grids
+ *   (1e) Back away from danger
+ *   (1f) Heal various conditions
+ *
+ *   (2) Attack
+ *   (2a) Simulate possible attacks
+ *   (2b) Perform optimal attack
+ *
+ *   (3) Recover
+ *   (3a) Recover by spells/prayers
+ *   (3b) Recover by items/etc
+ *   (3c) Recover by resting
+ *
+ * XXX XXX XXX
+ * In certain situations, the "proper" course of action is to simply
+ * attack a nearby monster, since often most of the danger is due to
+ * a single monster which can sometimes be killed in a single blow.
+ *
+ * Actually, both "borg_caution()" and "borg_recover()" need to
+ * be more intelligent, and should probably take into account
+ * such things as nearby monsters, and/or the relative advantage
+ * of simply pummeling nearby monsters instead of recovering.
+ *
+ * Note that invisible/offscreen monsters contribute to the danger
+ * of an extended "region" surrounding the observation, so we will
+ * no longer rest near invisible monsters if they are dangerous.
+ *
+ * XXX XXX XXX
+ * We should perhaps reduce the "fear" values of each region over
+ * time, to take account of obsolete invisible monsters.
+ *
+ * Note that walking away from a fast monster is counter-productive,
+ * since the monster will often just follow us, so we use a special
+ * method which allows us to factor in the speed of the monster and
+ * predict the state of the world after we move one step.  Of course,
+ * walking away from a spell casting monster is even worse, since the
+ * monster will just get to use the spell attack multiple times.  But,
+ * if we are trying to get to known safety, then fleeing in such a way
+ * might make sense.  Actually, this has been done too well, note that
+ * it makes sense to flee some monsters, if they "stumble", or if we
+ * are trying to get to stairs.  XXX XXX XXX
+ *
+ * Note that the "flow" routines attempt to avoid entering into
+ * situations that are dangerous, but sometimes we do not see the
+ * danger coming, and then we must attempt to survive by any means.
+ *
+ * We will attempt to "teleport" if the danger in the current situation,
+ * as well as that resulting from attempting to "back away" from danger,
+ * are sufficient to kill us in one or two blows.  This allows us to
+ * avoid teleportation in situations where simply backing away is the
+ * proper course of action, for example, when standing next to a nasty
+ * stationary monster, but also to teleport when backing away will not
+ * reduce the danger sufficiently.
+ *
+ * But note that in "nasty" situations (when we are running out of light,
+ * or when we are starving, blind, confused, or hallucinating), we will
+ * ignore the possibility of "backing away" from danger, when considering
+ * the possibility of using "teleport" to escape.  But if the teleport
+ * fails, we will still attempt to "retreat" or "back away" if possible.
+ *
+ * XXX XXX XXX Note that it should be possible to do some kind of nasty
+ * "flow" algorithm which would use a priority queue, or some reasonably
+ * efficient normal queue stuff, to determine the path which incurs the
+ * smallest "cumulative danger", and minimizes the total path length.
+ * It may even be sufficient to treat each step as having a cost equal
+ * to the danger of the destination grid, plus one for the actual step.
+ * This would allow the Borg to prefer a ten step path passing through
+ * one grid with danger 10, to a five step path, where each step has
+ * danger 9.  Currently, he often chooses paths of constant danger over
+ * paths with small amounts of high danger.  However, the current method
+ * is very fast, which is certainly a point in its favor...
+ *
+ * When in danger, attempt to "flee" by "teleport" or "recall", and if
+ * this is not possible, attempt to "heal" damage, if needed, and else
+ * attempt to "flee" by "running".
+ *
+ * XXX XXX XXX Both "borg_caution()" and "borg_recover()" should only
+ * perform the "healing" tasks if they will cure more "damage"/"stuff"
+ * than may be re-applied in the next turn, this should prevent using
+ * wimpy healing spells next to dangerous monsters, and resting to regain
+ * mana near a mana-drainer.
+ *
+ * Whenever we are in a situation in which, even when fully healed, we
+ * could die in a single round, we set the "goal_fleeing" flag, and if
+ * we could die in two rounds, we set the "goal_leaving" flag.
+ *
+ * In town, whenever we could die in two rounds if we were to stay still,
+ * we set the "goal_leaving" flag.  In combination with the "retreat" and
+ * the "back away" code, this should allow us to leave town before getting
+ * into situations which might be fatal.
+ *
+ * Flag "goal_fleeing" means get off this level right now, using recall
+ * if possible when we get a chance, and otherwise, take stairs, even if
+ * it is very dangerous to do so.
+ *
+ * Flag "goal_leaving" means get off this level when possible, using
+ * stairs if possible when we get a chance.
+ *
+ * We will also take stairs if we happen to be standing on them, and we
+ * could die in two rounds.  This is often "safer" than teleportation,
+ * and allows the "retreat" code to retreat towards stairs, knowing that
+ * once there, we will leave the level.
+ *
+ * If we can, we should try to hit a monster with an offset  spell.
+ * A Druj can not move but they are really dangerous.  So we should retreat
+ * to a happy grid (meaning we have los and it does not), we should target
+ * one space away from the bad guy then blast away with ball spells.
+ *
+ * Hack -- Special checks for dealing with Morgoth.
+ * The borg would like to stay put on level 100 and use
+ * spells to attack Morgoth then use Teleport Other as he
+ * gets too close.
+ * 1.  Make certain borg is sitting in a central room.
+ * 2.  Attack Morgoth with spells.
+ * 3.  Use Teleport Other on Morgoth as he approches.
+ * 4.  Use Teleport Other/Mass Banishment on all other monsters
+ *     if borg is correctly positioned in a good room.
+ * 5.  Stay put and rest until Morgoth returns.
+ */
+bool borg_caution(void)
+{
+    int j, p;
+    bool borg_surround= FALSE;
+    bool nasty = FALSE;
+
+    /*** Notice "nasty" situations ***/
+
+    /* About to run out of light is extremely nasty */
+    if (!borg_skill[BI_LITE] && borg_items[INVEN_LITE].pval < 250) nasty = TRUE;
+
+    /* Starvation is nasty */
+    if (borg_skill[BI_ISWEAK]) nasty = TRUE;
+
+    /* Blind-ness is nasty */
+    if (borg_skill[BI_ISBLIND]) nasty = TRUE;
+
+    /* Confusion is nasty */
+    if (borg_skill[BI_ISCONFUSED]) nasty = TRUE;
+
+    /* Hallucination is nasty */
+    if (borg_skill[BI_ISIMAGE]) nasty = TRUE;
+
+    /* if on level 100 and not ready for Morgoth, run */
+    if (borg_skill[BI_CDEPTH] == 100 && borg_t - borg_began < 10 &&
+    	!borg_morgoth_position)
+    {
+        if (borg_ready_morgoth == 0 && !borg_skill[BI_KING])
+        {
+            /* teleport level up to 99 to finish uniques */
+            if (borg_spell(6,2) ||
+                borg_prayer(4,3) ||
+                borg_read_scroll(SV_SCROLL_TELEPORT_LEVEL))
+            {
+                    borg_note("# Rising one dlevel (Not ready for Morgoth)");
+                    return (TRUE);
+            }
+
+            /* Start leaving */
+            if (!goal_leaving)
+            {
+                /* Note */
+                borg_note("# Leaving (Not ready for Morgoth now)");
+
+                /* Start leaving */
+                goal_leaving = TRUE;
+            }
+        }
+    }
+
+    /*** Evaluate local danger ***/
+
+    /* am I fighting a unique or a summoner, or scaryguy? */
+    borg_near_monster_type(borg_skill[BI_MAXCLEVEL] < 15 ? MAX_SIGHT : 12);
+    borg_surround = borg_surrounded();
+
+	/* No searching if scary guys on the level */
+	if (scaryguy_on_level == TRUE) borg_needs_searching = FALSE;
+
+    /* Only allow three 'escapes' per level unless heading for morogoth
+       or fighting a unique, then allow 85. */
+    if ((borg_escapes > 3 && !unique_on_level && !borg_ready_morgoth) ||
+         borg_escapes > 55)
+    {
+        /* No leaving if going after questors */
+        if (borg_skill[BI_CDEPTH] <=98)
+        {
+            /* Start leaving */
+            if (!goal_leaving)
+            {
+                /* Note */
+                borg_note("# Leaving (Too many escapes)");
+
+                /* Start leaving */
+                goal_leaving = TRUE;
+            }
+
+            /* Start fleeing */
+            if (!goal_fleeing && borg_escapes > 3)
+            {
+                /* Note */
+                borg_note("# Fleeing (Too many escapes)");
+
+                /* Start fleeing */
+                goal_fleeing = TRUE;
+            }
+        }
+    }
+
+    /* No hanging around if nasty here. */
+    if (scaryguy_on_level)
+    {
+        /* Note */
+        borg_note("# Scary guy on level.");
+
+        /* Start leaving */
+        if (!goal_leaving)
+        {
+            /* Note */
+            borg_note("# Leaving (Scary guy on level)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+
+        /* Start fleeing */
+        if (!goal_fleeing)
+        {
+            /* Note */
+            borg_note("# Fleeing (Scary guy on level)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+
+        /* Return to town quickly after leaving town */
+        if (borg_skill[BI_CDEPTH] == 0) borg_fleeing_town = TRUE;
+    }
+
+	/* Make a note if Ignoring monsters (no fighting) */
+	if (goal_ignoring)
+	{
+            /* Note */
+            borg_note("# Ignoring Fights.");
+	}
+
+	/* Note if ignorig messages */
+    if (borg_dont_react)
+    {
+        borg_note("# Borg ignoring messges.");
+    }
+
+    /* Look around */
+    p = borg_danger(c_y, c_x, 1, TRUE);
+
+    /* Describe (briefly) the current situation */
+    /* Danger (ignore stupid "fear" danger) */
+    if ((p > avoidance / 10) || (p > borg_fear_region[c_y/11][c_x/11]) ||
+    	borg_morgoth_position || borg_skill[BI_ISWEAK])
+    {
+        /* Describe (briefly) the current situation */
+        borg_note(format("# Loc:%d,%d Dep:%d Lev:%d HP:%d/%d SP:%d/%d Danger:p=%d",
+                         c_y, c_x, borg_skill[BI_CDEPTH], borg_skill[BI_CLEVEL],
+                         borg_skill[BI_CURHP], borg_skill[BI_MAXHP], borg_skill[BI_CURSP], borg_skill[BI_MAXSP],p));
+        if (borg_resistance)
+        {
+            borg_note(format("# Protected by Resistance (borg turns:%d; game turns:%d)", borg_resistance/borg_game_ratio,p_ptr->oppose_acid));
+        }
+        if (borg_shield)
+        {
+            borg_note("# Protected by Mystic Shield");
+        }
+        if (borg_prot_from_evil)
+        {
+            borg_note("# Protected by PFE");
+        }
+		if (borg_morgoth_position)
+		{
+			borg_note("# Protected by Sea of Runes.");
+		}
+		if (borg_fighting_unique >=10)
+		{
+			borg_note("# Questor Combat.");
+		}
+    }
+    /* Comment on glyph */
+    if (track_glyph_num)
+    {
+        int i;
+        for (i = 0; i < track_glyph_num; i++)
+        {
+            /* Enqueue the grid */
+            if ((track_glyph_y[i] == c_y) &&
+                (track_glyph_x[i] == c_x))
+                {
+                    /* if standing on one */
+                    borg_note(format("# Standing on Glyph"));
+                }
+        }
+    }
+    /* Comment on stair */
+    if (track_less_num)
+    {
+        int i;
+        for (i = 0; i < track_less_num; i++)
+        {
+            /* Enqueue the grid */
+            if ((track_less_y[i] == c_y) &&
+                (track_less_x[i] == c_x))
+                {
+                    /* if standing on one */
+                    borg_note(format("# Standing on up-stairs"));
+                }
+        }
+    }
+    /* Comment on stair */
+    if (track_more_num)
+    {
+        int i;
+        for (i = 0; i < track_more_num; i++)
+        {
+            /* Enqueue the grid */
+            if ((track_more_y[i] == c_y) &&
+                (track_more_x[i] == c_x))
+                {
+                    /* if standing on one */
+                    borg_note(format("# Standing on dn-stairs"));
+                }
+        }
+    }
+
+
+	/* Start being cautious and trying to not die */
+    if (borg_class == CLASS_MAGE && !borg_morgoth_position &&
+    	!borg_skill[BI_ISBLIND] && !borg_skill[BI_ISCUT] &&
+    	!borg_skill[BI_ISPOISONED] && !borg_skill[BI_ISCONFUSED])
+    {
+        /* do some defence before running away */
+        if (borg_defend(p))
+            return TRUE;
+
+        /* try healing before running away */
+        if (borg_heal(p))
+            return TRUE;
+    }
+    else
+    {
+        /* try healing before running away */
+        if (borg_heal(p))
+            return TRUE;
+
+        /* do some defence before running away! */
+        if (borg_defend(p))
+            return TRUE;
+    }
+
+
+    if (borg_uses_swaps)
+    {
+        /* do some swapping before running away! */
+        if (p > (avoidance / 3) )
+        {
+            if (borg_backup_swap(p))
+                return TRUE;
+        }
+    }
+
+    /* If I am waiting for recall,  & safe, then stay put. */
+    if (goal_recalling && borg_check_rest() &&
+        borg_skill[BI_CDEPTH] &&
+        !borg_skill[BI_ISHUNGRY])
+    {
+        /* rest here until lift off */
+        borg_note("# Resting for Recall.");
+        borg_keypress('R');
+        borg_keypress('5');
+        borg_keypress('0');
+        borg_keypress('0');
+        borg_keypress('\n');
+
+        return (TRUE);
+    }
+
+    /* If I am waiting for recall in town */
+    if (goal_recalling && goal_recalling <= (borg_game_ratio *2) && !borg_skill[BI_CDEPTH])
+    {
+        /* Cast other good Mage prep things */
+        if ((!borg_speed && borg_spell_fail(3, 2,15)) ||
+            (my_oppose_fire + my_oppose_cold + my_oppose_acid +
+             my_oppose_elec + my_oppose_pois < 3 && borg_spell_fail(4,3,15)) ||
+            (!borg_shield && borg_spell_fail(4,4,15)) ||
+            (!borg_hero && borg_spell_fail(7,0,15)) ||
+            (!borg_berserk && borg_spell_fail(7,1,15)))
+        {
+            borg_note("# Casting preparatory spell before Recall activates.");
+            return (TRUE);
+        }
+
+        /* Cast PFE just before returning to dungeon */
+        if  (!borg_prot_from_evil && borg_prayer_fail(2, 4, 15) )
+        {
+            borg_note("# Casting PFE before Recall activates.");
+            return (TRUE);
+        }
+
+        /* Cast other good Priest prep things */
+        if ((!borg_bless && (borg_prayer_fail(3,0,15) ||
+                            borg_prayer_fail(1,3,15) ||
+                            borg_prayer_fail(0,2,15))) ||
+            (!my_oppose_fire && !my_oppose_cold &&
+             borg_prayer_fail(1,7,15)))
+        {
+            borg_note("# Casting preparatory prayer before Recall activates.");
+            return (TRUE);
+        }
+
+    }
+
+    /*** Danger ***/
+
+    /* Impending doom */
+    /* Don't take off in the middle of a fight */
+    /* just to restock and it is useless to restock */
+    /* if you have just left town. */
+    if (borg_restock(borg_skill[BI_CDEPTH]) &&
+        !borg_fighting_unique &&
+        (borg_time_town + (borg_t - borg_began)) > 200)
+    {
+        /* Start leaving */
+        if (!goal_leaving)
+        {
+            /* Note */
+            borg_note(format("# Leaving (restock) %s", borg_restock(borg_skill[BI_CDEPTH])));
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+            /* Start fleeing */
+        if (!goal_fleeing && borg_skill[BI_ACCW] < 2 && borg_skill[BI_FOOD] > 3 &&
+             borg_skill[BI_AFUEL] > 2)
+        {
+            /* Flee */
+            borg_note(format("# Fleeing (restock) %s", borg_restock(borg_skill[BI_CDEPTH])));
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+    }
+    /* Excessive danger */
+    else if (p > (borg_skill[BI_CURHP] * 2))
+    {
+        /* Start fleeing */
+        /* do not flee level if going after Morgoth or fighting a unique */
+        if (!goal_fleeing && !borg_fighting_unique && (borg_skill[BI_CLEVEL] < 50) &&
+            !vault_on_level && (borg_skill[BI_CDEPTH] < 100 && borg_ready_morgoth == 1))
+        {
+            /* Note */
+            borg_note("# Fleeing (excessive danger)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+    }
+    /* Potential danger (near death) in town */
+    else if (!borg_skill[BI_CDEPTH] && (p > borg_skill[BI_CURHP]) && (borg_skill[BI_CLEVEL] < 50) )
+    {
+        /* Flee now */
+        if (!goal_leaving)
+        {
+            /* Flee! */
+            borg_note("# Leaving (potential danger)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+    }
+
+
+    /*** Stairs ***/
+
+    /* Leaving or Fleeing, take stairs */
+    if (goal_leaving || goal_fleeing || scaryguy_on_level || goal_fleeing_lunal)
+    {
+        if (borg_ready_morgoth == 0 && !borg_skill[BI_KING])
+        {
+			stair_less = TRUE;
+			if (goal_leaving) borg_note("# Fleeing and leaving the level.(goal_leaving)");
+			if (goal_fleeing) borg_note("# Fleeing and leaving the level.(goal_fleeing)");
+			if (scaryguy_on_level) borg_note("# Fleeing and leaving the level. (scaryguy)");
+			if (goal_fleeing_lunal) borg_note("# Fleeing and leaving the level. (fleeing_lunal)");
+		}
+
+        if (scaryguy_on_level) stair_less = TRUE;
+
+        /* Only go down if fleeing or prepared, but not when starving.
+         * or lacking on food
+         */
+        if (goal_fleeing == TRUE || goal_fleeing_lunal== TRUE) stair_more = TRUE;
+
+        if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH]+1))
+            stair_more = TRUE;
+
+        if (borg_skill[BI_CURLITE] == 0 || borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK] || borg_skill[BI_FOOD] < 2)
+              stair_more = FALSE;
+
+        /* Its ok to go one level deep if evading scary guy */
+        if (scaryguy_on_level) stair_more = TRUE;
+
+        /* if fleeing town, then dive */
+        if (!borg_skill[BI_CDEPTH]) stair_more = TRUE;
+    }
+
+    /* Take stairs up */
+    if (stair_less)
+    {
+        /* Current grid */
+        borg_grid *ag = &borg_grids[c_y][c_x];
+
+        /* Usable stairs */
+        if (ag->feat == FEAT_LESS)
+        {
+            if ((borg_skill[BI_MAXDEPTH] - 4) > borg_skill[BI_CDEPTH] && borg_skill[BI_MAXCLEVEL] >= 35)
+            {
+                borg_note("# Scumming.");
+                auto_scum = TRUE;
+            }
+
+			/* Log it */
+			borg_note(format("# Leaving via up stairs."));
+
+            /* Take the stairs */
+            if (dungeon_stair) borg_on_dnstairs = TRUE;
+            borg_keypress('<');
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+
+    /* Take stairs down */
+    if (stair_more && !goal_recalling)
+    {
+        /* Current grid */
+        borg_grid *ag = &borg_grids[c_y][c_x];
+
+        /* Usable stairs */
+        if (ag->feat == FEAT_MORE)
+        {
+            if ((borg_skill[BI_MAXDEPTH] - 5) > borg_skill[BI_CDEPTH] && borg_skill[BI_MAXCLEVEL] >= 35)
+            {
+                borg_note("# Scumming");
+                auto_scum = TRUE;
+            }
+
+			/* Do these if not lunal mode */
+			if (!goal_fleeing_lunal)
+			{
+        		/* Cast other good Mage prep things */
+        		if (!goal_fleeing && (borg_skill[BI_CURSP] > borg_skill[BI_MAXSP] * 6 /10 &&
+        		   ((!borg_speed && borg_spell_fail(3, 2,15)) ||
+        		    (my_oppose_fire + my_oppose_cold + my_oppose_acid +
+        		      my_oppose_elec + my_oppose_pois < 3 && borg_spell_fail(4,3,15)) ||
+        		    (!borg_shield && borg_spell_fail(4,4,15)) ||
+        		    (!borg_hero && borg_spell_fail(7,0,15)) ||
+        		    (!borg_berserk && borg_spell_fail(7,1,15)))))
+        		{
+        		    borg_note("# Casting preparatory spell before taking stairs.");
+        		    borg_no_rest_prep = 3000;
+        		    return (TRUE);
+        		}
+
+        		/* Cast PFE just before returning to dungeon */
+        		if  (!goal_fleeing && !borg_prot_from_evil && borg_prayer_fail(2, 4, 15) )
+        		{
+        		    borg_note("# Casting PFE before taking stairs.");
+        		    borg_no_rest_prep = 3000;
+        		    return (TRUE);
+        		}
+
+        		/* Cast other good Priest prep things */
+        		if (!goal_fleeing && (borg_skill[BI_CURSP] > borg_skill[BI_MAXSP] * 6 /10 &&
+        		    ((!borg_bless && (borg_prayer_fail(3,0,15) ||
+        		                     borg_prayer_fail(1,3,15) ||
+        		                     borg_prayer_fail(0,2,15))) ||
+        		    (!my_oppose_fire && !my_oppose_cold &&
+        		     borg_prayer_fail(1,7,15)))))
+        		{
+        		    borg_note("# Casting preparatory prayer before taking stairs.");
+        		    borg_no_rest_prep = 3000;
+        		    return (TRUE);
+        		}
+
+        	}
+
+       	    /* Take the stairs */
+       	    if (dungeon_stair) borg_on_upstairs = TRUE;
+       	    borg_keypress('>');
+
+       	    /* Success */
+       	    return (TRUE);
+    	}
+	}
+
+
+    /*** Deal with critical situations ***/
+
+    /* Hack -- require light */
+    if (!borg_skill[BI_CURLITE] && !borg_skill[BI_LITE]) /* No Lite, AND Not Glowing */
+    {
+        borg_item *item = &borg_items[INVEN_LITE];
+
+        /* Must have light -- Refuel current torch */
+        if ((item->tval == TV_LITE) && (item->sval == SV_LITE_TORCH))
+        {
+            /* Try to refuel the torch */
+            if ((item->pval < 500) && borg_refuel_torch()) return (TRUE);
+        }
+
+        /* Must have light -- Refuel current lantern */
+        if ((item->tval == TV_LITE) && (item->sval == SV_LITE_LANTERN))
+        {
+            /* Try to refill the lantern */
+            if ((item->pval < 1000) && borg_refuel_lantern()) return (TRUE);
+        }
+
+        /* Flee for fuel */
+        if (borg_skill[BI_CDEPTH] && (item->pval < 250))
+        {
+            /* Start leaving */
+            if (!goal_leaving)
+            {
+                /* Flee */
+                borg_note("# Leaving (need fuel)");
+
+                /* Start leaving */
+                goal_leaving = TRUE;
+            }
+        }
+    }
+
+    /* Hack -- prevent starvation */
+    if (borg_skill[BI_ISWEAK])
+    {
+        /* Attempt to satisfy hunger */
+        if (borg_eat_food_any() ||
+            borg_spell(2, 0) ||
+            borg_prayer(1, 5))
+        {
+            /* Success */
+            return (TRUE);
+        }
+
+        /* Try to restore mana then cast the spell next round */
+        if (borg_quaff_potion(SV_POTION_RESTORE_MANA)) return (TRUE);
+
+        /* Flee for food */
+        if (borg_skill[BI_CDEPTH])
+        {
+            /* Start leaving */
+            if (!goal_leaving)
+            {
+                /* Flee */
+                borg_note("# Leaving (need food)");
+
+                /* Start leaving */
+                goal_leaving = TRUE;
+            }
+
+            /* Start fleeing */
+            if (!goal_fleeing)
+            {
+                /* Flee */
+                borg_note("# Fleeing (need food)");
+
+                /* Start fleeing */
+                goal_fleeing = TRUE;
+            }
+        }
+    }
+
+    /* Prevent breeder explosions when low level */
+    if (breeder_level && borg_skill[BI_CLEVEL] < 15)
+    {
+        /* Start leaving */
+        if (!goal_fleeing)
+        {
+            /* Flee */
+            borg_note("# Fleeing (breeder level)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+
+    }
+
+    /*** Flee on foot ***/
+
+    /* Desperation Head for stairs */
+    /* If you are low level and near the stairs and you can */
+    /* hop onto them in very few steps, try to head to them */
+    /* out of desperation */
+    if (track_less_num &&
+        (goal_fleeing || (p > avoidance && borg_skill[BI_CLEVEL] < 35)))
+    {
+        int y, x, i;
+        int b_j = -1;
+
+        borg_grid *ag;
+
+        /* Check for an existing "up stairs" */
+        for (i = 0; i < track_less_num; i++)
+        {
+            x = track_less_x[i];
+            y = track_less_y[i];
+
+            ag = &borg_grids[y][x];
+
+            /* How far is the nearest up stairs */
+            j = distance(c_y, c_x, y, x);
+
+            /* Skip stairs if a monster is on the stair */
+            if (ag->kill) continue;
+
+            /* skip the closer ones */
+            if (b_j >= j) continue;
+
+            /* track it */
+            b_j =j;
+        }
+        /* If you are within a few (3) steps of the stairs */
+        /* and you can take some damage to get there */
+        /* go for it */
+        if (b_j < 3 && b_j != -1 &&
+            p < borg_skill[BI_CURHP])
+        {
+            borg_desperate = TRUE;
+            if (borg_flow_stair_less(GOAL_FLEE))
+            {
+                /* Note */
+                borg_note("# Desperate for Stairs (one)");
+
+                borg_desperate = FALSE;
+                return (TRUE);
+            }
+            borg_desperate = FALSE;
+        }
+
+        /* If you are next to steps of the stairs go for it */
+        if (b_j <= 2 && b_j != -1)
+        {
+            borg_desperate = TRUE;
+            if (borg_flow_stair_less(GOAL_FLEE))
+            {
+                /* Note */
+                borg_note("# Desperate for Stairs (two)");
+
+                borg_desperate = FALSE;
+                return (TRUE);
+            }
+            borg_desperate = FALSE;
+        }
+
+        /* Low level guys tend to waste money reading the recall scrolls */
+        if (b_j < 15 && b_j != -1 && scaryguy_on_level && borg_skill[BI_CLEVEL] < 20)
+        {
+			/* Dont run from Grip or Fang */
+            if (borg_skill[BI_CDEPTH] <= 5 && borg_skill[BI_CDEPTH] != 0 && borg_fighting_unique)
+			{
+				/* try to take them on, you cant outrun them */
+			}
+			else
+			{
+				borg_desperate = TRUE;
+            	if (borg_flow_stair_less(GOAL_FLEE))
+            	{
+            	    /* Note */
+            	    borg_note("# Desperate for Stairs (three)");
+
+            	    borg_desperate = FALSE;
+            	    return (TRUE);
+            	}
+	            borg_desperate = FALSE;
+			}
+        }
+    }
+
+
+    /* Strategic retreat */
+    /* Do not retreat if */
+    /* 1) we are icky (poisoned, blind, confused etc */
+    /* 2) we are boosting our avoidance because we are stuck */
+    /* 3) we are in a Sea of Runes */
+    /* 4) we are trying to avoid a scaryguy */
+   if (((p > avoidance / 3 && !nasty && !borg_no_retreat) ||
+          (borg_surround && p != 0)) &&
+        !borg_morgoth_position &&
+        !scaryguy_on_level)
+   {
+        int d, b_d = -1;
+        int r, b_r = -1;
+
+        int b_x = c_x;
+        int b_y = c_y;
+
+        /* Scan the useful viewable grids */
+        for (j = 1; j < borg_view_n; j++)
+        {
+            int x1 = c_x;
+            int y1 = c_y;
+
+            int x2 = borg_view_x[j];
+            int y2 = borg_view_y[j];
+
+            /* Cant if confused: no way to predict motion */
+            if (borg_skill[BI_ISCONFUSED]) continue;
+
+            /* Require "floor" grids */
+            if (!borg_cave_floor_bold(y2, x2)) continue;
+
+            /* XXX -- Borgs in an unexplored hall (& with only a torch
+             * will always return FALSE for Happy Grids:
+             *
+             *  222222      Where 2 = unknown grid.  Borg has a torch.
+             *  2221.#      Borg will consider both the . and the 1
+             *     #@#      for a retreat from the C. But the . will be
+             *     #C#      false d/t adjacent wall to the east.  1 will
+             *     #'#      will be false d/t unknown grid to the west.
+             *              So he makes no attempt to retreat.
+             * However, the next function (backing away), allows him
+             * to back up to 1 safely.
+             *
+             * To play safer, the borg should not retreat to grids where
+             * he has not previously been.  This tends to run him into
+             * more monsters.  It is better for him to retreat to grids
+             * previously travelled, where the monsters are most likely
+             * dead, and the path is clear.  However, there is not (yet)
+             * tag for those grids.  Something like BORG_BEEN would work.
+             */
+
+            /* Require "happy" grids (most of the time)*/
+            if (!borg_happy_grid_bold(y2, x2)) continue;
+
+            /* Track "nearest" grid */
+            if (b_r >= 0)
+            {
+                int ay = ((y2 > y1) ? (y2 - y1) : (y1 - y2));
+                int ax = ((x2 > x1) ? (x2 - x1) : (x1 - x2));
+
+                /* Ignore "distant" locations */
+                if ((ax > b_r) || (ay > b_r)) continue;
+            }
+
+            /* Reset */
+            r = 0;
+
+            /* Simulate movement */
+            while (1)
+            {
+                borg_grid *ag;
+
+                /* Obtain direction */
+                d = borg_goto_dir(y1, x1, y2, x2);
+
+                /* Verify direction */
+                if ((d == 0) || (d == 5)) break;
+
+                /* Track distance */
+                r++;
+
+                /* Simulate the step */
+                y1 += ddy[d];
+                x1 += ddx[d];
+
+                /* Obtain the grid */
+                ag = &borg_grids[y1][x1];
+
+                /* Require floor */
+                if (!borg_cave_floor_grid(ag)) break;
+
+                /* Require line of sight */
+                if (!borg_los(y1, x1, y2, x2)) break;
+
+                /* Check danger of that spot (over time) */
+                if (!borg_surround && borg_danger(y1, x1, r+1, TRUE) >= p) break;
+
+                /* make sure it is not dangerous to take the first step; unless surrounded. */
+                if (r == 1)
+                {
+                    /* Not surrounded */
+                    if (!borg_surround)
+                    {
+                        if (borg_danger(y1, x1, 1, TRUE) >= borg_skill[BI_CURHP] * 6/10)
+                        break;
+                    }
+                    else
+                    /* Surrounded, try to back-up */
+                    {
+                        if (borg_danger(y1, x1, 1, TRUE) >= (b_r  <= 3 ? borg_skill[BI_CURHP] * 15/10 : borg_skill[BI_CURHP]))
+                        break;
+                    }
+                }
+
+                /* Skip monsters */
+                if (ag->kill) break;
+
+                /* Skip traps */
+                if ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL)) break;
+
+                /* Safe arrival */
+                if ((x1 == x2) && (y1 == y2))
+                {
+                    /* Save distance */
+                    b_r = r;
+
+                    /* Save location */
+                    b_x = x2;
+                    b_y = y2;
+
+                    /* Done */
+                    break;
+                }
+            }
+        }
+
+        /* Retreat */
+        if (b_r >= 0)
+        {
+            /* Save direction */
+            b_d = borg_goto_dir(c_y, c_x, b_y, b_x);
+
+            /* Hack -- set goal */
+            g_x = c_x + ddx[b_d];
+            g_y = c_y + ddy[b_d];
+
+            /* Note */
+            borg_note(format("# Retreating to %d,%d (distance %d) via %d,%d (%d > %d)",
+                             b_y, b_x, b_r, g_y, g_x, p, borg_danger(g_y, g_x, 1, TRUE)));
+
+            /* Strategic retreat */
+            borg_keypress(I2D(b_d));
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+    /*** Escape if possible ***/
+
+    /* Attempt to escape via spells */
+    if (borg_escape(p))
+    {
+        /* increment the escapes this level counter */
+        borg_escapes++;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /*** Back away ***/
+    /* Do not back up if
+     * 1) we are icky (poisoned, blind, confused etc
+     * 2) we are boosting our avoidance because we are stuck
+     * 3) we are in a sweet Morgoth position (sea of runes)
+	 * 4) we are trying to get off the level from a scary guy.
+	 */
+    if (((p > avoidance / 3 && !nasty && !borg_no_retreat) ||
+         (borg_surround && p != 0)) &&
+        !borg_morgoth_position &&
+        !scaryguy_on_level)
+    {
+        int i = -1, b_i = -1;
+        int k = -1, b_k = -1;
+        int f = -1, b_f = -1;
+		int g_k = 0;
+
+        /* Current danger */
+        b_k = p;
+
+        /* Fake the danger down if surounded so that he can move. */
+        if (borg_surround) b_k = (b_k * 6/10);
+
+        /* Check the freedom */
+        b_f = borg_freedom(c_y, c_x);
+
+        /* Attempt to find a better grid */
+        for (i = 0; i < 8; i++)
+        {
+            int x = c_x + ddx_ddd[i];
+            int y = c_y + ddy_ddd[i];
+
+            /* Access the grid */
+            borg_grid *ag = &borg_grids[y][x];
+
+            /* Cant if confused: no way to predict motion */
+            if (borg_skill[BI_ISCONFUSED]) continue;
+
+            /* Skip walls/doors */
+            if (!borg_cave_floor_grid(ag)) continue;
+
+            /* Skip monster grids */
+            if (ag->kill) continue;
+
+            /* Mega-Hack -- skip stores XXX XXX XXX */
+            if ((ag->feat >= FEAT_SHOP_HEAD) && (ag->feat <= FEAT_SHOP_TAIL)) continue;
+
+            /* Mega-Hack -- skip traps XXX XXX XXX */
+            if ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL)) continue;
+
+            /* Extract the danger there */
+            k = borg_danger(y, x, 2, TRUE);
+
+			/* Skip this grid if danger is higher than my HP.
+			 * Take my chances with fighting.
+			 */
+			if (k >= avoidance * 9 / 10) continue;
+
+            /* Skip higher danger */
+            /* note: if surrounded, then b_k has been lowered. */
+            if (b_k < k) continue;
+
+			/* Record the danger of this prefered grid */
+			g_k = k;
+
+            /* Check the freedom there */
+            f = borg_freedom(y, x);
+
+            /* Danger is the same */
+            if (b_k == k)
+            {
+                /* If I am low level, reward backing-up if safe */
+                if (borg_skill[BI_CLEVEL] <= 5 && borg_skill[BI_CDEPTH] &&
+                   (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] ||
+                    borg_skill[BI_CURSP] < borg_skill[BI_MAXSP]))
+                {
+                        /* do consider the retreat */
+                }
+                else
+                {
+                    /* Freedom of my grid is better than the next grid
+                     * so stay put and fight.
+                     */
+                    if (b_f > f || borg_skill[BI_CDEPTH] >= 85) continue;
+                }
+            }
+
+            /* Save the info */
+            b_i = i; b_k = k; b_f = f;
+        }
+
+        /* Back away */
+        if (b_i >= 0)
+        {
+            /* Hack -- set goal */
+            g_x = c_x + ddx_ddd[b_i];
+            g_y = c_y + ddy_ddd[b_i];
+
+            /* Note */
+            borg_note(format("# Backing up to %d,%d (%d > %d)",
+                             g_x, g_y, p, g_k));
+
+            /* Back away from danger */
+            borg_keypress(I2D(ddd[b_i]));
+
+            /* Success */
+            return (TRUE);
+        }
+
+    }
+
+
+    /*** Cures ***/
+
+    /* cure confusion, second check, first (slightly different) in borg_heal */
+    if (borg_skill[BI_ISCONFUSED])
+    {
+        if (borg_skill[BI_MAXHP]-borg_skill[BI_CURHP] >= 300 &&
+            (borg_quaff_potion(SV_POTION_HEALING) ||
+             borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+             borg_quaff_potion(SV_POTION_LIFE)))
+        {
+            borg_note("# Healing.  Confusion.");
+            return (TRUE);
+        }
+        if (borg_eat_food(SV_FOOD_CURE_CONFUSION) ||
+            borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+            borg_quaff_crit(FALSE) ||
+            borg_quaff_potion(SV_POTION_HEALING) ||
+            borg_use_staff_fail(SV_STAFF_HEALING))
+        {
+            borg_note("# Healing.  Confusion.");
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure fear when afraid */
+    if (borg_skill[BI_ISAFRAID] &&
+       (rand_int(100) < 70 ||
+        (borg_class == CLASS_WARRIOR && borg_skill[BI_AMISSILES] <=0)))
+    {
+        if (borg_prayer(0, 3) ||
+            borg_quaff_potion(SV_POTION_BOLDNESS) ||
+            borg_quaff_potion(SV_POTION_HEROISM) ||
+            borg_quaff_potion(SV_POTION_BERSERK_STRENGTH) ||
+            borg_spell_fail(7, 1, 25) || /* berserk */
+            borg_spell_fail(7, 0, 25) || /* hero */
+            borg_activate_artifact(ACT_REM_FEAR_POIS,INVEN_FEET) )
+        {
+            return (TRUE);
+        }
+    }
+
+
+    /*** Note impending death XXX XXX XXX ***/
+
+    /* Flee from low hit-points */
+    if (((borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 3) ||
+        ((borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 2) && borg_skill[BI_CURHP] < (borg_skill[BI_CLEVEL] *3) )) &&
+        (borg_skill[BI_ACCW] < 3) &&
+        (borg_skill[BI_AHEAL] < 1))
+    {
+        /* Flee from low hit-points */
+        if (borg_skill[BI_CDEPTH] && (rand_int(100) < 25))
+        {
+            /* Start leaving */
+            if (!goal_leaving)
+            {
+                /* Flee */
+                borg_note("# Leaving (low hit-points)");
+
+                /* Start leaving */
+                goal_leaving = TRUE;
+
+            }
+            /* Start fleeing */
+            if (!goal_fleeing)
+            {
+                /* Flee */
+                borg_note("# Fleeing (low hit-points)");
+
+                /* Start fleeing */
+                goal_fleeing = TRUE;
+            }
+
+        }
+    }
+
+    /* Flee from bleeding wounds or poison and no heals */
+    if ((borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) && (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 2) )
+    {
+        /* Flee from bleeding wounds */
+        if (borg_skill[BI_CDEPTH] && (rand_int(100) < 25))
+        {
+            /* Start leaving */
+            if (!goal_leaving)
+            {
+                /* Flee */
+                borg_note("# Leaving (bleeding/posion)");
+
+                /* Start leaving */
+                goal_leaving = TRUE;
+            }
+
+            /* Start fleeing */
+            if (!goal_fleeing)
+            {
+                /* Flee */
+                borg_note("# Fleeing (bleeding/poison)");
+
+                /* Start fleeing */
+                goal_fleeing = TRUE;
+            }
+        }
+    }
+
+    /* Emergency check on healing.  Borg_heal has already been checked but
+     * but we did not use our ez_heal potions.  All other attempts to save
+     * ourself have failed.  Use the ez_heal if I have it.
+     */
+    if ((borg_skill[BI_CURHP] < borg_skill[BI_MAXHP]/10 || /* dangerously low HP */
+        (p > borg_skill[BI_CURHP] * 2 && /* extreme danger -AND-*/
+         (borg_skill[BI_ATELEPORT] + borg_skill[BI_AESCAPE] <= 2 && borg_skill[BI_CURHP] < borg_skill[BI_MAXHP]/4)) || /* low on escapes */
+         (p > borg_skill[BI_CURHP] && borg_skill[BI_AEZHEAL] > 5 && borg_skill[BI_CURHP] < borg_skill[BI_MAXHP]/4) || /* moderate danger, lots of heals */
+         (p > borg_skill[BI_CURHP] * 12/10 && borg_skill[BI_MAXHP] - borg_skill[BI_CURHP] >= 400 && borg_fighting_unique && borg_skill[BI_CDEPTH] >= 85)) && /* moderate danger, unique, deep */
+        (borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+          borg_quaff_potion(SV_POTION_HEALING) ||
+          borg_quaff_potion(SV_POTION_LIFE) ))
+    {
+        borg_note("# Using reserve EZ_Heal.");
+        return (TRUE);
+    }
+
+    /* Hack -- use "recall" to flee if possible */
+    if (goal_fleeing && borg_skill[BI_CDEPTH] >= 1 && (borg_recall()))
+    {
+        /* Note */
+        borg_note("# Fleeing the level (recall)");
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* If I am waiting for recall,and in danger, buy time with
+     * phase and cure_anythings.
+     */
+     if (goal_recalling && (p > avoidance * 2))
+     {
+         if (!borg_skill[BI_ISCONFUSED] && !borg_skill[BI_ISBLIND] && borg_skill[BI_MAXSP] > 60 &&
+              borg_skill[BI_CURSP] < (borg_skill[BI_CURSP] / 4) && borg_quaff_potion(SV_POTION_RESTORE_MANA))
+         {
+                 borg_note("# Buying time waiting for Recall.(1)");
+                 return (TRUE);
+         }
+
+         if (borg_read_scroll(SV_SCROLL_PHASE_DOOR) ||
+             borg_spell_fail(0, 2, 30) ||
+             borg_prayer_fail(4, 0, 30) ||
+             borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+             borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+             borg_zap_rod(SV_ROD_HEALING))
+             {
+                 borg_note("# Buying time waiting for Recall.(2)");
+                 return (TRUE);
+             }
+
+         if ((borg_skill[BI_MAXHP] - borg_skill[BI_CURHP] < 100) &&
+             (borg_quaff_crit(TRUE) ||
+              borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+              borg_quaff_potion(SV_POTION_CURE_LIGHT)))
+             {
+                 borg_note("# Buying time waiting for Recall.(3)");
+                 return (TRUE);
+             }
+
+         if ((borg_skill[BI_MAXHP] - borg_skill[BI_CURHP] > 150) &&
+             (borg_quaff_potion(SV_POTION_HEALING) ||
+              borg_quaff_potion(SV_POTION_STAR_HEALING) ||
+              borg_quaff_potion(SV_POTION_LIFE) ||
+              borg_quaff_crit(TRUE) ||
+              borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+              borg_quaff_potion(SV_POTION_CURE_LIGHT)))
+             {
+                 borg_note("# Buying time waiting for Recall.(4)");
+                 return (TRUE);
+             }
+
+     }
+
+
+
+    /* if I am gonna die next round, and I have no way to escape
+     * use the unknown stuff (if I am low level).
+     */
+    if (p > (borg_skill[BI_CURHP] * 4) && borg_skill[BI_CLEVEL] < 20 && !borg_skill[BI_MAXSP])
+    {
+        if (borg_use_unknown()||
+           borg_read_unknown() ||
+           borg_quaff_unknown() ||
+           borg_eat_unknown()) return (TRUE);
+
+    }
+
+
+
+    /* Nothing */
+    return (FALSE);
+}
+
+
+/*
+ * New method for handling attacks, missiles, and spells
+ *
+ * Every turn, we evaluate every known method of causing damage
+ * to monsters, and evaluate the "reward" inherent in each of
+ * the known methods which is usable at that time, and then
+ * we actually use whichever method, if any, scores highest.
+ *
+ * For each attack, we need a function which will determine the best
+ * possible result of using that attack, and return its value.  Also,
+ * if requested, the function should actually perform the action.
+ *
+ * Note that the functions should return zero if the action is not
+ * usable, or if the action is not useful.
+ *
+ * These functions need to apply some form of "cost" evaluation, to
+ * prevent the use of expensive spells with minimal reward.  Also,
+ * we should always prefer attacking by hand to using spells if the
+ * damage difference is "small", since there is no "cost" in making
+ * a physical attack.
+ *
+ * We should take account of "spell failure", as well as "missile
+ * missing" and "blow missing" probabilities.
+ *
+ * Note that the functions may store local state information when
+ * doing a "simulation" and then they can use this information if
+ * they are asked to implement their strategy.
+ *
+ * There are several types of damage inducers:
+ *
+ *   Attacking physically
+ *   Launching missiles
+ *   Throwing objects
+ *   Casting spells
+ *   Praying prayers
+ *   Using wands
+ *   Using rods
+ *   Using staffs
+ *   Using scrolls
+ *   Activating Artifacts
+ *   Activate Dragon Armour
+ */
+enum
+{
+    BF_LAUNCH_NORMAL,
+    BF_LAUNCH_SEEKER,
+    BF_LAUNCH_SILVER,
+    BF_LAUNCH_FLAME,
+    BF_LAUNCH_FROST,
+    BF_LAUNCH_ANIMAL,
+    BF_LAUNCH_UNDEAD,
+    BF_LAUNCH_DEMON,
+    BF_LAUNCH_ORC,
+    BF_LAUNCH_GIANT,
+    BF_LAUNCH_TROLL, /* 10 */
+    BF_LAUNCH_DRAGON,
+    BF_LAUNCH_EVIL,
+    BF_LAUNCH_WOUNDING,
+	BF_LAUNCH_VENOM,
+	BF_LAUNCH_HOLY,
+
+    BF_OBJECT,
+    BF_THRUST,
+    BF_SPELL_MAGIC_MISSILE,
+    BF_SPELL_MAGIC_MISSILE_RESERVE,
+    BF_SPELL_STINK_CLOUD,
+    BF_SPELL_ELEC_BOLT,
+    BF_SPELL_LITE_BEAM,
+    BF_SPELL_COLD_BOLT,
+    BF_SPELL_STONE_TO_MUD,
+    BF_SPELL_FIRE_BOLT,
+    BF_SPELL_POLYMORPH,
+    BF_SPELL_ACID_BOLT,
+    BF_SPELL_SLOW_MONSTER,
+    BF_SPELL_COLD_BALL,
+    BF_SPELL_SLEEP_III,
+    BF_SPELL_FIRE_BALL,
+	BF_SPELL_SHOCK_WAVE,
+	BF_SPELL_EXPLOSION,
+    BF_SPELL_CLOUD_KILL,
+    BF_SPELL_CONFUSE_MONSTER,
+    BF_SPELL_ACID_BALL,
+    BF_SPELL_COLD_STORM,
+    BF_SPELL_METEOR_STORM,
+	BF_SPELL_RIFT,
+	BF_SPELL_BEDLAM,
+	BF_SPELL_REND_SOUL,
+	BF_SPELL_CHAOS_STRIKE,
+    BF_SPELL_MANA_STORM,
+
+
+    BF_PRAYER_BLIND_CREATURE,
+    BF_PRAYER_SANCTUARY,
+    BF_PRAYER_HOLY_ORB_BALL,
+    BF_PRAYER_DISP_UNDEAD1,
+    BF_PRAYER_DISP_EVIL1,
+    BF_PRAYER_HOLY_WORD,
+    BF_PRAYER_DISP_UNDEAD2,
+    BF_PRAYER_DISP_EVIL2,
+    BF_PRAYER_DRAIN_LIFE, /* 50 */
+
+    BF_ROD_ELEC_BOLT,
+    BF_ROD_COLD_BOLT,
+    BF_ROD_ACID_BOLT,
+    BF_ROD_FIRE_BOLT,
+    BF_ROD_LITE_BEAM,
+    BF_ROD_DRAIN_LIFE,
+    BF_ROD_ELEC_BALL,
+    BF_ROD_COLD_BALL,
+    BF_ROD_ACID_BALL,
+    BF_ROD_FIRE_BALL, /* 60 */
+    BF_ROD_SLOW_MONSTER,
+    BF_ROD_SLEEP_MONSTER,
+
+    BF_STAFF_SLEEP_MONSTERS,
+    BF_STAFF_SLOW_MONSTERS,
+    BF_STAFF_DISPEL_EVIL,
+    BF_STAFF_POWER,
+    BF_STAFF_HOLINESS,
+
+    BF_WAND_MAGIC_MISSILE,
+    BF_WAND_ELEC_BOLT,
+    BF_WAND_COLD_BOLT, /* 70 */
+    BF_WAND_ACID_BOLT,
+    BF_WAND_FIRE_BOLT,
+    BF_WAND_SLOW_MONSTER,
+    BF_WAND_SLEEP_MONSTER,
+    BF_WAND_CONFUSE_MONSTER,
+    BF_WAND_FEAR_MONSTER,
+    BF_WAND_ANNIHILATION,
+    BF_WAND_DRAIN_LIFE,
+    BF_WAND_LITE_BEAM,
+    BF_WAND_STINKING_CLOUD, /* 80 */
+    BF_WAND_ELEC_BALL,
+    BF_WAND_COLD_BALL,
+    BF_WAND_ACID_BALL,
+    BF_WAND_FIRE_BALL,
+    BF_WAND_WONDER,
+    BF_WAND_DRAGON_COLD,
+    BF_WAND_DRAGON_FIRE,
+
+    BF_ACT_FIRE1,
+    BF_ACT_FIRE2,
+    BF_ACT_FIRE3, /* 90 */
+    BF_ACT_FROST1,
+    BF_ACT_FROST2,
+    BF_ACT_FROST3,
+    BF_ACT_FROST4,
+    BF_ACT_FROST5,
+    BF_ACT_DRAIN_LIFE1,
+    BF_ACT_DRAIN_LIFE2,
+    BF_ACT_STINKING_CLOUD,
+    BF_ACT_CONFUSE,
+    BF_ACT_ARROW,
+    BF_ACT_MISSILE,
+    BF_ACT_SLEEP,
+    BF_ACT_LIGHTNING_BOLT,
+    BF_ACT_ACID1,
+    BF_ACT_DISP_EVIL,
+    BF_ACT_ELEC2,
+	BF_ACT_MANA_BOLT,
+
+	BF_RING_ACID,
+	BF_RING_FIRE,
+	BF_RING_ICE,
+	BF_RING_LIGHTNING,
+
+    BF_DRAGON_BLUE,
+    BF_DRAGON_WHITE,
+    BF_DRAGON_BLACK,
+    BF_DRAGON_GREEN,
+    BF_DRAGON_RED,
+    BF_DRAGON_MULTIHUED,
+    BF_DRAGON_BRONZE,
+    BF_DRAGON_GOLD,
+    BF_DRAGON_CHAOS,
+    BF_DRAGON_LAW,
+    BF_DRAGON_BALANCE,
+    BF_DRAGON_SHINING,
+    BF_DRAGON_POWER,
+    BF_MAX
+};
+
+
+
+/*
+ * Guess how much damage a physical attack will do to a monster
+ */
+static int borg_thrust_damage_one(int i)
+{
+    int dam;
+    int mult;
+
+    borg_kill *kill;
+
+    monster_race *r_ptr;
+
+    borg_item *item;
+
+    int chance;
+
+    /* Examine current weapon */
+    item = &borg_items[INVEN_WIELD];
+
+    /* Monster record */
+    kill = &borg_kills[i];
+
+    /* Monster race */
+    r_ptr = &r_info[kill->r_idx];
+
+    /* Damage */
+    dam = (item->dd * (item->ds + 1) / 2);
+
+    /* here is the place for slays and such */
+    mult = 1;
+
+    if (((borg_skill[BI_WS_ANIMAL]) && (r_ptr->flags3 & RF3_ANIMAL)) ||
+       ((borg_skill[BI_WS_EVIL]) && (r_ptr->flags3 & RF3_EVIL)))
+        mult = 2;
+    if (((borg_skill[BI_WS_UNDEAD]) && (r_ptr->flags3 & RF3_ANIMAL)) ||
+       ((borg_skill[BI_WS_DEMON]) && (r_ptr->flags3 & RF3_DEMON)) ||
+       ((borg_skill[BI_WS_ORC]) && (r_ptr->flags3 & RF3_ORC)) ||
+       ((borg_skill[BI_WS_TROLL]) && (r_ptr->flags3 & RF3_TROLL)) ||
+       ((borg_skill[BI_WS_GIANT]) && (r_ptr->flags3 & RF3_GIANT)) ||
+       ((borg_skill[BI_WS_DRAGON]) && (r_ptr->flags3 & RF3_DRAGON)) ||
+       ((borg_skill[BI_WB_ACID]) && !(r_ptr->flags3 & RF3_IM_ACID)) ||
+       ((borg_skill[BI_WB_FIRE]) && !(r_ptr->flags3 & RF3_IM_FIRE)) ||
+       ((borg_skill[BI_WB_COLD]) && !(r_ptr->flags3 & RF3_IM_COLD)) ||
+       ((borg_skill[BI_WB_POIS]) && !(r_ptr->flags3 & RF3_IM_POIS)) ||
+       ((borg_skill[BI_WB_ELEC]) && !(r_ptr->flags3 & RF3_IM_ELEC)))
+        mult = 3;
+    if (((borg_skill[BI_WK_UNDEAD]) && (r_ptr->flags3 & RF3_ANIMAL)) ||
+       ((borg_skill[BI_WK_DEMON]) && (r_ptr->flags3 & RF3_DEMON)) ||
+       ((borg_skill[BI_WK_DRAGON]) && (r_ptr->flags3 & RF3_DRAGON)))
+        mult = 5;
+
+    /* add the multiplier */
+        dam *= mult;
+
+    /* add weapon bonuses */
+    dam += item->to_d;
+
+    /* add player bonuses */
+    dam += borg_skill[BI_TODAM];
+
+    /* multiply the damage for the whole round of attacks */
+    dam *= borg_skill[BI_BLOWS];
+
+    /* reduce for % chance to hit (AC) */
+    chance = (borg_skill[BI_THN] + ((borg_skill[BI_TOHIT] + item->to_h) * 3));
+    if ((r_ptr->ac * 3 / 4) > 0)
+        chance = (chance * 100) / (r_ptr->ac * 3 / 4);
+
+    /* 5% automatic success/fail */
+    if (chance > 95) chance = 95;
+    if (chance < 5) chance = 5;
+
+    /* add 20% to chance to give a bit more wieght to weapons */
+    if (borg_skill[BI_CLEVEL] > 15) chance += 20;
+
+    /* Mages with Mana do not get that bonus, they should cast */
+    if (borg_class == CLASS_MAGE && borg_skill[BI_CURSP] > 1) chance -= 20;
+
+	/* reduce damage by the % chance to hit */
+    dam = (dam * chance) / 100;
+
+	/* Try to place a minimal amount of damage */
+	if (dam <= 0) dam = 1;
+
+    /* Limit damage to twice maximal hitpoints */
+    if (dam > kill->power * 2) dam = kill->power * 2;
+
+    /* Reduce the damage if a mage, they should not melee if they can avoid it */
+    if (borg_class == CLASS_MAGE && borg_skill[BI_MAXCLEVEL] < 40 &&
+    	borg_skill[BI_CURSP] > 1) dam = (dam * 8 / 10) + 1;
+
+    /*
+     * Enhance the preceived damage on Uniques.  This way we target them
+     * Keep in mind that he should hit the uniques but if he has a
+     * x5 great bane of dragons, he will tend attack the dragon since the
+     * precieved (and actual) damage is higher.  But don't select
+     * the town uniques (maggot does no damage)
+     *
+     */
+    if ((r_ptr->flags1 & RF1_UNIQUE) && borg_skill[BI_CDEPTH] >=1) dam += (dam * 5);
+
+    /* Hack -- ignore Maggot until later.  Player will chase Maggot
+     * down all accross the screen waking up all the monsters.  Then
+     * he is stuck in a comprimised situation.
+     */
+    if ((r_ptr->flags1 & RF1_UNIQUE) && borg_skill[BI_CDEPTH] ==0)
+    {
+        dam = dam * 2/3;
+
+        /* Dont hunt maggot until later */
+        if (borg_skill[BI_CLEVEL] < 5) dam = 0;
+    }
+
+    /* give a small bonus for whacking a breeder */
+    if (r_ptr->flags2 & RF2_MULTIPLY)
+        dam = (dam * 3/2);
+
+    /* Enhance the preceived damgage to summoner in order to influence the
+     * choice of targets.
+     */
+    if ( (r_ptr->flags6 & RF6_S_KIN) ||
+         (r_ptr->flags6 & RF6_S_HI_DEMON) ||
+         (r_ptr->flags6 & RF6_S_MONSTER) ||
+         (r_ptr->flags6 & RF6_S_MONSTERS) ||
+         (r_ptr->flags6 & RF6_S_ANIMAL) ||
+         (r_ptr->flags6 & RF6_S_SPIDER) ||
+         (r_ptr->flags6 & RF6_S_HOUND) ||
+         (r_ptr->flags6 & RF6_S_HYDRA) ||
+         (r_ptr->flags6 & RF6_S_ANGEL) ||
+         (r_ptr->flags6 & RF6_S_DEMON) ||
+         (r_ptr->flags6 & RF6_S_UNDEAD) ||
+         (r_ptr->flags6 & RF6_S_DRAGON) ||
+         (r_ptr->flags6 & RF6_S_HI_UNDEAD) ||
+         (r_ptr->flags6 & RF6_S_WRAITH) ||
+         (r_ptr->flags6 & RF6_S_UNIQUE) )
+       dam += ((dam * 3)/2);
+
+	/*
+	 * Apply massive damage bonus to Questor monsters to
+	 * encourage borg to strike them.
+	 */
+    if (r_ptr->flags1 & RF1_QUESTOR) dam += (dam * 5);
+
+    /* Damage */
+    return (dam);
+}
+
+
+
+/*
+ * Simulate/Apply the optimal result of making a physical attack
+ */
+extern int borg_attack_aux_thrust(void)
+{
+    int p, dir;
+
+    int i, b_i = -1;
+    int d, b_d = -1;
+
+    borg_grid *ag;
+
+    borg_kill *kill;
+
+    /* Too afraid to attack */
+    if (borg_skill[BI_ISAFRAID]) return (0);
+
+
+    /* Examine possible destinations */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        int x = borg_temp_x[i];
+        int y = borg_temp_y[i];
+
+        /* Require "adjacent" */
+        if (distance(c_y, c_x, y, x) > 1) continue;
+
+        /* Acquire grid */
+        ag = &borg_grids[y][x];
+
+        /* Calculate "average" damage */
+        d = borg_thrust_damage_one(ag->kill);
+
+        /* No damage */
+        if (d <= 0) continue;
+
+        /* Obtain the monster */
+        kill = &borg_kills[ag->kill];
+
+        /* Hack -- avoid waking most "hard" sleeping monsters */
+        if (!kill->awake && (d <= kill->power) )
+        {
+            /* Calculate danger */
+            borg_full_damage = TRUE;
+            p = borg_danger_aux(y, x, 1, ag->kill, TRUE);
+            borg_full_damage = FALSE;
+
+            if (p > avoidance / 2)
+                continue;
+        }
+
+        /* Hack -- ignore sleeping town monsters */
+        if (!borg_skill[BI_CDEPTH] && !kill->awake) continue;
+
+
+        /* Calculate "danger" to player */
+        borg_full_damage = TRUE;
+        p = borg_danger_aux(c_y, c_x, 2, ag->kill, TRUE);
+        borg_full_damage = FALSE;
+
+        /* Reduce "bonus" of partial kills */
+        if (d <= kill->power) p = p / 10;
+
+        /* Add the danger to the damage */
+        d += p;
+
+        /* Ignore lower damage */
+        if ((b_i >= 0) && (d < b_d)) continue;
+
+        /* Save the info */
+        b_i = i;
+        b_d = d;
+    }
+
+    /* Nothing to attack */
+    if (b_i < 0) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (b_d);
+
+    /* Save the location */
+    g_x = borg_temp_x[b_i];
+    g_y = borg_temp_y[b_i];
+
+    ag = &borg_grids[g_y][g_x];
+    kill= &borg_kills[ag->kill];
+
+    /* Note */
+    borg_note(format("# Facing %s at (%d,%d) who has %d Hit Points.",(r_name + r_info[kill->r_idx].name), g_y,g_x,kill->power));
+    borg_note(format("# Attacking with weapon '%s'",
+                     borg_items[INVEN_WIELD].desc));
+
+    /* Get a direction for attacking */
+    dir = borg_extract_dir(c_y, c_x, g_y, g_x);
+
+    /* Attack the grid */
+    borg_keypress('+');
+    borg_keypress(I2D(dir));
+
+    /* Success */
+    return (b_d);
+}
+
+
+
+
+/*
+ * Target a location.  Can be used alone or at "Direction?" prompt.
+ *
+ * Warning -- This will only work for locations on the current panel
+ */
+bool borg_target(int y, int x)
+{
+    int x1, y1, x2, y2;
+
+    borg_grid *ag;
+    borg_kill *kill;
+
+    ag = &borg_grids[y][x];
+    kill = &borg_kills[ag->kill];
+
+
+    /* Log */
+    /* Report a little bit */
+    if (ag->kill)
+    {
+       borg_note(format("# Targeting %s who has %d Hit Points (%d,%d).",(r_name + r_info[kill->r_idx].name), kill->power, y, x));
+    }
+    else
+    {
+        borg_note(format("# Targetting location (%d,%d)", y, x));
+    }
+
+    /* Target mode */
+    borg_keypress('*');
+
+    /* Target a location */
+    borg_keypress('p');
+
+    /* Determine "path" */
+    x1 = c_x;
+    y1 = c_y;
+    x2 = x;
+    y2 = y;
+
+    /* Move to the location (diagonals) */
+    for (; (y1 < y2) && (x1 < x2); y1++, x1++) borg_keypress('3');
+    for (; (y1 < y2) && (x1 > x2); y1++, x1--) borg_keypress('1');
+    for (; (y1 > y2) && (x1 < x2); y1--, x1++) borg_keypress('9');
+    for (; (y1 > y2) && (x1 > x2); y1--, x1--) borg_keypress('7');
+
+    /* Move to the location */
+    for (; y1 < y2; y1++) borg_keypress('2');
+    for (; y1 > y2; y1--) borg_keypress('8');
+    for (; x1 < x2; x1++) borg_keypress('6');
+    for (; x1 > x2; x1--) borg_keypress('4');
+
+    /* Select the target */
+    borg_keypress('5');
+
+	/* Carry these variables to be used on reporting spell
+	 * pathway
+	 */
+	borg_target_y = y;
+	borg_target_x = x;
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Mark spot along the target path a wall.
+ * This will mark the unknown squares as a wall.  This might not be
+ * the wall we ran into but also might be.
+ *
+ * Warning -- This will only work for locations on the current panel
+ */
+bool borg_target_unknown_wall(int y, int x)
+{
+    int n_x, n_y;
+    bool found = FALSE;
+    bool y_hall = FALSE;
+    bool x_hall = FALSE;
+
+    borg_note(format("# Perhaps wall near targetted location (%d,%d)", y, x));
+
+    /* Determine "path" */
+    n_x = c_x;
+    n_y = c_y;
+
+    /* check for 'in a hall' x axis */
+    /* This check is for this: */
+    /*
+     *      x
+     *    ..@..
+     *      x
+     *
+     * 'x' being 'not a floor' and '.' being a floor.
+     *
+     * We would like to know if in a hall so we can place
+     * the suspect wall off the hallway path.
+     * like this:######x  P
+     * ........@....
+     * ##################
+     * The shot may miss and we want the borg to guess the
+     * wall to be at the X instead of first unkown grid which
+     * is 3 west and 1 south of the X.
+     */
+
+    if ((borg_grids[c_y+1][c_x].feat == FEAT_FLOOR &&
+        borg_grids[c_y+2][c_x].feat == FEAT_FLOOR &&
+        borg_grids[c_y-1][c_x].feat == FEAT_FLOOR &&
+        borg_grids[c_y-2][c_x].feat == FEAT_FLOOR) &&
+        (borg_grids[c_y][c_x+1].feat != FEAT_FLOOR &&
+         borg_grids[c_y][c_x-1].feat != FEAT_FLOOR))
+        x_hall = TRUE;
+
+    /* check for 'in a hall' y axis.
+     * Again, we want to place the suspected wall off our
+     * hallway.
+     */
+    if ((borg_grids[c_y][c_x+1].feat == FEAT_FLOOR &&
+        borg_grids[c_y][c_x+2].feat == FEAT_FLOOR &&
+        borg_grids[c_y][c_x-1].feat == FEAT_FLOOR &&
+        borg_grids[c_y][c_x-2].feat == FEAT_FLOOR) &&
+        (borg_grids[c_y+1][c_x].feat != FEAT_FLOOR &&
+         borg_grids[c_y-1][c_x].feat != FEAT_FLOOR))
+        y_hall = TRUE;
+
+    while (1)
+    {
+        if (borg_grids[n_y][n_x].feat == FEAT_NONE &&
+            ((n_y != c_y) || !y_hall) &&
+            ((n_x != c_x) || !x_hall))
+        {
+            borg_note(format("# Guessing wall (%d,%d) near target (%d,%d)", n_y, n_x, y, x));
+            borg_grids[n_y][n_x].feat = FEAT_WALL_SOLID;
+            found = TRUE;
+            return (found); /* not sure... should we return here?
+                             maybe should mark ALL unknowns in path... */
+        }
+        if (n_x == x && n_y == y)
+            break;
+
+        /* Calculate the new location */
+        mmove2(&n_y, &n_x, c_y, c_x, y, x);
+    }
+
+    return found;
+}
+
+
+/*
+ * Guess how much damage a spell attack will do to a monster
+ *
+ * We only handle the "standard" damage types.
+ *
+ * We are paranoid about monster resistances
+ *
+ * He tends to waste all of his arrows on a monsters immediately adjacent
+ * to him.  Then he has no arrows for the rest of the level.  We will
+ * decrease the damage if the monster is adjacent and we are getting low
+ * on missiles.
+ *
+ * We will also decrease the value of the missile attack on breeders or
+ * high clevel borgs town scumming.
+ */
+int borg_launch_damage_one(int i, int dam, int typ)
+{
+    int p1, p2 = 0;
+	int j;
+    bool borg_use_missile = FALSE;
+	int ii;
+	int vault_grids = 0;
+	int x, y;
+	int k;
+	bool gold_eater = FALSE;
+
+    borg_kill *kill;
+    borg_grid *ag;
+
+    monster_race *r_ptr;
+
+    /* Monster record */
+    kill = &borg_kills[i];
+
+    /* all danger checks are with maximal damage */
+    borg_full_damage = TRUE;
+
+    /* Monster race */
+    r_ptr = &r_info[kill->r_idx];
+
+	/* Very quickly look for gold eating monsters */
+    for (k = 0; k < 4; k++)
+    {
+        monster_blow *b_ptr = &r_ptr->blow[k];
+
+        /* gold eater */
+        if (b_ptr->effect == RBE_EAT_GOLD) gold_eater = TRUE;
+	}
+
+    /* Analyze the damage type */
+    switch (typ)
+    {
+        /* Magic Missile */
+        case GF_MISSILE:
+        break;
+
+        /* Standard Arrow */
+        case GF_ARROW:
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Seeker Arrow/Bolt */
+        case GF_ARROW_SEEKER:
+        if (!(r_ptr->flags1 & RF1_UNIQUE) &&
+             (kill->level < borg_skill[BI_CLEVEL])) dam /= 3;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Silver Arrow/Bolt */
+        case GF_ARROW_SILVER:
+/* No code in 3.0 for this
+ *      if (r_ptr->flags3 & RF3_EVIL) dam *= 3;
+ *      if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+ *          !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+ */
+        break;
+
+        /* Arrow of Flame*/
+        case GF_ARROW_FLAME:
+        if (!(r_ptr->flags3 & RF3_IM_FIRE)) dam *= 3;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of Frost*/
+        case GF_ARROW_FROST:
+        if (!(r_ptr->flags3 & RF3_IM_COLD)) dam *= 3;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of Hurt Animal*/
+        case GF_ARROW_ANIMAL:
+        if (r_ptr->flags3 & RF3_ANIMAL) dam *= 2;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of hurt evil */
+        case GF_ARROW_EVIL:
+        if (r_ptr->flags3 & RF3_EVIL) dam *= 2;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of slay undead*/
+        case GF_ARROW_UNDEAD:
+        if (r_ptr->flags3 & RF3_UNDEAD) dam *= 2;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of slay demon*/
+        case GF_ARROW_DEMON:
+        if (r_ptr->flags3 & RF3_DEMON) dam *= 2;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of slay orc*/
+        case GF_ARROW_ORC:
+        if (r_ptr->flags3 & RF3_ORC) dam *= 2;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of slay troll*/
+        case GF_ARROW_TROLL:
+        if (r_ptr->flags3 & RF3_TROLL) dam *= 2;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of slay giant*/
+        case GF_ARROW_GIANT:
+        if (r_ptr->flags3 & RF3_GIANT) dam *= 2;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of slay dragon*/
+        case GF_ARROW_DRAGON:
+        if (r_ptr->flags3 & RF3_DRAGON) dam *= 3;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of Wounding*/
+        case GF_ARROW_WOUNDING:
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of Poison Branding*/
+        case GF_ARROW_POISON:
+        if (!(r_ptr->flags3 & RF3_IM_POIS)) dam *= 3;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+        /* Arrow of Holy Might*/
+        case GF_ARROW_HOLY:
+        if (r_ptr->flags3 & RF3_EVIL) dam *= 3;
+        if (distance(c_y, c_x,kill->y, kill->x) == 1 &&
+            !(r_ptr->flags1 & RF1_UNIQUE)) dam /= 5;
+        break;
+
+
+        /* Pure damage */
+        case GF_MANA:
+        /* Reduce damage slightly if not fighting unique. */
+        /* Should cut down on some mana use. */
+        if (!borg_fighting_unique || borg_has[266] < 3)
+            dam = dam * 8 / 10;
+        if (borg_fighting_unique && borg_has[266] > 7)
+            dam *= 2;
+        break;
+
+        /* Meteor -- powerful magic missile */
+        case GF_METEOR:
+        break;
+
+
+        /* Acid */
+        case GF_ACID:
+        if (r_ptr->flags3 & RF3_IM_ACID) dam /= 9;
+        break;
+
+        /* Electricity */
+        case GF_ELEC:
+        if (r_ptr->flags3 & RF3_IM_ELEC) dam /= 9;
+        break;
+
+        /* Fire damage */
+        case GF_FIRE:
+        if (r_ptr->flags3 & RF3_IM_FIRE) dam /= 9;
+        break;
+
+        /* Cold */
+        case GF_COLD:
+        if (r_ptr->flags3 & RF3_IM_COLD) dam /= 9;
+        break;
+
+        /* Poison */
+        case GF_POIS:
+        if (r_ptr->flags3 & RF3_IM_POIS) dam /= 9;
+        break;
+
+        /* Ice */
+        case GF_ICE:
+        if (r_ptr->flags3 & RF3_IM_COLD) dam /= 9;
+        break;
+
+
+        /* Holy Orb */
+        case GF_HOLY_ORB:
+        if (r_ptr->flags3 & RF3_EVIL) dam *= 2;
+        break;
+
+        /* dispel undead */
+        case GF_DISP_UNDEAD:
+        if (!(r_ptr->flags3 & RF3_UNDEAD)) dam = 0;
+        break;
+
+        /*  Dispel Evil */
+        case GF_DISP_EVIL:
+        if (!(r_ptr->flags3 & RF3_EVIL)) dam = 0;
+        break;
+
+        /*  Holy Word */
+        case GF_HOLY_WORD:
+        if (!(r_ptr->flags3 & RF3_EVIL)) dam = 0;
+        break;
+
+
+        /* Weak Lite */
+        case GF_LITE_WEAK:
+        if (!(r_ptr->flags3 & RF3_HURT_LITE)) dam = 0;
+        break;
+
+
+        /* Drain Life */
+        case GF_OLD_DRAIN:
+        if (distance(c_y, c_x,kill->y, kill->x) == 1) dam /= 5;
+        if ((r_ptr->flags3 & RF3_UNDEAD) ||
+            (r_ptr->flags3 & RF3_DEMON) ||
+            (strchr("Egv", r_ptr->d_char)))
+        {
+            dam = 0;
+        }
+        break;
+
+        /* Stone to Mud */
+        case GF_KILL_WALL:
+        if (!(r_ptr->flags3 & RF3_HURT_ROCK)) dam = 0;
+        break;
+
+        /* New mage spell */
+        case GF_NETHER:
+        {
+            if (r_ptr->flags3 & RF3_UNDEAD)
+            {
+                dam = 0;
+            }
+            else if (r_ptr->flags4 & RF4_BR_NETH)
+            {
+                dam *= 3; dam /= 9;
+            }
+            else if (r_ptr->flags3 & RF3_EVIL)
+            {
+                dam /= 2;
+            }
+        }
+            break;
+
+        /* New mage spell */
+        case GF_CHAOS:
+        if (r_ptr->flags4 & RF4_BR_CHAO)
+        {
+			dam *=3; dam /= 9;
+        }
+		/* If the monster is Unique full damage ok.
+		 * Otherwise, polymorphing will reset HP
+		 */
+		if (!r_ptr->flags1 & RF1_UNIQUE) dam = 0;
+        break;
+
+        /* New mage spell */
+        case GF_GRAVITY:
+        if (r_ptr->flags4 & RF4_BR_GRAV)
+        {
+            dam *= 3; dam /= 9;
+        }
+        break;
+
+        /* New mage spell */
+        case GF_SHARD:
+        if (r_ptr->flags4 & RF4_BR_SHAR)
+        {
+            dam *= 3; dam /= 9;
+        }
+        break;
+
+        /* New mage spell */
+        case GF_SOUND:
+        if (r_ptr->flags4 & RF4_BR_SOUN)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        /* Weird attacks */
+        case GF_PLASMA:
+        if (r_ptr->flags4 & RF4_BR_PLAS)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_CONFUSION:
+        if (r_ptr->flags4 & RF4_BR_CONF)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_DISENCHANT:
+        if (r_ptr->flags4 & RF4_BR_DISE)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_NEXUS:
+        if (r_ptr->flags4 & RF4_BR_NEXU)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_FORCE:
+        if (r_ptr->flags4 & RF4_BR_WALL)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_INERTIA:
+        if (r_ptr->flags4 & RF4_BR_INER)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_TIME:
+        if (r_ptr->flags4 & RF4_BR_TIME)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_LITE:
+        if (r_ptr->flags4 & RF4_BR_LITE)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_DARK:
+        if (r_ptr->flags4 & RF4_BR_DARK)
+        {
+                dam *= 3; dam /= 9;
+        }
+        break;
+
+        case GF_WATER:
+        if (r_ptr->flags5 & RF5_BA_WATE)
+        {
+                dam *= 3; dam /= 9;
+        }
+        dam /= 2;
+        break;
+
+
+        /* Various */
+        case GF_OLD_HEAL:
+        case GF_OLD_CLONE:
+        case GF_OLD_SPEED:
+        case GF_DARK_WEAK:
+        case GF_KILL_DOOR:
+        case GF_KILL_TRAP:
+        case GF_MAKE_WALL:
+        case GF_MAKE_DOOR:
+        case GF_MAKE_TRAP:
+        case GF_AWAY_UNDEAD:
+        case GF_TURN_EVIL:
+        dam = 0;
+        break;
+
+        /* These spells which put the monster out of commission, we
+         * look at the danger of the monster prior to and after being
+         * put out of commission.  The difference is the damage.
+         * The following factors are considered when we
+         * consider the spell:
+         *
+         * 1. Is it already comprised by that spell?
+         * 2. Is it comprimised by another spell?
+         * 3. Does it resist the modality?
+         * 4. Will it make it's savings throw better than half the time?
+         * 5. We generally ignore these spells for breeders.
+         *
+         * The spell sleep II and sanctuary have a special consideration
+         * since the monsters must be adjacent to the player.
+         */
+
+        case GF_AWAY_ALL:
+		/* Teleport Other works differently.  Basically the borg
+		 * will keep a list of all the monsters in the line of
+		 * fire.  Then when he checks the danger, he will not
+		 * include those monsters.
+		 */
+
+        /* try not to teleport away uniques. These are the guys you are trying */
+        /* to kill! */
+        if (r_ptr->flags1 & RF1_UNIQUE)
+        {
+          	/* If this unique is causing the danger, get rid of it */
+          	if (dam > avoidance * 13/10 && borg_skill[BI_CDEPTH] <= 98)
+          	{
+          	  /* get rid of this unique by storing his info */
+			  borg_tp_other_n ++;
+          	  borg_tp_other_index[borg_tp_other_n] = i;
+          	  borg_tp_other_y[borg_tp_other_n] = kill->y;
+          	  borg_tp_other_x[borg_tp_other_n] = kill->x;
+          	}
+
+          	/* If fighting multiple uniques, get rid of one */
+          	else if (borg_fighting_unique >=2 && borg_fighting_unique <=8)
+          	{
+          	  /* get rid of one unique or both if they are in a beam-line */
+			  borg_tp_other_n ++;
+          	  borg_tp_other_index[borg_tp_other_n] = i;
+          	  borg_tp_other_y[borg_tp_other_n] = kill->y;
+          	  borg_tp_other_x[borg_tp_other_n] = kill->x;
+          	}
+          	/* Unique is adjacent to Borg */
+          	else if (borg_class == CLASS_MAGE &&
+          			 distance(c_y, c_x, kill->y, kill->x) <= 2)
+          	{
+          	  /* get rid of unique next to me */
+			  borg_tp_other_n ++;
+          	  borg_tp_other_index[borg_tp_other_n] = i;
+          	  borg_tp_other_y[borg_tp_other_n] = kill->y;
+          	  borg_tp_other_x[borg_tp_other_n] = kill->x;
+
+			}
+			/* Unique in a vault, get rid of it, clean vault */
+			else if (vault_on_level)
+			{
+				/* Scan grids adjacent to monster */
+				for (ii = 0; ii < 8; ii++)
+				{
+	            	x = kill->x + ddx_ddd[ii];
+	            	y = kill->y + ddy_ddd[ii];
+
+	            	/* Access the grid */
+	            	ag = &borg_grids[y][x];
+
+		        	/* Skip unknown grids (important) */
+		        	if (ag->feat == FEAT_NONE) continue;
+
+		        	/* Count adjacent Permas */
+		        	if (ag->feat == FEAT_PERM_INNER) vault_grids ++;
+				}
+
+				/* Near enough perma grids? */
+				if (vault_grids >= 2)
+				{
+					/* get rid of unique next to perma grids */
+			  		borg_tp_other_n ++;
+          	  		borg_tp_other_index[borg_tp_other_n] = i;
+          	  		borg_tp_other_y[borg_tp_other_n] = kill->y;
+          	  		borg_tp_other_x[borg_tp_other_n] = kill->x;
+				}
+
+			}
+          	else dam = -999;
+        }
+        else /* not a unique */
+        {
+			/* get rid of this unique by storing his info */
+			  borg_tp_other_n ++;
+          	  borg_tp_other_index[borg_tp_other_n] = i;
+          	  borg_tp_other_y[borg_tp_other_n] = kill->y;
+          	  borg_tp_other_x[borg_tp_other_n] = kill->x;
+		}
+        break;
+
+		/* This teleport away is used to teleport away all monsters
+		 * as the borg goes through his special attacks.
+		 */
+		case GF_AWAY_ALL_MORGOTH:
+		/* Mostly no damage */
+		dam = 0;
+
+		/* If its touching a glyph grid, nail it. */
+		for (j = 0; j < 8; j++)
+		{
+	        int y2 = kill->y + ddy_ddd[j];
+	        int x2 = kill->x + ddx_ddd[j];
+
+	        /* Get the grid */
+	        ag = &borg_grids[y2][x2];
+
+			/* If its touching a glyph grid, nail it. */
+			if (ag->feat == FEAT_GLYPH)
+			{
+	          	  /* get rid of this one by storing his info */
+				  borg_tp_other_n ++;
+	          	  borg_tp_other_index[borg_tp_other_n] = i;
+	          	  borg_tp_other_y[borg_tp_other_n] = kill->y;
+	          	  borg_tp_other_x[borg_tp_other_n] = kill->x;
+				  dam = 100;
+			}
+		}
+
+		/* If the borg is not in a good position, do it */
+		if (morgoth_on_level && !borg_morgoth_position)
+		{
+          	  /* get rid of this one by storing his info */
+			borg_tp_other_n ++;
+          	borg_tp_other_index[borg_tp_other_n] = i;
+          	borg_tp_other_y[borg_tp_other_n] = kill->y;
+          	borg_tp_other_x[borg_tp_other_n] = kill->x;
+			dam = 100;
+		}
+
+		/* If the borg does not have enough Mana to attack this
+		 * round and cast Teleport Away next round, then do it now.
+		 */
+		if (borg_skill[BI_CURSP] <= 30)
+		{
+          	/* get rid of this unique by storing his info */
+			borg_tp_other_n ++;
+          	borg_tp_other_index[borg_tp_other_n] = i;
+          	borg_tp_other_y[borg_tp_other_n] = kill->y;
+          	borg_tp_other_x[borg_tp_other_n] = kill->x;
+			dam = 100;
+		}
+		break;
+
+        /* This GF_ is hacked to work for Mass Genocide.  Since
+         * we cannot mass gen uniques.
+         */
+        case GF_DISP_ALL:
+        if (r_ptr->flags1 & RF1_UNIQUE)
+        {
+          dam = 0;
+          break;
+        }
+        dam = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        break;
+
+        case GF_OLD_CONF:
+        dam = 0;
+        if (r_ptr->flags3 & RF3_NO_CONF) break;
+        if (r_ptr->flags2 & RF2_MULTIPLY) break;
+        if (kill->speed < r_ptr->speed ) break;
+        if (kill->afraid) break;
+        if (kill->confused) break;
+        if (!kill->awake) break;
+        if ((kill->level >=
+            (borg_skill[BI_CLEVEL] < 13)  ? borg_skill[BI_CLEVEL] : (((borg_skill[BI_CLEVEL]-10)/4)*3) + 10)) break;
+        dam = -999;
+        if (r_ptr->flags1 & RF1_UNIQUE) break;
+        borg_confuse_spell = FALSE;
+        p1 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_confuse_spell = TRUE;
+        p2 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_confuse_spell = FALSE;
+        dam= (p1-p2);
+        break;
+
+        case GF_TURN_ALL:
+        dam = 0;
+        if (kill->speed < r_ptr->speed ) break;
+        if (r_ptr->flags3 & RF3_NO_FEAR) break;
+        if (kill->afraid) break;
+        if (kill->confused) break;
+        if (!kill->awake) break;
+        if ((kill->level >=
+            (borg_skill[BI_CLEVEL] < 13)  ? borg_skill[BI_CLEVEL] : (((borg_skill[BI_CLEVEL]-10)/4)*3) + 10)) break;
+        dam = -999;
+        if (r_ptr->flags1 & RF1_UNIQUE) break;
+        borg_fear_mon_spell = FALSE;
+        p1 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_fear_mon_spell = TRUE;
+        p2 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_fear_mon_spell = FALSE;
+        dam= (p1-p2);
+        break;
+
+        case GF_OLD_SLOW:
+        dam = 0;
+        if (kill->speed < r_ptr->speed ) break;
+        if (kill->afraid) break;
+        if (kill->confused) break;
+        if (!kill->awake) break;
+        if ((kill->level >=
+            (borg_skill[BI_CLEVEL] < 13)  ? borg_skill[BI_CLEVEL] : (((borg_skill[BI_CLEVEL]-10)/4)*3) + 10)) break;
+        dam = -999;
+        if (r_ptr->flags1 & RF1_UNIQUE) break;
+        borg_slow_spell = FALSE;
+        p1 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_slow_spell = TRUE;
+        p2 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_slow_spell = FALSE;
+        dam= (p1-p2);
+        break;
+
+        case GF_OLD_SLEEP:
+        dam = 0;
+        if (r_ptr->flags3 & RF3_NO_SLEEP) break;
+        if (kill->speed < r_ptr->speed ) break;
+        if (kill->afraid) break;
+        if (kill->confused) break;
+        if (!kill->awake) break;
+        if ((kill->level >=
+            (borg_skill[BI_CLEVEL] < 13)  ? borg_skill[BI_CLEVEL] : (((borg_skill[BI_CLEVEL]-10)/4)*3) + 10)) break;
+        dam = -999;
+        if (r_ptr->flags1 & RF1_UNIQUE) break;
+        borg_sleep_spell = FALSE;
+        p1 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_sleep_spell = TRUE;
+        p2 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+        borg_sleep_spell = FALSE;
+        dam= (p1-p2);
+        break;
+
+        case GF_OLD_POLY:
+        dam = 0;
+        if ((kill->level >=
+            (borg_skill[BI_CLEVEL] < 13)  ? borg_skill[BI_CLEVEL] : (((borg_skill[BI_CLEVEL]-10)/4)*3) + 10)) break;
+        dam = -999;
+        if (r_ptr->flags1 & RF1_UNIQUE) break;
+        dam = borg_danger_aux(c_y,c_x,2,i, TRUE);
+        /* dont bother unless he is a scary monster */
+        if (dam < avoidance * 2) dam = 0;
+        break;
+
+        case GF_TURN_UNDEAD:
+        if (r_ptr->flags3 & RF3_UNDEAD)
+        {
+            dam = 0;
+            if (kill->confused) break;
+            if (kill->afraid) break;
+            if (kill->speed < r_ptr->speed ) break;
+            if (!kill->awake) break;
+            if (kill->level > borg_skill[BI_CLEVEL]-5) break;
+            borg_fear_mon_spell = FALSE;
+            p1 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+            borg_fear_mon_spell = TRUE;
+            p2 = borg_danger_aux(c_y,c_x,1,i, TRUE);
+            borg_fear_mon_spell = FALSE;
+            dam= (p1-p2);
+        }
+        else
+        {
+            dam = 0;
+        }
+        break;
+
+        /* Banishment-- cast when in extreme danger (checked in borg_defense). */
+        case GF_AWAY_EVIL:
+        if (r_ptr->flags3 & RF3_EVIL)
+        {
+            /* try not teleport away uniques. */
+            if (r_ptr->flags1 & RF1_UNIQUE)
+            {
+                /* Banish ones with escorts */
+                if (r_ptr->flags1 & RF1_ESCORT)
+                {
+                    dam = 0;
+                }
+                else
+                {
+                    /* try not Banish non escorted uniques */
+                    dam = -500;
+                }
+
+            }
+            else
+            {
+                /* damage is the danger of the baddie */
+                dam = borg_danger_aux(c_y,c_x,1,i, TRUE);
+            }
+        }
+        else
+        {
+            dam = 0;
+        }
+        break;
+    }
+
+    /* use Missiles on certain types of monsters */
+    if ((borg_skill[BI_CDEPTH] >= 1) &&
+         (borg_danger_aux(kill->y,kill->x,1,i, TRUE) >= avoidance * 3/10 ||
+         (r_ptr->flags1 & RF1_FRIENDS /* monster has friends*/ &&
+          kill->level >= borg_skill[BI_CLEVEL] - 5 /* close levels */) ||
+         kill->ranged_attack /* monster has a ranged attack */ ||
+         r_ptr->flags1 & RF1_UNIQUE ||
+         r_ptr->flags2 & RF2_MULTIPLY ||
+         gold_eater || /* Monster can steal gold */
+         borg_skill[BI_CLEVEL] <= 20 /* stil very weak */))
+    {
+        borg_use_missile = TRUE;
+    }
+
+    /* Restore normal calcs of danger */
+    borg_full_damage = FALSE;
+
+    /* Return Damage as pure danger of the monster */
+    if (typ == GF_AWAY_ALL || typ == GF_AWAY_EVIL ||
+    	typ == GF_AWAY_ALL_MORGOTH) return (dam);
+
+    /* Limit damage to twice maximal hitpoints */
+    if (dam > kill->power * 2) dam = kill->power * 2;
+
+    /* give a small bonus for whacking a unique */
+    /* this should be just enough to give prefrence to wacking uniques */
+    if ((r_ptr->flags1 & RF1_UNIQUE) && borg_skill[BI_CDEPTH] >=1)
+        dam = (dam * 3);
+
+    /* Hack -- ignore Maggot until later.  Player will chase Maggot
+     * down all accross the screen waking up all the monsters.  Then
+     * he is stuck in a comprimised situation.
+     */
+    if ((r_ptr->flags1 & RF1_UNIQUE) && borg_skill[BI_CDEPTH] ==0)
+    {
+        dam = dam * 2/3;
+
+        /* Dont hunt maggot until later */
+        if (borg_skill[BI_CLEVEL] < 5) dam = 0;
+    }
+
+    /* give a small bonus for whacking a breeder */
+    if (r_ptr->flags2 & RF2_MULTIPLY)
+        dam = (dam * 3/2);
+
+    /* Enhance the preceived damage to summoner in order to influence the
+     * choice of targets.
+     */
+    if ( (r_ptr->flags6 & RF6_S_KIN) ||
+         (r_ptr->flags6 & RF6_S_HI_DEMON) ||
+         (r_ptr->flags6 & RF6_S_MONSTER) ||
+         (r_ptr->flags6 & RF6_S_MONSTERS) ||
+         (r_ptr->flags6 & RF6_S_ANIMAL) ||
+         (r_ptr->flags6 & RF6_S_SPIDER) ||
+         (r_ptr->flags6 & RF6_S_HOUND) ||
+         (r_ptr->flags6 & RF6_S_HYDRA) ||
+         (r_ptr->flags6 & RF6_S_ANGEL) ||
+         (r_ptr->flags6 & RF6_S_DEMON) ||
+         (r_ptr->flags6 & RF6_S_UNDEAD) ||
+         (r_ptr->flags6 & RF6_S_DRAGON) ||
+         (r_ptr->flags6 & RF6_S_HI_UNDEAD) ||
+         (r_ptr->flags6 & RF6_S_WRAITH) ||
+         (r_ptr->flags6 & RF6_S_UNIQUE) )
+       dam += ((dam * 3)/2);
+
+	/*
+	 * Apply massive damage bonus to Questor monsters to
+	 * encourage borg to strike them.
+	 */
+    if (r_ptr->flags1 & RF1_QUESTOR) dam += (dam * 3);
+
+    /*  Try to conserve missiles.
+     */
+    if (typ == GF_ARROW ||
+        (typ >= GF_ARROW_FLAME &&
+         typ <= GF_ARROW_HOLY))
+    {
+        if (!borg_use_missile)
+        /* set damage to zero, force borg to melee attack */
+        dam = 0;
+    }
+
+    /* Damage */
+    return (dam);
+}
+/*
+ * Simulate / Invoke the launching of a bolt at a monster
+ */
+static int borg_launch_bolt_aux_hack(int i, int dam, int typ)
+{
+    int d, p2, p1, x, y;
+    int o_y = 0;
+    int o_x = 0;
+    int walls =0;
+    int unknown =0;
+
+    borg_grid *ag;
+
+    borg_kill *kill;
+
+    monster_race *r_ptr;
+
+    /* Monster */
+    kill = &borg_kills[i];
+
+    /* monster race */
+    r_ptr = &r_info[kill->r_idx];
+
+    /* Skip dead monsters */
+    if (!kill->r_idx) return (0);
+
+    /* Require current knowledge */
+    if (kill->when < borg_t - 2) return (0);
+
+    /* Acquire location */
+    x = kill->x;
+    y = kill->y;
+
+    /* Acquire the grid */
+    ag = &borg_grids[y][x];
+
+    /* Never shoot walls/doors */
+    if (!borg_cave_floor_grid(ag)) return (0);
+
+    /* dont shoot at ghosts if not on known floor grid */
+    if ((r_ptr->flags2 & RF2_PASS_WALL) &&
+    	(ag->feat == FEAT_INVIS ||
+    	 (ag->feat != FEAT_FLOOR &&
+    	  ag->feat != FEAT_OPEN &&
+    	  ag->feat != FEAT_BROKEN &&
+    	  ag->feat != FEAT_TRAP_HEAD))) return (0);
+
+    /* dont shoot at ghosts in walls, not perfect */
+    if (r_ptr->flags2 & RF2_PASS_WALL)
+    {
+        /* if 2 walls and 1 unknown skip this monster */
+        /* Acquire location */
+        x = kill->x;
+        y = kill->y;
+
+        /* Get grid */
+        for (o_x = -1; o_x <= 1; o_x++)
+        {
+            for (o_y = -1; o_y <= 1; o_y++)
+            {
+                /* Acquire location */
+                x = kill->x + o_x;
+                y = kill->y + o_y;
+
+                ag = &borg_grids[y][x];
+
+                if (ag->feat >= FEAT_MAGMA &&
+                    ag->feat <= FEAT_PERM_SOLID) walls++;
+                if (ag->feat & FEAT_INVIS) unknown++;
+            }
+        }
+        /* Is the ghost likely in a wall? */
+        if (walls >=2 && unknown >=1) return (0);
+    }
+
+
+
+    /* Calculate damage */
+    d = borg_launch_damage_one(i, dam, typ);
+
+	/* Return Damage, on Teleport Other, true damage is
+	 * calculated elsewhere */
+	if (typ == GF_AWAY_ALL || typ == GF_AWAY_ALL_MORGOTH) return (d);
+
+    /* Return Damage as pure danger of the monster */
+    if (typ == GF_AWAY_EVIL) return (d);
+
+    /* Return 0 if the true damge (w/o the danger bonus) is 0 */
+    if (d <= 0) return (d);
+
+    /* Calculate danger */
+    p2 = borg_danger_aux(y, x, 1, i, TRUE);
+
+    /* Hack -- avoid waking most "hard" sleeping monsters */
+    if (!kill->awake &&
+        (p2 > avoidance / 2) &&
+        (d < kill->power) )
+    {
+        return (-999);
+    }
+
+    /* Hack -- ignore sleeping town monsters */
+    if (!borg_skill[BI_CDEPTH] && !kill->awake)
+    {
+        return (0);
+    }
+
+    /* Hack -- ignore nonthreatening town monsters when low level */
+    if (!borg_skill[BI_CDEPTH] && borg_skill[BI_CLEVEL] < 3
+        /* && monster_is_nonthreatening_test */ )
+    {
+		/* Nothing yet */
+    }
+
+    /* Calculate "danger" to player */
+    p1 = borg_danger_aux(c_y, c_x, 1, i, TRUE);
+
+    /* Extra "bonus" if attack kills */
+    if (d > kill->power) p1 = 2 * p1;
+
+
+    /* Add in dangers */
+    d = d + p1 +(p2/2);
+
+    /* Result */
+    return (d);
+}
+
+
+/*
+ * Determine the "reward" of launching a beam/bolt/ball at a location
+ *
+ * An "unreachable" location always has zero reward.
+ *
+ * Basically, we sum the "rewards" of doing the appropriate amount of
+ * damage to each of the "affected" monsters.
+ *
+ * We will attempt to apply the offset-ball attack here
+ */
+static int borg_launch_bolt_aux(int y, int x, int rad, int dam, int typ, int max)
+{
+    int i;
+
+    int x1, y1;
+    int x2, y2;
+
+    int dist;
+
+    int r, n;
+
+    borg_grid *ag;
+    monster_race *r_ptr;
+    borg_kill *kill;
+
+    int q_x, q_y;
+
+    /* Extract panel */
+    q_x = w_x / 33;
+    q_y = w_y / 11;
+
+    /* Reset damage */
+    n = 0;
+
+    /* Initial location */
+    x1 = c_x; y1 = c_y;
+
+    /* Final location */
+    x2 = x; y2 = y;
+
+    /* Start over */
+    x = x1; y = y1;
+
+    /* Simulate the spell/missile path */
+    for (dist = 0; dist < max; dist++)
+    {
+        /* Get the grid */
+        ag = &borg_grids[y2][x2];
+        kill = &borg_kills[ag->kill];
+        r_ptr = &r_info[kill->r_idx];
+
+        ag = &borg_grids[y][x];
+
+        /* Stop at walls */
+        /* note: beams end at walls.  */
+        if (dist)
+        {
+            /* Stop at walls */
+            /* note if beam, this is the end of the beam */
+            /* dispel spells act like beams (sort of) */
+            if (!borg_cave_floor_grid(ag))
+            {
+				if (rad != -1 && rad != 10)
+                    return (0);
+                else
+                    return (n);
+            }
+        }
+
+
+        /* Collect damage (bolts/beams) */
+        if (rad <= 0 || rad == 10) n += borg_launch_bolt_aux_hack(ag->kill, dam, typ);
+
+        /* Check for arrival at "final target" */
+        /* except beams, which keep going. */
+        if ( (rad != -1 && rad !=10)  && ((x == x2) && (y == y2))) break;
+
+        /* Stop bolts at monsters  */
+        if (!rad && ag->kill) return (n);
+
+        /* The missile path can be complicated.  There are several checks
+         * which need to be made.  First we assume that we targetting
+         * a monster.  That monster could be known from either sight or
+         * ESP.  If the entire pathway from us to the monster is known,
+         * then there is no concern.  But if the borg is shooting through
+         * unknown grids, then there is a concern when he has ESP; without
+         * ESP he would not see that monster if the unknown grids
+         * contained walls or closed doors.
+         *
+         * 1.  ESP Inactive
+         *   A.  No Infravision
+         *       -Then the monster must be in a lit grid. OK to shoot
+         *   B.  Yes Infravision
+         *       -Then the monster must be projectable()  OK to shoot
+         * 2.  ESP Active
+         *   A. No Infravision
+         *       -Then the monster could be in a lit grid.  Try to shoot
+         *       -Or I detect it with ESP and it's not projectable().
+         *   B.  Yes Infravision
+         *       -Then the monster could be projectable()
+         *       -Or I detect it with ESP and it's not projectable().
+         *   -In the cases of ESP Active, the borg will test fire a missile.
+         *    Then wait for a 'painful ouch' from the monster.
+         *
+         * Low level borgs will not take the shot unless they have
+         * a clean and known pathway.  Borgs over a certain clevel,
+         * will attempt the shot and listen for the 'ouch' repsonse
+         * to know that the clear.  If no 'Ouch' is heard, then the
+         * borg will assume there is a wall in the way.  Exception to
+         * this is with arrows.  Arrows can miss the target or fall
+         * fall short, in which case no 'ouch' is heard.  So the borg
+         * allowed to miss two shots with arrows/bolts/thrown objects.
+         */
+
+        /* dont do the check if esp */
+        if (!borg_skill[BI_ESP])
+        {
+            /* Check the missile path--no Infra, no HAS_LITE */
+            if (dist && (borg_skill[BI_INFRA] <=0)
+#ifdef MONSTER_LITE
+             && !(r_ptr->flags2 & RF2_HAS_LITE)
+#endif /* has_lite */
+               )
+            {
+                /* Stop at unknown grids (see above) */
+                /* note if beam, dispel, this is the end of the beam */
+                if (ag->feat == FEAT_NONE && borg_skill[BI_CLEVEL] < 5)
+                    {
+                        if (rad != -1 && rad !=10)
+                            return (0);
+                        else
+                            return (n);
+                    }
+
+                /* Stop at weird grids (see above).
+                 * FEAT_INVIS is granted to grids which were unknown,
+                 * Then contained a monster or object.  Most of the time
+                 * FEAT_INVIS is a floor grid.  But could be a
+                 * monster which has PASS_WALL, in which case, bolts
+                 * will not affect it.
+                 * Note if beam, this is the end of the beam.
+                 */
+                if (ag->feat == FEAT_INVIS && borg_skill[BI_CLEVEL] < 5)
+                {
+                    if (rad != -1 && rad !=10)
+                        return (0);
+                    else
+                        return (n);
+                }
+
+                /* Stop at unseen walls */
+                /* We just shot and missed, this is our next shot */
+                if (successful_target < 0)
+                {
+                    /* When throwing things, it is common to just 'miss' */
+                    /* Skip only one round in this case */
+                    if (successful_target == -12)
+                        successful_target = 0;
+                    if (rad != -1 && rad !=10)
+                        return (0);
+                    else
+                        return (n);
+                }
+            }
+            else  /* I do have infravision or it's a lite monster */
+            {
+                /* Stop at unseen walls */
+                /* We just shot and missed, this is our next shot */
+                if (successful_target < 0)
+                {
+                    /* When throwing things, it is common to just 'miss' */
+                    /* Skip only one round in this case */
+                    if (successful_target == -12)
+                        successful_target = 0;
+                    if (rad != -1 && rad !=10)
+                        return (0);
+                    else
+                        return (n);
+                }
+            }
+         }
+        else /* I do have ESP */
+         {
+            /* Check the missile path */
+            if (dist )
+            {
+                /* if this area has been magic mapped,
+                * ok to shoot in the dark
+                */
+                if (!borg_detect_wall[q_y+0][q_x+0] &&
+                    !borg_detect_wall[q_y+0][q_x+1] &&
+                    !borg_detect_wall[q_y+1][q_x+0] &&
+                    !borg_detect_wall[q_y+1][q_x+1])
+                {
+
+                    /* Stop at unknown grids (see above) */
+                    /* note if beam, dispel, this is the end of the beam */
+                    if (ag->feat == FEAT_NONE && borg_skill[BI_CLEVEL] < 5)
+                    {
+                        if (rad != -1 && rad !=10)
+                            return (0);
+                        else
+                            return (n);
+                    }
+                    /* Stop at unseen walls */
+                    /* We just shot and missed, this is our next shot */
+                    if (successful_target < 0)
+                    {
+                        /* When throwing things, it is common to just 'miss' */
+                        /* Skip only one round in this case */
+                        if (successful_target == -12)
+                            successful_target = 0;
+                        if (rad != -1 && rad !=10)
+                            return (0);
+                        else
+                            return (n);
+                    }
+                }
+
+                /* Stop at weird grids (see above) */
+                /* note if beam, this is the end of the beam */
+                if (ag->feat == FEAT_INVIS && borg_skill[BI_CLEVEL] < 5)
+                {
+                    if (rad != -1 && rad !=10)
+                        return (0);
+                    else
+                        return (n);
+                }
+                /* Stop at unseen walls */
+                /* We just shot and missed, this is our next shot */
+                if (successful_target < 0)
+                {
+                    /* When throwing things, it is common to just 'miss' */
+                    /* Skip only one round in this case */
+                    if (successful_target == -12)
+                        successful_target = 0;
+
+                     if (rad != -1 && rad !=10)
+                         return (0);
+                     else
+                         return (n);
+                }
+            }
+        }
+
+        /* Calculate the new location */
+        mmove2(&y, &x, y1, x1, y2, x2);
+    }
+
+    /* Bolt/Beam attack */
+    if (rad <= 0 ) return (n);
+
+    /* Excessive distance */
+    if (dist >= MAX_RANGE) return (0);
+
+    /* Check monsters in blast radius */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        /* Acquire location */
+        x = borg_temp_x[i];
+        y = borg_temp_y[i];
+
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        /* Check distance */
+        r = distance(y2, x2, y, x);
+
+        /* Maximal distance */
+        if (r > rad) continue;
+
+        /* Never pass through walls*/
+        if (!borg_los(y2, x2, y, x)) continue;
+
+        /*  dispel spells should hurt the same no matter the rad: make r= y  and x */
+        if (rad == 10) r = 0;
+
+        /* Collect damage, lowered by distance */
+        n += borg_launch_bolt_aux_hack(ag->kill, dam / (r + 1), typ);
+
+        /* probable damage int was just changed by b_l_b_a_h*/
+
+        /* check destroyed stuff. */
+        if (ag->take)
+        {
+            borg_take *take = &borg_takes[ag->take];
+            object_kind *k_ptr = &k_info[take->k_idx];
+
+            switch (typ)
+            {
+                case GF_ACID:
+                {
+                    /* rings/boots cost extra (might be speed!) */
+                    if (k_ptr->tval == TV_BOOTS)
+                    {
+                        n -= 20;
+                    }
+                    break;
+                }
+                case GF_ELEC:
+                {
+                    /* rings/boots cost extra (might be speed!) */
+                    if (k_ptr->tval == TV_RING)
+                    {
+                        n -= 20;
+                    }
+                    break;
+                }
+
+                case GF_FIRE:
+                {
+                    /* rings/boots cost extra (might be speed!) */
+                    if (k_ptr->tval == TV_BOOTS)
+                    {
+                        n -= 20;
+                    }
+                    break;
+                }
+                case GF_COLD:
+                {
+                    if (k_ptr->tval == TV_POTION)
+                    {
+                        n -= 20;
+                    }
+                    break;
+                }
+                case GF_MANA:
+                {
+                   /* Used against uniques, allow the stuff to burn */
+                    break;
+                }
+            }
+        }
+    }
+
+    /* Result */
+    return (n);
+}
+
+
+/*
+ * Simulate/Apply the optimal result of launching a beam/bolt/ball
+ *
+ * Note that "beams" have a "rad" of "-1", "bolts" have a "rad" of "0",
+ * and "balls" have a "rad" of "2" or "3", depending on "blast radius".
+ *  dispel spells have a rad  of 10
+ */
+static int borg_launch_bolt(int rad, int dam, int typ, int max)
+{
+    int num = 0;
+
+    int i, b_i = -1;
+    int n, b_n = 0;
+    int b_o_y = 0, b_o_x = 0;
+    int o_y =0, o_x = 0;
+
+
+
+    /* Examine possible destinations */
+
+    /* This will allow the borg to target places adjacent to a monster
+     * in order to exploit and abuse a feature of the game.  Whereas,
+     * the borg, while targeting a monster will not score d/t walls, he
+     * could land a success hit by targeting adjacent to the monster.
+     * For example:
+     * ######################
+     * #####....@......######
+     * ############Px........
+     * ######################
+     * In order to hit the P, the borg must target the x and not the P.
+     *
+     * This is a massive exploitation.  But it ranks with Farming, Scumming,
+     * Savefile abuse.
+     */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        int x = borg_temp_x[i];
+        int y = borg_temp_y[i];
+
+        /* Consider each adjacent spot to and on top of the monster*/
+        for (o_x = -1; o_x <= 1; o_x++)
+        {
+            for (o_y = -1; o_y <= 1; o_y++)
+            {
+                /* Acquire location */
+                x = borg_temp_x[i] + o_x;
+                y = borg_temp_y[i] + o_y;
+
+				/* Skip certain types of Offset attacks */
+				if (o_x != 0 || o_y != 0)
+				{
+					/* Skip Offset Teleport Other attacks */
+/*					if (typ == GF_AWAY_ALL) continue; */
+				}
+
+				/* Reset Teleport Other variables */
+				borg_tp_other_n = 0;
+
+                /* Consider it */
+                n = borg_launch_bolt_aux(y, x, rad, dam, typ, max);
+
+				/* Skip certain types of Offset attacks */
+				if (o_x != 0 || o_y != 0)
+				{
+					/* Skip Offset Teleport Other attacks */
+					if (typ == GF_AWAY_ALL) continue;
+
+					/* Skip Offsets that do only 1 damage */
+					if (n == 1) continue;
+				}
+
+				/* Teleport Other is now considered */
+				if (typ == GF_AWAY_ALL)
+				{
+					/* Consider danger with certain monsters removed
+					 * from the danger check
+					 */
+					n = borg_danger(c_y, c_x, 1, TRUE);
+				}
+
+				/* Reset Teleport Other variables */
+				borg_tp_other_n = 0;
+
+                /* Skip useless attacks */
+                if (n <= 0) continue;
+
+                /* The game forbids targetting the outside walls */
+                if (x == 0 || y == 0 || x == DUNGEON_WID-1 || y == DUNGEON_HGT-1)
+                   continue;
+
+                /* Collect best attack */
+                if ((b_i >= 0) && (n < b_n)) continue;
+
+                /* Hack -- reset chooser */
+                if ((b_i >= 0) && (n > b_n)) num = 0;
+
+                /* Apply the randomizer */
+                if ((num > 1) && (rand_int(num) != 0)) continue;
+
+                /* Track it */
+                b_i = i;
+                b_n = n;
+                b_o_y = o_y;
+                b_o_x = o_x;
+            }
+        }
+    }
+
+	/* Reset Teleport Other variables */
+	borg_tp_other_n = 0;
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Save the location */
+    g_x = borg_temp_x[b_i] + b_o_x;
+    g_y = borg_temp_y[b_i] + b_o_y;
+
+    /* Target the location */
+    (void)borg_target(g_y, g_x);
+
+    /* Result */
+    return (b_n);
+}
+
+
+
+
+/*
+ * Simulate/Apply the optimal result of launching a normal missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip Ego branded items--they are looked at later */
+        if (item->name2) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}") &&
+            !streq(item->note, "{good}") &&
+            !streq(item->note, "{excellent}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d <= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing standard missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a SEEKER missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_seeker(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip non-seekers items--they are looked at later */
+        if (item->sval != SV_AMMO_HEAVY) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified */
+        if (!item->able) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d <= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_SEEKER, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Do it */
+    borg_note(format("# Firing seeker missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+/*
+ * Simulate/Apply the optimal result of launching a SILVER missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_silver(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip non-seekers items--they are looked at later */
+        if (item->sval != SV_AMMO_SILVER) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d <= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_SILVER, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Do it */
+    borg_note(format("# Firing silver missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_flame(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+
+        if (item->name2 != EGO_FLAME) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d <= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_FLAME, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing flame branded missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_frost(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_FROST) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_FROST, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing frost branded missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_venom(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+
+        if (item->name2 != EGO_AMMO_VENOM) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d <= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_POISON, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing venom branded missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_holy(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+
+        if (item->name2 != EGO_AMMO_HOLY) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d <= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_HOLY, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing holy branded missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_animal(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_ANIMAL) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_ANIMAL, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing animal missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_undead(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_UNDEAD) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_UNDEAD, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing undead missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_demon(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_DEMON) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_DEMON, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing demon missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_orc(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_ORC) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_ORC, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing orc missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_troll(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_TROLL) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_TROLL, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing troll missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_giant(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_GIANT) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_GIANT, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing giant missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_dragon(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_DRAGON) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_DRAGON, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing dragon branded missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_evil(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_HURT_EVIL) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_EVIL, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing evil branded missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of launching a branded missile
+ *
+ * First, pick the "optimal" ammo, then pick the optimal target
+ */
+static int borg_attack_aux_launch_wounding(void)
+{
+    int b_n = 0;
+
+    int k , b_k = -1;
+    int d , b_d = -1;
+
+    borg_item *bow = &borg_items[INVEN_BOW];
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (item->sval == SV_AMMO_HEAVY) continue;
+        if (item->name2 != EGO_WOUNDING) continue;
+
+        /* Skip bad missiles */
+        if (item->tval != my_ammo_tval) continue;
+
+        /* Skip worthless missiles */
+        if (item->value <= 0) continue;
+
+        /* Skip un-identified, non-average, missiles */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Determine average damage */
+        d = (item->dd * (item->ds + 1) / 2);
+        d = d + item->to_d + bow->to_d;
+        d = d * my_ammo_power * borg_skill[BI_SHOTS];
+
+
+        /* Paranoia */
+        if (d <= 0) continue;
+
+        if ((b_k >=0) && (d<= b_d)) continue;
+
+        b_k = k;
+        b_d = d;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Choose optimal type of bolt */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW_WOUNDING, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Firing wounding branded missile '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('f');
+
+    /* Use the missile */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of throwing an object
+ *
+ * First choose the "best" object to throw, then check targets.
+ */
+static int borg_attack_aux_object(void)
+{
+    int b_n;
+
+    int b_r = 0;
+
+    int k, b_k = -1;
+    int d, b_d = -1;
+
+    int div, mul;
+
+    /* Scan the pack */
+    for (k = 0; k < INVEN_PACK; k++)
+    {
+        borg_item *item = &borg_items[k];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip un-identified, non-average, objects */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Skip "equipment" items (not ammo) */
+        if (borg_wield_slot(item) >= 0) continue;
+
+        /* Determine average damage from object */
+        d = (k_info[item->kind].dd * (k_info[item->kind].ds + 1) / 2);
+
+        /* Skip useless stuff */
+        if (d <= 0) continue;
+
+        /* Skip "expensive" stuff */
+        if (item->tval != TV_POTION && item->sval != SV_POTION_DETONATIONS &&
+            d < item->value) continue;
+
+        /* Hack -- Save Detonations for Uniques */
+        if (item->tval == TV_POTION && item->sval == SV_POTION_DETONATIONS &&
+        	!borg_fighting_unique) continue;
+
+        /* Hack -- Save Heals and stuff */
+        if (item->tval == TV_POTION && item->sval >= SV_POTION_HEROISM &&
+        	item->sval <= SV_POTION_LIFE) continue;
+
+        /* Hack -- Save last flasks for fuel, if needed */
+        if (item->tval == TV_FLASK &&
+            (borg_skill[BI_AFUEL] <= 2 && !borg_fighting_unique)) continue;
+
+        /* Ignore worse damage */
+        if ((b_k >= 0) && (d <= b_d)) continue;
+
+        /* Track */
+        b_k = k;
+        b_d = d;
+
+        /* Extract a "distance multiplier" */
+        mul = 10;
+
+        /* Enforce a minimum "weight" of one pound */
+        div = ((item->weight > 10) ? item->weight : 10);
+
+        /* Hack -- Distance -- Reward strength, penalize weight */
+        b_r = (adj_str_blow[my_stat_ind[A_STR]] + 20) * mul / div;
+
+        /* Max distance of 10 */
+        if (b_r > 10) b_r = 10;
+    }
+
+    /* Nothing to use */
+    if (b_k < 0) return (0);
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(0, b_d, GF_ARROW, b_r);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Do it */
+    borg_note(format("# Throwing painful object '%s'",
+                     borg_items[b_k].desc));
+
+    /* Fire */
+    borg_keypress('v');
+
+    /* Use the object */
+    borg_keypress(I2A(b_k));
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -2;
+
+    /* Value */
+    return (b_n);
+}
+
+
+
+
+/*
+ * Simulate/Apply the optimal result of using a "normal" attack spell
+ *
+ * Take into account the failure rate of spells/objects/etc.  XXX XXX XXX
+ */
+static int borg_attack_aux_spell_bolt(int book, int what, int rad, int dam, int typ)
+{
+    int b_n;
+    int penalty =0;
+
+    borg_magic *as = &borg_magics[book][what];
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Paranoia */
+    if (borg_simulate &&
+       (borg_class != CLASS_MAGE && borg_skill[BI_CLEVEL] <= 2) &&
+       (rand_int(100) < 1)) return (0);
+
+	/* Not if money scumming in town */
+	if (borg_money_scum_amount && borg_skill[BI_CDEPTH] == 0) return (0);
+
+	/* Not if low on food */
+	if (borg_skill[BI_FOOD] == 0 ||
+		(borg_skill[BI_ISWEAK] && borg_spell_legal(2, 0))) return (0);
+
+    /* Require ability (right now) */
+    if (!borg_spell_okay_fail(book, what, (borg_fighting_unique ? 40 : 25))) return (0);
+
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* weak mages need that spell, they dont get penalized */
+    /* weak == those that can't teleport reliably anyway */
+    if (book == 0 && what == 0 &&
+        (!borg_spell_legal_fail(1, 5, 15) || borg_skill[BI_MAXCLEVEL] <= 30))
+    {
+        if (borg_simulate) return (b_n);
+    }
+
+    /* Penalize mana usage except on MM */
+	if (book != 0 && what != 0)
+	{
+		/* Standard penalty */
+		b_n = b_n - as->power;
+
+		/* Extra penalty if the cost far outweighs the damage */
+		if (borg_skill[BI_MAXSP] < 50 && as->power > b_n) b_n = b_n - as->power;
+
+	    /* Penalize use of reserve mana */
+	    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 2) b_n = b_n - (as->power * 3);
+
+	    /* Penalize use of deep reserve mana */
+	    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 3) b_n = b_n - (as->power * 5);
+
+	}
+
+    /* Really penalize use of mana needed for final teleport */
+    if (borg_class == CLASS_MAGE) penalty = 6;
+    if (borg_class == CLASS_RANGER) penalty = 22;
+    if (borg_class == CLASS_ROGUE) penalty = 20;
+    if ((borg_skill[BI_MAXSP] > 30) &&
+        (borg_skill[BI_CURSP] - as->power < penalty))
+        b_n = b_n - (as->power * 750);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+
+    /* Cast the spell */
+    (void)borg_spell(book, what);
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -1;
+
+    /* Value */
+    return (b_n);
+}
+
+/* This routine is the same as the one above only in an emergency case.
+ * The borg will enter negative mana casting this
+ */
+static int borg_attack_aux_spell_bolt_reserve(int book, int what, int rad, int dam, int typ)
+{
+    int b_n;
+    int i;
+
+	int x9, y9, ax, ay, d;
+	int near_monsters = 0;
+
+    /* Fake our Mana */
+    int sv_mana = borg_skill[BI_CURSP];
+
+    /* Only Weak guys should try this */
+    if (borg_skill[BI_CLEVEL] >= 15) return (0);
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+	/* Not if low on food */
+	if (borg_skill[BI_FOOD] == 0 ||
+		(borg_skill[BI_ISWEAK] && borg_spell_legal(2, 0))) return (0);
+
+    /* Must not have enough mana right now */
+    if (borg_spell_okay_fail(book, what, 25)) return (0);
+
+    /* Must be dangerous */
+    if (borg_danger(c_y, c_x,1, TRUE) < avoidance * 2) return (0);
+
+    /* Find the monster */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+
+        /* Monster */
+        kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* check the location */
+        x9 = kill->x;
+        y9 = kill->y;
+
+        /* Distance components */
+        ax = (x9 > c_x) ? (x9 - c_x) : (c_x - x9);
+        ay = (y9 > c_y) ? (y9 - c_y) : (c_y - y9);
+
+        /* Distance */
+        d = MAX(ax, ay);
+
+		/* Count the number of close monsters
+		 * There should only be one close monster.
+		 * We do not want to risk fainting.
+		 */
+        if (d < 7) near_monsters ++;
+
+        /* If it has too many hp to be taken out with this */
+        /* spell, don't bother trying */
+        /* NOTE: the +4 is because the damage is toned down
+                 as an 'average damage' */
+        if (kill->power > (dam+4))
+            return (0);
+
+		/* Do not use it in town */
+		if (borg_skill[BI_CDEPTH] == 0) return (0);
+
+        break;
+    }
+
+    /* Should only be 1 near monster */
+	if (near_monsters > 1) return (0);
+
+    /* Require ability (with faked mana) */
+    borg_skill[BI_CURSP] = borg_skill[BI_MAXSP];
+    if (!borg_spell_okay_fail(book, what, 25))
+    {
+        /* Restore Mana */
+        borg_skill[BI_CURSP] = sv_mana;
+        return (0);
+    }
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* return the value */
+    if (borg_simulate)
+    {
+        /* Restore Mana */
+        borg_skill[BI_CURSP] = sv_mana;
+        return (b_n);
+    }
+
+    /* Cast the spell with fake mana */
+    borg_skill[BI_CURSP] = borg_skill[BI_MAXSP];
+    if (borg_spell_fail(book, what, 25))
+    {
+        /* Note the use of the emergency spell */
+        borg_note("# Emergency use of an Attack Spell.");
+
+        /* verify use of spell */
+        /* borg_keypress('y'); */
+    }
+
+    /* Use target */
+    /* borg_keypress('5'); */
+    borg_confirm_target = TRUE;
+
+
+    /* Set our shooting flag */
+    successful_target = -1;
+
+    /* restore true mana */
+    borg_skill[BI_CURSP] = 0;
+
+    /* Value */
+    return (b_n);
+}
+
+
+
+/*
+ * Simulate/Apply the optimal result of using a "normal" attack prayer
+ */
+static int borg_attack_aux_prayer_bolt(int book, int what, int rad, int dam, int typ)
+{
+    int b_n;
+    int penalty =0;
+
+    borg_magic *as = &borg_magics[book][what];
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+
+	/* Not if money scumming in town */
+	if (borg_money_scum_amount && borg_skill[BI_CDEPTH] == 0) return (0);
+
+	/* Not if low on food */
+	if (borg_skill[BI_FOOD] == 0 ||
+		(borg_skill[BI_ISWEAK] && borg_prayer_legal(5, 2))) return (0);
+
+    /* Require ability */
+    if (!borg_prayer_okay_fail(book, what, 25)) return (0);
+
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* Penalize mana usage except Orb */
+	if (book != 2 && what != 1)
+	{
+    	/* Standard penalty */
+    	b_n = b_n - as->power;
+
+
+	    /* Penalize use of reserve mana */
+	    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 2) b_n = b_n - (as->power * 3);
+
+	    /* Penalize use of deep reserve mana */
+	    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 3) b_n = b_n - (as->power * 5);
+	}
+
+    /* Really penalize use of mana needed for final teleport */
+    if (borg_class == CLASS_PRIEST) penalty = 8;
+    if (borg_class == CLASS_PALADIN) penalty =20;
+    if ((borg_skill[BI_MAXSP] > 30) &&
+        (borg_skill[BI_CURSP] - as->power < penalty))
+        b_n = b_n - (as->power * 750);
+
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Cast the prayer */
+    (void)borg_prayer(book, what);
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -1;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ *  Simulate/Apply the optimal result of using a "dispel" attack prayer
+ */
+static int borg_attack_aux_prayer_dispel(int book, int what, int dam, int typ)
+{
+    int b_n;
+    int penalty =0;
+
+    borg_magic *as = &borg_magics[book][what];
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+	/* Not if low on food */
+	if (borg_skill[BI_FOOD] == 0 ||
+		(borg_skill[BI_ISWEAK] && borg_prayer_legal(5, 2))) return (0);
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+
+    /* Require ability */
+    if (!borg_prayer_okay_fail(book, what, 25)) return (0);
+
+    /* Choose optimal location--radius defined as 10 */
+    b_n = borg_launch_bolt(10, dam, typ, MAX_RANGE);
+
+    /* Penalize mana usage */
+    b_n = b_n - as->power;
+
+    /* Penalize use of reserve mana */
+    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 2) b_n = b_n - (as->power * 3);
+
+    /* Penalize use of deep reserve mana */
+    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 3) b_n = b_n - (as->power * 5);
+
+    /* Really penalize use of mana needed for final teleport */
+        if (borg_class == CLASS_PRIEST) penalty = 8;
+        if (borg_class == CLASS_PALADIN) penalty =20;
+        if ((borg_skill[BI_MAXSP] > 30) && (borg_skill[BI_CURSP] - as->power < penalty))
+            b_n = b_n - (as->power * 750);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Cast the prayer */
+    (void)borg_prayer(book, what);
+
+
+    /* Value */
+    return (b_n);
+}
+
+
+
+
+/*
+ *  Simulate/Apply the optimal result of using a "dispel" attack spell
+ */
+static int borg_attack_aux_spell_dispel(int book, int what, int dam, int typ)
+{
+    int b_n;
+    int penalty =0;
+
+    borg_magic *as = &borg_magics[book][what];
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+	/* Not if low on food */
+	if (borg_skill[BI_FOOD] == 0 ||
+		(borg_skill[BI_ISWEAK] && borg_spell_legal(2, 0))) return (0);
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+
+    /* Require ability */
+    if (!borg_spell_okay_fail(book, what, 25)) return (0);
+
+    /* Choose optimal location--radius defined as 10 */
+    b_n = borg_launch_bolt(10, dam, typ, MAX_RANGE);
+
+    /* Penalize mana usage */
+    b_n = b_n - as->power;
+
+    /* Penalize use of reserve mana */
+    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 2) b_n = b_n - (as->power * 3);
+
+    /* Penalize use of deep reserve mana */
+    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 3) b_n = b_n - (as->power * 5);
+
+    /* Really penalize use of mana needed for final teleport */
+        if (borg_class == CLASS_MAGE) penalty = 6;
+        if (borg_class == CLASS_RANGER) penalty =22;
+        if (borg_class == CLASS_ROGUE) penalty = 20;
+        if ((borg_skill[BI_MAXSP] > 30) && (borg_skill[BI_CURSP] - as->power < penalty))
+            b_n = b_n - (as->power * 750);
+
+    /* Really penalize use of mana needed for final teleport */
+    /* (6 pts for mage) */
+    if ((borg_skill[BI_MAXSP] > 30) && (borg_skill[BI_CURSP] - as->power) < 6)
+        b_n = b_n - (as->power * 750);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Cast the prayer */
+    (void)borg_spell(book, what);
+
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ *  Simulate/Apply the optimal result of using a "dispel" staff
+ * Which would be dispel evil, power, holiness.  Genocide handeled later.
+ */
+static int borg_attack_aux_staff_dispel(int sval, int rad, int dam, int typ)
+{
+    int i, b_n;
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+    /* look for the staff */
+    if (!borg_equips_staff_fail(sval)) return (0);
+    i =  borg_slot(TV_STAFF, sval);
+
+    /* Choose optimal location--radius defined as 10 */
+    b_n = borg_launch_bolt(10, dam, typ, MAX_RANGE);
+
+    /* Big Penalize charge usage */
+    b_n = b_n - 50;
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Cast the prayer */
+    (void)borg_use_staff(sval);
+
+
+    /* Value */
+    return (b_n);
+}
+
+
+
+/*
+ * Simulate/Apply the optimal result of using a "normal" attack rod
+ */
+static int borg_attack_aux_rod_bolt(int sval, int rad, int dam, int typ)
+{
+    int b_n;
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+
+    /* Look for that rod */
+    if (!borg_equips_rod(sval)) return (0);
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Zap the rod */
+    (void)borg_zap_rod(sval);
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -1;
+
+    /* Value */
+    return (b_n);
+}
+
+
+
+/*
+ * Simulate/Apply the optimal result of using a "normal" attack wand
+ */
+static int borg_attack_aux_wand_bolt(int sval, int rad, int dam, int typ)
+{
+    int i;
+
+    int b_n;
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+
+    /* Look for that wand */
+    i = borg_slot(TV_WAND, sval);
+
+    /* None available */
+    if (i < 0) return (0);
+
+    /* No charges */
+    if (!borg_items[i].pval) return (0);
+
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* Penalize charge usage */
+    b_n = b_n - 5;
+
+    /* Wands of wonder are used in last ditch efforts.  They behave
+     * randomly, so the best use of them is an emergency.  I have seen
+     * borgs die from hill orcs with fully charged wonder wands.  Odds
+     * are he could have taken the orcs with the wand.  So use them in
+     * an emergency after all the borg_caution() steps have failed
+     */
+    if (sval == SV_WAND_WONDER)
+    {
+        /* check the danger */
+        if (b_n > 0 && borg_danger(c_y,c_x,1, TRUE) >= (avoidance * 8/10) )
+        {
+            /* make the wand appear deadly */
+            b_n = 999;
+
+            /* note the use of the wand in the emergency */
+            borg_note(format("# Emergency use of a Wand of Wonder."));
+        }
+        else
+        {
+            b_n = 0;
+        }
+    }
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Aim the wand */
+    (void)borg_aim_wand(sval);
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -1;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of ACTIVATING an attack artifact
+ *
+ */
+static int borg_attack_aux_artifact(int art_name, int art_loc, int rad, int dam, int typ)
+{
+    int b_n;
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+
+    /* Look for that artifact and to see if it is charged */
+    if (!borg_equips_artifact(art_name,art_loc)) return (0);
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Activate the artifact */
+    (void)borg_activate_artifact(art_name, art_loc);
+
+    /* Use target */
+    if (art_name !=ACT_DISP_EVIL || art_name !=ACT_ARROW)
+    {
+        borg_keypress('5');
+
+            /* Set our shooting flag */
+            successful_target = -1;
+    }
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of ACTIVATING an attack ring
+ *
+ */
+static int borg_attack_aux_ring(int ring_name, int rad, int dam, int typ)
+{
+    int b_n;
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+    /* Look for that ring and to see if it is charged */
+    if (!borg_equips_ring(ring_name)) return (0);
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Activate the artifact */
+    (void)borg_activate_ring(ring_name);
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -1;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Simulate/Apply the optimal result of ACTIVATING a DRAGON ARMOUR
+ *
+ */
+static int borg_attack_aux_dragon(int sval, int rad, int dam, int typ)
+{
+    int b_n;
+
+
+    /* No firing while blind, confused, or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) return (0);
+
+
+    /* Paranoia */
+    if (borg_simulate && (rand_int(100) < 2)) return (0);
+
+
+    /* Look for that scale mail and charged*/
+    if (!borg_equips_dragon(sval)) return (0);
+
+    /* Choose optimal location */
+    b_n = borg_launch_bolt(rad, dam, typ, MAX_RANGE);
+
+    /* Simulation */
+    if (borg_simulate) return (b_n);
+
+    /* Activate the scale mail */
+     (void)borg_activate_dragon(sval);
+
+    /* Use target */
+    borg_keypress('5');
+
+    /* Set our shooting flag */
+    successful_target = -1;
+
+    /* Value */
+    return (b_n);
+}
+
+/*
+ * Try to sleep an adjacent bad guy
+ * This had been a defence maneuver, which explains the format.
+ * This is used for the sleep ii spell and the sanctuary prayer,
+ * also the holcolleth activation.
+ *
+ * There is a slight concern with the level of the artifact and the
+ * savings throw.  Currently the borg uses his own level to determine
+ * the save.  The artifact level may be lower and the borg will have
+ * the false impression that spell will work when in fact the monster
+ * may easily save against the attack.
+ */
+static int borg_attack_aux_sanctuary(void)
+{
+    int p1= 0;
+    int p2 = 0;
+    int d = 0;
+
+
+    borg_magic *as = &borg_magics[1][4];
+
+    /* Obtain initial danger */
+    borg_sleep_spell = FALSE;
+    p1= borg_danger(c_y,c_x,4, TRUE);
+
+    if (!borg_prayer_okay(1, 4))
+        return (0);
+
+    /* What effect is there? */
+    borg_sleep_spell_ii = TRUE;
+    p2=borg_danger(c_y,c_x,4, TRUE);
+    borg_sleep_spell_ii = FALSE;
+
+    /* value is d, enhance the value for rogues and rangers so that
+     * they can use their critical hits.
+     */
+    d = (p1-p2);
+
+    /* Penalize mana usage */
+    d = d - as->power;
+
+    /* Penalize use of reserve mana */
+    if (borg_skill[BI_CURSP] - as->power < borg_skill[BI_MAXSP] / 2) d = d - (as->power * 10);
+
+    /* Simulation */
+    if (borg_simulate) return (d);
+
+    /* Cast the spell */
+    if (borg_prayer(1, 4))
+    /* Value */
+    {
+        return (d);
+    }
+    else
+    return (0);
+}
+static int borg_attack_aux_artifact_holcolleth(void)
+{
+    int p1= 0;
+    int p2 = 0;
+    int d = 0;
+
+    /* Obtain initial danger */
+    borg_sleep_spell = FALSE;
+    p1= borg_danger(c_y,c_x,4, TRUE);
+
+    if (!borg_equips_artifact(ACT_SLEEP, INVEN_OUTER))
+        return (0);
+
+    /* What effect is there? */
+    borg_sleep_spell_ii = TRUE;
+    p2=borg_danger(c_y,c_x,4, TRUE);
+    borg_sleep_spell_ii = FALSE;
+
+    /* value is d, enhance the value for rogues and rangers so that
+     * they can use their critical hits.
+     */
+    d = (p1-p2);
+
+    /* Simulation */
+    if (borg_simulate) return (d);
+
+    /* Cast the spell */
+    if (borg_activate_artifact(ACT_SLEEP, INVEN_OUTER))
+    /* Value */
+    {
+        return (d);
+    }
+    else
+    return (0);
+}
+
+
+/*
+ * Simulate/Apply the optimal result of using the given "type" of attack
+ */
+static int borg_attack_aux(int what)
+{
+    int dam = 0, chance, rad = 0;
+
+    /* Analyze */
+    switch (what)
+    {
+        /* Physical attack */
+        case BF_THRUST:
+        return (borg_attack_aux_thrust());
+
+        /* Missile attack */
+        case BF_LAUNCH_NORMAL:
+        return (borg_attack_aux_launch());
+
+        /* Missile attack */
+        case BF_LAUNCH_SEEKER:
+        return (borg_attack_aux_launch_seeker());
+
+        /* Missile attack */
+        case BF_LAUNCH_SILVER:
+        return (borg_attack_aux_launch_silver());
+
+        /* Missile attack */
+        case BF_LAUNCH_FLAME:
+        return (borg_attack_aux_launch_flame());
+
+        /* Missile attack */
+        case BF_LAUNCH_FROST:
+        return (borg_attack_aux_launch_frost());
+
+        /* Missile attack */
+        case BF_LAUNCH_ANIMAL:
+        return (borg_attack_aux_launch_animal());
+
+        /* Missile attack */
+        case BF_LAUNCH_UNDEAD:
+        return (borg_attack_aux_launch_undead());
+
+        /* Missile attack */
+        case BF_LAUNCH_DEMON:
+        return (borg_attack_aux_launch_demon());
+
+        /* Missile attack */
+        case BF_LAUNCH_ORC:
+        return (borg_attack_aux_launch_orc());
+
+        /* Missile attack */
+        case BF_LAUNCH_TROLL:
+        return (borg_attack_aux_launch_troll());
+
+        /* Missile attack */
+        case BF_LAUNCH_GIANT:
+        return (borg_attack_aux_launch_giant());
+
+        /* Missile attack */
+        case BF_LAUNCH_DRAGON:
+        return (borg_attack_aux_launch_dragon());
+
+        /* Missile attack */
+        case BF_LAUNCH_EVIL:
+        return (borg_attack_aux_launch_evil());
+
+        /* Missile attack */
+        case BF_LAUNCH_WOUNDING:
+        return (borg_attack_aux_launch_wounding());
+
+        /* Missile attack */
+        case BF_LAUNCH_VENOM:
+        return (borg_attack_aux_launch_venom());
+
+        /* Missile attack */
+        case BF_LAUNCH_HOLY:
+        return (borg_attack_aux_launch_holy());
+
+        /* Object attack */
+        case BF_OBJECT:
+        return (borg_attack_aux_object());
+
+
+
+        /* Spell -- slow monster */
+        case BF_SPELL_SLOW_MONSTER:
+        dam = 10;
+        return (borg_attack_aux_spell_bolt(2,8, rad, dam, GF_OLD_SLOW));
+
+        /* Spell -- confuse monster */
+        case BF_SPELL_CONFUSE_MONSTER:
+        dam = 10;
+        return (borg_attack_aux_spell_bolt(1,0, rad, dam, GF_OLD_CONF));
+
+        case BF_SPELL_SLEEP_III:
+        dam = 10;
+        return (borg_attack_aux_spell_dispel(3,3, dam, GF_OLD_SLEEP));
+
+        /* Spell -- Polymorph Monster */
+        case BF_SPELL_POLYMORPH:
+        dam = 10;
+        return (borg_attack_aux_spell_bolt(2, 4, rad, dam, GF_OLD_POLY));
+
+        /* Spell -- magic missile */
+        case BF_SPELL_MAGIC_MISSILE:
+        dam = (3+((borg_skill[BI_CLEVEL])/4))*(4+1)/2;
+        return (borg_attack_aux_spell_bolt(0, 0, rad, dam, GF_MISSILE));
+
+        /* Spell -- magic missile EMERGENCY*/
+        case BF_SPELL_MAGIC_MISSILE_RESERVE:
+        dam = (3+((borg_skill[BI_CLEVEL])/4))*(4+1);
+        return (borg_attack_aux_spell_bolt_reserve(0, 0, rad, dam, GF_MISSILE));
+
+        /* Spell -- electric bolt */
+        case BF_SPELL_ELEC_BOLT:
+        dam = (3+((borg_skill[BI_CLEVEL]-5)/4))*(8+1)/2;
+        return (borg_attack_aux_spell_bolt(1, 1, rad, dam, GF_ELEC));
+
+        /* Spell -- cold bolt */
+        case BF_SPELL_COLD_BOLT:
+        dam = (5+((borg_skill[BI_CLEVEL]-5)/4))*(8+1)/2;
+        return (borg_attack_aux_spell_bolt(1, 7, rad, dam, GF_COLD));
+
+        /* Spell -- fire bolt */
+        case BF_SPELL_FIRE_BOLT:
+        dam = (8+((borg_skill[BI_CLEVEL]-5)/4))*(8+1)/2;
+        return (borg_attack_aux_spell_bolt(2, 3, rad, dam, GF_FIRE));
+
+        /* Spell -- acid bolt */
+        case BF_SPELL_ACID_BOLT:
+        dam = (6+((borg_skill[BI_CLEVEL]-5)/4))*(8+1)/2;
+        return (borg_attack_aux_spell_bolt(2, 7, rad, dam, GF_ACID));
+
+        /* Spell -- kill wall */
+        case BF_SPELL_STONE_TO_MUD:
+        dam = (20+(30/2));
+        return (borg_attack_aux_spell_bolt(2, 2, rad, dam, GF_KILL_WALL));
+
+        /* Spell -- light beam */
+        case BF_SPELL_LITE_BEAM:
+        rad = -1;
+        dam = (6*(8+1)/2);
+        return (borg_attack_aux_spell_bolt(1, 6, rad, dam, GF_LITE_WEAK));
+
+        /* Spell -- stinking cloud */
+        case BF_SPELL_STINK_CLOUD:
+        rad = 2;
+        dam = (10 + (borg_skill[BI_CLEVEL]/2));
+        return (borg_attack_aux_spell_bolt(0, 8, rad, dam, GF_POIS));
+
+        /* Spell -- cold ball */
+        case BF_SPELL_COLD_BALL:
+        rad = 2;
+        dam = (30 + borg_skill[BI_CLEVEL]);
+        return (borg_attack_aux_spell_bolt(3, 0, rad, dam, GF_COLD));
+
+        /* Spell -- acid ball */
+        case BF_SPELL_ACID_BALL:
+        rad = 2;
+        dam = (40 + (borg_skill[BI_CLEVEL]/2));
+        return (borg_attack_aux_spell_bolt(5, 3, rad, dam, GF_ACID));
+
+        /* Spell -- fire ball */
+        case BF_SPELL_FIRE_BALL:
+        rad = 2;
+        dam = (55 + borg_skill[BI_CLEVEL]);
+        return (borg_attack_aux_spell_bolt(3, 4, rad, dam, GF_FIRE));
+
+        /* Spell -- poison storm  Cloud Kill*/
+        case BF_SPELL_CLOUD_KILL:
+        rad = 3;
+        dam = (40 + (borg_skill[BI_CLEVEL]/2));
+        return (borg_attack_aux_spell_bolt(5, 2, rad, dam, GF_POIS));
+
+        /* Spell -- Ice Storm */
+        case BF_SPELL_COLD_STORM:
+        rad = 3;
+        dam = (50 + borg_skill[BI_CLEVEL] * 2);
+        return (borg_attack_aux_spell_bolt(5, 4, rad, dam, GF_ICE));
+
+        /* Spell -- meteor storm */
+        case BF_SPELL_METEOR_STORM:
+        rad = 3;
+        dam = (30 + borg_skill[BI_CLEVEL] / 2);
+        return (borg_attack_aux_spell_bolt(5, 5, rad, dam, GF_METEOR));
+
+        /* Spell -- Rift */
+        case BF_SPELL_RIFT:
+        dam = ((borg_skill[BI_CLEVEL] * 3) + 40);
+        return (borg_attack_aux_spell_bolt(5, 6, rad, dam, GF_GRAVITY));
+
+        /* Spell -- mana storm */
+        case BF_SPELL_MANA_STORM:
+        rad = 3;
+        dam = (300 + (borg_skill[BI_CLEVEL] * 2));
+        return (borg_attack_aux_spell_bolt(8, 7, rad, dam, GF_MANA));
+
+        /* Spell -- Shock Wave */
+        case BF_SPELL_SHOCK_WAVE:
+        dam = (borg_skill[BI_CLEVEL] + 10);
+        rad = 2;
+        return (borg_attack_aux_spell_bolt(5, 0, rad, dam, GF_SOUND));
+
+        /* Spell -- Explosion */
+        case BF_SPELL_EXPLOSION:
+        dam = ((borg_skill[BI_CLEVEL] * 2) + 20);
+        rad = 2;
+        return (borg_attack_aux_spell_bolt(5, 1, rad, dam, GF_SHARD));
+
+        /* Spell -- Bedlam (Big conf ball, no damage) */
+        case BF_SPELL_BEDLAM:
+        dam = (borg_skill[BI_CLEVEL]);
+        rad = 4;
+        return (borg_attack_aux_spell_bolt(8, 1, rad, dam, GF_OLD_CONF));
+
+        /* Spell -- Rend Soul */
+        case BF_SPELL_REND_SOUL:
+        dam = ((borg_skill[BI_CLEVEL] * 11) / 2);
+        return (borg_attack_aux_spell_bolt(8, 2, rad, dam, GF_NETHER));
+
+        /* Spell -- Chaos Strike */
+        case BF_SPELL_CHAOS_STRIKE:
+        dam = ((borg_skill[BI_CLEVEL] * 13) / 2);
+        return (borg_attack_aux_spell_bolt(8, 6, rad, dam, GF_CHAOS));
+
+
+        /* Prayer -- orb of draining */
+        case BF_PRAYER_HOLY_ORB_BALL:
+        rad = ((borg_skill[BI_CLEVEL] >= 30) ? 3 : 2);
+        dam = ((borg_class == CLASS_PRIEST) ? 2 : 4);
+        dam = (3*(8+1)/2 + borg_skill[BI_CLEVEL] + (borg_skill[BI_CLEVEL]/dam));
+        return (borg_attack_aux_prayer_bolt(2, 1, rad, dam, GF_HOLY_ORB));
+
+        /* Prayer -- blind creature */
+        case BF_PRAYER_BLIND_CREATURE:
+        dam = 10;
+        return (borg_attack_aux_prayer_bolt(1,0, rad, dam, GF_OLD_CONF));
+
+        /* Prayer -- and sanctuary */
+        case BF_PRAYER_SANCTUARY:
+        dam = 10;
+        return (borg_attack_aux_sanctuary());
+
+        /* Prayer -- Dispel Undead */
+        case BF_PRAYER_DISP_UNDEAD1:
+        dam = ((borg_skill[BI_CLEVEL] * 3)/2);
+        return (borg_attack_aux_prayer_dispel(3,1, dam, GF_DISP_UNDEAD));
+
+        /* Prayer -- Dispel Evil */
+        case BF_PRAYER_DISP_EVIL1:
+        dam = ((borg_skill[BI_CLEVEL] * 3)/2);
+        return (borg_attack_aux_prayer_dispel(3,3, dam, GF_DISP_EVIL));
+
+        /* Prayer -- Dispel Undead2 Wrath of God */
+        case BF_PRAYER_DISP_UNDEAD2:
+        dam = ((borg_skill[BI_CLEVEL] * 4)/2);
+        return (borg_attack_aux_prayer_dispel(8,0, dam, GF_DISP_UNDEAD));
+
+        /* Prayer -- Dispel EVIL2 Wrath of God */
+        case BF_PRAYER_DISP_EVIL2:
+        dam = ((borg_skill[BI_CLEVEL] * 4)/2);
+        return (borg_attack_aux_prayer_dispel(8,1, dam, GF_DISP_EVIL));
+
+        /* Prayer -- Banishment (teleport evil away)*/
+        /* This is a defense spell:  done in borg_defense() */
+
+        /* Prayer -- Holy Word also has heal effect and is considered in borg_heal */
+        case BF_PRAYER_HOLY_WORD:
+        if (borg_skill[BI_MAXHP] - borg_skill[BI_CURHP] >= 300)
+         /*  force him to think the spell is more deadly to get him to
+          * cast it.  This will provide some healing for him.
+          */
+        {
+         dam = ((borg_skill[BI_CLEVEL] * 10));
+         return (borg_attack_aux_prayer_dispel(3,5, dam, GF_DISP_EVIL));
+        }
+        else /* If he is not wounded dont cast this, use Disp Evil instead. */
+        {
+         dam = ((borg_skill[BI_CLEVEL] * 3)/2) -50;
+         return (borg_attack_aux_prayer_dispel(3,5, dam, GF_DISP_EVIL));
+        }
+
+        /* Prayer -- Drain Life Wrath of God */
+        case BF_PRAYER_DRAIN_LIFE:
+        dam = (borg_skill[BI_CLEVEL] * 4);
+        return (borg_attack_aux_prayer_bolt(8,4, rad, dam, GF_OLD_DRAIN));
+
+
+        /* ROD -- slow monster */
+        case BF_ROD_SLOW_MONSTER:
+        dam = 10;
+        return (borg_attack_aux_rod_bolt(SV_ROD_SLOW_MONSTER, rad, dam, GF_OLD_SLOW));
+
+        /* ROD -- sleep monster */
+        case BF_ROD_SLEEP_MONSTER:
+        dam = 10;
+        return (borg_attack_aux_rod_bolt(SV_ROD_SLEEP_MONSTER, rad, dam, GF_OLD_SLEEP));
+
+        /* Rod -- elec bolt */
+        case BF_ROD_ELEC_BOLT:
+        dam = 3*(8+1)/2;
+        return (borg_attack_aux_rod_bolt(SV_ROD_ELEC_BOLT, rad, dam, GF_ELEC));
+
+        /* Rod -- cold bolt */
+        case BF_ROD_COLD_BOLT:
+        dam = 5*(8+1)/2;
+        return (borg_attack_aux_rod_bolt(SV_ROD_COLD_BOLT, rad, dam, GF_COLD));
+
+        /* Rod -- acid bolt */
+        case BF_ROD_ACID_BOLT:
+        dam = 6*(8+1)/2;
+        return (borg_attack_aux_rod_bolt(SV_ROD_ACID_BOLT, rad, dam, GF_ACID));
+
+        /* Rod -- fire bolt */
+        case BF_ROD_FIRE_BOLT:
+        dam = 8*(8+1)/2;
+        return (borg_attack_aux_rod_bolt(SV_ROD_FIRE_BOLT, rad, dam, GF_FIRE));
+
+        /* Spell -- light beam */
+        case BF_ROD_LITE_BEAM:
+        rad = -1;
+        dam = (6*(8+1)/2);
+        return (borg_attack_aux_rod_bolt(SV_ROD_LITE, rad, dam, GF_LITE_WEAK));
+
+        /* Spell -- drain life */
+        case BF_ROD_DRAIN_LIFE:
+        dam = (75);
+        return (borg_attack_aux_rod_bolt(SV_ROD_DRAIN_LIFE, rad, dam, GF_OLD_DRAIN));
+
+        /* Rod -- elec ball */
+        case BF_ROD_ELEC_BALL:
+        rad = 2;
+        dam = 32;
+        return (borg_attack_aux_rod_bolt(SV_ROD_ELEC_BALL, rad, dam, GF_ELEC));
+
+        /* Rod -- acid ball */
+        case BF_ROD_COLD_BALL:
+        rad = 2;
+        dam = 48;
+        return (borg_attack_aux_rod_bolt(SV_ROD_COLD_BALL, rad, dam, GF_COLD));
+
+        /* Rod -- acid ball */
+        case BF_ROD_ACID_BALL:
+        rad = 2;
+        dam = 60;
+        return (borg_attack_aux_rod_bolt(SV_ROD_ACID_BALL, rad, dam, GF_ACID));
+
+        /* Rod -- fire ball */
+        case BF_ROD_FIRE_BALL:
+        rad = 2;
+        dam = 72;
+        return (borg_attack_aux_rod_bolt(SV_ROD_FIRE_BALL, rad, dam, GF_FIRE));
+
+
+        /* Wand -- magic missile */
+        case BF_WAND_MAGIC_MISSILE:
+        dam = 2*(6+1)/2;
+        return (borg_attack_aux_wand_bolt(SV_WAND_MAGIC_MISSILE, rad, dam, GF_MISSILE));
+
+        /* Wand -- slow monster */
+        case BF_WAND_SLOW_MONSTER:
+        dam = 10;
+        return (borg_attack_aux_wand_bolt(SV_WAND_SLOW_MONSTER, rad, dam, GF_OLD_SLOW));
+
+        /* Wand -- sleep monster */
+        case BF_WAND_SLEEP_MONSTER:
+        dam = 10;
+        return (borg_attack_aux_wand_bolt(SV_WAND_SLEEP_MONSTER, rad, dam, GF_OLD_SLEEP));
+
+        /* Wand -- fear monster */
+        case BF_WAND_FEAR_MONSTER:
+        dam = 2*(6+1)/2;
+        return (borg_attack_aux_wand_bolt(SV_WAND_FEAR_MONSTER, rad, dam, GF_TURN_ALL));
+
+       /* Wand -- conf monster */
+        case BF_WAND_CONFUSE_MONSTER:
+        dam = 2*(6+1)/2;
+        return (borg_attack_aux_wand_bolt(SV_WAND_CONFUSE_MONSTER, rad, dam, GF_OLD_CONF));
+
+        /* Wand -- elec bolt */
+        case BF_WAND_ELEC_BOLT:
+        dam = 3*(8+1)/2;
+        return (borg_attack_aux_wand_bolt(SV_WAND_ELEC_BOLT, rad, dam, GF_ELEC));
+
+        /* Wand -- cold bolt */
+        case BF_WAND_COLD_BOLT:
+        dam = 3*(8+1)/2;
+        return (borg_attack_aux_wand_bolt(SV_WAND_COLD_BOLT, rad, dam, GF_COLD));
+
+        /* Wand -- acid bolt */
+        case BF_WAND_ACID_BOLT:
+        dam = 5*(8+1)/2;
+        return (borg_attack_aux_wand_bolt(SV_WAND_ACID_BOLT, rad, dam, GF_ACID));
+
+        /* Wand -- fire bolt */
+        case BF_WAND_FIRE_BOLT:
+        dam = 6*(8+1)/2;
+        return (borg_attack_aux_wand_bolt(SV_WAND_FIRE_BOLT, rad, dam, GF_FIRE));
+
+        /* Spell -- light beam */
+        case BF_WAND_LITE_BEAM:
+        rad = -1;
+        dam = (6*(8+1)/2);
+        return (borg_attack_aux_wand_bolt(SV_WAND_LITE, rad, dam, GF_LITE_WEAK));
+
+        /* Wand -- stinking cloud */
+        case BF_WAND_STINKING_CLOUD:
+        rad = 2;
+        dam = 12;
+        return (borg_attack_aux_wand_bolt(SV_WAND_STINKING_CLOUD, rad, dam, GF_POIS));
+
+        /* Wand -- elec ball */
+        case BF_WAND_ELEC_BALL:
+        rad = 2;
+        dam = 32;
+        return (borg_attack_aux_wand_bolt(SV_WAND_ELEC_BALL, rad, dam, GF_ELEC));
+
+        /* Wand -- acid ball */
+        case BF_WAND_COLD_BALL:
+        rad = 2;
+        dam = 48;
+        return (borg_attack_aux_wand_bolt(SV_WAND_COLD_BALL, rad, dam, GF_COLD));
+
+        /* Wand -- acid ball */
+        case BF_WAND_ACID_BALL:
+        rad = 2;
+        dam = 60;
+        return (borg_attack_aux_wand_bolt(SV_WAND_ACID_BALL, rad, dam, GF_ACID));
+
+        /* Wand -- fire ball */
+        case BF_WAND_FIRE_BALL:
+        rad = 2;
+        dam = 72;
+        return (borg_attack_aux_wand_bolt(SV_WAND_FIRE_BALL, rad, dam, GF_FIRE));
+
+        /* Wand -- dragon cold */
+        case BF_WAND_DRAGON_COLD:
+        rad = 3;
+        dam = 80;
+        return (borg_attack_aux_wand_bolt(SV_WAND_DRAGON_COLD, rad, dam, GF_COLD));
+
+        /* Wand -- dragon fire */
+        case BF_WAND_DRAGON_FIRE:
+        rad = 3;
+        dam = 100;
+        return (borg_attack_aux_wand_bolt(SV_WAND_DRAGON_FIRE, rad, dam, GF_FIRE));
+
+        /* Wand -- annihilation */
+        case BF_WAND_ANNIHILATION:
+        dam = 125;
+        return (borg_attack_aux_wand_bolt(SV_WAND_ANNIHILATION, rad, dam, GF_OLD_DRAIN));
+
+        /* Wand -- drain life */
+        case BF_WAND_DRAIN_LIFE:
+        dam = 75;
+        return (borg_attack_aux_wand_bolt(SV_WAND_DRAIN_LIFE, rad, dam, GF_OLD_DRAIN));
+
+        /* Wand -- wand of wonder */
+        case BF_WAND_WONDER:
+        dam = 35;
+        return (borg_attack_aux_wand_bolt(SV_WAND_WONDER, rad, dam, GF_MISSILE));
+
+        /* Staff -- Sleep Monsters */
+        case BF_STAFF_SLEEP_MONSTERS:
+        dam = 60;
+        return (borg_attack_aux_staff_dispel(SV_STAFF_SLEEP_MONSTERS, rad, dam, GF_OLD_SLEEP));
+
+        /* Staff -- Slow Monsters */
+        case BF_STAFF_SLOW_MONSTERS:
+        dam = 60;
+        rad = 10;
+        return (borg_attack_aux_staff_dispel(SV_STAFF_SLOW_MONSTERS, rad, dam, GF_OLD_SLOW));
+
+        /* Staff -- Dispel Evil */
+        case BF_STAFF_DISPEL_EVIL:
+        dam = 60;
+        return (borg_attack_aux_staff_dispel(SV_STAFF_DISPEL_EVIL, rad, dam, GF_DISP_EVIL));
+
+        /* Staff -- Power */
+        case BF_STAFF_POWER:
+        dam = 120;
+        return (borg_attack_aux_staff_dispel(SV_STAFF_POWER, rad, dam, GF_TURN_ALL));
+
+        /* Staff -- holiness */
+        case BF_STAFF_HOLINESS:
+        if (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] /2) dam = 500;
+        else dam = 120;
+        return (borg_attack_aux_staff_dispel(SV_STAFF_HOLINESS, rad, dam, GF_DISP_EVIL));
+
+
+        /* Artifact -- Narthanc- fire bolt 9d8*/
+        case BF_ACT_FIRE1:
+        rad = 0;
+        dam = (9*(8+1)/2);
+        return (borg_attack_aux_artifact(ACT_FIRE1, INVEN_WIELD,rad, dam, GF_FIRE));
+
+        /* Artifact -- Anduril- fire ball 72*/
+        case BF_ACT_FIRE2:
+        rad = 2;
+        dam = 72;
+        return (borg_attack_aux_artifact(ACT_FIRE2, INVEN_WIELD, rad, dam, GF_FIRE));
+
+        /* Artifact -- NARYA- FIRE BALL 120 */
+        case BF_ACT_FIRE3:
+        rad = 2;
+        dam = 120;
+        return (borg_attack_aux_artifact(ACT_FIRE3,  INVEN_RIGHT,rad, dam, GF_FIRE));
+
+        /* Artifact -- Nimthanc- frost bolt 6d8*/
+        case BF_ACT_FROST1:
+        rad = 0;
+        dam = (6*(8+1)/2);
+        return (borg_attack_aux_artifact(ACT_FROST1, INVEN_WIELD, rad, dam, GF_COLD));
+
+        /* Artifact -- Belangil- frost ball 48*/
+        case BF_ACT_FROST2:
+        rad = 2;
+        dam = 48;
+        return (borg_attack_aux_artifact(ACT_FROST2,  INVEN_WIELD,rad, dam, GF_COLD));
+
+        /* Artifact -- Arunruth- frost bolt 12d8*/
+        case BF_ACT_FROST4:
+        rad = 0;
+        dam = (12*(8+1)/2);
+        return (borg_attack_aux_artifact(ACT_FROST4,  INVEN_WIELD,rad, dam, GF_COLD));
+
+        /* Artifact -- Ringil- frost ball 100*/
+        case BF_ACT_FROST3:
+        rad = 2;
+        dam = 100;
+        return (borg_attack_aux_artifact(ACT_FROST3,  INVEN_WIELD,rad, dam, GF_COLD));
+
+        /* Artifact -- Dethanc- electric bolt 4d8*/
+        case BF_ACT_LIGHTNING_BOLT:
+        rad = 0;
+        dam = (4*(8+1)/2);
+        return (borg_attack_aux_artifact(ACT_LIGHTNING_BOLT, INVEN_WIELD, rad, dam, GF_ELEC));
+
+        /* Artifact -- Rilia- poison gas 12*/
+        case BF_ACT_STINKING_CLOUD:
+        rad = 2;
+        dam = 12;
+        return (borg_attack_aux_artifact(ACT_STINKING_CLOUD, INVEN_WIELD, rad, dam, GF_POIS));
+
+        /* Artifact -- Theoden- drain Life 120*/
+        case BF_ACT_DRAIN_LIFE2:
+        rad = 0;
+        dam = 120;
+        return (borg_attack_aux_artifact(ACT_DRAIN_LIFE2, INVEN_WIELD, rad, dam, GF_OLD_DRAIN));
+
+        /* Artifact -- Totila- confustion */
+        case BF_ACT_CONFUSE:
+        rad = 0;
+        dam = 10;
+        return (borg_attack_aux_artifact(ACT_CONFUSE,  INVEN_WIELD,rad, dam, GF_OLD_CONF));
+
+        /* Artifact -- Holcolleth -- sleep ii and sanctuary */
+        case BF_ACT_SLEEP:
+        dam = 10;
+        return (borg_attack_aux_artifact_holcolleth());
+
+        /* Artifact -- TURMIL- drain life 90 */
+        case BF_ACT_DRAIN_LIFE1:
+        rad = 0;
+        dam = 90;
+        return (borg_attack_aux_artifact(ACT_DRAIN_LIFE1,  INVEN_WIELD,rad, dam, GF_OLD_DRAIN));
+
+        /* Artifact -- Razorback, Fingolfin- spikes 150 */
+        case BF_ACT_ARROW:
+        rad = 0;
+        dam = 150;
+        return (borg_attack_aux_artifact(ACT_ARROW,  INVEN_BODY,rad, dam, GF_MISSILE));
+
+        /* Artifact -- Cammithrim- Magic Missile 2d6 */
+        case BF_ACT_MISSILE:
+        rad = 0;
+        dam = (2*(6+1)/2);
+        return (borg_attack_aux_artifact(ACT_MISSILE,  INVEN_HANDS,rad, dam, GF_MISSILE));
+
+        /* Artifact -- PaurNEN- ACID bolt 5d8 */
+        case BF_ACT_ACID1:
+        rad = 0;
+        dam = (5*(8+1)/2);
+        return (borg_attack_aux_artifact(ACT_ACID1,  INVEN_HANDS,rad, dam, GF_ACID));
+
+        /* Artifact -- INGWE- DISPEL EVIL X5 */
+        case BF_ACT_DISP_EVIL:
+        rad = 10;
+        dam = (10 + (borg_skill[BI_CLEVEL]*5)/2);
+        return (borg_attack_aux_artifact(ACT_DISP_EVIL,  INVEN_NECK,rad, dam, GF_DISP_EVIL));
+
+        /* Artifact -- NENYA- COLD BALL 200 */
+        case BF_ACT_FROST5:
+        rad = 2;
+        dam = 200;
+        return (borg_attack_aux_artifact(ACT_FROST5,  INVEN_RIGHT,rad, dam, GF_COLD));
+
+        /* Artifact -- VILYA- ELEC BALL 250 */
+        case BF_ACT_ELEC2:
+        rad = 2;
+        dam = 250;
+        return (borg_attack_aux_artifact(ACT_ELEC2,  INVEN_RIGHT,rad, dam, GF_ELEC));
+
+        /* Artifact -- Mana Bolt */
+        case BF_ACT_MANA_BOLT:
+        rad = 0;
+        dam = (12*6) / 2;
+        return (borg_attack_aux_artifact(ACT_MANA_BOLT,  INVEN_RIGHT,rad, dam, GF_MANA));
+
+		/* Ring of ACID */
+		case BF_RING_ACID:
+		rad = 2;
+		dam = 70;
+        return (borg_attack_aux_ring(SV_RING_ACID, rad, dam, GF_ACID));
+
+		/* Ring of FLAMES */
+		case BF_RING_FIRE:
+		rad = 2;
+		dam = 80;
+        return (borg_attack_aux_ring(SV_RING_FLAMES, rad, dam, GF_FIRE));
+
+		/* Ring of ICE */
+		case BF_RING_ICE:
+		rad = 2;
+		dam = 75;
+        return (borg_attack_aux_ring(SV_RING_ICE, rad, dam, GF_ICE));
+
+		/* Ring of LIGHTNING */
+		case BF_RING_LIGHTNING:
+		rad = 2;
+		dam = 85;
+        return (borg_attack_aux_ring(SV_RING_LIGHTNING, rad, dam, GF_ELEC));
+
+    /* Hack -- Dragon Scale Mail can be activated as well */
+            case BF_DRAGON_BLUE:
+            rad =2;
+            dam=100;
+            return (borg_attack_aux_dragon(SV_DRAGON_BLUE, rad, dam, GF_ELEC));
+
+            case BF_DRAGON_WHITE:
+            rad =2;
+            dam=110;
+            return (borg_attack_aux_dragon(SV_DRAGON_WHITE, rad, dam, GF_COLD));
+
+            case BF_DRAGON_BLACK:
+            rad =2;
+            dam=130;
+            return (borg_attack_aux_dragon(SV_DRAGON_BLACK, rad, dam, GF_ACID));
+
+            case BF_DRAGON_GREEN:
+            rad =2;
+            dam=150;
+            return (borg_attack_aux_dragon(SV_DRAGON_GREEN, rad, dam, GF_POIS));
+
+            case BF_DRAGON_RED:
+            rad =2;
+            dam=200;
+            return (borg_attack_aux_dragon(SV_DRAGON_RED, rad, dam, GF_FIRE));
+
+            case BF_DRAGON_MULTIHUED:
+                chance = rand_int(5);
+            rad =2;
+            dam=200;
+            return (borg_attack_aux_dragon(SV_DRAGON_MULTIHUED, rad, dam,
+                    (((chance == 1) ? GF_ELEC :
+                           ((chance == 2) ? GF_COLD :
+                            ((chance == 3) ? GF_ACID :
+                             ((chance == 4) ? GF_POIS : GF_FIRE)))) )) );
+
+            case BF_DRAGON_BRONZE:
+            rad =2;
+            dam=120;
+            return (borg_attack_aux_dragon(SV_DRAGON_BRONZE, rad, dam, GF_CONFUSION));
+
+            case BF_DRAGON_GOLD:
+            rad =2;
+            dam=150;
+            return (borg_attack_aux_dragon(SV_DRAGON_GOLD, rad, dam, GF_SOUND));
+
+            case BF_DRAGON_CHAOS:
+            chance = rand_int(2);
+            rad =2;
+            dam=220;
+            return (borg_attack_aux_dragon(SV_DRAGON_CHAOS, rad, dam,
+                (chance == 1 ? GF_CHAOS : GF_DISENCHANT)) );
+
+            case BF_DRAGON_LAW:
+            chance = rand_int(2);
+            rad =2;
+            dam=230;
+            return (borg_attack_aux_dragon(SV_DRAGON_LAW, rad, dam,
+                (chance == 1 ? GF_SOUND : GF_SHARD)) );
+
+            case BF_DRAGON_BALANCE:
+            chance = rand_int(4);
+            rad =2;
+            dam=230;
+            return (borg_attack_aux_dragon(SV_DRAGON_BALANCE, rad, dam,
+              ( ((chance == 1) ? GF_CHAOS :
+                           ((chance == 2) ? GF_DISENCHANT :
+                            ((chance == 3) ? GF_SOUND : GF_SHARD))) )) );
+
+            case BF_DRAGON_SHINING:
+            chance = rand_int(2);
+            rad =2;
+            dam=200;
+            return (borg_attack_aux_dragon(SV_DRAGON_SHINING, rad, dam,
+                (chance == 0 ? GF_LITE : GF_DARK)) );
+
+            case BF_DRAGON_POWER:
+            rad =2;
+            dam=300;
+            return (borg_attack_aux_dragon(SV_DRAGON_POWER, rad, dam, GF_MISSILE));
+       }
+
+
+
+
+
+    /* Oops */
+    return (0);
+}
+
+
+/*
+ * Attack nearby monsters, in the best possible way, if any.
+ *
+ * We consider a variety of possible attacks, including physical attacks
+ * on adjacent monsters, missile attacks on nearby monsters, spell/prayer
+ * attacks on nearby monsters, and wand/rod attacks on nearby monsters.
+ *
+ * Basically, for each of the known "types" of attack, we "simulate" the
+ * "optimal" result of using that attack, and then we "apply" the "type"
+ * of attack which appears to have the "optimal" result.
+ *
+ * When calculating the "result" of using an attack, we only consider the
+ * effect of the attack on visible, on-screen, known monsters, which are
+ * within 16 grids of the player.  This prevents most "spurious" attacks,
+ * but we can still be fooled by situations like creeping coins which die
+ * while out of sight, leaving behind a pile of coins, which we then find
+ * again, and attack with distance attacks, which have no effect.  Perhaps
+ * we should "expect" certain results, and take note of failure to observe
+ * those effects.  XXX XXX XXX
+ *
+ * See above for the "semantics" of each "type" of attack.
+ */
+bool borg_attack(bool boosted_bravery)
+{
+    int i, x, y;
+
+    int n, b_n = 0;
+    int g, b_g = -1;
+
+    borg_grid *ag;
+
+    /* Nobody around */
+    if (!borg_kills_cnt) return (FALSE);
+
+    /* Set the attacking flag so that danger is boosted for monsters */
+    /* we want to attack first. */
+    borg_attacking = TRUE;
+
+    /* Reset list */
+    borg_temp_n = 0;
+
+    /* Find "nearby" monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+
+        /* Monster */
+        kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Require current knowledge */
+        if (kill->when < borg_t - 2) continue;
+
+        /* Ignore multiplying monsters and when fleeing from scaries*/
+        if (goal_ignoring && !borg_skill[BI_ISAFRAID] &&
+            (r_info[kill->r_idx].flags2 & RF2_MULTIPLY )) continue;
+
+        /* no attacking most scaryguys, try to get off the level */
+        if (scaryguy_on_level)
+        {
+            /* probably Grip or Fang. */
+            if (borg_skill[BI_CDEPTH] <= 5 && borg_skill[BI_CDEPTH] != 0 &&
+                borg_fighting_unique)
+            {
+                /* Try to fight Grip and Fang. */
+            }
+            else if (borg_skill[BI_CDEPTH] <= 5 && borg_skill[BI_CDEPTH] != 0 &&
+                (r_info[kill->r_idx].flags2 & RF2_MULTIPLY))
+            {
+                /* Try to fight single worms and mice. */
+            }
+            else if (borg_t - borg_began >= 2000 || borg_time_town + (borg_t - borg_began) >= 3000)
+            {
+                /* Try to fight been there too long. */
+            }
+            else if (boosted_bravery ||
+            		 borg_no_retreat >= 1 ||
+            		 goal_recalling)
+            {
+                /* Try to fight if being Boosted or recall engaged. */
+            }
+            else
+            {
+                /* Flee from other scary guys */
+                continue;
+            }
+
+        }
+
+        /* Acquire location */
+        x = kill->x;
+        y = kill->y;
+
+        /* Get grid */
+        ag = &borg_grids[y][x];
+
+        /* Never shoot off-screen */
+        if (!(ag->info & BORG_OKAY)) continue;
+
+        /* Never shoot through walls */
+        if (!(ag->info & BORG_VIEW)) continue;
+
+        /* Check the distance XXX XXX XXX */
+        if (distance(c_y, c_x, y, x) > MAX_RANGE) continue;
+
+        /* Save the location (careful) */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* No destinations */
+    if (!borg_temp_n)
+    {
+        borg_attacking = FALSE;
+        return (FALSE);
+    }
+
+    /* Simulate */
+    borg_simulate = TRUE;
+
+    /* Analyze the possible attacks */
+    for (g = 0; g < BF_MAX; g++)
+    {
+
+        /* Simulate */
+        n = borg_attack_aux(g);
+
+        /* Track "best" attack  <= */
+        if (n <= b_n) continue;
+
+        /* Track best */
+        b_g = g;
+        b_n = n;
+    }
+
+    /* Nothing good */
+    if (b_n <= 0)
+    {
+        borg_attacking = FALSE;
+        return (FALSE);
+    }
+
+
+    /* Note */
+    borg_note(format("# Performing attack type %d with value %d.", b_g, b_n));
+
+    /* Instantiate */
+    borg_simulate = FALSE;
+
+    /* Instantiate */
+    (void)borg_attack_aux(b_g);
+
+    borg_attacking = FALSE;
+
+    /* Success */
+    return (TRUE);
+}
+
+/* Log the pathway and feature of the spell pathway
+ * Useful for debugging beams and Tport Other spell
+ */
+void static borg_log_spellpath(bool beam)
+{
+    int n_x, n_y, x, y;
+
+	int dist = 0;
+
+    borg_grid *ag;
+    borg_kill *kill;
+
+	y = borg_target_y;
+	x = borg_target_x;
+	n_x = c_x;
+	n_y = c_y;
+
+    while (1)
+    {
+    	ag = &borg_grids[n_y][n_x];
+    	kill = &borg_kills[ag->kill];
+
+		/* Note the Pathway */
+        if (ag->kill)
+        {
+			borg_note(format("# Logging Spell pathway (%d,%d): %s, danger %d",
+			          n_y, n_x, (r_name + r_info[kill->r_idx].name),
+			          borg_danger_aux(c_y,c_x, 1, ag->kill, TRUE)));
+		}
+		else if (!borg_cave_floor_grid(ag))
+		{
+			borg_note(format("# Logging Spell pathway (%d,%d): Wall grid.", n_y, n_x));
+			break;
+		}
+		else
+		{
+			borg_note(format("# Logging Spell pathway (%d,%d).", n_y, n_x));
+		}
+
+        /* Stop loop if we reach our target if using bolt */
+        if (n_x == x && n_y == y) break;
+
+		/* Safegaurd not to loop */
+		dist ++;
+		if (dist >= MAX_RANGE) break;
+
+        /* Calculate the new location */
+        mmove2(&n_y, &n_x, c_y, c_x, y, x);
+    }
+}
+
+
+
+/*
+ *
+ * There are several types of setup moves:
+ *
+ *   Temporary speed
+ *   Protect From Evil
+ *   Bless\Prayer
+ *   Berserk\Heroism
+ *   Temp Resist (either all or just cold/fire?)
+ *   Shield
+ *   Teleport away
+ *   Glyph of Warding
+ *   See inviso
+ *
+ * * and many others
+ *
+ */
+enum
+{
+    BD_BLESS,
+    BD_SPEED,
+    BD_RESIST_FC,
+    BD_RESIST_FECAP,
+    BD_RESIST_F,
+    BD_RESIST_C, /* 5*/
+    BD_RESIST_A,
+    BD_RESIST_P,
+    BD_PROT_FROM_EVIL,
+    BD_SHIELD,
+    BD_TELE_AWAY, /* 10 */
+    BD_HERO,
+    BD_BERSERK,
+    BD_GLYPH,
+    BD_CREATE_DOOR,
+    BD_MASS_GENOCIDE, /* 15 */
+    BD_GENOCIDE,
+    BD_GENOCIDE_NASTIES,
+    BD_EARTHQUAKE,
+    BD_DESTRUCTION,
+    BD_TPORTLEVEL,  /* 20 */
+    BD_BANISHMENT,  /* Priest spell */
+    BD_DETECT_INVISO,
+    BD_LIGHT_BEAM,
+    BD_SHIFT_PANEL,
+	BD_REST,
+	BD_TELE_AWAY_MORGOTH,
+	BD_BANISHMENT_MORGOTH,
+	BD_LIGHT_MORGOTH,
+
+    BD_MAX
+};
+
+/*
+ * Bless/Prayer to prepare for battle
+ */
+static int borg_defend_aux_bless( int p1 )
+{
+    int fail_allowed = 15;
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+	int j;
+
+	bool borg_near_kill = FALSE;
+
+    /* already blessed */
+    if (borg_bless)
+        return (0);
+
+    /* Cant when Blind */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (0);
+
+    /* Dark */
+    if (!(ag->info & BORG_GLOW) && borg_skill[BI_CURLITE] == 0) return (0);
+
+
+    /* no spell */
+    if ( !borg_prayer_okay_fail(0, 2, fail_allowed) &&
+         !borg_prayer_okay_fail(3, 0, fail_allowed) &&
+         -1 == borg_slot(TV_SCROLL, SV_SCROLL_BLESSING) &&
+         -1 == borg_slot(TV_SCROLL, SV_SCROLL_HOLY_CHANT) &&
+         -1 == borg_slot(TV_SCROLL, SV_SCROLL_HOLY_PRAYER))
+        return (0);
+
+	/* Check if a monster is close to me .
+	 * Must be in a fairly central region
+	 */
+	if (c_y >= 3 && c_y <= AUTO_MAX_Y - 3 &&
+	    c_x >= 3 && c_x <= AUTO_MAX_X - 3)
+	{
+	    /* Scan 2 grids away neighbors */
+	    for (j = 0; j < 24; j++)
+	    {
+	        int y = c_y + borg_ddy_ddd[j];
+	        int x = c_x + borg_ddx_ddd[j];
+
+	        /* Get the grid */
+	        ag = &borg_grids[y][x];
+
+	        /* kill near me? */
+	        if (ag->kill) borg_near_kill = TRUE;
+
+	        /* kill adjacent to me is not good */
+	        if (j < 9 && ag->kill) borg_near_kill = FALSE;
+		}
+	}
+
+    /* if we are in some danger but not much, go for a quick bless */
+    if ((p1 > avoidance/12 || borg_near_kill) && p1 < avoidance/2)
+    {
+        /* Simulation */
+        /* bless is a low priority */
+        if (borg_simulate) return (1);
+
+		borg_note("# Attempting to cast Bless");
+
+        /* do it! */
+        if (borg_prayer(0, 2 ) || borg_prayer(3,0) ||
+            borg_read_scroll(SV_SCROLL_BLESSING) ||
+            borg_read_scroll(SV_SCROLL_HOLY_CHANT) ||
+            borg_read_scroll(SV_SCROLL_HOLY_PRAYER))
+             return 1;
+    }
+
+    return (0);
+}
+
+/*
+ * Speed to prepare for battle
+ */
+static int borg_defend_aux_speed( int p1 )
+{
+    int p2 = 0;
+    bool good_speed = FALSE;
+    bool speed_spell = FALSE;
+    bool speed_staff = FALSE;
+    bool speed_rod = FALSE;
+    int fail_allowed = 25;
+
+    /* already fast */
+    if (borg_speed)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+    /* only cast defence spells if fail rate is not too high */
+    if ( borg_spell_okay_fail( 3, 2, fail_allowed))
+        speed_spell = TRUE;
+
+    /* staff must have charges */
+    if ( borg_equips_staff_fail(SV_STAFF_SPEED))
+        speed_staff = TRUE;
+
+    /* rod can't be charging */
+    if (borg_equips_rod(SV_ROD_SPEED))
+        speed_rod = TRUE;
+
+    if (0 > borg_slot(TV_POTION, SV_POTION_SPEED) &&
+        !speed_staff &&
+        !speed_rod &&
+        !speed_spell &&
+        !borg_equips_artifact(ACT_HASTE1, INVEN_LEFT) &&
+        !borg_equips_artifact(ACT_HASTE2, INVEN_LEFT))
+        return (0);
+
+    /* if we have an infinite/large suppy of speed we can */
+    /* be generious with our use */
+    if (speed_rod || speed_spell || speed_staff ||
+       borg_equips_artifact(ACT_HASTE1, INVEN_WIELD) ||
+       borg_equips_artifact(ACT_HASTE2, INVEN_WIELD))
+       good_speed = TRUE;
+
+    /* pretend we are protected and look again */
+    borg_speed = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, TRUE);
+    borg_speed = FALSE;
+
+    /* if scaryguy around cast it. */
+    if (scaryguy_on_level)
+    {
+        /* HACK pretend that it was scary and will be safer */
+        p2 = p2 * 3/10;
+    }
+
+    /* if we are fighting a unique cast it. */
+    if (good_speed && borg_fighting_unique)
+    {
+        /* HACK pretend that it was scary and will be safer */
+        p2 = p2 * 7/10;
+    }
+    /* if we are fighting a unique and a summoner cast it. */
+    if (borg_fighting_summoner && borg_fighting_unique)
+    {
+        /* HACK pretend that it was scary and will be safer */
+        p2 = p2 * 7/10;
+    }
+    /* if the unique is Sauron cast it */
+    if (borg_skill[BI_CDEPTH] == 99 && borg_fighting_unique >=10 )
+    {
+        p2 = p2 * 6/10;
+    }
+
+    /* if the unique is Morgoth cast it */
+    if (borg_skill[BI_CDEPTH] == 100 && borg_fighting_unique >= 10)
+    {
+        p2 = p2 * 5/10;
+    }
+
+    /* Attempt to conserve Speed at end of game */
+    if (borg_skill[BI_CDEPTH] >=97 && !borg_fighting_unique && !good_speed) p2 = 9999;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if ( ((p1 > p2) &&
+           p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+           (p1 > (avoidance/5)) && good_speed) ||
+         ((p1 > p2) &&
+         p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/3)) &&
+         (p1 > (avoidance/7))))
+    {
+
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast Speed");
+
+        /* do it! */
+        if ( borg_zap_rod( SV_ROD_SPEED ) ||
+             borg_activate_artifact(ACT_HASTE1, INVEN_RIGHT) ||
+             borg_activate_artifact(ACT_HASTE2, INVEN_RIGHT) ||
+             borg_use_staff(SV_STAFF_SPEED) ||
+             borg_quaff_potion(SV_POTION_SPEED))
+            /* Value */
+            return (p1-p2);
+
+        if (borg_spell_fail( 3, 2, fail_allowed))
+            return (p1-p2);
+
+    }
+    /* default to can't do it. */
+    return (0);
+}
+
+
+/* cold/fire */
+static int borg_defend_aux_resist_fc( int p1 )
+{
+    int p2 = 0;
+    int fail_allowed = 25;
+    bool    save_fire = FALSE,
+            save_cold = FALSE;
+
+    if (my_oppose_fire &&
+        my_oppose_cold)
+        return (0);
+
+#if 0
+        if (borg_skill[BI_RFIRE] &&
+        borg_skill[BI_RCOLD])
+        return (0);
+#endif
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+    if (!borg_prayer_okay_fail(1, 7, fail_allowed) &&
+        !borg_equips_artifact(ACT_RESIST, INVEN_OUTER))
+        return (0);
+
+    /* elemental and PFE use the 'averaging' method for danger.  Redefine p1 as such. */
+    p1 = borg_danger(c_y, c_x, 1, FALSE);
+
+    /* pretend we are protected and look again */
+    save_fire = my_oppose_fire;
+    save_cold = my_oppose_cold;
+    my_oppose_fire = TRUE;
+    my_oppose_cold = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, FALSE);
+    my_oppose_fire = save_fire;
+    my_oppose_cold = save_cold;
+
+    /* Hack -
+     * If the borg is fighting a particular unique enhance the
+     * benefit of the spell.
+     */
+    if (borg_fighting_unique &&
+        (unique_on_level == 539) /* Tarresque */
+        /* ||
+         * (unique_on_level == XX) ||
+         */
+         ) p2 = p2 * 8 / 10;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast FC");
+
+        /* do it! */
+        if (borg_activate_artifact(ACT_RESIST, INVEN_OUTER) ||
+            borg_prayer_fail(1, 7, fail_allowed) )
+
+        /* Value */
+        return (p1-p2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+/* all resists */
+static int borg_defend_aux_resist_fecap( int p1)
+{
+    int p2 = 0;
+    int fail_allowed = 25;
+    bool    save_fire = FALSE,
+            save_acid = FALSE,
+            save_poison = FALSE,
+            save_elec = FALSE,
+            save_cold = FALSE;
+
+    if (my_oppose_fire &&
+        my_oppose_acid &&
+        my_oppose_pois &&
+        my_oppose_elec &&
+        my_oppose_cold)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+    if (!borg_spell_okay_fail(4, 3, fail_allowed) &&
+        !borg_equips_artifact(ACT_RESIST, INVEN_OUTER))
+        return (0);
+
+    /* elemental and PFE use the 'averaging' method for danger.  Redefine p1 as such. */
+    p1 = borg_danger(c_y, c_x, 1, FALSE);
+
+    /* pretend we are protected and look again */
+    save_fire = my_oppose_fire;
+    save_elec = my_oppose_elec;
+    save_cold = my_oppose_cold;
+    save_acid = my_oppose_acid;
+    save_poison =  my_oppose_pois;
+    my_oppose_fire = TRUE;
+    my_oppose_elec = TRUE;
+    my_oppose_cold = TRUE;
+    my_oppose_acid = TRUE;
+    my_oppose_pois = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, FALSE);
+    my_oppose_fire = save_fire;
+    my_oppose_elec = save_elec;
+    my_oppose_cold = save_cold;
+    my_oppose_acid = save_acid;
+    my_oppose_pois = save_poison;
+
+    /* Hack -
+     * If the borg is fighting a particular unique enhance the
+     * benefit of the spell.
+     */
+    if (borg_fighting_unique &&
+        (unique_on_level == 539) /* Tarresque */
+        /* ||
+         * (unique_on_level == XX) ||
+         */
+         ) p2 = p2 * 8 / 10;
+
+	/* Hack -
+	 * If borg is high enough level, he does not need to worry
+	 * about mana consumption.  Cast the good spell.
+	 */
+	if (borg_skill[BI_CLEVEL] >= 45) p2 = p2 * 8 / 10;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+
+        /* Simulation */
+        if (borg_simulate) return (p1 - p2 + 2);
+
+		borg_note("# Attempting to cast FECAP");
+
+        /* do it! */
+        if (borg_activate_artifact(ACT_RESIST, INVEN_OUTER) ||
+            borg_spell_fail(4, 3, fail_allowed) )
+
+        /* Value */
+        return (p1-p2+2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+/* fire */
+static int borg_defend_aux_resist_f( int p1 )
+{
+
+    int p2 = 0;
+    int fail_allowed = 25;
+    bool    save_fire = FALSE;
+
+    save_fire = my_oppose_fire;
+
+    if (my_oppose_fire)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+    if (!borg_spell_okay_fail(4, 1, fail_allowed) &&
+        !borg_equips_artifact(ACT_RESIST, INVEN_OUTER) &&
+        !borg_equips_ring(SV_RING_FLAMES) &&
+        -1 == borg_slot(TV_POTION, SV_POTION_RESIST_HEAT))
+        return (0);
+
+    /* elemental and PFE use the 'averaging' method for danger.  Redefine p1 as such. */
+    p1 = borg_danger(c_y, c_x, 1, FALSE);
+
+    /* pretend we are protected and look again */
+    my_oppose_fire = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, FALSE);
+    my_oppose_fire = save_fire;
+
+    /* Hack -
+     * If the borg is fighting a particular unique enhance the
+     * benefit of the spell.
+     */
+    if (borg_fighting_unique &&
+        (unique_on_level == 539) /* Tarresque */
+        /* ||
+         * (unique_on_level == XX) ||
+         */
+         ) p2 = p2 * 8 / 10;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast RFire");
+        /* do it! */
+        if (borg_activate_ring(SV_RING_FLAMES))
+        {
+			/* Ring also attacks so target self */
+			borg_keypress('*');
+			borg_keypress('5');
+			return (p1-p2);
+		}
+        if (borg_activate_artifact(ACT_RESIST, INVEN_OUTER) ||
+            borg_spell_fail(4, 1, fail_allowed) ||
+            borg_quaff_potion(SV_POTION_RESIST_HEAT))
+
+        /* Value */
+        return (p1-p2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+ /* cold */
+static int borg_defend_aux_resist_c( int p1 )
+{
+
+    int p2 = 0;
+    int fail_allowed = 25;
+    bool    save_cold = FALSE;
+
+    if ( my_oppose_cold )
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+       fail_allowed += 10;
+
+    if (!borg_spell_okay_fail(4, 0, fail_allowed) &&
+        !borg_equips_artifact(ACT_RESIST, INVEN_OUTER) &&
+        !borg_equips_ring(SV_RING_ICE) &&
+        -1 == borg_slot(TV_POTION, SV_POTION_RESIST_COLD))
+        return (0);
+
+    /* elemental and PFE use the 'averaging' method for danger.  Redefine p1 as such. */
+    p1 = borg_danger(c_y, c_x, 1, FALSE);
+
+    save_cold = my_oppose_cold;
+    /* pretend we are protected and look again */
+    my_oppose_cold = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, FALSE);
+    my_oppose_cold = save_cold;
+
+    /* Hack -
+     * If the borg is fighting a particular unique enhance the
+     * benefit of the spell.
+     */
+    if (borg_fighting_unique &&
+        (unique_on_level == 539) /* Tarresque */
+        /* ||
+         * (unique_on_level == XX) ||
+         */
+         ) p2 = p2 * 8 / 10;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast RCold");
+
+       /* do it! */
+        if (borg_activate_ring(SV_RING_ICE))
+        {
+			/* Ring also attacks so target self */
+			borg_keypress('*');
+			borg_keypress('5');
+			return (p1-p2);
+		}
+        if (borg_activate_artifact(ACT_RESIST, INVEN_OUTER) ||
+            borg_spell_fail(4, 0, fail_allowed) ||
+            borg_quaff_potion(SV_POTION_RESIST_COLD))
+
+        /* Value */
+        return (p1-p2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+/* acid */
+static int borg_defend_aux_resist_a( int p1 )
+{
+
+    int p2 = 0;
+    int fail_allowed = 25;
+    bool    save_acid = FALSE;
+
+    if (my_oppose_acid)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+    if (!borg_spell_okay_fail(4, 3, fail_allowed) &&
+    	!borg_equips_artifact(ACT_RESIST, INVEN_OUTER) &&
+        !borg_equips_ring(SV_RING_ACID))
+        return (0);
+
+    /* elemental and PFE use the 'averaging' method for danger.  Redefine p1 as such. */
+    p1 = borg_danger(c_y, c_x, 1, FALSE);
+
+    save_acid = my_oppose_acid;
+    /* pretend we are protected and look again */
+    my_oppose_acid = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, FALSE);
+    my_oppose_acid = save_acid;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast RAcid");
+
+        /* do it! */
+		if (borg_spell(4, 3))
+		{
+			return (p1-p2);
+		}
+
+        if (borg_activate_ring(SV_RING_ACID))
+        {
+			/* Ring also attacks so target self */
+			borg_keypress('*');
+			borg_keypress('5');
+			return (p1-p2);
+		}
+        if (borg_activate_artifact(ACT_RESIST, INVEN_OUTER))
+
+        /* Value */
+        return (p1-p2);
+    }
+    /* default to can't do it. */
+    return (0);
+}
+
+/* poison */
+static int borg_defend_aux_resist_p( int p1 )
+{
+    int p2 = 0;
+    int fail_allowed = 25;
+    bool    save_poison = FALSE;
+
+    if (my_oppose_pois)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+    if (!borg_spell_okay_fail(4, 2, fail_allowed) &&
+        !borg_equips_artifact(ACT_RESIST, INVEN_OUTER))
+        return (0);
+
+    /* elemental and PFE use the 'averaging' method for danger.  Redefine p1 as such. */
+    p1 = borg_danger(c_y, c_x, 1, FALSE);
+
+    save_poison = my_oppose_pois;
+    /* pretend we are protected and look again */
+    my_oppose_pois = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, FALSE);
+    my_oppose_pois = save_poison;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast RPois");
+
+        /* do it! */
+        if (borg_activate_artifact(ACT_RESIST, INVEN_OUTER) ||
+            borg_spell_fail(4, 2, fail_allowed) )
+
+        /* Value */
+        return (p1-p2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+static int borg_defend_aux_prot_evil( int p1)
+{
+    int p2 = 0;
+    int fail_allowed = 25;
+    bool pfe_spell = FALSE;
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+
+    /* if already protected */
+    if (borg_prot_from_evil)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 5;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+    if (borg_prayer_okay_fail(2,4,fail_allowed)) pfe_spell= TRUE;
+
+    if ( 0 <= borg_slot(TV_SCROLL,SV_SCROLL_PROTECTION_FROM_EVIL)) pfe_spell = TRUE;
+
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE])
+        pfe_spell = FALSE;
+
+    if (!(ag->info & BORG_GLOW) && borg_skill[BI_CURLITE] == 0) pfe_spell = FALSE;
+
+    if (borg_equips_artifact(ACT_PROT_EVIL,INVEN_NECK)) pfe_spell = TRUE;
+
+    if (pfe_spell == FALSE) return (0);
+
+    /* elemental and PFE use the 'averaging' method for danger.  Redefine p1 as such. */
+    p1 = borg_danger(c_y, c_x, 1, FALSE);
+
+    /* pretend we are protected and look again */
+    borg_prot_from_evil = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, FALSE);
+    borg_prot_from_evil = FALSE;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+
+    if ((p1 > p2 &&
+         p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+         p1 > (avoidance /7)) ||
+        (borg_money_scum_amount >= 1 && borg_skill[BI_CDEPTH] ==0))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast PFE");
+
+        /* do it! */
+        if (borg_prayer_fail(2, 4, fail_allowed) ||
+           borg_activate_artifact(ACT_PROT_EVIL, INVEN_NECK) ||
+           borg_read_scroll(SV_SCROLL_PROTECTION_FROM_EVIL) )
+
+        /* Value */
+        return (p1-p2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+static int borg_defend_aux_shield( int p1)
+{
+    int p2 = 0;
+    int fail_allowed = 25;
+
+    /* if already protected */
+    if (borg_shield)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 5;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 5;
+
+    if (!borg_spell_okay_fail(4, 4, fail_allowed))
+        return (0);
+
+    /* pretend we are protected and look again */
+    borg_shield = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, TRUE);
+    borg_shield = FALSE;
+
+    /* slightly enhance the value if fighting a unique */
+    if (borg_fighting_unique)  p2=(p2*7/10);
+
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+		borg_note("# Attempting to cast Shield");
+
+        /* do it! */
+        borg_spell_fail(4, 4, fail_allowed);
+        return (p1-p2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+/*
+ * Try to get rid of all of the non-uniques around so you can go at it
+ * 'mano-e-mano' with the unique. Teleport Other.
+ */
+static int borg_defend_aux_tele_away( int p1)
+{
+    int p2 = p1;
+    int fail_allowed = 50;
+    bool  spell_ok = FALSE;
+    int i, x, y;
+
+    borg_grid *ag;
+
+
+    /* Only tell away if scared or
+     * fighting multiple uniques or
+     * Inside a vault.
+     */
+    if ( (p1 < avoidance * 8/10 ||
+    	  (borg_fighting_unique >=2 &&
+    	   borg_fighting_unique <=8)) &&
+    	  borg_simulate)
+        return (0);
+
+    spell_ok = FALSE;
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance*4)
+        fail_allowed -= 18;
+    else
+    /* scary */
+    if ( p1 > avoidance*3)
+        fail_allowed -= 12;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*5)/2)
+        fail_allowed += 5;
+
+    if (borg_spell_okay_fail(3, 1, fail_allowed) ||
+        borg_prayer_okay_fail(4, 2, fail_allowed) ||
+        borg_equips_artifact(ACT_TELE_AWAY, INVEN_WIELD) ||
+        ( -1 != borg_slot(TV_WAND, SV_WAND_TELEPORT_AWAY) &&
+         borg_items[borg_slot(TV_WAND, SV_WAND_TELEPORT_AWAY)].pval))
+         spell_ok = TRUE;
+
+    if (!spell_ok) return (0);
+
+	/* No Teleport Other if surrounded */
+	if (borg_surrounded() == TRUE) return (0);
+
+    /* Borg_temp_n temporarily stores several things.
+     * Some of the borg_attack() sub-routines use these numbers,
+     * which would have been filled in borg_attack().
+     * Since this is a defence manuever which will move into
+     * and borrow some of the borg_attack() subroutines, we need
+     * to make sure that the borg_temp_n arrays are properly
+     * filled.  Otherwise, the borg will attempt to consider
+     * these grids which were left filled by some other routine.
+     * Which was probably a flow routine which stored about 200
+     * grids into the array.
+     * Any change in inclusion/exclusion criteria for filling this
+     * array in borg_attack() should be included here also.
+     */
+    /* Nobody around so dont worry */
+    if (!borg_kills_cnt && borg_simulate) return (0);
+
+    /* Reset list */
+    borg_temp_n = 0;
+	borg_tp_other_n = 0;
+
+    /* Find "nearby" monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+
+        /* Monster */
+        kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Require current knowledge */
+        if (kill->when < borg_t - 2) continue;
+
+        /* Acquire location */
+        x = kill->x;
+        y = kill->y;
+
+        /* Get grid */
+        ag = &borg_grids[y][x];
+
+        /* Never shoot off-screen */
+        if (!(ag->info & BORG_OKAY)) continue;
+
+        /* Never shoot through walls */
+        if (!(ag->info & BORG_VIEW)) continue;
+
+        /* Check the distance XXX XXX XXX */
+        if (distance(c_y, c_x, y, x) > MAX_RANGE) continue;
+
+        /* Save the location (careful) */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* No destinations */
+    if (!borg_temp_n && borg_simulate) return (0);
+
+    /* choose then target a bad guy or several
+     * If left as bolt, he targets the single most nasty guy.
+     * If left as beam, he targets the collection of monsters.
+     */
+    p2 = borg_launch_bolt(-1, 50, GF_AWAY_ALL, MAX_RANGE);
+
+    /* Reset list */
+    borg_temp_n = 0;
+	borg_tp_other_n = 0;
+
+    /* check to see if I am left better off */
+    if (borg_simulate)
+    {
+		if (p1 > p2 &&
+        	p2 <= avoidance/2)
+    	{
+    	    /* Simulation */
+    	    return (p2);
+		}
+		else return (0);
+	}
+
+	/* Log the Path for Debug */
+	borg_log_spellpath(TRUE);
+
+	/* Log additional info for debug */
+	for (i = 0; i < borg_tp_other_n; i++)
+	{
+		borg_note(format("# %d, index %d (%d,%d)",borg_tp_other_n,
+			borg_tp_other_index[i],	borg_tp_other_y[i],
+			borg_tp_other_x[i]));
+	}
+
+	borg_note("# Attempting to cast T.O.");
+
+    /* Cast the spell */
+    if (borg_spell(3, 1) ||
+        borg_prayer(4, 2) ||
+        borg_activate_artifact(ACT_TELE_AWAY, INVEN_WIELD)||
+        borg_aim_wand(SV_WAND_TELEPORT_AWAY))
+    {
+        /* Use target */
+        borg_keypress('5');
+
+        /* Set our shooting flag */
+        successful_target = -1;
+
+        /* Value */
+        return (p2);
+    }
+
+    return (0);
+}
+
+/*
+ * Hero to prepare for battle, +12 tohit.
+ */
+static int borg_defend_aux_hero( int p1 )
+{
+    int fail_allowed = 15;
+
+    /* already hero */
+    if (borg_hero)
+        return (0);
+
+    if ( !borg_spell_okay_fail(7, 0, fail_allowed ) &&
+         -1 == borg_slot(TV_POTION, SV_POTION_HEROISM))
+        return (0);
+
+    /* if we are in some danger but not much, go for a quick bless */
+    if ((p1 > avoidance * 1 / 10 && p1 < avoidance * 5 / 10) ||
+         (borg_fighting_unique && p1 < avoidance * 7 / 10))
+    {
+        /* Simulation */
+        /* hero is a low priority */
+        if (borg_simulate) return (1);
+
+		borg_note("# Attempting to cast Hero");
+
+        /* do it! */
+        if (borg_spell(7, 0 ) ||
+            borg_quaff_potion(SV_POTION_HEROISM))
+             return 1;
+    }
+
+    return (0);
+}
+
+/*
+ * Bersek to prepare for battle, +24 tohit, -10 AC
+ */
+static int borg_defend_aux_berserk( int p1 )
+{
+    int fail_allowed = 15;
+
+    /* already berserk */
+    if (borg_berserk)
+        return (0);
+
+    if (!borg_spell_okay_fail(7, 1, fail_allowed ) &&
+        -1 == borg_slot(TV_POTION, SV_POTION_BERSERK_STRENGTH) &&
+        !borg_equips_artifact(ACT_BERSERKER, INVEN_WIELD))
+        return (0);
+
+    /* if we are in some danger but not much, go for a quick bless */
+    if ((p1 > avoidance * 1 / 10 && p1 < avoidance * 5 / 10) ||
+         (borg_fighting_unique && p1 < avoidance * 7 / 10))
+    {
+        /* Simulation */
+        /* berserk is a low priority */
+        if (borg_simulate) return (5);
+
+        /* do it! */
+        if (borg_spell(7, 1) ||
+        	borg_activate_artifact(ACT_BERSERKER, INVEN_WIELD) ||
+            borg_quaff_potion(SV_POTION_BERSERK_STRENGTH))
+             return 2;
+    }
+
+    return (0);
+}
+
+/* Glyph of Warding and Rune of Protection */
+static int borg_defend_aux_glyph( int p1)
+{
+    int p2 = 0, i;
+    int fail_allowed = 25;
+    bool glyph_spell = FALSE;
+
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+    /* He should not cast it while on an object.
+     * I have addressed this inadequately in borg9.c when dealing with
+     * messages.  The message "the object resists" will delete the glyph
+     * from the array.  Then I set a broken door on that spot, the borg ignores
+     * broken doors, so he won't loop.
+     */
+
+    if ( (ag->take) ||
+         (ag->feat == FEAT_GLYPH) ||
+         ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL)) ||
+         ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_DOOR_TAIL)) ||
+         (ag->feat == FEAT_LESS) ||
+         (ag->feat == FEAT_MORE) ||
+         (ag->feat == FEAT_OPEN) ||
+         (ag->feat == FEAT_BROKEN) )
+        {
+            return (0);
+        }
+
+    /* Morgoth breaks these in one try so its a waste of mana against him */
+    if (borg_fighting_unique >= 10) return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 5;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 20;
+
+    if (borg_prayer_okay_fail(3,4,fail_allowed)) glyph_spell = TRUE;
+    if (borg_spell_okay_fail(6,4,fail_allowed)) glyph_spell = TRUE;
+
+    if ( 0 <= borg_slot(TV_SCROLL,SV_SCROLL_RUNE_OF_PROTECTION)) glyph_spell = TRUE;
+
+    if ((borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE]) && glyph_spell)
+        glyph_spell = FALSE;
+    if (!(ag->info & BORG_GLOW) && borg_skill[BI_CURLITE] == 0) glyph_spell = FALSE;
+
+
+    if (!glyph_spell) return (0);
+
+    /* pretend we are protected and look again */
+    borg_on_glyph = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, TRUE);
+    borg_on_glyph = FALSE;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+        /* do it! */
+        if (borg_prayer_fail(3, 4, fail_allowed) ||
+        	borg_spell_fail(6, 4, fail_allowed) ||
+            borg_read_scroll(SV_SCROLL_RUNE_OF_PROTECTION))
+        {
+            /* Check for an existing glyph */
+            for (i = 0; i < track_glyph_num; i++)
+            {
+                /* Stop if we already new about this glyph */
+                if ((track_glyph_x[i] == c_x) && (track_glyph_y[i] == c_y)) return (p1-p2);
+            }
+
+            /* Track the newly discovered glyph */
+            if ((i == track_glyph_num) && (track_glyph_size))
+            {
+                borg_note("# Noting the creation of a glyph.");
+                track_glyph_num++;
+                track_glyph_x[i] = c_x;
+                track_glyph_y[i] = c_y;
+            }
+            return (p1-p2);
+        }
+
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+/* Create Door */
+static int borg_defend_aux_create_door( int p1)
+{
+    int p2 = 0;
+    int fail_allowed = 30;
+    int door_bad =0;
+    int door_x = 0, door_y = 0,
+        x = 0,y = 0;
+
+    borg_grid *ag;
+
+
+    /* any summoners near?*/
+    if (!borg_fighting_summoner) return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 5;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 20;
+
+    if (!borg_spell_okay_fail(6, 0, fail_allowed))
+        return (0);
+
+    /* Do not cast if surounded by doors or something */
+    /* Get grid */
+    for (door_x = -1; door_x <= 1; door_x++)
+    {
+        for (door_y = -1; door_y <= 1; door_y++)
+        {
+            /* Acquire location */
+            x = door_x + c_x;
+            y = door_y + c_y;
+
+            ag = &borg_grids[y][x];
+
+            /* track spaces already protected */
+            if ( (ag->feat == FEAT_GLYPH) || ag->kill ||
+               ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_PERM_SOLID)))
+            {
+                door_bad++;
+            }
+
+            /* track spaces that cannot be protected */
+            if ( (ag->take) ||
+               ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL)) ||
+               (ag->feat == FEAT_LESS) ||
+               (ag->feat == FEAT_MORE) ||
+               (ag->feat == FEAT_OPEN) ||
+               (ag->feat == FEAT_BROKEN) ||
+               (ag->kill))
+            {
+                door_bad++;
+            }
+        }
+    }
+
+
+    /* Track it */
+    /* lets make sure that we going to be benifited */
+    if (door_bad >= 6)
+    {
+        /* not really worth it.  Only 2 spaces protected */
+        return (0);
+    }
+
+    /* pretend we are protected and look again */
+    borg_create_door = TRUE;
+    p2 = borg_danger(c_y, c_x, 1, TRUE);
+    borg_create_door = FALSE;
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+        p1 > (avoidance/7))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+        /* do it! */
+        if (borg_spell_fail(6, 0, fail_allowed))
+        {
+            /* Set the breeder flag to keep doors closed. Avoid summons */
+            breeder_level = TRUE;
+
+			/* Must make a new Sea too */
+			borg_needs_new_sea = TRUE;
+
+            /* Value */
+            return (p1-p2);
+        }
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+
+
+/* This will simulate and cast the mass genocide spell.
+ */
+static int borg_defend_aux_mass_genocide(int p1)
+{
+    int hit = 0, i= 0,p2;
+    int b_p =0, p;
+
+    borg_grid *ag;
+    borg_kill *kill;
+    monster_race *r_ptr;
+
+    /* see if prayer is legal */
+    if (!borg_spell_okay_fail(8, 5, 40) &&
+        !borg_equips_artifact(ACT_MASS_BANISHMENT, INVEN_WIELD))
+        return (0);
+
+    /* See if he is in real danger */
+    if (p1 < avoidance * 12/10 && borg_simulate)
+    	return (0);
+
+    /* Find a monster and calculate its danger */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+
+        /* Monster */
+        kill = &borg_kills[i];
+        r_ptr = &r_info[kill->r_idx];
+
+        ag= &borg_grids[kill->y][kill->x];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Check the distance */
+        if (distance(c_y, c_x, kill->y, kill->x) > 20) continue;
+
+        /* we try not to genocide uniques */
+        if (r_ptr->flags1 & RF1_UNIQUE) continue;
+
+        /* Calculate danger */
+        borg_full_damage = TRUE;
+        p = borg_danger_aux(c_y, c_x, 1, i, TRUE);
+        borg_full_damage = FALSE;
+
+        /* store the danger for this type of monster */
+        b_p = b_p + p;
+        hit = hit + 3;
+    }
+
+    /* normalize the value */
+    p2 = (p1 - b_p);
+    if (p2 < 0) p2 = 0;
+
+    /* if strain (plus a pad incase we did not know about some monsters)
+     * is greater than hp, don't cast it
+     */
+    if ((hit * 12 / 10) >= borg_skill[BI_CURHP]) return (0);
+
+    /* Penalize the strain from casting the spell */
+    p2 = p2 + hit;
+
+    /* Be more likely to use this if fighting Morgoth */
+    if (borg_fighting_unique >= 10 && (hit / 3 > 8))
+    {
+        p2 = p2 * 6/10;
+    }
+
+    /* if this is an improvement and we may not avoid monster now and */
+    /* we may have before */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?(avoidance*2/3): (avoidance/2)) )
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+        /* Cast the spell */
+        if (borg_spell(8, 5) ||
+            borg_activate_artifact(ACT_MASS_BANISHMENT, INVEN_WIELD))
+        {
+
+	        /* Remove monsters from the borg_kill */
+	        for (i = 1; i < borg_kills_nxt; i++)
+	        {
+	            borg_kill *kill;
+	            monster_race *r_ptr;
+
+	            /* Monster */
+	            kill = &borg_kills[i];
+	            r_ptr = &r_info[kill->r_idx];
+
+				/* Cant kill uniques like this */
+				if (r_ptr->flags1 & RF1_UNIQUE) continue;
+
+	            /* remove this monster */
+	            borg_delete_kill(i);
+			}
+
+            /* Value */
+            return (p1-p2);
+        }
+    }
+    /* Not worth it */
+    return (0);
+
+}
+/* This will simulate and cast the genocide spell.
+ * There are two seperate functions happening here.
+ * 1. will genocide the race which is immediately threatening the borg.
+ * 2. will genocide the race which is most dangerous on the level.  Though it may not be
+ *    threatening the borg right now.  It was considered to nuke the escorts of a unique.
+ *    But it could also be used to nuke a race if it becomes too dangerous, for example
+ *    a summoner called up 15-20 hounds, and they must be dealt with.
+ * The first option may be called at any time.  While the 2nd option is only called when the
+ * borg is in relatively good health.
+ */
+static int borg_defend_aux_genocide(int p1)
+{
+    int i, p, u, b_i = 0;
+    int p2 = 0;
+    int threat = 0;
+    int max=1;
+
+    int b_p[256];
+    int b_num[256];
+    int b_threat[256];
+    int b_threat_num[256];
+
+	int total_danger_to_me = 0;
+
+    char genocide_target = (char)0;
+    char b_threat_id = (char)0;
+
+    borg_grid *ag;
+
+    bool genocide_spell = FALSE;
+    int fail_allowed = 25;
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance)
+        fail_allowed -= 19;
+    else
+    /* a little scary */
+    if ( p1 > (avoidance*2)/3)
+        fail_allowed -= 10;
+    else
+    /* not very scary, allow lots of fail */
+    if ( p1 < avoidance/3)
+        fail_allowed += 10;
+
+	/* Normalize the p1 value.  It contains danger added from
+	 * regional fear and monster fear.  Which wont be counted
+	 * in the post-genocide checks
+	 */
+	if (borg_fear_region[c_y/11][c_x/11]) p1 -= borg_fear_region[c_y/11][c_x/11];
+	if (borg_fear_monsters[c_y][c_x]) p1 -= borg_fear_monsters[c_y][c_x];
+
+
+	/* Make sure I have the spell */
+    if (borg_spell_okay_fail(8, 3, fail_allowed) ||
+        borg_equips_artifact(ACT_BANISHMENT, INVEN_BODY) ||
+        borg_equips_staff_fail(SV_STAFF_BANISHMENT) ||
+        ( -1 != borg_slot(TV_SCROLL, SV_SCROLL_BANISHMENT)))
+        {
+            genocide_spell = TRUE;
+        }
+
+    if (genocide_spell == FALSE) return (0);
+
+
+    /* Don't try it if really weak */
+    if (borg_skill[BI_CURHP] <= 75) return (0);
+
+    /* two methods to calculate the threat:
+     *1. cycle each character of monsters on screen
+     *   collect collective threat of each char
+     *2 select race of most dangerous guy, and choose him.
+     * Method 2 is cheaper and faster.
+     *
+     * The borg uses method #1
+     */
+
+    /* Clear previous dangers */
+    for (i= 0; i < 256; i++)
+    {
+        b_p[i] = 0;
+        b_num[i] = 0;
+        b_threat[i]=0;
+        b_threat_num[i]=0;
+    }
+
+    /* Find a monster and calculate its danger */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+        monster_race *r_ptr;
+
+        /* Monster */
+        kill = &borg_kills[i];
+        r_ptr = &r_info[kill->r_idx];
+
+        ag= &borg_grids[kill->y][kill->x];
+
+        /* Our char of the monster */
+        u = r_ptr->d_char;
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* we try not to genocide uniques */
+        if (r_ptr->flags1 & RF1_UNIQUE) continue;
+
+        /* Calculate danger */
+        borg_full_damage = TRUE;
+        /* Danger to me by this monster */
+        p = borg_danger_aux(c_y, c_x, 1, i, TRUE);
+
+        /* Danger of this monster to his own grid */
+        threat = borg_danger_aux(kill->y, kill->x, 1, i, TRUE);
+        borg_full_damage = FALSE;
+
+        /* store the danger for this type of monster */
+        b_p[u] = b_p[u] + p; /* Danger to me */
+        total_danger_to_me += p;
+        b_threat[u] = b_threat[u] + threat; /* Danger to monsters grid */
+
+        /* Store the number of this type of monster */
+        b_num[u] ++;
+        b_threat_num[u] ++;
+    }
+
+    /* Now, see which race contributes the most danger
+     * both to me and danger on the level
+     */
+
+    for (i=0; i < 256; i++)
+    {
+
+		/* skip the empty ones */
+		if (b_num[i] == 0 && b_threat_num[i] ==0) continue;
+
+        /* for the race threatening me right now */
+        if (b_p[i] > max)
+        {
+            /* track the race */
+            max = b_p[i];
+            b_i = i;
+
+            /* note the danger with this race gone.  Note that the borg does max his danger
+             * at 2000 points.  It could be much, much higher at depth 99 or so.
+             * What the borg should do is recalculate the danger without considering this monster
+             * instead of this hack which does not yeild the true danger.
+             */
+            p2 = total_danger_to_me - b_p[b_i];
+        }
+
+        /* for this race on the whole level */
+        if (b_threat[i] > max)
+        {
+            /* track the race */
+            max = b_threat[i];
+            b_threat_id = i;
+        }
+
+		/* Leave an interesting note for debugging */
+		if (!borg_simulate) borg_note(format("# Race '%c' is a threat with total danger %d from %d individuals.",i,b_threat[i],b_threat_num[i]));
+
+    }
+
+    /* This will track and decide if it is worth genociding this dangerous race for the level */
+    if (b_threat_id)
+    {
+        /* Not if I am weak (should have 400 HP really in case of a Pit) */
+        if (borg_skill[BI_CURHP] < 375) b_threat_id = 0;
+
+        /* The threat must be real */
+        if (b_threat[b_threat_id] < borg_skill[BI_MAXHP] * 5) b_threat_id = 0;
+
+        /* Too painful to cast it (padded to be safe incase of unknown monsters) */
+        if ((b_num[b_threat_id] * 4)*12/10 >= borg_skill[BI_CURHP]) b_threat_id = 0;
+
+        /* Do not perform in Danger */
+        if (borg_danger(c_y,c_x,1, TRUE) > avoidance / 5) b_threat_id = 0;
+
+        /* report the danger and most dangerous race */
+        if (b_threat_id)
+        {
+             borg_note(format("# Race '%c' is a real threat with total danger %d from %d individuals.",b_threat_id,b_threat[b_threat_id],b_threat_num[b_threat_id]));
+        }
+
+        /* Genociding this race would reduce the danger of the level */
+        genocide_target = b_threat_id;
+
+    }
+
+    /* Consider the immediate threat genocide */
+    if (b_i)
+    {
+        /* Too painful to cast it (padded to be safe incase of unknown monsters) */
+        if ((b_num[b_i] * 4)*12/10 >= borg_skill[BI_CURHP]) b_i = 0;
+
+        /* See if he is in real danger, generally,
+         * or deeper in the dungeon, conservatively,
+         */
+        if (p1 < avoidance * 12/10 ||
+           (borg_skill[BI_CDEPTH] > 75 && p1 < avoidance)) b_i = 0;
+
+        /* Did this help improve my situation? */
+        if (p2 <= (avoidance / 2)) b_i = 0;
+
+        /* Genociding this race would help me immediately */
+        genocide_target = b_i;
+
+    }
+
+    /* Complete the genocide routine */
+    if (genocide_target)
+    {
+        if (borg_simulate)
+        {
+	        /* Simulation for immediate threat */
+			if (b_i) return (p1-p2);
+
+	        /* Simulation for immediate threat */
+	        if (b_threat_id) return (b_threat[b_threat_id]);
+		}
+
+        if (b_i) borg_note(format("# Banishing race '%c' (qty:%d).  Danger after spell:%d",genocide_target, b_num[b_i], p2));
+        if (b_threat_id) borg_note(format("# Banishing race '%c' (qty:%d).  Danger from them:%d",genocide_target, b_threat_num[b_threat_id], b_threat[b_threat_id]));
+
+        /* do it! ---use scrolls first since they clutter inventory */
+        if ( borg_read_scroll( SV_SCROLL_BANISHMENT) ||
+            borg_spell(8, 3) ||
+            borg_activate_artifact(ACT_BANISHMENT, INVEN_BODY) ||
+            borg_use_staff(SV_STAFF_BANISHMENT))
+        {
+            /* and the winner is.....*/
+            borg_keypress((genocide_target));
+        }
+
+        /* Remove this race from the borg_kill */
+        for (i = 1; i < borg_kills_nxt; i++)
+        {
+            borg_kill *kill;
+            monster_race *r_ptr;
+
+            /* Monster */
+            kill = &borg_kills[i];
+            r_ptr = &r_info[kill->r_idx];
+
+            /* Our char of the monster */
+            if (r_ptr->d_char != genocide_target) continue;
+
+	        /* we do not genocide uniques */
+	        if (r_ptr->flags1 & RF1_UNIQUE) continue;
+
+            /* remove this monster */
+            borg_delete_kill(i);
+        }
+
+        return (p1-p2);
+
+    }
+    /* default to can't do it. */
+    return (0);
+}
+
+/* This will cast the genocide spell on Hounds and other
+ * really nasty guys like Angels, Demons, and Liches
+ * at the beginning of each level or when they get too numerous.
+ */
+static int borg_defend_aux_genocide_nasties(int p1)
+{
+    int i= 0;
+	int nasty_num = 0;
+
+    char genocide_target= 'Z';
+
+    bool genocide_spell = FALSE;
+
+    /* Not if level is already cleared */
+    if (borg_hound_count < 20 &&
+    	borg_demon_count < 20 &&
+    	borg_wight_count < 20 &&
+    	borg_angel_count < 10 &&
+    	borg_lich_count < 10) return (0);
+
+    /* Not if I am weak */
+    if (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] ||
+        borg_skill[BI_CURHP] < 300) return (0);
+
+    /* only do it when deep, */
+    if (borg_skill[BI_CDEPTH] < 50) return (0);
+
+    /* Do not perform in Danger */
+    if (p1 > avoidance / 4)
+        return (0);
+
+    if (borg_spell_okay_fail(8, 3, 35) ||
+        borg_equips_artifact(ACT_BANISHMENT, INVEN_BODY) ||
+        borg_equips_staff_fail(SV_STAFF_BANISHMENT))
+        {
+            genocide_spell = TRUE;
+        }
+
+    if (genocide_spell == FALSE) return (0);
+
+    if (borg_simulate) return (1);
+
+	/* Find the most numerous nasty */
+	if (borg_hound_count >= 20)
+	{
+		genocide_target = 'Z';
+		nasty_num = borg_hound_count;
+	}
+	if (borg_demon_count >= 20)
+	{
+		genocide_target = 'U';
+		nasty_num = borg_demon_count;
+	}
+	if (borg_wight_count >= 20)
+	{
+		genocide_target = 'W';
+		nasty_num = borg_demon_count;
+	}
+	if (borg_angel_count >= 10)
+	{
+		genocide_target = 'A';
+		nasty_num = borg_angel_count;
+	}
+	if (borg_lich_count >= 10)
+	{
+		genocide_target = 'L';
+		nasty_num = borg_lich_count;
+	}
+
+
+    borg_note(format("# Banishing nasties '%c' (qty:%d).",genocide_target, nasty_num));
+
+    if (borg_spell(8, 3) ||
+        borg_activate_artifact(ACT_BANISHMENT, INVEN_BODY) ||
+        borg_use_staff(SV_STAFF_BANISHMENT))
+    {
+        /* and the winner is.....*/
+        borg_keypress((genocide_target));
+
+        /* set the flag to not do it again */
+        if (genocide_target == 'Z') borg_hound_count = 0;
+        if (genocide_target == 'U') borg_demon_count = 0;
+        if (genocide_target == 'A') borg_angel_count = 0;
+        if (genocide_target == 'W') borg_wight_count = 0;
+        if (genocide_target == 'L') borg_lich_count = 0;
+
+        /* Remove this race from the borg_kill */
+        for (i = 1; i < borg_kills_nxt; i++)
+        {
+            borg_kill *kill;
+            monster_race *r_ptr;
+
+            /* Monster */
+            kill = &borg_kills[i];
+            r_ptr = &r_info[kill->r_idx];
+
+            /* Our char of the monster */
+            if (r_ptr->d_char != genocide_target) continue;
+
+            /* remove this monster */
+            borg_delete_kill(i);
+        }
+
+    return (1);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+/* Earthquake, priest and mage spells.
+ */
+static int borg_defend_aux_earthquake(int p1)
+{
+    int p2 = 0;
+    int door_bad = 0;
+    int door_x, door_y, x, y;
+
+    borg_grid *ag;
+
+	/* Can I cast the spell? */
+    if (!borg_prayer_okay_fail(2, 5, 35) &&
+        !borg_spell_okay_fail(8, 0, 35))
+        return (0);
+
+    /* See if he is in real danger or fighting summoner*/
+    if (p1 < avoidance * 5 / 10 && !borg_fighting_summoner)
+        return (0);
+
+    /* Do not cast if surounded by doors or something */
+    /* Get grid */
+    for (door_x = -1; door_x <= 1; door_x++)
+    {
+        for (door_y = -1; door_y <= 1; door_y++)
+        {
+            /* Acquire location */
+            x = door_x + c_x;
+            y = door_y + c_y;
+
+            ag = &borg_grids[y][x];
+
+            /* track spaces already protected */
+            if ( (ag->feat == FEAT_GLYPH) || ag->kill ||
+               ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_PERM_SOLID)))
+            {
+                door_bad++;
+            }
+
+            /* track spaces that cannot be protected */
+            if ( (ag->take) ||
+               ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL)) ||
+               (ag->feat == FEAT_LESS) ||
+               (ag->feat == FEAT_MORE) ||
+               (ag->feat == FEAT_OPEN) ||
+               (ag->feat == FEAT_BROKEN) ||
+               (ag->kill))
+            {
+                door_bad++;
+            }
+        }
+    }
+
+
+    /* Track it */
+    /* lets make sure that we going to be benifited */
+    if (door_bad >= 6)
+    {
+        /* not really worth it.  Only 2 spaces protected */
+        return (0);
+    }
+
+    /* What effect is there? */
+    borg_create_door= TRUE;
+    p2 = borg_danger(c_y,c_x,1, TRUE);
+    borg_create_door= FALSE;
+
+    if (p1 > p2 &&
+           p2 <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)) &&
+           p1 > (avoidance/5))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p2);
+
+        /* Cast the spell */
+        if (borg_prayer(2, 5) ||
+            borg_spell(8,0))
+            {
+				/* Must make a new Sea too */
+				borg_needs_new_sea = TRUE;
+                return (p2);
+            }
+     }
+     return (0);
+}
+
+/* Word of Destruction, priest and mage spells.  Death is right around the
+ *  corner, so kill everything.
+ */
+static int borg_defend_aux_destruction(int p1)
+{
+    int p2 = 0;
+    int d = 0;
+    bool spell= FALSE;
+
+    /* Cast the spell */
+	if (!borg_simulate)
+	{
+    	if (borg_prayer(8, 3) ||
+    	    borg_use_staff(SV_STAFF_DESTRUCTION))
+    	{
+			/* Must make a new Sea too */
+			borg_needs_new_sea = TRUE;
+    	    return (500);
+    	}
+	}
+
+    /* See if he is in real danger */
+    if (p1 < avoidance * 2)
+        return (0);
+
+    /* Borg_defend() is called before borg_escape().  He may have some
+     * easy ways to escape (teleport scroll) but he may attempt this spell
+     * of Destruction instead of using the scrolls.
+	 * Note that there will be some times when it is better for
+	 * the borg to use Destruction instead of Teleport;  too
+	 * often he will die out-of-the-fryingpan-into-the-fire.
+	 * So we have him to a quick check on safe landing zones.
+     */
+
+    /* Use teleport scrolls instead of WoD */
+    if ((borg_skill[BI_ATELEPORT] || borg_skill[BI_ATELEPORTLVL]) &&
+        !borg_skill[BI_ISBLIND] && !borg_skill[BI_ISCONFUSED] &&
+         borg_fighting_unique <= 5)
+    {
+		if (borg_caution_teleport(75, 2)) return (0);
+	}
+
+    /* Use teleport staff instead of WoD */
+    if (borg_skill[BI_AESCAPE] >= 2)
+    {
+		if (borg_caution_teleport(75, 2)) return (0);
+	}
+
+    /* capable of casting the spell */
+    if (borg_prayer_okay_fail(8, 3, 55) ||
+        borg_equips_staff_fail(SV_STAFF_DESTRUCTION))
+        spell = TRUE;
+
+    /* Special check for super danger--no fail check */
+    if (p1 > (avoidance * 4) && borg_equips_staff_fail(SV_STAFF_DESTRUCTION))
+        spell= TRUE;
+
+    if (spell == FALSE) return (0);
+
+    /* What effect is there? */
+    p2= 0;
+
+    /* value is d */
+    d = (p1-p2);
+
+    /* Try not to cast this against uniques */
+    if (borg_fighting_unique <= 3 && p1 < avoidance * 5) d = 0;
+    if (borg_fighting_unique >= 10) d = 0;
+
+    /* Simulation */
+    if (borg_simulate) return (d);
+
+	return (0);
+}
+
+/* Teleport Level, priest and mage spells.  Death is right around the
+ *  corner, Get off the level now.
+ */
+static int borg_defend_aux_teleportlevel( int p1)
+{
+    /* Cast the spell */
+	if (!borg_simulate)
+	{
+    	if (borg_prayer(4, 3) ||
+    	    borg_spell(6, 2))
+    	{
+			/* Must make a new Sea too */
+			borg_needs_new_sea = TRUE;
+    	    return (500);
+    	}
+	}
+
+    /* See if he is in real danger */
+    if (p1 < avoidance * 2)
+        return (0);
+
+    /* Borg_defend() is called before borg_escape().  He may have some
+     * easy ways to escape (teleport scroll) but he may attempt this spell
+     * of this spell instead of using the scrolls.
+	 * Note that there will be some times when it is better for
+	 * the borg to use this instead of Teleport;  too
+	 * often he will die out-of-the-fryingpan-into-the-fire.
+	 * So we have him to a quick check on safe landing zones.
+     */
+
+    /* Use teleport scrolls instead if safe to land */
+    if ((borg_skill[BI_ATELEPORT] || borg_skill[BI_ATELEPORTLVL]) &&
+        !borg_skill[BI_ISBLIND] && !borg_skill[BI_ISCONFUSED])
+    {
+		if (borg_caution_teleport(65, 2)) return (0);
+	}
+
+    /* Use teleport staff instead if safe to land */
+    if (borg_skill[BI_AESCAPE] >= 2)
+    {
+		if (borg_caution_teleport(65, 2)) return (0);
+	}
+
+    /* capable of casting the spell */
+    if (!borg_prayer_okay_fail(4, 3, 55) &&
+        !borg_spell_okay_fail(6, 2, 55))
+         return (0);
+
+    /* Try not to cast this against special uniques */
+    if (borg_fighting_unique >= 10) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (p1);
+
+	return (0);
+}
+
+/* Remove Evil guys within LOS.  The Priest Spell */
+static int borg_defend_aux_banishment( int p1)
+{
+    int p2 = 0;
+    int fail_allowed = 15;
+    int i;
+	int banished_monsters = 0;
+
+    borg_grid *ag;
+
+    /* Only tell away if scared */
+    if ( p1 < avoidance * 1/10)
+        return (0);
+
+    /* if very scary, do not allow for much chance of fail */
+    if ( p1 > avoidance * 4)
+        fail_allowed -= 10;
+
+    if (!borg_prayer_okay_fail(8, 2, fail_allowed))
+        return (0);
+
+    /* reset initial danger */
+    p1 =1;
+
+    /* Two passes to determine exact danger */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+        monster_race *r_ptr;
+
+        /* Monster */
+        kill = &borg_kills[i];
+        r_ptr = &r_info[kill->r_idx];
+
+        ag= &borg_grids[kill->y][kill->x];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Check the LOS */
+        if (!borg_projectable(c_y, c_x, kill->y, kill->x)) continue;
+
+        /* Calculate danger of who is left over */
+        borg_full_damage = TRUE;
+        p1 += borg_danger_aux(c_y, c_x, 1, i, TRUE);
+        borg_full_damage = FALSE;
+    }
+
+	/* Set P2 to be P1 and subtract the danger from each monster
+	 * which will be booted.  Non booted monsters wont decrement
+	 * the p2
+	 */
+	p2 = p1;
+
+    /* Pass two -- Find a monster and calculate its danger */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+        monster_race *r_ptr;
+
+        /* Monster */
+        kill = &borg_kills[i];
+        r_ptr = &r_info[kill->r_idx];
+
+        ag= &borg_grids[kill->y][kill->x];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Check the LOS */
+        if (!borg_projectable(c_y, c_x, kill->y, kill->x)) continue;
+
+		/* Note who gets considered */
+		if (!borg_simulate)
+		{
+			borg_note(format("# Banishing Evil: (%d,%d): %s, danger %d. is considered.",
+	          kill->y, kill->x, (r_name + r_info[kill->r_idx].name),
+	          borg_danger_aux(c_y,c_x, 1, ag->kill, TRUE)));
+		}
+
+        /* Non evil monsters*/
+        if (!(r_ptr->flags3 & RF3_EVIL))
+        {
+			/* Note who gets to stay */
+			if (!borg_simulate)
+			{
+				borg_note(format("# Banishing Evil: (%d,%d): %s, danger %d. Stays (not evil).",
+	    	      kill->y, kill->x, (r_name + r_info[kill->r_idx].name),
+	    	      borg_danger_aux(c_y,c_x, 1, ag->kill, TRUE)));
+			}
+
+			continue;
+		}
+
+		/* Monsters in walls cant be booted */
+		if (!borg_cave_floor_bold(kill->y, kill->x))
+		{
+			/* Note who gets banished */
+			if (!borg_simulate)
+			{
+				borg_note(format("# Banishing Evil: (%d,%d): %s, danger %d. Stays (in wall).",
+		          kill->y, kill->x, (r_name + r_info[kill->r_idx].name),
+		          borg_danger_aux(c_y,c_x, 1, ag->kill, TRUE)));
+			}
+			continue;
+		}
+
+		/* Note who gets banished */
+		if (!borg_simulate)
+		{
+			borg_note(format("# Banishing Evil: (%d,%d): %s, danger %d. Booted.",
+		          kill->y, kill->x, (r_name + r_info[kill->r_idx].name),
+		          borg_danger_aux(c_y,c_x, 1, ag->kill, TRUE)));
+
+		}
+
+		/* Count */
+		banished_monsters ++;
+
+        /* Calculate danger of who is left over */
+        borg_full_damage = TRUE;
+        p2 -= borg_danger_aux(c_y, c_x, 1, i, TRUE);
+        borg_full_damage = FALSE;
+
+    }
+
+	/* p2 is the danger after all the bad guys are removed. */
+    /* no negatives */
+    if (p2 <= 0) p2 = 0;
+
+	/* No monsters get booted */
+	if (banished_monsters == 0) p2 = 9999;
+
+    /* Try not to cast this against Morgy/Sauron */
+    if (borg_fighting_unique >= 10 && borg_skill[BI_CURHP] > 250 && borg_skill[BI_CDEPTH] == 99) p2 = 9999;
+    if (borg_fighting_unique >= 10 && borg_skill[BI_CURHP] > 350 && borg_skill[BI_CDEPTH] == 100) p2 = 9999;
+
+    /* check to see if I am left better off */
+    if (p1 > p2 &&
+        p2 <= (borg_fighting_unique?((avoidance*2)/3) : (avoidance/2)))
+    {
+        /* Simulation */
+        if (borg_simulate) return (p1-p2);
+
+        /* Cast the spell */
+        if (borg_prayer(8, 2))
+        {
+            /* Value */
+            return (p1-p2);
+        }
+    }
+    return (0);
+}
+
+
+
+/*
+ * Detect Inviso/Monsters
+ * Used only if I am hit by an unseen guy.
+ * Casts detect invis.
+ */
+static int borg_defend_aux_inviso(int p1)
+{
+    int fail_allowed = 25;
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+
+    /* no need */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_SINV] || borg_see_inv)
+        return (0);
+
+    /* not recent */
+    if (borg_t > need_see_inviso + 5) return (0);
+
+
+    /* too dangerous to cast */
+    if (p1 > avoidance * 7) return (0);
+
+    /* Do I have anything that will work? */
+    if (-1 == borg_slot(TV_POTION,SV_POTION_DETECT_INVIS)  &&
+        -1 == borg_slot(TV_SCROLL,SV_SCROLL_DETECT_INVIS) &&
+        !borg_equips_staff_fail(SV_STAFF_DETECT_INVIS) &&
+        !borg_equips_staff_fail(SV_STAFF_DETECT_EVIL) &&
+        !borg_prayer_okay_fail(2, 3, fail_allowed) &&
+        !borg_spell_okay_fail(2, 6, fail_allowed))
+        return (0);
+
+    /* Darkness */
+    if (!(ag->info & BORG_GLOW) && !borg_skill[BI_CURLITE]) return (0);
+
+    /* No real value known, but lets cast it to find the bad guys. */
+    if (borg_simulate) return (10);
+
+
+    /* smoke em if you got em */
+    /* short time */
+    if (borg_quaff_potion(SV_POTION_DETECT_INVIS))
+    {
+        borg_see_inv = 18000;
+        return (10);
+    }
+    /* long time */
+    if (borg_prayer_fail(2, 3, fail_allowed) ||
+        borg_spell_fail(2, 6, fail_allowed))
+    {
+        borg_see_inv = 30000;
+        return (10);
+    }
+    /* snap shot */
+    if (borg_read_scroll(SV_SCROLL_DETECT_INVIS) ||
+        borg_use_staff(SV_STAFF_DETECT_INVIS) ||
+        borg_use_staff(SV_STAFF_DETECT_EVIL))
+    {
+        borg_see_inv = 3000; /* hack, actually a snap shot, no ignition message */
+        return (10);
+    }
+
+    /* ah crap, I guess I wont be able to see them */
+    return (0);
+
+}
+
+/*
+ * Light Beam to spot lurkers
+ * Used only if I am hit by an unseen guy.
+ * Lights up a hallway.
+ */
+static int borg_defend_aux_lbeam(void)
+{
+    bool hallway = FALSE;
+    int x=c_x;
+    int y=c_y;
+
+
+    /* no need */
+    if (borg_skill[BI_ISBLIND])
+        return (0);
+
+    /* Light Beam section to spot non seen guys */
+        /* not recent, dont bother */
+        if (borg_t > (need_see_inviso+2))
+            return (0);
+
+        /* Check to see if I am in a hallway */
+        /* Case 1a: north-south corridor */
+        if (borg_cave_floor_bold(y-1, x) && borg_cave_floor_bold(y+1, x) &&
+            !borg_cave_floor_bold(y, x-1) && !borg_cave_floor_bold(y, x+1) &&
+            !borg_cave_floor_bold(y+1, x-1) && !borg_cave_floor_bold(y+1, x+1) &&
+            !borg_cave_floor_bold(y-1, x-1) && !borg_cave_floor_bold(y-1, x+1))
+        {
+            /* ok to light up */
+            hallway = TRUE;
+        }
+
+        /* Case 1b: east-west corridor */
+        if (borg_cave_floor_bold(y, x-1) && borg_cave_floor_bold(y, x+1) &&
+            !borg_cave_floor_bold(y-1, x) && !borg_cave_floor_bold(y+1, x) &&
+            !borg_cave_floor_bold(y+1, x-1) && !borg_cave_floor_bold(y+1, x+1) &&
+            !borg_cave_floor_bold(y-1, x-1) && !borg_cave_floor_bold(y-1, x+1))
+        {
+            /* ok to light up */
+            hallway = TRUE;
+        }
+
+        /* Case 1aa: north-south doorway */
+        if (borg_cave_floor_bold(y-1, x) && borg_cave_floor_bold(y+1, x) &&
+            !borg_cave_floor_bold(y, x-1) && !borg_cave_floor_bold(y, x+1))
+        {
+            /* ok to light up */
+            hallway = TRUE;
+        }
+
+        /* Case 1ba: east-west doorway */
+        if (borg_cave_floor_bold(y, x-1) && borg_cave_floor_bold(y, x+1) &&
+            !borg_cave_floor_bold(y-1, x) && !borg_cave_floor_bold(y+1, x))
+        {
+            /* ok to light up */
+            hallway = TRUE;
+        }
+
+
+        /* not in a hallway */
+        if (!hallway) return (0);
+
+        /* Make sure I am not in too much danger */
+        if (borg_simulate && p1 > avoidance*3/4) return (0);
+
+        /* test the beam function */
+        if (!borg_lite_beam(TRUE)) return (0);
+
+        /* return some value */
+        if (borg_simulate) return (10);
+
+
+        /* if in a hallway call the Light Beam routine */
+        if (borg_lite_beam(FALSE))
+        {
+            return (10);
+        }
+        return (0);
+}
+
+/* Shift the panel to locate offscreen monsters */
+static int borg_defend_aux_panel_shift(void)
+{
+    int dir=0;
+    int wx = Term->offset_x / PANEL_WID;
+    int wy = Term->offset_y / PANEL_HGT;
+
+    /* no need */
+    if (!need_shift_panel && borg_skill[BI_CDEPTH] < 70)
+        return (0);
+
+	/* if Morgy is on my panel, dont do it */
+	if (borg_skill[BI_CDEPTH] == 100 && w_y == morgy_panel_y &&
+		w_x == morgy_panel_x) return (0);
+
+    /* Which direction do we need to move? */
+    /* Shift panel to the right */
+    if (c_x >= 52 && c_x <= 60 && wx == 0) dir = 6;
+    if (c_x >= 84 && c_x <= 94 && wx == 1) dir = 6;
+    if (c_x >= 116 && c_x <= 123 && wx == 2) dir = 6;
+    if (c_x >= 148 && c_x <= 159 && wx == 3) dir = 6;
+    /* Shift panel to the left */
+    if (c_x <= 142 && c_x >= 136 && wx == 4) dir = 4;
+    if (c_x <= 110 && c_x >= 103 && wx == 3) dir = 4;
+    if (c_x <= 78 && c_x >= 70 && wx == 2) dir = 4;
+    if (c_x <= 46 && c_x >= 37 && wx == 1) dir = 4;
+
+    /* Shift panel down */
+    if (c_y >= 15 && c_y <= 19 && wy == 0) dir = 2;
+    if (c_y >= 25 && c_y <= 30 && wy == 1) dir = 2;
+    if (c_y >= 36 && c_y <= 41 && wy == 2) dir = 2;
+    if (c_y >= 48 && c_y <= 52 && wy == 3) dir = 2;
+    /* Shift panel up */
+    if (c_y <= 51 && c_y >= 47 && wy == 4) dir = 8;
+    if (c_y <= 39 && c_y >= 35 && wy == 3) dir = 8;
+    if (c_y <= 28 && c_y >= 24 && wy == 2) dir = 8;
+    if (c_y <= 17 && c_y >= 13 && wy == 1) dir = 8;
+
+    /* Do the Shift if needed, then note it,  reset the flag */
+    if (need_shift_panel == TRUE)
+    {
+        /* Send action (view panel info) */
+        borg_keypress('L');
+
+        if (dir) borg_keypress(I2D(dir));
+        borg_keypress(ESCAPE);
+
+        borg_note("# Shifted panel to locate offscreen monster.");
+        need_shift_panel = FALSE;
+
+       	/* Leave the panel shift mode */
+       	borg_keypress(ESCAPE);
+    }
+    else
+    /* check to make sure its appropriate */
+    {
+
+        /* Hack Not if I just did one */
+        if (when_shift_panel &&
+            (borg_t - when_shift_panel <= 10 ||
+             borg_t - borg_t_morgoth <= 10))
+        {
+            /* do nothing */
+        }
+        else
+        /* shift up? only if a north corridor */
+        if (dir == 8 && borg_projectable_pure(c_y,c_x, c_y-2, c_x) &&
+            track_step_y[track_step_num -1] != c_y - 1)
+        {
+            /* Send action (view panel info) */
+            borg_keypress('L');
+            if (dir) borg_keypress(I2D(dir));
+            borg_note("# Shifted panel as a precaution.");
+            /* Mark the time to avoid loops */
+            when_shift_panel = borg_t;
+        	/* Leave the panel shift mode */
+        	borg_keypress(ESCAPE);
+        }
+        else /* shift down? only if a south corridor */
+        if  (dir == 2 && borg_projectable_pure(c_y,c_x, c_y+2, c_x) &&
+            track_step_y[track_step_num -1] != c_y + 1)
+        {
+            /* Send action (view panel info) */
+            borg_keypress('L');
+            borg_keypress(I2D(dir));
+            borg_note("# Shifted panel as a precaution.");
+            /* Mark the time to avoid loops */
+            when_shift_panel = borg_t;
+        	/* Leave the panel shift mode */
+        	borg_keypress(ESCAPE);
+        }
+        else /* shift Left? only if a west corridor */
+        if  (dir == 4 && borg_projectable_pure(c_y,c_x, c_y, c_x-2) &&
+        track_step_x[track_step_num -1] != c_x - 1)
+        {
+            /* Send action (view panel info) */
+            borg_keypress('L');
+            if (dir) borg_keypress(I2D(dir));
+            borg_note("# Shifted panel as a precaution.");
+            /* Mark the time to avoid loops */
+            when_shift_panel = borg_t;
+        	/* Leave the panel shift mode */
+        	borg_keypress(ESCAPE);
+        }
+        else /* shift Right? only if a east corridor */
+        if  (dir == 6 && borg_projectable_pure(c_y,c_x, c_y, c_x+2) &&
+        track_step_x[track_step_num -1] != c_x + 1)
+        {
+            /* Send action (view panel info) */
+            borg_keypress('L');
+            if (dir) borg_keypress(I2D(dir));
+            borg_note("# Shifted panel as a precaution.");
+            /* Mark the time to avoid loops */
+            when_shift_panel = borg_t;
+        	/* Leave the panel shift mode */
+        	borg_keypress(ESCAPE);
+        }
+
+
+    }
+    /* This uses no energy */
+    return (0);
+}
+
+/* This and the next routine is used on level 100 and when
+ * attacking Morgoth. The borg has found a safe place to wait
+ * for Morgoth to show.
+ *
+ * If the borg is not being threatened immediately by a monster,
+ * then rest right here.
+ *
+ * Only borgs with teleport away and a good attack spell do this
+ * routine.
+ */
+static int borg_defend_aux_rest(void)
+{
+	int i;
+    borg_grid *ag;
+
+	/* Only if in a good place */
+	if (!borg_morgoth_position) return (0);
+
+	/* Not if Morgoth is not on this level */
+	if (!morgoth_on_level) return (0);
+
+	/* Not if I can not teleport away */
+    if (!borg_spell_okay_fail(3, 1, 30) &&
+        !borg_prayer_okay_fail(4, 2, 30)) return (0);
+
+	/* Not if a monster can see me */
+    /* Examine all the monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+
+        int x9 = kill->x;
+        int y9 = kill->y;
+        int ax, ay, d;
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+		/* If a little twitchy, its ok to stay put */
+		if (avoidance > borg_skill[BI_CURHP]) continue;
+
+        /* Distance components */
+        ax = (x9 > c_x) ? (x9 - c_x) : (c_x - x9);
+        ay = (y9 > c_y) ? (y9 - c_y) : (c_y - y9);
+
+        /* Distance */
+        d = MAX(ax, ay);
+
+        /* Minimal distance */
+        if (d > MAX_RANGE) continue;
+
+		/* Get the grid */
+		ag = &borg_grids[kill->y][kill->x];
+
+		/* If I can see Morgoth, don't rest */
+        if (borg_projectable(c_y, c_x, kill->y, kill->x) &&
+            kill->r_idx == 547)
+        {
+			borg_note("# Not resting. I can see Morgoth.");
+			return(0);
+		}
+
+	}
+
+	/* Return some value for this rest */
+	if (borg_simulate) return (200);
+
+	/* Rest */
+	borg_keypress(',');
+	borg_note(format("# Resting on grid (%d, %d), waiting for Morgoth.",c_y,c_x));
+
+	/* All done */
+	return (200);
+}
+
+/*
+ * Try to get rid of all of the monsters while I build my
+ * Sea of Runes.
+ */
+static int borg_defend_aux_tele_away_morgoth(void)
+{
+	int p2 = 0;
+    int fail_allowed = 50;
+    int i, x, y;
+
+    borg_grid *ag;
+
+	/* Only if on level 100 */
+	if (!borg_skill[BI_CDEPTH] == 100) return (0);
+
+	/* Not if Morgoth is not on this level */
+	if (!morgoth_on_level) return (0);
+
+    /* Do I have the T.O. spell? */
+    if (!borg_spell_okay_fail(3, 1, fail_allowed) &&
+        !borg_prayer_okay_fail(4, 2, fail_allowed)) return (0);
+
+    /* Do I have the Glyph spell? No good to use TO if I cant build the sea of runes */
+    if (borg_skill[BI_AGLYPH] < 10) return (0);
+
+	/* No Teleport Other if surrounded */
+	if (borg_surrounded() == TRUE) return (0);
+
+    /* Borg_temp_n temporarily stores several things.
+     * Some of the borg_attack() sub-routines use these numbers,
+     * which would have been filled in borg_attack().
+     * Since this is a defence manuever which will move into
+     * and borrow some of the borg_attack() subroutines, we need
+     * to make sure that the borg_temp_n arrays are properly
+     * filled.  Otherwise, the borg will attempt to consider
+     * these grids which were left filled by some other routine.
+     * Which was probably a flow routine which stored about 200
+     * grids into the array.
+     * Any change in inclusion/exclusion criteria for filling this
+     * array in borg_attack() should be included here also.
+     */
+
+    /* Nobody around so dont worry */
+    if (!borg_kills_cnt && borg_simulate) return (0);
+
+    /* Reset list */
+    borg_temp_n = 0;
+	borg_tp_other_n = 0;
+
+    /* Find "nearby" monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill;
+
+        /* Monster */
+        kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Require current knowledge */
+        if (kill->when < borg_t - 2) continue;
+
+        /* Acquire location */
+        x = kill->x;
+        y = kill->y;
+
+        /* Get grid */
+        ag = &borg_grids[y][x];
+
+        /* Never shoot off-screen */
+        if (!(ag->info & BORG_OKAY)) continue;
+
+        /* Never shoot through walls */
+        if (!(ag->info & BORG_VIEW)) continue;
+
+        /* Check the distance XXX XXX XXX */
+        if (distance(c_y, c_x, y, x) > MAX_RANGE) continue;
+
+        /* Check the LOS */
+        if (!borg_projectable(c_y, c_x, kill->y, kill->x)) continue;
+
+        /* Save the location (careful) */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* No destinations */
+    if (!borg_temp_n && borg_simulate) return (0);
+
+    /* choose then target a bad guy or several
+     * If left as bolt, he targets the single most nasty guy.
+     * If left as beam, he targets the collection of monsters.
+     */
+	p2 = borg_launch_bolt(-1, 50, GF_AWAY_ALL_MORGOTH, MAX_RANGE);
+
+	/* Normalize the value a bit */
+	if (p2 > 1000) p2 = 1000;
+
+    /* Reset list */
+    borg_temp_n = 0;
+	borg_tp_other_n = 0;
+
+	/* Return a good score to make him do it */
+    if (borg_simulate) return (p2);
+
+	/* Log the Path for Debug */
+	borg_log_spellpath(TRUE);
+
+	/* Log additional info for debug */
+	for (i = 0; i < borg_tp_other_n; i++)
+	{
+		borg_note(format("# %d, index %d (%d,%d)",borg_tp_other_n,
+			borg_tp_other_index[i],	borg_tp_other_y[i],
+			borg_tp_other_x[i]));
+	}
+
+	borg_note("# Attempting to cast T.O. for depth 100.");
+
+    /* Cast the spell */
+    if (borg_spell(3, 1) ||
+        borg_prayer(4, 2) ||
+        borg_activate_artifact(ACT_TELE_AWAY, INVEN_WIELD)||
+        borg_aim_wand(SV_WAND_TELEPORT_AWAY))
+    {
+        /* Use target */
+        borg_keypress('5');
+
+        /* Set our shooting flag */
+        successful_target = -1;
+
+        /* Value */
+        return (p2);
+    }
+
+    return (0);
+}
+
+/*
+ * Try to get rid of all of the monsters while I build my
+ * Sea of Runes.
+ */
+static int borg_defend_aux_banishment_morgoth(void)
+{
+    int fail_allowed = 50;
+    int i, x, y;
+	int count = 0;
+	int glyphs = 0;
+
+    borg_grid *ag;
+    borg_kill *kill;
+    monster_race *r_ptr;
+
+	/* Not if Morgoth is not on this level */
+	if (!morgoth_on_level) return (0);
+
+	/* Scan grids looking for glyphs */
+    for (i = 0; i < 8; i++)
+    {
+        /* Access offset */
+        x = c_x + ddx_ddd[i];
+        y = c_y + ddy_ddd[i];
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+        /* Check for Glyphs */
+        if (ag->feat == FEAT_GLYPH) glyphs ++;
+	}
+
+	/* Only if on level 100 and in a sea of runes or
+	 * in the process of building one
+	 */
+#if 0
+	if (!borg_morgoth_position && glyphs < 3) return (0);
+#endif
+
+    /* Do I have the spell? (Banish Evil) */
+    if (!borg_spell_okay_fail(8, 5, fail_allowed) &&
+        !borg_prayer_okay_fail(8, 2, fail_allowed)) return (0);
+
+    /* Do I have the Glyph spell? No good to use TO if I cant build the sea of runes */
+    if (borg_skill[BI_AGLYPH] < 10) return (0);
+
+    /* Nobody around so dont worry */
+    if (!borg_kills_cnt && borg_simulate) return (0);
+
+    /* Find "nearby" monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        /* Monster */
+        kill = &borg_kills[i];
+	    r_ptr = &r_info[kill->r_idx];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Require current knowledge */
+        if (kill->when < borg_t - 2) continue;
+
+        /* Acquire location */
+        x = kill->x;
+        y = kill->y;
+
+        /* Get grid */
+        ag = &borg_grids[y][x];
+
+		/* Never try on non-evil guys if Priest */
+		if (cp_ptr->spell_book == TV_PRAYER_BOOK &&
+		    !(r_ptr->flags3 & RF3_EVIL)) continue;
+
+
+        /* Check the distance  */
+        if (distance(c_y, c_x, y, x) > MAX_RANGE) continue;
+
+		/* Monster must be LOS */
+        if (!borg_projectable(c_y, c_x, kill->y, kill->x)) continue;
+
+		/* Count the number of monsters too close double*/
+        if (distance(c_y, c_x, y, x) <= 7) count ++;
+
+		/* Count the number of monster on screen */
+		count ++;
+    }
+
+    /* No destinations */
+    if (count <= 7 && borg_simulate) return (0);
+
+	/* Return a good score to make him do it */
+    if (borg_simulate) return (1500);
+
+	borg_note(format("# Attempting to cast Banishment for depth 100.  %d monsters ", count));
+
+    /* Cast the spell */
+    if (borg_spell(8, 5) ||
+        borg_prayer(8, 2))
+    {
+	        /* Remove this race from the borg_kill */
+	        for (i = 0; i < borg_kills_nxt; i++)
+	        {
+	            borg_kill *kill;
+	            monster_race *r_ptr;
+
+	            /* Monster */
+	            kill = &borg_kills[i];
+	            r_ptr = &r_info[kill->r_idx];
+
+				/* Cant kill uniques like this */
+				if (r_ptr->flags1 & RF1_UNIQUE) continue;
+
+	            /* remove this monster */
+	            borg_delete_kill(i);
+			}
+
+        /* Value */
+        return (1000);
+    }
+
+    return (0);
+}
+
+/*
+ * Sometimes the borg will not fire on Morgoth as he approaches
+ * while tunneling through rock.  The borg still remembers and
+ * assumes that the rock is unknown grid.
+ */
+static int borg_defend_aux_light_morgoth(void)
+{
+    int fail_allowed = 50;
+    int i, x, y;
+    int b_y = -1;
+    int b_x = -1;
+	int count = 0;
+
+    borg_grid *ag;
+    borg_kill *kill;
+    monster_race *r_ptr;
+
+	/* Only if on level 100 and in a sea of runes */
+	if (!borg_morgoth_position) return (0);
+
+	/* Not if Morgoth is not on this level */
+	if (!morgoth_on_level) return (0);
+
+    /* Do I have the spell? */
+    if (!borg_spell_okay_fail(1, 6, fail_allowed) &&
+        !borg_prayer_okay_fail(5, 4, fail_allowed)) return (0);
+
+    /* Nobody around so dont worry */
+    if (!borg_kills_cnt && borg_simulate) return (0);
+
+    /* Find "nearby" monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        /* Monster */
+        kill = &borg_kills[i];
+	    r_ptr = &r_info[kill->r_idx];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Skip non- Morgoth monsters */
+	    if (kill->r_idx != 547) continue;
+
+        /* Require current knowledge */
+        if (kill->when < borg_t - 2) continue;
+
+        /* Acquire location */
+        x = kill->x;
+        y = kill->y;
+
+        /* Get grid */
+        ag = &borg_grids[y][x];
+
+        /* Check the distance  */
+        if (distance(c_y, c_x, y, x) > MAX_RANGE) continue;
+        if (distance(c_y, c_x, y, x) <= 5) continue;
+
+        /* We want at least one dark spot on the path */
+        if (!borg_projectable_dark(c_y, c_x, y, x)) continue;
+
+		/* Count Morgoth so I try the spell */
+		count ++;
+		b_y = y;
+		b_x = x;
+    }
+
+    /* No destinations */
+    if (count <= 0 && borg_simulate) return (0);
+
+	/* Return a good score to make him do it */
+    if (borg_simulate) return (500);
+
+	borg_note(format("# Attempting to Illuminate a Pathway to (%d, %d)",b_y,b_x));
+
+	/* Target Morgoth Grid */
+	(void)borg_target(b_y,b_x);
+
+    /* Cast the spell */
+    if (borg_spell(1, 6) ||
+        borg_prayer(5, 4))
+    {
+		/* Select the target */
+		borg_keypress('5');
+
+        /* Value */
+        return (200);
+    }
+
+    return (0);
+}
+
+/*
+ * Simulate/Apply the optimal result of using the given "type" of defence
+ * p1 is the current danger level (passed in for effiency)
+ */
+static int borg_defend_aux(int what, int p1)
+{
+    /* Analyze */
+    switch (what)
+    {
+        case BD_SPEED:
+        {
+            return (borg_defend_aux_speed(p1));
+        }
+
+        case BD_PROT_FROM_EVIL:
+        {
+            return (borg_defend_aux_prot_evil(p1));
+        }
+        case BD_RESIST_FC:
+        {
+            return (borg_defend_aux_resist_fc(p1));
+        }
+        case BD_RESIST_FECAP:
+        {
+            return (borg_defend_aux_resist_fecap(p1));
+        }
+        case BD_RESIST_F:
+        {
+            return (borg_defend_aux_resist_f(p1));
+        }
+        case BD_RESIST_C:
+        {
+            return (borg_defend_aux_resist_c(p1));
+        }
+        case BD_RESIST_A:
+        {
+            return (borg_defend_aux_resist_a(p1));
+        }
+        case BD_RESIST_P:
+        {
+            return (borg_defend_aux_resist_p(p1));
+        }
+        case BD_BLESS:
+        {
+            return (borg_defend_aux_bless(p1));
+        }
+
+        case BD_HERO:
+        {
+          return (borg_defend_aux_hero(p1));
+        }
+        case BD_BERSERK:
+        {
+          return (borg_defend_aux_berserk(p1));
+        }
+        case BD_SHIELD:
+        {
+            return (borg_defend_aux_shield(p1));
+        }
+        case BD_TELE_AWAY:
+        {
+            return (borg_defend_aux_tele_away(p1));
+        }
+        case BD_GLYPH:
+        {
+            return (borg_defend_aux_glyph(p1));
+        }
+        case BD_CREATE_DOOR:
+        {
+            return (borg_defend_aux_create_door(p1));
+        }
+        case BD_MASS_GENOCIDE:
+        {
+            return (borg_defend_aux_mass_genocide(p1));
+        }
+        case BD_GENOCIDE:
+        {
+            return (borg_defend_aux_genocide(p1));
+        }
+        case BD_GENOCIDE_NASTIES:
+        {
+            return (borg_defend_aux_genocide_nasties(p1));
+        }
+        case BD_EARTHQUAKE:
+        {
+            return (borg_defend_aux_earthquake(p1));
+        }
+		case BD_TPORTLEVEL:
+		{
+			return (borg_defend_aux_teleportlevel(p1));
+		}
+		case BD_DESTRUCTION:
+        {
+            return (borg_defend_aux_destruction(p1));
+        }
+        case BD_BANISHMENT:
+        {
+            return (borg_defend_aux_banishment(p1));
+        }
+        case BD_DETECT_INVISO:
+        {
+            return (borg_defend_aux_inviso(p1));
+        }
+        case BD_LIGHT_BEAM:
+        {
+            return (borg_defend_aux_lbeam());
+        }
+        case BD_SHIFT_PANEL:
+        {
+            return (borg_defend_aux_panel_shift());
+        }
+        case BD_REST:
+        {
+            return (borg_defend_aux_rest());
+        }
+        case BD_TELE_AWAY_MORGOTH:
+        {
+            return (borg_defend_aux_tele_away_morgoth());
+        }
+        case BD_BANISHMENT_MORGOTH:
+        {
+            return (borg_defend_aux_banishment_morgoth());
+        }
+        case BD_LIGHT_MORGOTH:
+        {
+            return (borg_defend_aux_light_morgoth());
+        }
+
+    }
+    return (0);
+}
+
+/*
+ * prepare to attack... this is setup for a battle.
+ */
+bool borg_defend(int p1)
+{
+    int n, b_n = 0;
+    int g, b_g = -1;
+
+    /* Simulate */
+    borg_simulate = TRUE;
+
+
+    /* if you have Resist All and it is about to drop, */
+    /* refresh it (if you can) */
+    if (borg_resistance && borg_resistance < (borg_game_ratio *2))
+    {
+        int p;
+
+        /* check 'true' danger. This will make sure we do not */
+        /* refresh our Resistance if no-one is around */
+        borg_attacking = TRUE;
+        p = borg_danger(c_y,c_x,1, FALSE); /* Note FALSE for danger!! */
+        borg_attacking = FALSE;
+        if (p > borg_fear_region[c_y/11][c_x/11] ||
+            borg_fighting_unique)
+        {
+            if (borg_spell(4, 3))
+            {
+                borg_note(format("# Refreshing Resistance.  borg_resistance=%d, p_ptr->=%d, (ratio=%d)",borg_resistance, p_ptr->oppose_acid, borg_game_ratio));
+                borg_attempting_refresh_resist = TRUE;
+                borg_resistance = 25000;
+                return (TRUE);
+            }
+        }
+    }
+
+    /* Analyze the possible setup moves */
+    for (g = 0; g < BD_MAX; g++)
+    {
+		/* Simulate */
+        n = borg_defend_aux(g, p1);
+
+        /* Track "best" attack */
+        if (n <= b_n) continue;
+
+        /* Track best */
+        b_g = g;
+        b_n = n;
+    }
+
+    /* Nothing good */
+    if (b_n <= 0)
+    {
+        return (FALSE);
+    }
+
+    /* Note */
+    borg_note(format("# Performing defence type %d with value %d", b_g, b_n));
+
+    /* Instantiate */
+    borg_simulate = FALSE;
+
+    /* Instantiate */
+    (void)borg_defend_aux(b_g, p1);
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Perma spells.  Some are cool to have on all the time, so long as their
+ * mana cost is not too much.
+ * There are several types of setup moves:
+ *
+ *   Temporary speed
+ *   Protect From Evil
+ *   Prayer
+ *   Temp Resist (either all or just cold/fire?)
+ *   Shield
+ *
+ */
+enum
+{
+    BP_SPEED,
+    BP_PROT_FROM_EVIL,
+    BP_BLESS,
+
+    BP_RESIST_ALL,
+    BP_RESIST_ALL_COLLUIN,
+    BP_RESIST_F,
+    BP_RESIST_C,
+    BP_RESIST_P,
+    BP_RESIST_FC,
+
+    BP_SHIELD,
+    BP_HERO,
+    BP_BERSERK,
+    BP_BERSERK_POTION,
+
+    BP_GLYPH,
+    BP_SEE_INV,
+
+    BP_MAX
+};
+
+/*
+ * Bless/Prayer to prepare for battle
+ */
+static int borg_perma_aux_bless(void)
+{
+    int fail_allowed = 15, cost;
+
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 20;
+    if (borg_fighting_unique) fail_allowed = 25;
+
+    /* already blessed */
+    if (borg_bless)
+        return (0);
+
+    /* Cant when Blind */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (0);
+
+    /* XXX Dark */
+
+    if ( !borg_prayer_okay_fail(0, 2, fail_allowed))
+        return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[0][2];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (borg_skill[BI_CLEVEL] > 10 &&
+        cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    /* bless is a low priority */
+    if (borg_simulate) return (1);
+
+    /* do it! */
+    borg_prayer(0,2);
+
+	/* No resting to recoop mana */
+    borg_no_rest_prep = 18000;
+
+    return (1);
+}
+/* all resists FECAP*/
+static int borg_perma_aux_resist(void)
+{
+    int cost = 0;
+    int fail_allowed = 5;
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+    if (my_oppose_fire + my_oppose_acid + my_oppose_pois +
+        my_oppose_elec + my_oppose_cold >= 3)
+        return (0);
+
+    if (!borg_spell_okay_fail(4, 3, fail_allowed))
+        return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[4][3];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (2);
+
+    /* do it! */
+    borg_spell_fail(4, 3, fail_allowed);
+
+	/* No resting to recoop mana */
+    borg_no_rest_prep = 3000;
+
+    /* default to can't do it. */
+    return (2);
+}
+
+/* all resists from the cloak*/
+static int borg_perma_aux_resist_colluin(void)
+{
+    if (my_oppose_fire + my_oppose_acid + my_oppose_pois +
+        my_oppose_elec + my_oppose_cold >= 3)
+        return (0);
+
+    /* Only use it when Unique is close */
+    if (!borg_fighting_unique) return (0);
+
+    if (!borg_equips_artifact(ACT_RESIST, INVEN_OUTER))
+        return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (2);
+
+    /* do it! */
+    borg_activate_artifact(ACT_RESIST, INVEN_OUTER);
+
+	/* No resting to recoop mana */
+    borg_no_rest_prep = 3000;
+
+    /* Value */
+    return (2);
+}
+
+/* resists--- Only bother if a Unique is on the level.*/
+static int borg_perma_aux_resist_f(void)
+{
+    int cost = 0;
+    int fail_allowed = 5;
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+    if (my_oppose_fire || !unique_on_level)
+        return (0);
+
+    if (borg_skill[BI_IFIRE]) return (0);
+
+    if (!borg_spell_okay_fail(4, 1, fail_allowed))
+        return (0);
+
+	/* Skip it if I can do the big spell */
+    if (borg_spell_okay_fail(4, 3, fail_allowed)) return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[4][1];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= borg_skill[BI_CURSP] /20) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (1);
+
+    /* do it! */
+    if (borg_spell_fail(4, 1, fail_allowed) )
+    {
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+
+        /* Value */
+        return (1);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+/* resists--- Only bother if a Unique is on the level.*/
+static int borg_perma_aux_resist_c(void)
+{
+    int cost = 0;
+    int fail_allowed = 5;
+    borg_magic *as;
+
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+    if (my_oppose_cold || !unique_on_level)
+        return (0);
+
+    if (borg_skill[BI_ICOLD]) return (0);
+
+    if (!borg_spell_okay_fail(4, 0, fail_allowed))
+        return (0);
+
+	/* Skip it if I can do the big spell */
+    if (borg_spell_okay_fail(4, 3, fail_allowed)) return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[4][0];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= borg_skill[BI_CURSP] /20) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (1);
+
+    /* do it! */
+    if (borg_spell_fail(4, 0, fail_allowed) )
+    {
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+
+        /* Value */
+        return (1);
+    }
+
+
+    /* default to can't do it. */
+    return (0);
+}
+
+
+/* resists--- Only bother if a Unique is on the level.*/
+static int borg_perma_aux_resist_p(void)
+{
+    int cost = 0;
+    int fail_allowed = 5;
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+
+    if (my_oppose_pois || !unique_on_level)
+        return (0);
+
+    if (!borg_spell_okay_fail(4, 2, fail_allowed))
+        return (0);
+
+	/* Skip it if I can do the big spell */
+    if (borg_spell_okay_fail(4, 3, fail_allowed)) return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[4][2];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= borg_skill[BI_CURSP] /20) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (1);
+
+    /* do it! */
+    if (borg_spell_fail(4, 2, fail_allowed) )
+	{
+       	/* No resting to recoop mana */
+    	borg_no_rest_prep = 3000;
+
+		/* Value */
+        return (1);
+	}
+
+    /* default to can't do it. */
+    return (0);
+}
+/* resist fire and cold for priests */
+static int borg_perma_aux_resist_fc(void)
+{
+    int cost = 0;
+    int fail_allowed = 5;
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+    /* cast if one drops and unique is near */
+    if (borg_fighting_unique &&
+        ((my_oppose_fire || borg_skill[BI_IFIRE]) &&
+         (my_oppose_cold || borg_skill[BI_ICOLD]))) return (0);
+
+
+    /* cast if both drop and no unique is near */
+    if (!borg_fighting_unique &&
+        (my_oppose_fire ||
+        my_oppose_cold)) return (0);
+
+    /* no need if immune */
+    if (borg_skill[BI_IFIRE] && borg_skill[BI_ICOLD]) return (0);
+
+    if (!borg_prayer_okay_fail(1, 7, fail_allowed))
+        return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[1][7];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (2);
+
+    /* do it! */
+    if (borg_prayer_fail(1, 7, fail_allowed) )
+	{
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+
+        /* Value */
+        return (2);
+	}
+
+
+    /* default to can't do it. */
+    return (0);
+}
+
+
+
+/*
+ * Speed to prepare for battle
+ */
+static int borg_perma_aux_speed(void)
+{
+    int fail_allowed = 7;
+    int cost;
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+
+    /* already fast */
+    if (borg_speed)
+        return (0);
+
+    /* only cast defence spells if fail rate is not too high */
+    if (!borg_spell_okay_fail( 3, 2, fail_allowed))
+        return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[3][2];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (5);
+
+    /* do it! */
+    if (borg_spell_fail( 3, 2, fail_allowed))
+	{
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+		return (5);
+	}
+
+    /* default to can't do it. */
+    return (0);
+}
+
+static int borg_perma_aux_shield(void)
+{
+    int fail_allowed = 5;
+    int cost;
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+    /* if already protected */
+    if (borg_shield)
+        return (0);
+
+    if (!borg_spell_okay_fail(4, 4, fail_allowed))
+        return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[4][4];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (2);
+
+    /* do it! */
+    if (borg_spell_fail(4, 4, fail_allowed))
+	{
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+		return (2);
+	}
+
+    /* default to can't do it. */
+    return (0);
+}
+static int borg_perma_aux_prot_evil(void)
+{
+    int cost = 0;
+    int fail_allowed = 5;
+    borg_magic *as;
+
+    /* if already protected */
+    if (borg_prot_from_evil)
+        return (0);
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+
+    if (!borg_prayer_okay_fail(2,4,fail_allowed)) return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[2][4];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (3);
+
+    /* do it! */
+    if (borg_prayer_fail(2, 4, fail_allowed))
+	{
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+
+        /* Value */
+        return (3);
+	}
+
+    /* default to can't do it. */
+    return (0);
+}
+/*
+ * Hero to prepare for battle
+ */
+static int borg_perma_aux_hero(void)
+{
+    int fail_allowed = 5, cost;
+
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+    /* already blessed */
+    if (borg_hero)
+        return (0);
+
+    /* Cant when Blind */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (0);
+
+    /* XXX Dark */
+
+    if ( !borg_spell_okay_fail(7, 0, fail_allowed))
+        return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[7][0];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    /* hero is a low priority */
+    if (borg_simulate) return (1);
+
+    /* do it! */
+    if (borg_spell(7,0))
+	{
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+		return 1;
+	}
+
+
+    return (0);
+}
+
+/*
+ * Berserk to prepare for battle
+ */
+static int borg_perma_aux_berserk(void)
+{
+    int fail_allowed = 5, cost;
+
+    borg_magic *as;
+
+    /* increase the threshold */
+    if (unique_on_level) fail_allowed = 10;
+    if (borg_fighting_unique) fail_allowed = 15;
+
+    /* already blessed */
+    if (borg_berserk)
+        return (0);
+
+    /* Cant when Blind */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (0);
+
+    /* XXX Dark */
+
+    if ( !borg_spell_okay_fail(7, 1, fail_allowed))
+        return (0);
+
+    /* Obtain the cost of the spell */
+    as = &borg_magics[7][1];
+    cost = as->power;
+
+    /* If its cheap, go ahead */
+    if (cost >= ((unique_on_level) ? borg_skill[BI_CURSP] / 7 : borg_skill[BI_CURSP] /10)) return (0);
+
+    /* Simulation */
+    /* Berserk is a low priority */
+    if (borg_simulate) return (2);
+
+    /* do it! */
+    if (borg_spell(7,1))
+	{
+		/* No resting to recoop mana */
+	    borg_no_rest_prep = 3000;
+		return 2;
+	}
+
+
+    return (0);
+}
+/*
+ * Berserk to prepare for battle
+ */
+static int borg_perma_aux_berserk_potion(void)
+{
+
+    /* Saver the potions */
+    if (!borg_fighting_unique) return (0);
+
+    /* already blessed */
+    if (borg_hero || borg_berserk)
+        return (0);
+
+    /* do I have any? */
+    if (-1 == borg_slot(TV_POTION,SV_POTION_BERSERK_STRENGTH))
+        return (0);
+
+    /* Simulation */
+    /* Berserk is a low priority */
+    if (borg_simulate) return (2);
+
+    /* do it! */
+    if (borg_quaff_potion(SV_POTION_BERSERK_STRENGTH))
+          return (2);
+
+
+    return (0);
+}
+
+/* Glyph of Warding in a a-s corridor */
+static int borg_perma_aux_glyph(void)
+{
+    int i, wall_y, wall_x, wall_count = 0, y,x;
+    int fail_allowed = 20;
+
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+    /* check to make sure a summoner is near */
+    if (borg_kills_summoner == -1) return (0);
+
+    /* make sure I have the spell */
+    if (!borg_prayer_okay_fail(3,4,fail_allowed) &&
+    	!borg_spell_okay_fail(6,4,fail_allowed)) return (0);
+
+
+    /* He should not cast it while on an object.
+     * I have addressed this inadequately in borg9.c when dealing with
+     * messages.  The message "the object resists" will delete the glyph
+     * from the array.  Then I set a broken door on that spot, the borg ignores
+     * broken doors, so he won't loop.
+     */
+    if ( (ag->take) ||
+         (ag->feat == FEAT_GLYPH) ||
+         ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL)) ||
+         ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_DOOR_TAIL)) ||
+         (ag->feat == FEAT_LESS) ||
+         (ag->feat == FEAT_MORE) ||
+         (ag->feat == FEAT_OPEN) ||
+         (ag->feat == FEAT_BROKEN) )
+        {
+            return (0);
+        }
+
+    /* This spell is cast while he is digging and AS Corridor */
+    /* Get grid */
+    for (wall_x = -1; wall_x <= 1; wall_x++)
+    {
+        for (wall_y = -1; wall_y <= 1; wall_y++)
+        {
+            /* Acquire location */
+            x = wall_x + c_x;
+            y = wall_y + c_y;
+
+            ag = &borg_grids[y][x];
+
+            /* track adjacent walls */
+            if ( (ag->feat == FEAT_GLYPH) ||
+               ((ag->feat >= FEAT_MAGMA) && (ag->feat <= FEAT_WALL_SOLID)))
+            {
+                wall_count++;
+            }
+        }
+    }
+
+    /* must be in a corridor */
+    if (wall_count < 6) return (0);
+
+    /* Simulation */
+    if (borg_simulate) return (10);
+
+    /* do it! */
+    if (borg_prayer_fail(3, 4, fail_allowed) ||
+    	borg_spell_fail(6, 4, fail_allowed) ||
+        borg_read_scroll(SV_SCROLL_RUNE_OF_PROTECTION))
+    {
+        /* Check for an existing glyph */
+        for (i = 0; i < track_glyph_num; i++)
+        {
+            /* Stop if we already new about this glyph */
+            if ((track_glyph_x[i] == c_x) && (track_glyph_y[i] == c_y)) return (p1-p2);
+        }
+
+        /* Track the newly discovered glyph */
+        if ((i == track_glyph_num) && (track_glyph_size))
+        {
+            borg_note("# Noting the creation of a corridor glyph.");
+            track_glyph_num++;
+            track_glyph_x[i] = c_x;
+            track_glyph_y[i] = c_y;
+        }
+        return (p1-p2);
+    }
+
+    /* default to can't do it. */
+    return (0);
+}
+
+/*
+ * Detect Inviso/Monsters
+ * Casts detect invis.
+ */
+static int borg_perma_aux_see_inv(void)
+{
+    int fail_allowed = 25;
+    borg_grid *ag = &borg_grids[c_y][c_x];
+
+
+    /* no need */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] ||
+        borg_skill[BI_SINV] || borg_see_inv)
+        return (0);
+
+    /* Do I have anything that will work? */
+    if (!borg_prayer_okay_fail(2, 3, fail_allowed) &&
+        !borg_spell_okay_fail(2, 6, fail_allowed))
+        return (0);
+
+    /* Darkness */
+    if (!(ag->info & BORG_GLOW) && !borg_skill[BI_CURLITE]) return (0);
+
+    /* No real value known, but lets cast it to find the bad guys. */
+    if (borg_simulate) return (10);
+
+
+    /* long time */
+    if (borg_prayer_fail(2, 3, fail_allowed) ||
+        borg_spell_fail(2, 6, fail_allowed))
+    {
+        borg_see_inv = 32000;
+        return (10);
+    }
+
+    /* ah crap, I guess I wont be able to see them */
+    return (0);
+
+}
+
+
+
+/*
+ * Simulate/Apply the optimal result of using the given "type" of set-up
+ */
+static int borg_perma_aux(int what)
+{
+
+    /* Analyze */
+    switch (what)
+    {
+        case BP_SPEED:
+        {
+            return (borg_perma_aux_speed());
+        }
+
+        case BP_PROT_FROM_EVIL:
+        {
+            return (borg_perma_aux_prot_evil());
+        }
+        case BP_RESIST_ALL:
+        {
+            return (borg_perma_aux_resist());
+        }
+        case BP_RESIST_ALL_COLLUIN:
+        {
+            return (borg_perma_aux_resist_colluin());
+        }
+        case BP_RESIST_F:
+        {
+            return (borg_perma_aux_resist_f());
+        }
+        case BP_RESIST_C:
+        {
+            return (borg_perma_aux_resist_c());
+        }
+        case BP_RESIST_P:
+        {
+            return (borg_perma_aux_resist_p());
+        }
+        case BP_RESIST_FC:
+        {
+            return (borg_perma_aux_resist_fc());
+        }
+        case BP_BLESS:
+        {
+            return (borg_perma_aux_bless());
+        }
+        case BP_HERO:
+        {
+            return (borg_perma_aux_hero());
+        }
+        case BP_BERSERK:
+        {
+            return (borg_perma_aux_berserk());
+        }
+        case BP_BERSERK_POTION:
+        {
+            return (borg_perma_aux_berserk_potion());
+        }
+        case BP_SHIELD:
+        {
+            return (borg_perma_aux_shield());
+        }
+        case BP_GLYPH:
+        {
+            return (borg_perma_aux_glyph());
+        }
+        case BP_SEE_INV:
+        {
+			return (borg_perma_aux_see_inv());
+		}
+    }
+    return (0);
+}
+
+
+/*
+ * Walk around with certain spells on if you can afford to do so.
+ */
+bool borg_perma_spell()
+{
+    int n, b_n = 0;
+    int g, b_g = -1;
+
+
+    /* Simulate */
+    borg_simulate = TRUE;
+
+    /* Not in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Analyze the possible setup moves */
+    for (g = 0; g < BP_MAX; g++)
+    {
+        /* Simulate */
+        n = borg_perma_aux(g);
+
+        /* Track "best" move */
+        if (n <= b_n) continue;
+
+        /* Track best */
+        b_g = g;
+        b_n = n;
+    }
+
+    /* Nothing good */
+    if (b_n <= 0)
+    {
+        return (FALSE);
+    }
+
+    /* Note */
+    borg_note(format("# Performing perma-spell type %d with value %d", b_g, b_n));
+
+    /* Instantiate */
+    borg_simulate = FALSE;
+
+    /* Instantiate */
+    (void)borg_perma_aux(b_g);
+    /* Success */
+    return (TRUE);
+
+}
+
+/*
+ * check to make sure there are no monsters around
+ * that should prevent resting
+ */
+bool borg_check_rest(void)
+{
+    int i;
+
+    /* Do not rest recently after killing a multiplier */
+    /* This will avoid the problem of resting next to */
+    /* an unkown area full of breeders */
+    if (when_last_kill_mult > (borg_t-4) &&
+        when_last_kill_mult <= borg_t)
+        return (FALSE);
+
+	/* No resting to recover if I just cast a prepatory spell
+	 * which is what I like to do right before I take a stair
+	 */
+	if (borg_no_rest_prep >= 1) return (FALSE);
+
+	/* No resting if Blessed and good HP unless SP sux */
+	if ((borg_bless || borg_hero || borg_berserk) &&
+	    (borg_skill[BI_CURHP] >= borg_skill[BI_MAXHP] * 8/10) &&
+	     borg_skill[BI_CURSP] >= borg_skill[BI_MAXSP] * 3/10) return (FALSE);
+
+    when_last_kill_mult = 0;
+
+    /* Generally disturb_move is off */
+    disturb_move = FALSE;
+
+	/* Be concerned about the Regional Fear. */
+	if (borg_fear_region[c_y/11][c_x/11] > borg_skill[BI_CURHP] / 10 &&
+		borg_skill[BI_CDEPTH] != 100) return (FALSE);
+
+	/* Be concerned about the Monster Fear. */
+	if (borg_fear_monsters[c_y][c_x] > borg_skill[BI_CURHP] / 10 &&
+		borg_skill[BI_CDEPTH] != 100) return (FALSE);
+
+	/* Be concerned about the Monster Fear. */
+	if (borg_danger(c_y, c_x, 1, TRUE) > borg_skill[BI_CURHP] / 40 &&
+		borg_skill[BI_CDEPTH] >= 85) return (FALSE);
+
+	/* Be concerned if low on food */
+    if (borg_skill[BI_CURLITE] == 0 || borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK] || borg_skill[BI_FOOD] < 2)
+       return (FALSE);
+
+    /* Examine all the monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+        monster_race *r_ptr = &r_info[kill->r_idx];
+
+        int x9 = kill->x;
+        int y9 = kill->y;
+        int ax, ay, d;
+        int p = 0;
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Distance components */
+        ax = (x9 > c_x) ? (x9 - c_x) : (c_x - x9);
+        ay = (y9 > c_y) ? (y9 - c_y) : (c_y - y9);
+
+        /* Distance */
+        d = MAX(ax, ay);
+
+        /* Minimal distance */
+        if (d > MAX_RANGE) continue;
+
+		/* If monster is asleep, dont worry */
+		if (!kill->awake) continue;
+
+        /* if too close, don't rest */
+        if (d < 2) return (FALSE);
+
+        /* if too close, don't rest */
+        if (d < 3 && !(r_ptr->flags1 & RF1_NEVER_MOVE)) return (FALSE);
+
+        /* one call for dangers */
+        borg_full_damage = TRUE;
+        p = borg_danger_aux(y9, x9, 1, i, TRUE);
+        borg_full_damage = FALSE;
+
+
+        /* Real scary guys pretty close */
+        if (d < 5 && (p > avoidance/3)) return (FALSE);
+
+        /* scary guys far away */
+/*        if (d < 17 && d > 5 && (p > avoidance/3)) return (FALSE); */
+
+        /* Scary guys kinda close, tinker with disturb near.
+         * We do not want a borg with ESP stopping his rest
+         * each round, having only rested one turn. So we set
+         * disturb_move to true only if some scary guys are
+         * somewhat close to us.
+         */
+        if (d < 13 && (p > avoidance * 6 / 10))
+           disturb_move = TRUE;
+
+        if (d < 8 && (p > avoidance/2))
+           disturb_move = TRUE;
+
+        /* should check LOS... monster to me.  Ignore wimpy ones unless they have ranged attack */
+        if ((p >= borg_skill[BI_CURHP] / 10 && borg_los(y9,x9, c_y,c_x) &&
+            borg_skill[BI_CDEPTH]) ||
+            kill->ranged_attack) return FALSE;
+
+        /* should check LOS... me to monster. Ignore wimpy ones unless they have ranged attack*/
+        if ((p >= borg_skill[BI_CURHP] / 10 && borg_los(c_y,c_x,y9,x9) &&
+            borg_skill[BI_CDEPTH]) ||
+            kill->ranged_attack) return FALSE;
+
+        /* Perhaps borg should check and see if the previous grid was los */
+
+        /* if absorbs mana, not safe */
+        if ((r_ptr->flags5 & RF5_DRAIN_MANA) && (borg_skill[BI_MAXSP] > 1)) return FALSE;
+
+        /* if it walks through walls, not safe */
+        if (r_ptr->flags2 & RF2_PASS_WALL) return FALSE;
+        if (r_ptr->flags2 & RF2_KILL_WALL) return FALSE;
+
+    }
+    return TRUE;
+}
+
+/*
+ * Attempt to recover from damage and such after a battle
+ *
+ * Note that resting while in danger is counter-productive, unless
+ * the danger is low, in which case it may induce "farming".
+ *
+ * Note that resting while recall is active will often cause you
+ * to lose hard-won treasure from nasty monsters, so we disable
+ * resting when waiting for recall in the dungeon near objects.
+ *
+ * First we try spells/prayers, which are "free", and then we
+ * try food, potions, scrolls, staffs, rods, artifacts, etc.
+ *
+ * XXX XXX XXX
+ * Currently, we use healing spells as if they were "free", but really,
+ * this is only true if the "danger" is less than the "reward" of doing
+ * the healing spell, and if there are no monsters which might soon step
+ * around the corner and attack.
+ */
+bool borg_recover(void)
+{
+    int p = 0;
+    int q;
+
+    /*** Handle annoying situations ***/
+
+    /* Refuel current torch */
+    if ((borg_items[INVEN_LITE].tval == TV_LITE) &&
+        (borg_items[INVEN_LITE].sval == SV_LITE_TORCH))
+    {
+        /* Refuel the torch if needed */
+        if (borg_items[INVEN_LITE].pval < 2500)
+        {
+            if (borg_refuel_torch()) return (TRUE);
+
+            /* Take note */
+            borg_note(format("# Need to refuel but cant!", p));
+        }
+    }
+
+    /* Refuel current lantern */
+    if ((borg_items[INVEN_LITE].tval == TV_LITE) &&
+        (borg_items[INVEN_LITE].sval == SV_LITE_LANTERN))
+    {
+        /* Refuel the lantern if needed */
+        if (borg_items[INVEN_LITE].pval < 5000)
+        {
+            if (borg_refuel_lantern()) return (TRUE);
+
+            /* Take note */
+            borg_note(format("# Need to refuel but cant!", p));
+        }
+    }
+
+
+    /*** Do not recover when in danger ***/
+
+    /* Look around for danger */
+    p = borg_danger(c_y, c_x, 1, TRUE);
+
+    /* Never recover in dangerous situations */
+    if (p > avoidance / 4) return (FALSE);
+
+
+    /*** Roll for "paranoia" ***/
+
+    /* Base roll */
+    q = rand_int(100);
+
+    /* Half dead */
+    if (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 2) q = q - 10;
+
+    /* Almost dead */
+    if (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 4) q = q - 10;
+
+
+    /*** Use "cheap" cures ***/
+
+    /* Hack -- cure stun */
+    if (borg_skill[BI_ISSTUN] && (q < 75))
+    {
+        if (borg_activate_artifact(ACT_CURE_WOUNDS, INVEN_WIELD) ||
+            borg_prayer(2, 7) ||
+            borg_prayer(3, 2) ||
+            borg_prayer(6, 1) ||
+            borg_prayer(6, 2))
+
+        {
+            /* Take note */
+            borg_note(format("# Cure Stun", p));
+
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure stun */
+    if (borg_skill[BI_ISHEAVYSTUN])
+    {
+        if (borg_activate_artifact(ACT_CURE_WOUNDS, INVEN_WIELD) ||
+            borg_prayer(2, 7) ||
+            borg_prayer(3, 2) ||
+            borg_prayer(6, 1) ||
+            borg_prayer(6, 2))
+        {
+            /* Take note */
+            borg_note(format("# Cure Heavy Stun", p));
+
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure cuts */
+    if (borg_skill[BI_ISCUT] && (q < 75))
+    {
+        if (borg_activate_artifact(ACT_CURE_WOUNDS, INVEN_WIELD) ||
+            borg_prayer(2, 2) ||
+            borg_prayer(2, 7) ||
+            borg_prayer(3, 2) ||
+            borg_prayer(6, 0) ||
+            borg_prayer(6, 1) ||
+            borg_prayer(6, 2))
+        {
+            /* Take note */
+            borg_note(format("# Cure Cuts", p));
+
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure poison */
+    if (borg_skill[BI_ISPOISONED] && (q < 75))
+    {
+        if (borg_activate_artifact(ACT_REM_FEAR_POIS, INVEN_FEET) ||
+            borg_spell(1, 3) ||
+            borg_prayer(2, 0))
+        {
+            /* Take note */
+            borg_note(format("# Cure poison", p));
+
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure fear */
+    if (borg_skill[BI_ISAFRAID] && (q < 75))
+    {
+        if (borg_activate_artifact(ACT_REM_FEAR_POIS, INVEN_FEET) ||
+            borg_spell(7, 1) ||
+            borg_spell(7, 0) ||
+            borg_prayer(0, 3))
+        {
+            /* Take note */
+            borg_note(format("# Cure fear", p));
+
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- satisfy hunger */
+    if ((borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) && (q < 75))
+    {
+        if (borg_spell(2, 0) ||
+            borg_prayer(1, 5))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- heal damage */
+    if ((borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 2) && (q < 75) && p == 0 &&
+        (borg_skill[BI_CURSP] > borg_skill[BI_MAXSP] /4))
+    {
+        if (borg_activate_artifact(ACT_HEAL1, INVEN_BODY) ||
+            borg_prayer(3, 2) ||
+            borg_prayer(6, 2) ||
+            borg_prayer(2, 7) ||
+            borg_prayer(6, 1) )
+        {
+            /* Take note */
+            borg_note(format("# heal damage (recovering)"));
+
+            return (TRUE);
+        }
+    }
+
+    /* cure experience loss with prayer */
+    if (borg_skill[BI_ISFIXEXP] && (borg_activate_artifact(ACT_RESTORE_LIFE, INVEN_OUTER) ||
+            borg_prayer(6, 4)) )
+    {
+        return (TRUE);
+    }
+
+    /* cure stat drain with prayer */
+    if ((borg_skill[BI_ISFIXSTR] ||
+         borg_skill[BI_ISFIXINT] ||
+         borg_skill[BI_ISFIXWIS] ||
+         borg_skill[BI_ISFIXDEX] ||
+         borg_skill[BI_ISFIXCON] ||
+         borg_skill[BI_ISFIXCHR] ||
+         borg_skill[BI_ISFIXALL]) &&
+        borg_prayer(6, 3))
+        {
+            return (TRUE);
+        }
+
+    /*** Use "expensive" cures ***/
+
+    /* Hack -- cure stun */
+    if (borg_skill[BI_ISSTUN] && (q < 25))
+    {
+        if (borg_use_staff_fail(SV_STAFF_CURING) ||
+            borg_zap_rod(SV_ROD_CURING) ||
+            borg_zap_rod(SV_ROD_HEALING) ||
+            borg_activate_artifact(ACT_HEAL1, INVEN_BODY) ||
+            borg_activate_artifact(ACT_HEAL2, INVEN_HEAD) ||
+            borg_quaff_crit(FALSE))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure heavy stun */
+    if (borg_skill[BI_ISHEAVYSTUN] && (q < 95))
+    {
+        if (borg_quaff_crit(TRUE) ||
+            borg_use_staff_fail(SV_STAFF_CURING) ||
+            borg_zap_rod(SV_ROD_CURING) ||
+            borg_zap_rod(SV_ROD_HEALING) ||
+            borg_activate_artifact(ACT_HEAL1, INVEN_BODY) ||
+            borg_activate_artifact(ACT_HEAL2, INVEN_HEAD))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure cuts */
+    if (borg_skill[BI_ISCUT] && (q < 25))
+    {
+        if (borg_use_staff_fail(SV_STAFF_CURING) ||
+            borg_zap_rod(SV_ROD_CURING) ||
+            borg_zap_rod(SV_ROD_HEALING) ||
+            borg_activate_artifact(ACT_HEAL1, INVEN_BODY) ||
+            borg_activate_artifact(ACT_HEAL2, INVEN_HEAD) ||
+            borg_quaff_crit(borg_skill[BI_CURHP] < 10))
+        {
+                return (TRUE);
+        }
+    }
+
+    /* Hack -- cure poison */
+    if (borg_skill[BI_ISPOISONED] && (q < 25))
+    {
+        if (borg_quaff_potion(SV_POTION_CURE_POISON) ||
+            borg_quaff_potion(SV_POTION_SLOW_POISON) ||
+            borg_eat_food(SV_FOOD_WAYBREAD) ||
+            borg_eat_food(SV_FOOD_CURE_POISON) ||
+            borg_quaff_crit(borg_skill[BI_CURHP] < 10) ||
+            borg_use_staff_fail(SV_STAFF_CURING) ||
+            borg_zap_rod(SV_ROD_CURING) ||
+            borg_activate_artifact(ACT_REM_FEAR_POIS, INVEN_FEET))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure blindness */
+    if (borg_skill[BI_ISBLIND] && (q < 25))
+    {
+        if (borg_eat_food(SV_FOOD_CURE_BLINDNESS) ||
+            borg_quaff_potion(SV_POTION_CURE_LIGHT) ||
+            borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+            borg_quaff_crit(FALSE) ||
+            borg_use_staff_fail(SV_STAFF_CURING) ||
+            borg_zap_rod(SV_ROD_CURING))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure confusion */
+    if (borg_skill[BI_ISCONFUSED] && (q < 25))
+    {
+        if (borg_eat_food(SV_FOOD_CURE_CONFUSION) ||
+            borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+            borg_quaff_crit(FALSE) ||
+            borg_use_staff_fail(SV_STAFF_CURING) ||
+            borg_zap_rod(SV_ROD_CURING))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- cure fear */
+    if (borg_skill[BI_ISAFRAID] && (q < 25))
+    {
+        if (borg_eat_food(SV_FOOD_CURE_PARANOIA) ||
+            borg_quaff_potion(SV_POTION_BOLDNESS) ||
+            borg_quaff_potion(SV_POTION_HEROISM) ||
+            borg_quaff_potion(SV_POTION_BERSERK_STRENGTH) ||
+            borg_activate_artifact(ACT_REM_FEAR_POIS, INVEN_FEET))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- satisfy hunger */
+    if ((borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) && (q < 25))
+    {
+        if (borg_read_scroll(SV_SCROLL_SATISFY_HUNGER))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- heal damage */
+    if ((borg_skill[BI_CURHP] < borg_skill[BI_MAXHP] / 2) && (q < 25))
+    {
+        if (borg_zap_rod(SV_ROD_HEALING) ||
+            borg_quaff_potion(SV_POTION_CURE_SERIOUS) ||
+            borg_quaff_crit(FALSE) ||
+            borg_activate_artifact(ACT_CURE_WOUNDS, INVEN_WIELD))
+        {
+            return (TRUE);
+        }
+    }
+
+    /* If Fleeing, then do not rest */
+    if (goal_fleeing) return (FALSE);
+
+    /* If Scumming, then do not rest */
+    if (borg_lunal_mode) return (FALSE);
+
+    /* Hack -- Rest to recharge Rods of Healing or Recall*/
+    if (borg_has[374] || borg_has[354])
+    {
+        /* Step 1.  Recharge just 1 rod. */
+        if ((borg_has[374] && !borg_items[borg_slot(TV_ROD, SV_ROD_HEALING)].pval) ||
+            (borg_has[354] && !borg_items[borg_slot(TV_ROD, SV_ROD_RECALL)].pval))
+        {
+            /* Mages can cast the recharge spell */
+
+
+
+            /* Rest until at least one recharges */
+            if (!borg_skill[BI_ISWEAK] && !borg_skill[BI_ISCUT] && !borg_skill[BI_ISHUNGRY] && !borg_skill[BI_ISPOISONED] &&
+                borg_check_rest() && !borg_spell_okay(7,4))
+            {
+                /* Take note */
+                borg_note("# Resting to recharge a rod...");
+
+                /* Reset the Bouncing-borg Timer */
+                time_this_panel =0;
+
+                /* Rest until done */
+                borg_keypress('R');
+                borg_keypress('1');
+                borg_keypress('0');
+                borg_keypress('0');
+                borg_keypress('\n');
+
+                /* Done */
+                return (TRUE);
+            }
+        }
+    }
+
+    /*** Just Rest ***/
+
+    /* Hack -- rest until healed */
+    if ((borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE] ||
+         borg_skill[BI_ISAFRAID] || borg_skill[BI_ISSTUN] || borg_skill[BI_ISHEAVYSTUN] ||
+         (borg_skill[BI_CURHP] < borg_skill[BI_MAXHP]) ||
+         (borg_skill[BI_CURSP] < borg_skill[BI_MAXSP] * 6 / 10)) &&
+         (!borg_takes_cnt || !goal_recalling) &&
+         !scaryguy_on_level &&
+        (rand_int(100) < 90) && borg_check_rest())
+    {
+        /* XXX XXX XXX */
+        if (!borg_skill[BI_ISWEAK] && !borg_skill[BI_ISCUT] && !borg_skill[BI_ISHUNGRY] && !borg_skill[BI_ISPOISONED])
+        {
+            /* Take note */
+            borg_note(format("# Resting (danger %d)...", p));
+
+            /* Rest until done */
+            borg_keypress('R');
+            borg_keypress('&');
+            borg_keypress('\n');
+
+            /* Reset our panel clock */
+            time_this_panel =0;
+
+            /* Done */
+            return (TRUE);
+        }
+    }
+
+    /* Hack to recharge mana if a low level mage or priest */
+    if (borg_skill[BI_MAXSP] && borg_skill[BI_CLEVEL] < 25 &&
+        borg_skill[BI_CURSP] < (borg_skill[BI_MAXSP] * 5 / 10) &&
+        p == 0 && borg_no_rest_prep <= 1 && !borg_bless &&
+        !borg_hero && !borg_berserk)
+    {
+        if (!borg_skill[BI_ISWEAK] && !borg_skill[BI_ISCUT] &&
+            !borg_skill[BI_ISHUNGRY] && !borg_skill[BI_ISPOISONED] && borg_skill[BI_FOOD] > 2)
+        {
+            /* Take note */
+            borg_note(format("# Resting to gain Mana. (danger %d)...", p));
+
+            /* Rest until done */
+            borg_keypress('R');
+            borg_keypress('*');
+            borg_keypress('\n');
+
+            /* Done */
+            return (TRUE);
+        }
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Take one "step" towards the given location, return TRUE if possible
+ */
+static bool borg_play_step(int y2, int x2)
+{
+    borg_grid *ag;
+    borg_grid *ag2;
+
+    int dir, x, y, ox, oy, i;
+
+    int o_y=0, o_x=0, door_found = 0;
+
+    /* Breeder levels, close all doors */
+    if (breeder_level)
+    {
+        /* scan the adjacent grids */
+        for (ox = -1; ox <= 1; ox++)
+        {
+                for (oy = -1; oy <= 1; oy++)
+                {
+                    /* skip our own spot */
+                    if ((oy+c_y == c_y) && (ox+c_x == c_x)) continue;
+
+                    /* skip our orignal goal */
+                    if ((oy+c_y == y2) && (ox+c_x == x2)) continue;
+
+                    /* Acquire location */
+                    ag = &borg_grids[oy+c_y][ox+c_x];
+
+                    /* skip non open doors */
+                    if (ag->feat != FEAT_OPEN) continue;
+
+                    /* skip monster on door */
+                    if (ag->kill) continue;
+
+                    /* Skip repeatedly closed doors */
+                    if (track_door_num >= 255) continue;
+
+                    /* save this spot */
+                    o_y = oy;
+                    o_x = ox;
+                    door_found = 1;
+                }
+        }
+
+        /* Is there a door to close? */
+        if (door_found)
+        {
+            /* Get a direction, if possible */
+            dir = borg_goto_dir(c_y, c_x, c_y+o_y, c_x+o_x);
+
+            /* Obtain the destination */
+            x = c_x + ddx[dir];
+            y = c_y + ddy[dir];
+
+            /* Hack -- set goal */
+            g_x = x;
+            g_y = y;
+
+            /* Close */
+            borg_note("# Closing a door");
+            borg_keypress('c');
+            borg_keypress(I2D(dir));
+
+            /* Check for an existing flag */
+            for (i = 0; i < track_door_num; i++)
+            {
+                /* Stop if we already new about this door */
+                if ((track_door_x[i] == x) && (track_door_y[i] == y)) return (TRUE);
+            }
+
+            /* Track the newly closed door */
+            if (i == track_door_num && i < track_door_size)
+            {
+
+                borg_note("# Noting the closing of a door.");
+                track_door_num++;
+                track_door_x[i] = x;
+                track_door_y[i] = y;
+            }
+            return (TRUE);
+
+        }
+    }
+
+    /* Get a direction, if possible */
+    dir = borg_goto_dir(c_y, c_x, y2, x2);
+
+    /* We have arrived */
+    if (dir == 5) return (FALSE);
+
+    /* Obtain the destination */
+    x = c_x + ddx[dir];
+    y = c_y + ddy[dir];
+
+    /* Access the grid we are stepping on */
+    ag = &borg_grids[y][x];
+
+    /* Hack -- set goal */
+    g_x = x;
+    g_y = y;
+
+    /* Monsters -- Attack */
+    if (ag->kill)
+    {
+        borg_kill *kill = &borg_kills[ag->kill];
+
+        /* can't attack someone if afraid! */
+        if (borg_skill[BI_ISAFRAID])
+            return (FALSE);
+
+        /* Hack -- ignore Maggot until later.  */
+        if ((r_info[kill->r_idx].flags1 & RF1_UNIQUE) && borg_skill[BI_CDEPTH] ==0 &&
+            borg_skill[BI_CLEVEL] < 5)
+            return (FALSE);
+
+        /* Message */
+        borg_note(format("# Walking into a '%s' at (%d,%d)",
+                         r_name + r_info[kill->r_idx].name,
+                         kill->y, kill->x));
+
+        /* Walk into it */
+        if (my_no_alter)
+        {
+            borg_keypress(';');
+            my_no_alter = FALSE;
+        }
+        else
+        {
+            borg_keypress('+');
+        }
+        borg_keypress(I2D(dir));
+        return (TRUE);
+    }
+
+
+    /* Objects -- Take */
+    if (ag->take)
+    {
+        borg_take *take = &borg_takes[ag->take];
+
+        /*** Handle Chests ***/
+        /* The borg will cheat when it comes to chests.
+         * He does not have to but it makes him faster and
+         * it does not give him any information that a
+         * person would not know by looking at the trap.
+         * So there is no advantage to the borg.
+         */
+
+        if (strstr(k_name + k_info[take->k_idx].name, "chest") &&
+            !strstr(k_name + k_info[take->k_idx].name, "Ruined"))
+        {
+            object_type *o_ptr = &o_list[cave_o_idx[y2][x2]];
+
+            borg_take *take = &borg_takes[ag->take];
+
+            /* Cheat some game info for faster borg */
+            o_ptr = &o_list[cave_o_idx[y2][x2]];
+
+
+
+            /* Unknown, Search it */
+            if (!object_known_p(o_ptr) &&
+                chest_traps[o_ptr->pval])
+            {
+                borg_note(format("# Searching a '%s' at (%d,%d)",
+                         k_name + k_info[take->k_idx].name,
+                         take->y, take->x));
+
+                /* Walk onto it */
+                borg_keypress('0');
+                borg_keypress('5');
+                borg_keypress('s');
+                return (TRUE);
+            }
+
+            /* Traps. Disarm it w/ fail check */
+            if (o_ptr->pval >= 1 && object_known_p(o_ptr) &&
+                borg_skill[BI_DEV] - o_ptr->pval >= borg_chest_fail_tolerance )
+            {
+                borg_note(format("# Disarming a '%s' at (%d,%d)",
+                         k_name + k_info[take->k_idx].name,
+                         take->y, take->x));
+
+                /* Open it */
+                borg_keypress('D');
+                borg_keypress(I2D(dir));
+                return (TRUE);
+            }
+
+
+            /* No trap, or unknown trap that passed above checks - Open it */
+            if (o_ptr->pval < 0 || !object_known_p(o_ptr))
+            {
+                borg_note(format("# Opening a '%s' at (%d,%d)",
+                         k_name + k_info[take->k_idx].name,
+                         take->y, take->x));
+
+                /* Open it */
+                borg_keypress('o');
+                borg_keypress(I2D(dir));
+                return (TRUE);
+            }
+
+            /* Empty chest */
+            /* continue in routine and pick it up */
+        }
+
+        /*** Handle other takes ***/
+        /* Message */
+        borg_note(format("# Walking onto and deleting a '%s' at (%d,%d)",
+                         k_name + k_info[take->k_idx].name,
+                         take->y, take->x));
+
+		/* Delete the item from the list */
+		borg_delete_take(ag->take);
+
+        /* Walk onto it */
+        borg_keypress(I2D(dir));
+
+
+        return (TRUE);
+    }
+
+
+    /* Glyph of Warding */
+    if (ag->feat == FEAT_GLYPH)
+    {
+        /* Message */
+        borg_note(format("# Walking onto a glyph of warding."));
+
+        /* Walk onto it */
+        borg_keypress(I2D(dir));
+        return (TRUE);
+    }
+
+
+    /* Traps -- disarm -- */
+    if (borg_skill[BI_CURLITE] && !borg_skill[BI_ISBLIND] && !borg_skill[BI_ISCONFUSED] && !scaryguy_on_level &&
+        (ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL))
+    {
+
+        /* NOTE: If a scary guy is on the level, we allow the borg to run over the
+         * trap in order to escape this level.
+         */
+
+        /* allow "destroy doors" */
+        if (borg_prayer(7, 0))
+        {
+            borg_note("# Unbarring ways");
+            return (TRUE);
+        }
+
+        /* Disarm */
+        borg_note("# Disarming a trap");
+        borg_keypress('D');
+        borg_keypress(I2D(dir));
+
+        /* We are not sure if the trap will get 'untrapped'. pretend it will*/
+        ag->feat = FEAT_NONE;
+        return (TRUE);
+    }
+
+
+    /* Closed Doors -- Open */
+    if ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_DOOR_HEAD + 0x07))
+    {
+        /* Paranoia XXX XXX XXX */
+        if (!rand_int(100)) return (FALSE);
+
+        /* Not a good idea to open locked doors if a monster
+         * is next to the borg beating on him
+         */
+
+        /* scan the adjacent grids */
+        for (i = 0; i < 8; i++)
+        {
+            /* Grid in that direction */
+            x = c_x + ddx_ddd[i];
+            y = c_y + ddy_ddd[i];
+
+            /* Access the grid */
+            ag2 = &borg_grids[y][x];
+
+            /* If monster adjacent to me and I'm weak, dont
+             * even try to open the door
+             */
+            if (ag2->kill && borg_skill[BI_CLEVEL] < 15) return (FALSE);
+        }
+
+        /* Open */
+        if (my_need_alter)
+        {
+            borg_keypress('+');
+            my_need_alter = FALSE;
+        }
+        else
+        {
+            borg_note("# Opening a door");
+            borg_keypress('0');
+            borg_keypress('9');
+            borg_keypress('o');
+        }
+        borg_keypress(I2D(dir));
+
+        /* Remove this closed door from the list.
+         * Its faster to clear all doors from the list
+         * then rebuild the list.
+         */
+        if (track_closed_num)
+        {
+			track_closed_num = 0;
+		}
+
+        return (TRUE);
+    }
+
+
+
+    /* Jammed Doors -- Bash or destroy */
+    if ((ag->feat >= FEAT_DOOR_HEAD + 0x08) && (ag->feat <= FEAT_DOOR_TAIL))
+    {
+        /* Paranoia XXX XXX XXX */
+        if (!rand_int(100)) return (FALSE);
+
+        /* Not if hungry */
+        if (borg_skill[BI_ISWEAK]) return (FALSE);
+
+        /* Mega-Hack -- allow "destroy doors" */
+        if (borg_prayer(7, 0))
+        {
+            borg_note("# Unbarring ways");
+            return (TRUE);
+        }
+
+        /* Mega-Hack -- allow "destroy doors" */
+        if (borg_spell(1, 2))
+        {
+            borg_note("# Destroying doors");
+            return (TRUE);
+        }
+
+        /* Mega-Hack -- allow "stone to mud" */
+        if (borg_spell(2, 2))
+        {
+            borg_note("# Melting a door");
+            borg_keypress(I2D(dir));
+
+	        /* Remove this closed door from the list.
+	         * Its faster to clear all doors from the list
+	         * then rebuild the list.
+	         */
+	        if (track_closed_num)
+	        {
+				track_closed_num = 0;
+			}
+            return (TRUE);
+        }
+
+        /* Bash */
+        borg_note("# Bashing a door");
+        borg_keypress('B');
+        borg_keypress(I2D(dir));
+
+        /* Remove this closed door from the list.
+         * Its faster to clear all doors from the list
+         * then rebuild the list.
+         */
+        if (track_closed_num)
+        {
+			track_closed_num = 0;
+		}
+        return (TRUE);
+    }
+
+    /* Rubble, Treasure, Seams, Walls -- Tunnel or Melt */
+    if (ag->feat >= FEAT_SECRET)
+    {
+
+        /* Mega-Hack -- prevent infinite loops */
+        if (rand_int(100) < 10) return (FALSE);
+
+        /* Not if hungry */
+        if (borg_skill[BI_ISWEAK]) return (FALSE);
+
+        /* Mega-Hack -- allow "stone to mud" */
+        if (borg_spell(2, 2))
+        {
+            borg_note("# Melting a wall/etc");
+            borg_keypress(I2D(dir));
+            return (TRUE);
+        }
+
+        /* No tunneling if in danger */
+        if (borg_danger(c_y,c_x,1, TRUE) >= borg_skill[BI_CURHP] /4) return (FALSE);
+
+        /* Tunnel */
+        /* If I have a shovel then use it */
+        if (borg_items[weapon_swap].tval == TV_DIGGING &&
+            !(borg_items[INVEN_WIELD].cursed))
+        {
+            borg_note("# Swapping Digger");
+            borg_keypress(ESCAPE);
+            borg_keypress('w');
+            borg_keypress(I2A(weapon_swap));
+            borg_keypress(' ');
+            borg_keypress(' ');
+        }
+        borg_note("# Digging through wall/etc");
+        borg_keypress('0');
+        borg_keypress('9');
+        borg_keypress('9');
+        /* Some borgs will dig more */
+        if (borg_worships_gold)
+        {
+            borg_keypress('9');
+        }
+
+        borg_keypress('T');
+        borg_keypress(I2D(dir));
+        return (TRUE);
+    }
+
+
+    /* Shops -- Enter */
+    if ((ag->feat >= FEAT_SHOP_HEAD) && (ag->feat <= FEAT_SHOP_TAIL))
+    {
+        /* Message */
+        borg_note(format("# Entering a '%d' shop", (ag->feat - FEAT_SHOP_HEAD) + 1));
+
+        /* Enter the shop */
+        borg_keypress(I2D(dir));
+        return (TRUE);
+    }
+
+
+    /* Perhaps the borg could search for traps as he walks around level one. */
+    if (borg_skill[BI_MAXCLEVEL] <= 5 && borg_skill[BI_CDEPTH] &&
+        !borg_skill[BI_ISSEARCHING] && borg_needs_searching == TRUE &&
+        !borg_no_retreat && !scaryguy_on_level &&
+        borg_skill[BI_CURLITE] != 0 && !borg_skill[BI_ISHUNGRY] && !borg_skill[BI_ISWEAK] && borg_skill[BI_FOOD] > 2)
+    {
+		borg_note("# Borg searching-walking engaged.");
+        borg_keypress('S');
+    }
+
+    /* Turn off the searching if needed */
+    if (!borg_needs_searching && borg_skill[BI_ISSEARCHING])
+    {
+		borg_note("# Disengage the searching-walking.");
+        borg_keypress('S');
+        borg_skill[BI_ISSEARCHING] = FALSE;
+    }
+
+    /* Walk in that direction */
+    if (my_need_alter)
+    {
+        borg_keypress('+');
+        my_need_alter = FALSE;
+    }
+    else
+    {
+        /* nothing */
+    }
+
+	/* Note if Borg is searching */
+	if (borg_skill[BI_ISSEARCHING]) borg_note("# Borg is searching while walking.");
+
+    borg_keypress(I2D(dir));
+
+    /* Stand stairs up */
+    if (goal_less)
+    {
+        /* Up stairs */
+        if (ag->feat == FEAT_LESS)
+        {
+            /* Stand on stairs */
+            borg_on_upstairs = TRUE;
+            goal_less = FALSE;
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+
+
+    /* Did something */
+    return (TRUE);
+}
+
+
+
+
+/*
+ * Act twitchy
+ */
+bool borg_twitchy(void)
+{
+    int dir;
+
+    /* This is a bad thing */
+    borg_note("# Twitchy!");
+
+    /* try to phase out of it */
+    if (borg_caution_phase(15, 2) &&
+       (borg_spell_fail(0, 2, 40) ||
+        borg_prayer_fail(4, 0, 40) ||
+        borg_activate_artifact(ACT_PHASE, INVEN_BODY)||
+        borg_activate_artifact(ACT_TELEPORT,INVEN_OUTER) ||
+        borg_read_scroll(SV_SCROLL_PHASE_DOOR) ))
+    {
+        /* We did something */
+        return (TRUE);
+    }
+    /* Pick a random direction */
+    dir = randint(9);
+
+    /* Hack -- set goal */
+    g_x = c_x + ddx[dir];
+    g_y = c_y + ddy[dir];
+
+    /* Maybe alter */
+    if (rand_int(100) < 10 && dir != 5)
+    {
+        /* Send action (alter) */
+        borg_keypress('+');
+
+        /* Send direction */
+        borg_keypress(I2D(dir));
+    }
+
+    /* Normally move */
+    else
+    {
+        /* Send direction */
+        borg_keypress(I2D(dir));
+    }
+
+    /* We did something */
+    return (TRUE);
+}
+
+
+
+
+
+/*
+ * Commit the current "flow"
+ */
+static bool borg_flow_commit(cptr who, int why)
+{
+    int cost;
+
+    /* Cost of current grid */
+    cost = borg_data_cost->data[c_y][c_x];
+
+    /* Verify the total "cost" */
+    if (cost >= 250) return (FALSE);
+
+    /* Message */
+    if (who) borg_note(format("# Flowing toward %s at cost %d", who, cost));
+
+    /* Obtain the "flow" information */
+    COPY(borg_data_flow, borg_data_cost, borg_data);
+
+    /* Save the goal type */
+    goal = why;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+
+
+/*
+ * Attempt to take an optimal step towards the current goal location
+ *
+ * Note that the "borg_update()" routine notices new monsters and objects,
+ * and movement of monsters and objects, and cancels any flow in progress.
+ *
+ * Note that the "borg_update()" routine notices when a grid which was
+ * not thought to block motion is discovered to in fact be a grid which
+ * blocks motion, and removes that grid from any flow in progress.
+ *
+ * When given multiple alternative steps, this function attempts to choose
+ * the "safest" path, by penalizing grids containing embedded gold, monsters,
+ * rubble, doors, traps, store doors, and even floors.  This allows the Borg
+ * to "step around" dangerous grids, even if this means extending the path by
+ * a step or two, and encourages him to prefer grids such as objects and stairs
+ * which are not only interesting but which are known not to be invisible traps.
+ *
+ * XXX XXX XXX XXX This function needs some work.  It should attempt to
+ * analyze the "local region" around the player and determine the optimal
+ * choice of locations based on some useful computations.
+ *
+ * If it works, return TRUE, otherwise, cancel the goal and return FALSE.
+ */
+bool borg_flow_old(int why)
+{
+    int x, y;
+
+    borg_grid *ag;
+
+
+    /* Continue */
+    if (goal == why)
+    {
+        int b_n = 0;
+
+        int i, b_i = -1;
+
+        int c, b_c;
+
+
+        /* Flow cost of current grid */
+        b_c = borg_data_flow->data[c_y][c_x] * 10;
+
+        /* Prevent loops */
+        b_c = b_c - 5;
+
+
+        /* Look around */
+        for (i = 0; i < 8; i++)
+        {
+            /* Grid in that direction */
+            x = c_x + ddx_ddd[i];
+            y = c_y + ddy_ddd[i];
+
+            /* Access the grid */
+            ag = &borg_grids[y][x];
+
+            /* Flow cost at that grid */
+            c = borg_data_flow->data[y][x] * 10;
+
+            /* Never backtrack */
+            if (c > b_c) continue;
+
+            /* avoid screen edgeds */
+            if (x > AUTO_MAX_X-1 ||
+                x < 1 ||
+                y > AUTO_MAX_Y-1 ||
+                y < 1)
+                continue;
+
+
+            /* Notice new best value */
+            if (c < b_c) b_n = 0;
+
+            /* Apply the randomizer to equivalent values */
+            if ((++b_n >= 2) && (rand_int(b_n) != 0)) continue;
+
+            /* Track it */
+            b_i = i; b_c = c;
+        }
+
+        /* Try it */
+        if (b_i >= 0)
+        {
+            /* Access the location */
+            x = c_x + ddx_ddd[b_i];
+            y = c_y + ddy_ddd[b_i];
+
+            /* Attempt motion */
+            if (borg_play_step(y, x)) return (TRUE);
+        }
+
+        /* Cancel goal */
+        goal = 0;
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+
+
+
+/*
+ * Prepare to flee the level via stairs
+ */
+bool borg_flow_stair_both(int why)
+{
+    int i;
+
+    /* None to flow to */
+    if (!track_less_num && !track_more_num) return (FALSE);
+
+
+    /* dont go down if hungry or low on food, unless fleeing a scary town */
+    if (!goal_fleeing && !scaryguy_on_level &&
+        (borg_skill[BI_ISWEAK] ||
+         borg_skill[BI_ISHUNGRY] || borg_skill[BI_FOOD] < 2))
+        return (FALSE);
+
+	/* Absolutely no diving if no light */
+	if (borg_skill[BI_CURLITE] ==0 && borg_skill[BI_CDEPTH] != 0) return (FALSE);
+
+    /* clear the possible searching flag */
+    borg_needs_searching = FALSE;
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue useful grids */
+    for (i = 0; i < track_less_num; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(track_less_y[i], track_less_x[i]);
+    }
+
+    /* Enqueue useful grids */
+    for (i = 0; i < track_more_num; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(track_more_y[i], track_more_x[i]);
+    }
+
+
+    /* Spread the flow */
+    borg_flow_spread(250, TRUE, FALSE, FALSE);
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("stairs", why)) return (FALSE);
+
+
+    /* Take one step */
+    if (!borg_flow_old(why)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+
+/*
+ * Prepare to flow towards "up" stairs
+ */
+bool borg_flow_stair_less(int why)
+{
+    int i;
+
+    /* None to flow to */
+    if (!track_less_num) return (FALSE);
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* clear the possible searching flag */
+    borg_needs_searching = FALSE;
+
+    /* Enqueue useful grids */
+    for (i = 0; i < track_less_num; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(track_less_y[i], track_less_x[i]);
+    }
+
+    if (borg_skill[BI_CLEVEL] > 35 || borg_skill[BI_CURLITE] == 0)
+    {
+        /* Spread the flow */
+        borg_flow_spread(250, TRUE, FALSE, FALSE);
+    }
+    else
+    {
+        /* Spread the flow, No Optimize, Avoid */
+        borg_flow_spread(250, FALSE, !borg_desperate, FALSE);
+    }
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("up-stairs", why)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(why)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to flow towards "down" stairs
+ */
+bool borg_flow_stair_more(int why)
+{
+    int i;
+
+    /* None to flow to */
+    if (!track_more_num) return (FALSE);
+
+    /* not unless safe or Lunal Mode */
+    if (!borg_lunal_mode && (cptr)NULL != borg_prepared(borg_skill[BI_CDEPTH] + 1))
+        return (FALSE);
+
+    /* dont go down if hungry or low on food, unless fleeing a scary town */
+    if (borg_skill[BI_CDEPTH] && !scaryguy_on_level &&
+       (borg_skill[BI_ISWEAK] || borg_skill[BI_ISHUNGRY] ||
+        borg_skill[BI_FOOD] < 2))
+        return (FALSE);
+
+    /* No diving if no light */
+    if (borg_skill[BI_CURLITE] == 0) return (FALSE);
+
+    /* don't head for the stairs if you are recalling,  */
+    /* even if you are fleeing. */
+    if (goal_recalling)
+        return (FALSE);
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue useful grids */
+    for (i = 0; i < track_more_num; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(track_more_y[i], track_more_x[i]);
+    }
+
+    /* Spread the flow */
+    borg_flow_spread(250, TRUE, FALSE, FALSE);
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("down-stairs", why)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(why)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Hack -- Glyph creating
+ */
+
+static byte glyph_x;
+static byte glyph_y;
+static byte glyph_y_center = 0;
+static byte glyph_x_center = 0;
+
+/*
+ * Prepare to flow towards a special glyph of warding pattern
+ *
+ * The borg will look for a room that is at least 7x7.
+ * ##########
+ * #3.......#
+ * #2.xxxxx.#
+ * #1.xxxxx.#
+ * #0.xx@xx.#
+ * #1.xxxxx.#
+ * #2.xxxxx.#
+ * #3.......#
+ * # 3210123#
+ * ##########
+ * and when he locates one, he will attempt to:
+ * 1. flow to a central location and
+ * 2. begin planting Runes in a pattern. When complete,
+ * 3. move to the center of it.
+ */
+/*
+ * ghijk  The borg will use the following ddx and ddy to search
+ * d827a  for a suitable grid in an open room.
+ * e4@3b
+ * f615c
+ * lmnop  24 grids
+ *
+ */
+bool borg_flow_glyph(int why)
+{
+    int i;
+    int cost;
+
+    int x, y;
+    int v = 0;
+
+    int b_x = c_x;
+    int b_y = c_y;
+    int b_v = -1;
+	int goal_glyph = 0;
+	int glyph = 0;
+
+    borg_grid *ag;
+
+    if ((glyph_y_center == 0 && glyph_x_center == 0) ||
+         distance (c_y, c_x, glyph_y_center, glyph_x_center) >= 35)
+    {
+		borg_needs_new_sea = TRUE;
+	}
+
+    /* We have arrived */
+    if ((glyph_x == c_x) && (glyph_y == c_y))
+    {
+        /* Cancel */
+        glyph_x = 0;
+        glyph_y = 0;
+
+			/* Store the center of the glyphs */
+		if (borg_needs_new_sea)
+		{
+			glyph_y_center = c_y;
+			glyph_x_center = c_x;
+		}
+		borg_needs_new_sea = FALSE;
+
+        /* Take note */
+        borg_note(format("# Glyph Creating at (%d,%d)", c_x, c_y));
+
+        if (borg_prayer_fail(3, 4, 30) ||
+        	borg_spell_fail(6, 4, 30) ||
+            borg_read_scroll(SV_SCROLL_RUNE_OF_PROTECTION))
+        {
+            /* Check for an existing glyph */
+            for (i = 0; i < track_glyph_num; i++)
+            {
+                /* Stop if we already new about this glyph */
+                if ((track_glyph_x[i] == c_x) && (track_glyph_y[i] == c_y)) return (p1-p2);
+            }
+
+            /* Track the newly discovered glyph */
+            if ((i == track_glyph_num) && (track_glyph_size))
+            {
+                borg_note("# Noting the creation of a glyph.");
+                track_glyph_num++;
+                track_glyph_x[i] = c_x;
+                track_glyph_y[i] = c_y;
+            }
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Reverse flow */
+    borg_flow_reverse();
+
+    /* Scan the entire map */
+    for (y = 15; y < AUTO_MAX_Y-15; y++)
+    {
+        for (x = 50; x < AUTO_MAX_X-50; x++)
+        {
+            borg_grid *ag_ptr[24];
+
+            int floor = 0;
+            int glyph = 0;
+
+
+            /* Acquire the grid */
+            ag = &borg_grids[y][x];
+
+            /* Skip every non floor/glyph */
+            if (ag->feat != FEAT_FLOOR &&
+                ag->feat != FEAT_GLYPH) continue;
+
+            /* Acquire the cost */
+            cost = borg_data_cost->data[y][x];
+
+            /* Skip grids that are really far away.  He probably
+             * won't be able to safely get there
+             */
+            if (cost >= 50) continue;
+
+            /* Extract adjacent locations to each considered grid */
+            for (i = 0; i < 24; i++)
+            {
+                /* Extract the location */
+                int xx = x + borg_ddx_ddd[i];
+                int yy = y + borg_ddy_ddd[i];
+
+                /* Get the grid contents */
+                ag_ptr[i] = &borg_grids[yy][xx];
+            }
+
+            /* Center Grid */
+            if (borg_needs_new_sea)
+            {
+				goal_glyph = 24;
+
+	            /* Count Adjacent Flooors */
+	            for (i = 0; i < 24; i++)
+	            {
+	                ag = ag_ptr[i];
+	                if (ag->feat == FEAT_FLOOR ||
+	                    ag->feat == FEAT_GLYPH) floor++;
+	            }
+
+            	/* Not a good location if not the center of the sea */
+            	if (floor != 24)
+            	{
+					continue;
+				}
+
+	            /* Count floors already glyphed */
+	            for (i = 0; i < 24; i++)
+	            {
+	                ag = ag_ptr[i];
+
+	                /* Glyphs */
+	                if (ag->feat == FEAT_GLYPH)
+	                {
+	                    glyph++;
+	                }
+	            }
+
+	            /* Tweak -- Reward certain floors, punish distance */
+	            v = 100 + (glyph * 500) - (cost * 1);
+				if (borg_grids[y][x].feat == FEAT_FLOOR) v += 3000;
+
+				/* If this grid is surrounded by glyphs, select it */
+				if (glyph == goal_glyph) v += 5000;
+
+				/* If this grid is already glyphed but not
+				 * surrounded by glyphs, then choose another.
+				 */
+				if (glyph != goal_glyph && borg_grids[y][x].feat == FEAT_GLYPH)
+				v = -1;
+
+	            /* The grid is not searchable */
+	            if (v <= 0) continue;
+
+	            /* Track "best" grid */
+	            if ((b_v >= 0) && (v < b_v)) continue;
+
+	            /* Save the data */
+	            b_v = v; b_x = x; b_y = y;
+			}
+			/* old center, making outlying glyphs, */
+			else
+            {
+ 			    /* Count Adjacent Flooors */
+	            for (i = 0; i < 24; i++)
+	            {
+					/* Leave if this grid is not in good array */
+					if (glyph_x_center + borg_ddx_ddd[i] != x) continue;
+					if (glyph_y_center + borg_ddy_ddd[i] != y) continue;
+
+	                /* Already got a glyph on it */
+	                if (borg_grids[y][x].feat == FEAT_GLYPH) continue;
+
+		            /* Tweak -- Reward certain floors, punish distance */
+		            v = 500 + (glyph * 500) - (cost * 1);
+
+		            /* The grid is not searchable */
+		            if (v <= 0) continue;
+
+		            /* Track "best" grid */
+		            if ((b_v >= 0) && (v < b_v)) continue;
+
+		            /* Save the data */
+		            b_v = v; b_x = x; b_y = y;
+				}
+	        }
+		}
+    }
+
+    /* Extract adjacent locations to each considered grid */
+	if (glyph_y_center != 0 &&
+	    glyph_x_center != 0)
+	{
+
+    	for (i = 0; i < 24; i++)
+    	{
+    	    /* Extract the location */
+    	    int xx = glyph_x_center + borg_ddx_ddd[i];
+    	    int yy = glyph_y_center + borg_ddy_ddd[i];
+
+    	    borg_grid *ag_ptr[24];
+
+    		/* Get the grid contents */
+    	    ag_ptr[i] = &borg_grids[yy][xx];
+    	    ag = ag_ptr[i];
+
+			/* If it is not a glyph, skip it */
+    	    if (ag->feat == FEAT_GLYPH) glyph++;
+
+    	    /* Save the data */
+    	    if (glyph == 24)
+    	    {
+    	    	b_v = 5000; b_x = glyph_x_center; b_y = glyph_y_center;
+			}
+		}
+	}
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Hack -- Nothing found */
+    if (b_v < 0) return (FALSE);
+
+
+    /* Access grid */
+    ag = &borg_grids[b_y][b_x];
+
+    /* Memorize */
+    glyph_x = b_x;
+    glyph_y = b_y;
+
+    /* Enqueue the grid */
+    borg_flow_enqueue_grid(b_y, b_x);
+
+    /* Spread the flow */
+    borg_flow_spread(250, TRUE, FALSE, FALSE);
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("Glyph", GOAL_MISC)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_MISC)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to flow towards light
+ */
+bool borg_flow_light(int why)
+{
+    int y,x,i;
+
+
+    /* reset counters */
+    borg_glow_n = 0;
+    i=0;
+
+    /* build the glow array */
+    /* Scan map */
+    for (y = w_y; y < w_y + SCREEN_HGT; y++)
+    {
+        for (x = w_x; x < w_x + SCREEN_WID; x++)
+        {
+            borg_grid *ag = &borg_grids[y][x];
+
+            /* Not a perma-lit, and not our spot. */
+            if (!(ag->info & BORG_GLOW)) continue;
+
+            /* keep count */
+            borg_glow_y[borg_glow_n] = y;
+            borg_glow_x[borg_glow_n] = x;
+            borg_glow_n++;
+
+        }
+     }
+    /* None to flow to */
+    if (!borg_glow_n) return (FALSE);
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue useful grids */
+    for (i = 0; i < borg_glow_n; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(borg_glow_y[i], borg_glow_x[i]);
+    }
+
+    /* Spread the flow */
+    borg_flow_spread(250, TRUE, FALSE, FALSE);
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("a lighted area", why)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(why)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Prepare to "flow" towards any non-visited shop
+ */
+bool borg_flow_shop_visit(void)
+{
+    int i, x, y;
+
+    /* Must be in town */
+    if (borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Visit the shops */
+    for (i = 0; i < MAX_STORES; i++)
+    {
+		/* If low Level skip certain buildings in town
+		 * in order to reduce time spent in town.
+		 */
+		if (borg_skill[BI_CLEVEL] <= 10)
+		{
+			/* Skip Magic Shop unless Mage */
+			if (i == 5 &&
+			    (borg_class != CLASS_MAGE))
+			{
+				borg_shops[i].when = borg_t;
+				continue;
+			}
+
+			/* Skip Black Market */
+			if (i == 6)
+			{
+				borg_shops[i].when = borg_t;
+				continue;
+			}
+
+			/* Skip Home */
+			if (i == 7)
+			{
+				borg_shops[i].when = borg_t;
+				continue;
+			}
+
+		}
+
+        /* Must not be visited */
+        if (borg_shops[i].when) continue;
+
+        /* if poisoned or bleeding skip non temples */
+        if ( (borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) &&
+             (i != 3 && i !=7) ) continue;
+
+        /* if starving--skip non food places */
+        if (borg_skill[BI_FOOD] == 0 &&
+             (i != 0 && i !=7) ) continue;
+
+        /* if dark--skip non food places */
+        if ( borg_skill[BI_CURLITE] == 0 && (i != 0 ) && borg_skill[BI_CLEVEL] >= 2) continue;
+
+        /* if only torch-- go directly to Gen Store --Get a Lantern */
+        if ( borg_skill[BI_CURLITE] == 1 && i != 0 &&
+             !borg_shops[0].when && borg_gold >= 75) continue;
+
+        /* Obtain the location */
+        x = track_shop_x[i];
+        y = track_shop_y[i];
+
+        /* Hack -- Must be known and not under the player */
+        if (!x || !y || ((c_x == x) && (c_y == y))) continue;
+
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(y, x);
+    }
+
+    /* Spread the flow */
+    borg_flow_spread(250, TRUE, FALSE, FALSE);
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("shops", GOAL_MISC)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_MISC)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to "flow" towards a specific shop entry
+ */
+bool borg_flow_shop_entry(int i)
+{
+    int x, y;
+
+    cptr name = (f_name + f_info[0x08+i].name);
+
+    /* Must be in town */
+    if (borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Obtain the location */
+    x = track_shop_x[i];
+    y = track_shop_y[i];
+
+    /* Hack -- Must be known */
+    if (!x || !y) return (FALSE);
+
+    /* Hack -- re-enter a shop if needed */
+    if ((x == c_x) && (y == c_y))
+    {
+        /* Note */
+        borg_note("# Re-entering a shop");
+
+        /* Enter the store */
+        borg_keypress('5');
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue the grid */
+    borg_flow_enqueue_grid(y, x);
+
+    /* Spread the flow */
+    borg_flow_spread(250, TRUE, FALSE, FALSE);
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit(name, GOAL_MISC)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_MISC)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * The borg can take a shot from a distance
+ *
+ */
+static bool borg_has_distance_attack( void )
+{
+    int rad;
+    int dam;
+
+    borg_simulate = TRUE;
+
+    /* XXX For now only line up Magic Missle shots */
+    rad  = 0;
+    dam = (3+((borg_skill[BI_CLEVEL])/4))*(4+1)/2;
+    if (borg_attack_aux_spell_bolt(0, 0, rad, dam, GF_MISSILE) > 0)
+        return TRUE;
+
+    return FALSE;
+}
+
+
+/*
+ * Take a couple of steps to line up a shot
+ *
+ */
+bool borg_flow_kill_aim(bool viewable)
+{
+    int o_y, o_x;
+    int s_c_y = c_y;
+    int s_c_x = c_x;
+    int i;
+
+    /* Efficiency -- Nothing to kill */
+    if (!borg_kills_cnt) return (FALSE);
+
+    /* Sometimes we loop on this if we back  up to a point where */
+    /* the monster is out of site */
+    if (time_this_panel > 500) return (FALSE);
+
+	/* Not if hungry */
+	if (borg_skill[BI_ISHUNGRY]) return (FALSE);
+
+    /* If you can shoot from where you are, don't bother reaiming */
+    if (borg_has_distance_attack()) return (FALSE);
+
+    /* Consider each adjacent spot */
+    for (o_x = -2; o_x <= 2; o_x++)
+    {
+        for (o_y = -2; o_y <= 2; o_y++)
+        {
+            /* borg_attack would have already checked
+               for a shot from where I currently am */
+            if (o_x == 0 && o_y == 0)
+                continue;
+
+            /* XXX  Mess with where the program thinks the
+               player is */
+            c_x = s_c_x + o_x;
+            c_y = s_c_y + o_y;
+
+            /* avoid screen edgeds */
+            if (c_x > AUTO_MAX_X-2 ||
+                c_x < 2 ||
+                c_y > AUTO_MAX_Y-2 ||
+                c_y < 2)
+                continue;
+
+            /* Make sure we do not end up next to a monster */
+            for (i = 0; i < borg_kills_nxt; i++)
+            {
+                if (distance(c_y, c_x,
+                    borg_kills[i].y, borg_kills[i].x) == 1)
+                    break;
+            }
+            if (i != borg_kills_nxt)
+                continue;
+
+            /* Check for a distance attack from here */
+            if (borg_has_distance_attack())
+            {
+                /* Clear the flow codes */
+                borg_flow_clear();
+
+                /* Enqueue the grid */
+                borg_flow_enqueue_grid(c_y, c_x);
+
+                /* restore the saved player position */
+                c_x = s_c_x;
+                c_y = s_c_y;
+
+                /* Spread the flow */
+                borg_flow_spread(5, TRUE, !viewable, FALSE);
+
+                /* Attempt to Commit the flow */
+                if (!borg_flow_commit("targetable position", GOAL_KILL)) return (FALSE);
+
+                /* Take one step */
+                if (!borg_flow_old(GOAL_KILL)) return (FALSE);
+
+                return (TRUE);
+            }
+        }
+    }
+
+    /* restore the saved player position */
+    c_x = s_c_x;
+    c_y = s_c_y;
+
+    return FALSE;
+}
+
+/*
+ * Dig an anti-summon corridor
+ *
+ *            ############## We want the borg to not dig #1
+ *            #............# but to dig #2, and hopefully shoot from the
+ *      #######............# last #2 and try to avoid standing on #3.
+ *      #222223............# This is great for offset ball attacks but
+ *      #2#####..s.........# not for melee.  Warriors need to dig a wall
+ * ######2###########+###### adjacent to the monsters so he can swing on them.
+ * #            1     #
+ * # ################ #
+ *   #              # #
+ * ###              # #
+ *
+ */
+bool borg_flow_kill_corridor(bool viewable)
+{
+    int o_y, o_x;
+    int m_x, m_y;
+    int f_y,f_x;
+    int floors = 0;
+    int b_y = 0, b_x = 0;
+    int perma_grids = 0;
+
+    borg_kill *kill;
+
+    /* Efficiency -- Nothing to kill */
+    if (!borg_kills_cnt) return (FALSE);
+
+    /* Only do this to summoners when they are close*/
+    if (borg_kills_summoner == -1) return (FALSE);
+
+    /* Do not dig when weak. It takes too long */
+    if (borg_skill[BI_STR] < 17) return (FALSE);
+
+    /* Sometimes we loop on this */
+    if (time_this_panel > 500) return (FALSE);
+
+    /* Do not dig when confused */
+    if (borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+    /* Not when darkened */
+    if (borg_skill[BI_CURLITE] == 0) return (FALSE);
+
+    /* get the summoning monster */
+    kill = &borg_kills[borg_kills_summoner];
+
+    /* Consider each adjacent spot to monster*/
+    for (o_x = -1; o_x <= 1; o_x++)
+    {
+        for (o_y = -1; o_y <= 1; o_y++)
+        {
+            borg_grid *ag ;
+
+            /* Check grids near monster */
+            m_x = kill->x + o_x;
+            m_y = kill->y + o_y;
+
+            /* grid the grid */
+            ag = &borg_grids[m_y][m_x];
+
+            /* avoid screen edgeds */
+            if (m_x > AUTO_MAX_X-2 ||
+                m_x < 2 ||
+                m_y > AUTO_MAX_Y-2 ||
+                m_y < 2)
+                continue;
+
+            /* Can't tunnel a non wall or permawall*/
+            if (ag->feat != FEAT_NONE && ag->feat < FEAT_MAGMA) continue;
+            if (ag->feat >= FEAT_PERM_EXTRA)
+            {
+                perma_grids ++;
+                continue;
+            }
+
+            /* Do not dig unless we appear strong enough to succeed or we have a digger */
+            if (borg_spell_legal(2, 2) ||
+                borg_skill[BI_DIG] > (borg_skill[BI_CDEPTH] > 80 ? 30:40))
+            {
+               /* digging ought to work */
+            }
+            else
+            {
+                /* do not try digging */
+                 continue;
+            }
+
+            /* reset floors counter */
+            floors = 0;
+
+            /* That grid must not have too many floors adjacent */
+            for (f_x = -1; f_x <= 1; f_x++)
+            {
+                for (f_y = -1; f_y <= 1; f_y++)
+                {
+                    /* grid the grid */
+                    ag = &borg_grids[m_y+f_y][m_x+f_x];
+
+                    /* check if this neighbor is a floor */
+                    if (ag->feat == FEAT_FLOOR ||
+                        ag->feat == FEAT_BROKEN) floors ++;
+                }
+            }
+
+            /* Do not dig if too many floors near. */
+            if (floors >=5) continue;
+
+            /* Track the good location */
+            b_y = m_y;
+            b_x = m_x;
+        }
+    }
+    /* NOTE: Perma_grids count the number of grids which contain permawalls.
+     * The borg may try to flow to an unknown grid but may get stuck on a perma
+     * wall.  This will keep him from flowing to a summoner if the summoner is
+     * near a perma grid.  The real fix would to be in the flow_spread so that
+     * he will not flow through perma_grids.  I will work on that next.
+     */
+    if (b_y !=0 && b_x !=0 && perma_grids == 0)
+    {
+        /* Clear the flow codes */
+        borg_flow_clear();
+
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(m_y, m_x);
+
+        /* Spread the flow */
+        borg_flow_spread(15, TRUE, FALSE, TRUE);
+
+        /* Attempt to Commit the flow */
+        if (!borg_flow_commit("anti-summon corridor", GOAL_KILL)) return (FALSE);
+
+        /* Take one step */
+        if (!borg_flow_old(GOAL_KILL)) return (FALSE);
+
+        return (TRUE);
+    }
+
+    return FALSE;
+}
+
+
+
+/*
+ * Prepare to "flow" towards monsters to "kill"
+ * But in a few phases, viewable, near and far.
+ * Note that monsters under the player are always deleted
+ */
+bool borg_flow_kill(bool viewable, int nearness)
+{
+    int i, x, y, p, j,b_j= -1;
+    int b_stair = -1;
+
+    bool borg_in_hall = FALSE;
+    int hall_y, hall_x, hall_walls = 0;
+    bool skip_monster = FALSE;
+
+    borg_grid *ag;
+
+
+    /* Efficiency -- Nothing to kill */
+    if (!borg_kills_cnt) return (FALSE);
+
+    /* Don't chase down town monsters when you are just starting out */
+    if (borg_skill[BI_CDEPTH] == 0 && borg_skill[BI_CLEVEL] < 7) return (FALSE);
+
+    /* YOU ARE NOT A WARRIOR!! DON'T ACT LIKE ONE!! */
+    if (borg_class == CLASS_MAGE &&
+        borg_skill[BI_CLEVEL] < (borg_skill[BI_CDEPTH] ? 35 : 5)) return (FALSE);
+
+	/* Not if Weak from hunger or no food */
+	if (borg_skill[BI_ISWEAK] || borg_skill[BI_FOOD] == 0) return (FALSE);
+
+    /* Nothing found */
+    borg_temp_n = 0;
+
+    /* check to see if in a hall, used later */
+    for (hall_x = -1; hall_x <= 1; hall_x++)
+    {
+        for (hall_y = -1; hall_y <= 1; hall_y++)
+        {
+            /* Acquire location */
+            x = hall_x + c_x;
+            y = hall_y + c_y;
+
+            ag = &borg_grids[y][x];
+
+            /* track walls */
+            if ( (ag->feat == FEAT_GLYPH) ||
+               ((ag->feat >= FEAT_MAGMA) && (ag->feat <= FEAT_PERM_SOLID)))
+            {
+                hall_walls++;
+            }
+
+            /* addem up */
+            if (hall_walls >= 5) borg_in_hall = TRUE;
+        }
+    }
+
+
+    /* Check distance away from stairs, used later */
+
+    /* Check for an existing "up stairs" */
+    for (i = 0; i < track_less_num; i++)
+    {
+        x = track_less_x[i];
+        y = track_less_y[i];
+
+        /* How far is the nearest up stairs */
+        j = distance(c_y, c_x, y, x);
+
+        /* skip the closer ones */
+        if (b_j >= j) continue;
+
+        /* track it */
+        b_j =j;
+        b_stair = i;
+    }
+
+    /* Scan the monster list */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Ignore multiplying monsters */
+        if (goal_ignoring && !borg_skill[BI_ISAFRAID] &&
+            (r_info[kill->r_idx].flags2 & RF2_MULTIPLY)) continue;
+
+        /* Ignore molds when low level */
+        if (borg_skill[BI_MAXCLEVEL] < 5 &&
+            (r_info[kill->r_idx].flags1 & RF1_NEVER_MOVE)) continue;
+
+        /* Avoid fighting if a scary guy is on the level */
+        if (scaryguy_on_level) continue;
+
+        /* Avoid multiplying monsters when low level */
+        if (borg_skill[BI_CLEVEL] < 10 && (r_info[kill->r_idx].flags2 & RF2_MULTIPLY)) continue;
+
+        /* Hack -- ignore Maggot until later.  Player will chase Maggot
+         * down all accross the screen waking up all the monsters.  Then
+         * he is stuck in a comprimised situation.
+         */
+        if ((r_info[kill->r_idx].flags1 & RF1_UNIQUE) && borg_skill[BI_CDEPTH] ==0 &&
+            borg_skill[BI_CLEVEL] < 5) continue;
+
+        /* Access the location */
+        x = kill->x;
+        y = kill->y;
+
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        /* Require line of sight if requested */
+        if (viewable && !(ag->info & BORG_VIEW)) continue;
+
+        /* Calculate danger */
+        borg_full_damage = FALSE;
+        p = borg_danger_aux(y, x, 1, i, TRUE);
+        borg_full_damage = FALSE;
+
+
+        /* Hack -- Skip "deadly" monsters unless uniques*/
+        if (borg_skill[BI_CLEVEL] > 15 && (!r_info->flags1 & RF1_UNIQUE) &&
+            p > avoidance / 2) continue;
+        if (borg_skill[BI_CLEVEL] <= 15 && p > avoidance / 3) continue;
+
+        /* Skip ones that make me wander too far */
+        if (b_stair != -1 && borg_skill[BI_CLEVEL < 10])
+        {
+            /* Check the distance of this monster to the stair */
+            j = distance (track_less_y[b_stair], track_less_x[b_stair],
+                          y, x);
+            /* skip far away monsters while I am close to stair */
+            if (b_j <= borg_skill[BI_CLEVEL] * 5 + 9 &&
+                  j >= borg_skill[BI_CLEVEL] * 5 + 9 ) continue;
+        }
+
+        /* Hack -- Avoid getting surrounded */
+        if (borg_in_hall && (r_info[kill->r_idx].flags1 & RF1_FRIENDS))
+        {
+            /* check to see if monster is in a hall, */
+            for (hall_x = -1; hall_x <= 1; hall_x++)
+            {
+                for (hall_y = -1; hall_y <= 1; hall_y++)
+                {
+                    ag = &borg_grids[hall_y + y][hall_x + x];
+
+                    /* track walls */
+                    if ( (ag->feat == FEAT_GLYPH) ||
+                       ((ag->feat >= FEAT_MAGMA) && (ag->feat <= FEAT_PERM_SOLID)))
+                    {
+                        hall_walls++;
+                    }
+
+                /* we want the monster to be in a hall also
+                 *
+                 *  ########################
+                 *  ############      S  ###
+                 *  #         @'     SSS ###
+                 *  # ##########       SS###
+                 *  # #        #       Ss###
+                 *  # #        ###### ######
+                 *  # #             # #
+                 * Currently, we would like the borg to avoid
+                 * flowing to a situation like the one above.
+                 * We would like him to stay in the hall and
+                 * attack from a distance.  One problem is the
+                 * lower case 's' in the corner, He will show
+                 * up as being in a corner, and the borg may
+                 * flow to it.  Let's hope that is a rare case.
+                 *
+                 * The borg might flow to the 'dark' south exit
+                 * of the room.  This would be dangerous for
+                 * him as well.
+                 */
+                    /* add 'em up */
+                    if (hall_walls < 4)
+                    {
+                        /* This monster is not in a hallway.
+                         * It may not be safe to fight.
+                         */
+                        skip_monster =  TRUE;
+                    }
+                }
+            }
+        }
+        /* skip certain ones */
+        if (skip_monster) continue;
+
+        /* Careful -- Remember it */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* Nothing to kill */
+    if (!borg_temp_n) return (FALSE);
+
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Look for something to kill */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(borg_temp_y[i], borg_temp_x[i]);
+    }
+
+    /* Spread the flow */
+    /* if we are not flowing toward monsters that we can see, make sure they */
+    /* are at least easily reachable.  The second flag is whether or not */
+    /* to avoid unknown squares.  This was for performance when we have ESP. */
+    borg_flow_spread(nearness, TRUE, !viewable, FALSE);
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("kill", GOAL_KILL)) return (FALSE);
+
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_KILL)) return (FALSE);
+
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+/*
+ * Prepare to "flow" towards objects to "take"
+ *
+ * Note that objects under the player are always deleted
+ */
+bool borg_flow_take(bool viewable, int nearness)
+{
+    int i, x, y;
+    int b_stair = -1, j, b_j = -1;
+
+    borg_grid *ag;
+
+
+    /* Efficiency -- Nothing to take */
+    if (!borg_takes_cnt) return (FALSE);
+
+    /* Require one empty slot */
+    if (borg_items[INVEN_PACK-1].iqty) return (FALSE);
+
+	/* If ScaryGuy, no chasing down items */
+	if (scaryguy_on_level) return (FALSE);
+
+	/* If out of fuel, don't mess around */
+	if (!borg_skill[BI_CURLITE]) return (FALSE);
+
+    /* Starting over on count */
+    borg_temp_n = 0;
+
+    /* Set the searching flag for low level borgs */
+    borg_needs_searching = TRUE;
+
+	/* if the borg is running on Boosted Bravery, no
+	 * searching
+	 */
+	if (borg_no_retreat >= 1) borg_needs_searching = FALSE;
+
+    /* Check distance away from stairs, used later */
+    /* Check for an existing "up stairs" */
+    for (i = 0; i < track_less_num; i++)
+    {
+        x = track_less_x[i];
+        y = track_less_y[i];
+
+        /* How far is the nearest up stairs */
+        j = distance(c_y, c_x, y, x);
+
+        /* skip the closer ones */
+        if (b_j >= j) continue;
+
+        /* track it */
+        b_j =j;
+        b_stair = i;
+    }
+
+    /* Scan the object list */
+    for (i = 1; i < borg_takes_nxt; i++)
+    {
+        borg_take *take = &borg_takes[i];
+
+        int a;
+        bool item_bad;
+
+        /* Skip dead objects */
+        if (!take->k_idx) continue;
+
+        /* Access the location */
+        x = take->x;
+        y = take->y;
+
+        /* Skip ones that make me wander too far */
+        if (b_stair != -1 && borg_skill[BI_CLEVEL < 10])
+        {
+            /* Check the distance of this 'take' to the stair */
+            j = distance (track_less_y[b_stair], track_less_x[b_stair],
+                          y, x);
+            /* skip far away takes while I am close to stair*/
+            if (b_j <= borg_skill[BI_CLEVEL] * 5 + 9 &&
+                  j >= borg_skill[BI_CLEVEL] * 5 + 9 ) continue;
+        }
+
+        /* look to see if this is on the bad items list */
+        item_bad = FALSE;
+        for (a = 0; a < 50; a++)
+        {
+            if (x == bad_obj_x[a] && y == bad_obj_y[a])
+                item_bad = TRUE;
+        }
+
+        /* it is a bad item, do not track it */
+        if (item_bad) continue;
+
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        /* Require line of sight if requested */
+        if (viewable && !(ag->info & BORG_VIEW)) continue;
+
+        /* Careful -- Remember it */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* Nothing to take */
+    if (!borg_temp_n) return (FALSE);
+
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Look for something to take */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(borg_temp_y[i], borg_temp_x[i]);
+    }
+
+    /* Spread the flow */
+    /* if we are not flowing toward items that we can see, make sure they */
+    /* are at least easily reachable.  The second flag is weather or not  */
+    /* to avoid unkown squares.  This was for performance. */
+    borg_flow_spread(nearness, TRUE, !viewable, FALSE);
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("item", GOAL_TAKE)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_TAKE)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+/*
+ * Prepare to "flow" towards special objects to "take"
+ *
+ * Note that objects under the player are always deleted
+ */
+bool borg_flow_take_lunal(bool viewable, int nearness)
+{
+    int i, x, y;
+
+    borg_grid *ag;
+
+
+    /* Efficiency -- Nothing to take */
+    if (!borg_takes_cnt) return (FALSE);
+
+    /* Require one empty slot */
+    if (borg_items[INVEN_PACK-1].iqty) return (FALSE);
+
+    /* Nothing yet */
+    borg_temp_n = 0;
+
+    /* Set the searching flag for low level borgs */
+    borg_needs_searching = TRUE;
+
+    /* Scan the object list -- set filter*/
+    for (i = 1; i < borg_takes_nxt; i++)
+    {
+        borg_take *take = &borg_takes[i];
+
+        int a;
+        bool item_bad;
+
+        /* Skip dead objects */
+        if (!take->k_idx) continue;
+
+        /* Access the location */
+        x = take->x;
+        y = take->y;
+
+		/* all items start bad */
+        item_bad = TRUE;
+
+		/* Certain Potions are good to have */
+		if (take->k_idx == 225 ||
+		    take->k_idx == 228 ||
+		    take->k_idx == 231 ||
+		    take->k_idx == 234 ||
+		    take->k_idx == 231 ||
+		    take->k_idx == 251 ||
+		    take->k_idx == 418 ||
+		    take->k_idx == 419 ||
+		    take->k_idx == 420 ||
+		    (take->k_idx >= 241 &&
+			 take->k_idx <= 244))
+		{
+			borg_note(format("# Lunal Item %s, at %d,%d", k_name + k_info[take->k_idx].name, y, x ));
+			item_bad = FALSE;
+		}
+
+		/* Gold is good to have */
+		if (take->k_idx >= 480 &&
+			take->k_idx <= 497)
+		{
+			borg_note(format("# Lunal Item %s, at %d,%d", k_name + k_info[take->k_idx].name, y, x ));
+			item_bad = FALSE;
+		}
+
+		/* Certain insta_arts are good */
+		if ((take->k_idx >= 500 &&
+			 take->k_idx <= 502) ||
+			(take->k_idx >= 512 &&
+			 take->k_idx <= 514))
+		{
+			borg_note(format("# Lunal Item %s, at %d,%d", k_name + k_info[take->k_idx].name, y, x ));
+			item_bad = FALSE;
+		}
+
+        /* look to see if this is on the bad items list */
+        for (a = 0; a < 50; a++)
+        {
+            if (x == bad_obj_x[a] && y == bad_obj_y[a])
+                item_bad = TRUE;
+        }
+
+        /* it is a bad item, do not track it */
+        if (item_bad) continue;
+
+        /* Get the grid */
+        ag = &borg_grids[y][x];
+
+        /* Require line of sight if requested */
+        if (viewable && !(ag->info & BORG_VIEW)) continue;
+
+        /* Careful -- Remember it */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* Nothing to take */
+    if (!borg_temp_n) return (FALSE);
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Look for something to take */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(borg_temp_y[i], borg_temp_x[i]);
+    }
+
+    /* Spread the flow */
+    /* if we are not flowing toward items that we can see, make sure they */
+    /* are at least easily reachable.  The second flag is weather or not  */
+    /* to avoid unknown squares.  This was for performance. */
+    borg_flow_spread(nearness, TRUE, !viewable, FALSE);
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("lunal item", GOAL_TAKE)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_TAKE)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Determine if a grid is "interesting" (and should be explored)
+ *
+ * A grid is "interesting" if it is a closed door, rubble, hidden treasure,
+ * or a visible trap, or an "unknown" grid.
+ * or a non-perma-wall adjacent to a perma-wall. (GCV)
+ *
+ * b_stair is the index to the closest upstairs.
+ */
+static bool borg_flow_dark_interesting(int y, int x, int b_stair)
+{
+    int oy;
+    int ox, i;
+    int j, b_j;
+
+
+    borg_grid *ag;
+
+    /* Have the borg so some Searching */
+    borg_needs_searching = TRUE;
+
+    /* Get the borg_grid */
+    ag = &borg_grids[y][x];
+
+    /* Skip ones that make me wander too far */
+    if (b_stair != -1 && borg_skill[BI_CLEVEL < 10])
+    {
+        /* Check the distance of this grid to the stair */
+        j = distance (track_less_y[b_stair], track_less_x[b_stair],
+                      y, x);
+        /* Distance of me to the stairs */
+        b_j = distance (c_y, c_x, track_less_y[b_stair], track_less_x[b_stair]);
+
+        /* skip far away grids while I am close to stair*/
+        if (b_j <= borg_skill[BI_CLEVEL] * 5 + 9 &&
+              j >= borg_skill[BI_CLEVEL] * 5 + 9 ) return (FALSE);
+    }
+
+
+    /* Explore unknown grids */
+    if (ag->feat == FEAT_NONE) return (TRUE);
+
+    /* Efficiency -- Ignore "boring" grids */
+    if (ag->feat < FEAT_TRAP_HEAD) return (FALSE);
+
+    /* Explore "known treasure" */
+    if ((ag->feat == FEAT_MAGMA_K) || (ag->feat == FEAT_QUARTZ_K))
+    {
+        /* Do not dig when confused */
+        if (borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+        /* Do not bother if super rich */
+        if (borg_gold >= 1000000) return (FALSE);
+
+        /* Not when darkened */
+        if (borg_skill[BI_CURLITE] == 0) return (FALSE);
+
+        /* Allow "stone to mud" ability */
+        if (borg_spell_legal(2, 2)) return (TRUE);
+
+        /* Do not dig unless we appear strong enough to succeed or we have a digger */
+        if (borg_skill[BI_DIG] > 40)
+        {
+           /* digging ought to work */
+        }
+        else
+        {
+             return (FALSE);
+        }
+
+        /* Okay */
+        return (TRUE);
+    }
+
+    /* "Vaults" Explore non perma-walls adjacent to a perma wall */
+    if (ag->feat == FEAT_WALL_EXTRA || ag->feat == FEAT_MAGMA ||
+        ag->feat == FEAT_QUARTZ)
+    {
+        /* Do not attempt when confused */
+        if (borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+        /* hack and cheat.  No vaults  on this level */
+        if (!vault_on_level) return (FALSE);
+
+        /* AJG Do not attempt on the edge */
+        if(x < AUTO_MAX_X-1
+        && y < AUTO_MAX_Y-1
+        && x > 1
+        && y > 1)
+        {
+            /* scan the adjacent grids */
+            for (ox = -1; ox <= 1; ox++)
+            {
+                for (oy = -1; oy <= 1; oy++)
+                {
+
+                    /* Acquire location */
+                    ag = &borg_grids[oy+y][ox+x];
+
+                    /* skip non perma grids wall */
+                    if (ag->feat != FEAT_PERM_INNER) continue;
+
+                    /* Allow "stone to mud" ability */
+                    if (borg_spell_legal(2, 2) ||
+                        borg_equips_artifact(ACT_STONE_TO_MUD, INVEN_WIELD)) return (TRUE);
+
+                    /* Do not dig unless we appear strong enough to succeed or we have a digger */
+                    if (borg_skill[BI_DIG] > 40)
+                    {
+                       /* digging ought to work, proceed */
+                    }
+                    else
+                    {
+                         continue;
+                    }
+                    if (borg_skill[BI_DIG] < 40) return (FALSE);
+
+                    /* Glove up and dig in */
+                    return (TRUE);
+                }
+            }
+        }
+    /* not adjacent to a GCV,  Restore Grid */
+    ag = &borg_grids[y][x];
+
+    }
+
+    /* Explore "rubble" */
+    if (ag->feat == FEAT_RUBBLE && !borg_skill[BI_ISWEAK])
+    {
+        return (TRUE);
+    }
+
+
+    /* Explore "closed doors" */
+    if ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_DOOR_TAIL))
+    {
+            /* some closed doors leave alone */
+            if (breeder_level)
+            {
+                    /* Did I close this one */
+                    for (i = 0; i < track_door_num; i++)
+                    {
+                        /* mark as icky if I closed this one */
+                        if ((track_door_x[i] == x) && (track_door_y[i] == y))
+                        {
+                            /* not interesting */
+                            return (FALSE);
+                        }
+                    }
+
+            }
+        /* this door should be ok to open */
+        return (TRUE);
+    }
+
+
+    /* Explore "visible traps" */
+    if ((ag->feat >= FEAT_TRAP_HEAD) && (ag->feat <= FEAT_TRAP_TAIL))
+    {
+        /* Do not disarm when blind */
+        if (borg_skill[BI_ISBLIND]) return (FALSE);
+
+        /* Do not disarm when confused */
+        if (borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+        /* Do not disarm when hallucinating */
+        if (borg_skill[BI_ISIMAGE]) return (FALSE);
+
+        /* Do not flow without lite */
+        if (borg_skill[BI_CURLITE] == 0) return (FALSE);
+
+        /* Do not disarm trap doors on level 99 */
+        if (borg_skill[BI_CDEPTH] == 99 && ag->feat == FEAT_TRAP_HEAD) return (FALSE);
+
+        /* Do not disarm when you could end up dead */
+        if (borg_skill[BI_CURHP] < 60) return (FALSE);
+
+        /* Do not disarm when clumsy */
+        if (borg_skill[BI_DIS] < 30 && borg_skill[BI_CLEVEL] < 20 ) return (FALSE);
+        if (borg_skill[BI_DIS] < 45 && borg_skill[BI_CLEVEL] < 10 ) return (FALSE);
+
+		/* Do not explore if a Scaryguy on the Level */
+		if (scaryguy_on_level) return (FALSE);
+
+        /* NOTE: the flow code allows a borg to flow through a trap and so he may
+         * still try to disarm one on his way to the other interesting grid.  If mods
+         * are made to the above criteria for disarming traps, then mods must also be
+         * made to borg_flow_spread() and borg_flow_direct()
+         */
+
+        /* Okay */
+        return (TRUE);
+    }
+
+
+    /* Ignore other grids */
+    return (FALSE);
+}
+
+
+/*
+ * Determine if a grid is "reachable" (and can be explored)
+ */
+static bool borg_flow_dark_reachable(int y, int x)
+{
+    int j;
+
+    borg_grid *ag;
+
+    /* Scan neighbors */
+    for (j = 0; j < 8; j++)
+    {
+        int y2 = y + ddy_ddd[j];
+        int x2 = x + ddx_ddd[j];
+
+        /* Get the grid */
+        ag = &borg_grids[y2][x2];
+
+        /* Skip unknown grids (important) */
+        if (ag->feat == FEAT_NONE) continue;
+
+        /* Accept known floor grids */
+        if (borg_cave_floor_grid(ag)) return (TRUE);
+    }
+
+    /* Failure */
+    return (FALSE);
+}
+
+/* Dig a straight Tunnel to a close monster */
+bool borg_flow_kill_direct(bool viewable)
+{
+    int o_y, o_x;
+    int m_x, m_y;
+    int f_y,f_x;
+    int b_y = 0, b_x = 0;
+    int perma_grids = 0;
+	int i;
+	int b_i = -1;
+	int d;
+	int b_d = MAX_SIGHT;
+
+    borg_kill *kill;
+
+
+    /* Do not dig when weak. It takes too long */
+    if (borg_skill[BI_STR] < 14) return (FALSE);
+
+    /* Only when sitting for too long or twitchy */
+    if (borg_t - borg_began < 3000 && borg_times_twitch < 5) return (FALSE);
+
+    /* Do not dig when confused */
+    if (borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+    /* Not when darkened */
+    if (borg_skill[BI_CURLITE] == 0) return (FALSE);
+
+    /* Efficiency -- Nothing to kill */
+    if (borg_kills_cnt)
+	{
+		/* Scan the monsters */
+	    for (i = 1; i < borg_kills_nxt; i++)
+	    {
+	        kill = &borg_kills[i];
+
+	        /* Skip "dead" monsters */
+	        if (!kill->r_idx) continue;
+
+	        /* Distance away */
+	        d = distance(kill->y, kill->x, c_y, c_x);
+
+	        /* Track closest one */
+	        if (d > b_d) continue;
+
+	        /* Track it */
+	        b_i = i; b_d = d;
+	    }
+	}
+
+	/* If no Kill, then pick the center of the map */
+	if (b_i == -1)
+	{
+
+        /* Clear the flow codes */
+        borg_flow_clear();
+
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(AUTO_MAX_Y / 2, AUTO_MAX_X / 2);
+
+        /* Spread the flow */
+        borg_flow_spread(150, TRUE, FALSE, TRUE);
+
+        /* Attempt to Commit the flow */
+        if (!borg_flow_commit("center direct", GOAL_KILL)) return (FALSE);
+
+        /* Take one step */
+        if (!borg_flow_old(GOAL_KILL)) return (FALSE);
+
+        return (TRUE);
+    }
+
+    if (b_i) /* don't want it near permawall */
+    {
+	    /* get the closest monster */
+	    kill = &borg_kills[b_i];
+
+        /* Clear the flow codes */
+        borg_flow_clear();
+
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(kill->y, kill->x);
+
+        /* Spread the flow */
+        borg_flow_spread(15, TRUE, FALSE, TRUE);
+
+        /* Attempt to Commit the flow */
+        if (!borg_flow_commit("kill direct", GOAL_KILL)) return (FALSE);
+
+        /* Take one step */
+        if (!borg_flow_old(GOAL_KILL)) return (FALSE);
+
+        return (TRUE);
+    }
+
+    return FALSE;
+}
+
+/*
+ * Place a "direct path" into the flow array, checking danger
+ *
+ * Modify the "cost" array in such a way that from any point on
+ * one "direct" path from the player to the given grid, as long
+ * as the rest of the path is "safe" and "clear", the Borg will
+ * walk along the path to the given grid.
+ *
+ * This function is used by "borg_flow_dark_1()" to provide an
+ * optimized "flow" during the initial exploration of a level.
+ * It is also used by "borg_flow_dark_2()" in a similar fashion.
+ */
+static void borg_flow_direct(int y, int x)
+{
+    int n = 0;
+
+    int x1, y1, x2, y2;
+
+    int ay, ax;
+
+    int shift;
+
+	int p, fear;
+
+    borg_grid *ag;
+
+
+    /* Avoid icky grids */
+    if (borg_data_icky->data[y][x]) return;
+
+    /* Unknown */
+    if (!borg_data_know->data[y][x])
+    {
+        /* Mark as known */
+        borg_data_know->data[y][x] = TRUE;
+
+        /* Get the danger */
+        p = borg_danger(y, x, 1, TRUE);
+
+		/* Increase bravery */
+		if (borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 5 / 10;
+		if (borg_skill[BI_MAXCLEVEL] != 50) fear = avoidance * 3 / 10;
+		if (scaryguy_on_level) fear = avoidance * 2;
+		if (unique_on_level && vault_on_level && borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 3;
+		if (scaryguy_on_level && borg_skill[BI_CLEVEL] <= 5) fear = avoidance * 3;
+		if (goal_ignoring) fear = avoidance * 5;
+		if (borg_t - borg_began > 5000) fear = avoidance * 25;
+		if (borg_skill[BI_FOOD] == 0) fear = avoidance * 100;
+
+		/* Normal in town */
+		if (borg_skill[BI_CLEVEL] == 0) fear = avoidance * 1 / 10;
+
+        /* Mark dangerous grids as icky */
+        if (p > fear)
+        {
+            /* Icky */
+            borg_data_icky->data[y][x] = TRUE;
+
+            /* Avoid */
+            return;
+        }
+    }
+
+
+    /* Save the flow cost (zero) */
+    borg_data_cost->data[y][x] = 0;
+
+
+    /* Save "origin" */
+    y1 = y;
+    x1 = x;
+
+    /* Save "destination" */
+    y2 = c_y;
+    x2 = c_x;
+
+    /* Calculate distance components */
+    ay = (y2 < y1) ? (y1 - y2) : (y2 - y1);
+    ax = (x2 < x1) ? (x1 - x2) : (x2 - x1);
+
+    /* Path */
+    while (1)
+    {
+        /* Check for arrival at player */
+        if ((x == x2) && (y == y2)) return;
+
+        /* Next */
+        n++;
+
+        /* Move mostly vertically */
+        if (ay > ax)
+        {
+            /* Extract a shift factor XXX */
+            shift = (n * ax + (ay-1) / 2) / ay;
+
+            /* Sometimes move along the minor axis */
+            x = (x2 < x1) ? (x1 - shift) : (x1 + shift);
+
+            /* Always move along major axis */
+            y = (y2 < y1) ? (y1 - n) : (y1 + n);
+        }
+
+        /* Move mostly horizontally */
+        else
+        {
+            /* Extract a shift factor XXX */
+            shift = (n * ay + (ax-1) / 2) / ax;
+
+            /* Sometimes move along the minor axis */
+            y = (y2 < y1) ? (y1 - shift) : (y1 + shift);
+
+            /* Always move along major axis */
+            x = (x2 < x1) ? (x1 - n) : (x1 + n);
+        }
+
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+
+        /* Ignore "wall" grids */
+        if (!borg_cave_floor_grid(ag)) return;
+
+        /* Avoid Traps if low level-- unless brave or scaryguy. */
+        if (ag->feat >= FEAT_TRAP_HEAD && ag->feat <= FEAT_TRAP_TAIL &&
+            avoidance <= borg_skill[BI_CURHP] && !scaryguy_on_level)
+       	{
+            /* Do not disarm when you could end up dead */
+            if (borg_skill[BI_CURHP] < 60) return;
+
+            /* Do not disarm when clumsy */
+            if (borg_skill[BI_DIS] < 30 && borg_skill[BI_CLEVEL] < 20 ) return;
+            if (borg_skill[BI_DIS] < 45 && borg_skill[BI_CLEVEL] < 10 ) return;
+        }
+
+        /* Abort at "icky" grids */
+        if (borg_data_icky->data[y][x]) return;
+
+        /* Analyze every grid once */
+        if (!borg_data_know->data[y][x])
+        {
+            /* Mark as known */
+            borg_data_know->data[y][x] = TRUE;
+
+	        /* Get the danger */
+	        p = borg_danger(y, x, 1, TRUE);
+
+			/* Increase bravery */
+			if (borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 5 / 10;
+			if (borg_skill[BI_MAXCLEVEL] != 50) fear = avoidance * 3 / 10;
+			if (scaryguy_on_level) fear = avoidance * 2;
+			if (unique_on_level && vault_on_level && borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 3;
+			if (scaryguy_on_level && borg_skill[BI_CLEVEL] <= 5) fear = avoidance * 3;
+			if (goal_ignoring) fear = avoidance * 5;
+			if (borg_t - borg_began > 5000) fear = avoidance * 25;
+			if (borg_skill[BI_FOOD] == 0) fear = avoidance * 100;
+
+			/* Normal in town */
+			if (borg_skill[BI_CLEVEL] == 0) fear = avoidance * 1 / 10;
+
+            /* Avoid dangerous grids (forever) */
+            if (p > fear)
+            {
+                /* Mark as icky */
+                borg_data_icky->data[y][x] = TRUE;
+
+                /* Abort */
+                return;
+            }
+        }
+
+        /* Abort "pointless" paths if possible */
+        if (borg_data_cost->data[y][x] <= n) break;
+
+        /* Save the new flow cost */
+        borg_data_cost->data[y][x] = n;
+    }
+}
+
+/* Currently not used, I thought I might need it for anti-summoning */
+extern void borg_flow_direct_dig(int y, int x)
+{
+    int n = 0;
+
+    int x1, y1, x2, y2;
+
+    int ay, ax;
+
+    int shift;
+
+    borg_grid *ag;
+
+	int p, fear;
+
+#if 0
+    /* Avoid icky grids */
+    if (borg_data_icky->data[y][x]) return;
+
+    /* Unknown */
+    if (!borg_data_know->data[y][x])
+    {
+        /* Mark as known */
+        borg_data_know->data[y][x] = TRUE;
+
+        /* Mark dangerous grids as icky */
+        if (borg_danger(y, x, 1, TRUE) > avoidance / 3)
+        {
+            /* Icky */
+            borg_data_icky->data[y][x] = TRUE;
+
+            /* Avoid */
+            return;
+        }
+    }
+
+#endif
+
+    /* Save the flow cost (zero) */
+    borg_data_cost->data[y][x] = 0;
+
+
+    /* Save "origin" */
+    y1 = y;
+    x1 = x;
+
+    /* Save "destination" */
+    y2 = c_y;
+    x2 = c_x;
+
+    /* Calculate distance components */
+    ay = (y2 < y1) ? (y1 - y2) : (y2 - y1);
+    ax = (x2 < x1) ? (x1 - x2) : (x2 - x1);
+
+    /* Path */
+    while (1)
+    {
+        /* Check for arrival at player */
+        if ((x == x2) && (y == y2)) return;
+
+        /* Next */
+        n++;
+
+        /* Move mostly vertically */
+        if (ay > ax)
+        {
+            /* Extract a shift factor XXX */
+            shift = (n * ax + (ay-1) / 2) / ay;
+
+            /* Sometimes move along the minor axis */
+            x = (x2 < x1) ? (x1 - shift) : (x1 + shift);
+
+            /* Always move along major axis */
+            y = (y2 < y1) ? (y1 - n) : (y1 + n);
+        }
+
+        /* Move mostly horizontally */
+        else
+        {
+            /* Extract a shift factor XXX */
+            shift = (n * ay + (ax-1) / 2) / ax;
+
+            /* Sometimes move along the minor axis */
+            y = (y2 < y1) ? (y1 - shift) : (y1 + shift);
+
+            /* Always move along major axis */
+            x = (x2 < x1) ? (x1 - n) : (x1 + n);
+        }
+
+
+        /* Access the grid */
+        ag = &borg_grids[y][x];
+
+
+        /* Abort at "icky" grids */
+        if (borg_data_icky->data[y][x]) return;
+
+        /* Analyze every grid once */
+        if (!borg_data_know->data[y][x])
+        {
+            /* Mark as known */
+            borg_data_know->data[y][x] = TRUE;
+
+	        /* Get the danger */
+	        p = borg_danger(y, x, 1, TRUE);
+
+			/* Increase bravery */
+			if (borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 5 / 10;
+			if (borg_skill[BI_MAXCLEVEL] != 50) fear = avoidance * 3 / 10;
+			if (scaryguy_on_level) fear = avoidance * 2;
+			if (unique_on_level && vault_on_level && borg_skill[BI_MAXCLEVEL] == 50) fear = avoidance * 3;
+			if (scaryguy_on_level && borg_skill[BI_CLEVEL] <= 5) fear = avoidance * 3;
+			if (goal_ignoring) fear = avoidance * 5;
+			if (borg_t - borg_began > 5000) fear = avoidance * 25;
+			if (borg_skill[BI_FOOD] == 0) fear = avoidance * 100;
+
+			/* Normal in town */
+			if (borg_skill[BI_CLEVEL] == 0) fear = avoidance * 1 / 10;
+
+            /* Avoid dangerous grids (forever) */
+            if (p > fear)
+            {
+                /* Mark as icky */
+                borg_data_icky->data[y][x] = TRUE;
+
+                /* Abort */
+                return;
+            }
+        }
+
+        /* Abort "pointless" paths if possible */
+        if (borg_data_cost->data[y][x] <= n) break;
+
+        /* Save the new flow cost */
+        borg_data_cost->data[y][x] = n;
+    }
+}
+
+
+
+/*
+ * Hack -- mark off the edges of a rectangle as "avoid" or "clear"
+ */
+static void borg_flow_border(int y1, int x1, int y2, int x2, bool stop)
+{
+    int x, y;
+
+    /* Scan west/east edges */
+    for (y = y1; y <= y2; y++)
+    {
+        /* Avoid/Clear west edge */
+        borg_data_know->data[y][x1] = stop;
+        borg_data_icky->data[y][x1] = stop;
+
+        /* Avoid/Clear east edge */
+        borg_data_know->data[y][x2] = stop;
+        borg_data_icky->data[y][x2] = stop;
+    }
+
+    /* Scan north/south edges */
+    for (x = x1; x <= x2; x++)
+    {
+        /* Avoid/Clear north edge */
+        borg_data_know->data[y1][x] = stop;
+        borg_data_icky->data[y1][x] = stop;
+
+        /* Avoid/Clear south edge */
+        borg_data_know->data[y2][x] = stop;
+        borg_data_icky->data[y2][x] = stop;
+    }
+}
+
+
+/*
+ * Prepare to "flow" towards "interesting" grids (method 1)
+ *
+ * This function examines the torch-lit grids for "interesting" grids.
+ */
+static bool borg_flow_dark_1(int b_stair)
+{
+    int i;
+
+    int x, y;
+
+
+    /* Hack -- not in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+
+    /* Reset */
+    borg_temp_n = 0;
+
+    /* Scan torch-lit grids */
+    for (i = 0; i < borg_lite_n; i++)
+    {
+        y = borg_lite_y[i];
+        x = borg_lite_x[i];
+
+        /* Skip "boring" grids (assume reachable) */
+        if (!borg_flow_dark_interesting(y, x, b_stair)) continue;
+
+        /* Careful -- Remember it */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* Nothing */
+    if (!borg_temp_n) return (FALSE);
+
+
+	/* Wipe icky codes from grids if needed */
+	if (goal_ignoring || scaryguy_on_level) borg_danger_wipe = TRUE;
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Create paths to useful grids */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        y = borg_temp_y[i];
+        x = borg_temp_x[i];
+
+        /* Create a path */
+        borg_flow_direct(y, x);
+    }
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit(NULL, GOAL_DARK)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_DARK)) return (FALSE);
+
+    /* Forget goal */
+    goal = 0;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to "flow" towards "interesting" grids (method 2)
+ *
+ * This function is only used when the player is at least 4 grids away
+ * from the outer dungeon wall, to prevent any nasty memory errors.
+ *
+ * This function examines the grids just outside the torch-lit grids
+ * for "unknown" grids, and flows directly towards them (one step).
+ */
+static bool borg_flow_dark_2(void)
+{
+    int i, r;
+
+    int x, y;
+
+    borg_grid *ag;
+
+
+    /* Hack -- not in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Set the searching flag for low level borgs */
+    borg_needs_searching = TRUE;
+
+    /* Maximal radius */
+    r = borg_skill[BI_CURLITE] + 1;
+
+
+    /* Reset */
+    borg_temp_n = 0;
+
+    /* Four directions */
+    for (i = 0; i < 4; i++)
+    {
+        y = c_y + ddy_ddd[i] * r;
+        x = c_x + ddx_ddd[i] * r;
+
+        /* Check legality */
+        if (y < 1) continue;
+        if (x < 1) continue;
+        if (y > AUTO_MAX_Y - 2) continue;
+        if (x > AUTO_MAX_X - 2) continue;
+
+        /* Acquire grid */
+        ag = &borg_grids[y][x];
+
+        /* Require unknown */
+        if (ag->feat != FEAT_NONE) continue;
+
+        /* Require viewable */
+        if (!(ag->info & BORG_VIEW)) continue;
+
+        /* if it makes me wander, skip it */
+
+        /* Careful -- Remember it */
+        borg_temp_x[borg_temp_n] = x;
+        borg_temp_y[borg_temp_n] = y;
+        borg_temp_n++;
+    }
+
+    /* Nothing */
+    if (!borg_temp_n) return (FALSE);
+
+	/* Wipe icky codes from grids if needed */
+	if (goal_ignoring || scaryguy_on_level) borg_danger_wipe = TRUE;
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Create paths to useful grids */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        y = borg_temp_y[i];
+        x = borg_temp_x[i];
+
+        /* Create a path */
+        borg_flow_direct(y, x);
+    }
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit(NULL, GOAL_DARK)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_DARK)) return (FALSE);
+
+    /* Forget goal */
+    goal = 0;
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to "flow" towards "interesting" grids (method 3)
+ *
+ * Note the use of a limit on the "depth" of the flow, and of the flag
+ * which avoids "unknown" grids when calculating the flow, both of which
+ * help optimize this function to only handle "easily reachable" grids.
+ *
+ * The "borg_temp" array is much larger than any "local region".
+ */
+static bool borg_flow_dark_3(int b_stair)
+{
+    int i;
+
+    int x, y;
+
+    int x1, y1, x2, y2;
+
+
+    /* Hack -- not in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+
+    /* Local region */
+    y1 = c_y - 4;
+    x1 = c_x - 4;
+    y2 = c_y + 4;
+    x2 = c_x + 4;
+
+    /* Restrict to "legal" grids */
+    if (y1 < 1) y1 = 1;
+    if (x1 < 1) x1 = 1;
+    if (y2 > AUTO_MAX_Y - 2) y2 = AUTO_MAX_Y - 2;
+    if (x2 > AUTO_MAX_X - 2) x2 = AUTO_MAX_X - 2;
+
+
+    /* Reset */
+    borg_temp_n = 0;
+
+    /* Examine the region */
+    for (y = y1; y <= y2; y++)
+    {
+        /* Examine the region */
+        for (x = x1; x <= x2; x++)
+        {
+            /* Skip "boring" grids */
+            if (!borg_flow_dark_interesting(y, x, b_stair)) continue;
+
+            /* Skip "unreachable" grids */
+            if (!borg_flow_dark_reachable(y, x)) continue;
+
+
+
+            /* Careful -- Remember it */
+            borg_temp_x[borg_temp_n] = x;
+            borg_temp_y[borg_temp_n] = y;
+            borg_temp_n++;
+        }
+    }
+
+    /* Nothing interesting */
+    if (!borg_temp_n) return (FALSE);
+
+	/* Wipe icky codes from grids if needed */
+	if (goal_ignoring || scaryguy_on_level) borg_danger_wipe = TRUE;
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue useful grids */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        y = borg_temp_y[i];
+        x = borg_temp_x[i];
+
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(y, x);
+    }
+
+    /* Spread the flow (limit depth) */
+    borg_flow_spread(5, TRUE, TRUE, FALSE);
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit(NULL, GOAL_DARK)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_DARK)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to "flow" towards "interesting" grids (method 4)
+ *
+ * Note that we avoid grids close to the edge of the panel, since they
+ * induce panel scrolling, which is "expensive" in terms of CPU usage,
+ * and because this allows us to "expand" the border by several grids
+ * to lay down the "avoidance" border in known legal grids.
+ *
+ * We avoid paths that would take us into different panels by setting
+ * the "icky" flag for the "border" grids to prevent path construction,
+ * and then clearing them when done, to prevent confusion elsewhere.
+ *
+ * The "borg_temp" array is large enough to hold one panel full of grids.
+ */
+static bool borg_flow_dark_4(int b_stair)
+{
+    int i, x, y;
+
+    int x1, y1, x2, y2;
+
+
+    /* Hack -- not in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+	/* Hack -- Not if a vault is on the level */
+	if (vault_on_level) return (FALSE);
+
+    /* Local region */
+    y1 = c_y - 11;
+    x1 = c_x - 11;
+    y2 = c_y + 11;
+    x2 = c_x + 11;
+
+    /* Restrict to "legal" grids */
+    if (y1 < 1) y1 = 1;
+    if (x1 < 1) x1 = 1;
+    if (y2 > AUTO_MAX_Y - 2) y2 = AUTO_MAX_Y - 2;
+    if (x2 > AUTO_MAX_X - 2) x2 = AUTO_MAX_X - 2;
+
+
+    /* Nothing yet */
+    borg_temp_n = 0;
+
+    /* Examine the panel */
+    for (y = y1; y <= y2; y++)
+    {
+        /* Examine the panel */
+        for (x = x1; x <= x2; x++)
+        {
+            /* Skip "boring" grids */
+            if (!borg_flow_dark_interesting(y, x, b_stair)) continue;
+
+            /* Skip "unreachable" grids */
+            if (!borg_flow_dark_reachable(y, x)) continue;
+
+            /* Careful -- Remember it */
+            borg_temp_x[borg_temp_n] = x;
+            borg_temp_y[borg_temp_n] = y;
+            borg_temp_n++;
+        }
+    }
+
+    /* Nothing useful */
+    if (!borg_temp_n) return (FALSE);
+
+	/* Wipe icky codes from grids if needed */
+	if (goal_ignoring || scaryguy_on_level) borg_danger_wipe = TRUE;
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue useful grids */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        y = borg_temp_y[i];
+        x = borg_temp_x[i];
+
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(y, x);
+    }
+
+
+    /* Expand borders */
+    y1--; x1--; y2++; x2++;
+
+    /* Avoid the edges */
+    borg_flow_border(y1, x1, y2, x2, TRUE);
+
+    /* Spread the flow (limit depth) */
+    borg_flow_spread(32, TRUE, TRUE, FALSE);
+
+    /* Clear the edges */
+    borg_flow_border(y1, x1, y2, x2, FALSE);
+
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("dark-4", GOAL_DARK)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_DARK)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to "flow" towards "interesting" grids (method 5)
+ */
+static bool borg_flow_dark_5(int b_stair)
+{
+    int i, x, y;
+
+
+    /* Hack -- not in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+
+    /* Nothing yet */
+    borg_temp_n = 0;
+
+    /* Examine every "legal" grid */
+    for (y = 1; y < AUTO_MAX_Y-1; y++)
+    {
+        for (x = 1; x < AUTO_MAX_X-1; x++)
+        {
+            /* Skip "boring" grids */
+            if (!borg_flow_dark_interesting(y, x, b_stair)) continue;
+
+            /* Skip "unreachable" grids */
+            if (!borg_flow_dark_reachable(y, x)) continue;
+
+            /* Careful -- Remember it */
+            borg_temp_x[borg_temp_n] = x;
+            borg_temp_y[borg_temp_n] = y;
+            borg_temp_n++;
+
+            /* Paranoia -- Check for overflow */
+            if (borg_temp_n == AUTO_TEMP_MAX)
+            {
+                /* Hack -- Double break */
+                y = AUTO_MAX_Y;
+                x = AUTO_MAX_X;
+                break;
+            }
+        }
+    }
+
+    /* Nothing useful */
+    if (!borg_temp_n) return (FALSE);
+
+	/* Wipe icky codes from grids if needed */
+	if (goal_ignoring || scaryguy_on_level) borg_danger_wipe = TRUE;
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Enqueue useful grids */
+    for (i = 0; i < borg_temp_n; i++)
+    {
+        y = borg_temp_y[i];
+        x = borg_temp_x[i];
+
+        /* Enqueue the grid */
+        borg_flow_enqueue_grid(y, x);
+    }
+
+    /* Spread the flow */
+	if (borg_skill[BI_CLEVEL] <= 5)
+	{
+		/* Short Leash */
+		borg_flow_spread(15, TRUE, TRUE, FALSE);
+	}
+	else
+	{
+		/* Long Leash */
+		borg_flow_spread(250, TRUE, TRUE, FALSE);
+	}
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("dark-5", GOAL_DARK)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_DARK)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+/*
+ * Prepare to "flow" towards "interesting" grids
+ *
+ * The "exploration" routines are broken into "near" and "far"
+ * exploration, and each set is chosen via the flag below.
+ */
+bool borg_flow_dark(bool neer)
+{
+    int i;
+    int x, y, j, b_j = -1;
+    int b_stair = -1;
+
+    /* Paranoia */
+    if (borg_flow_dark_interesting(c_y, c_x, -1))
+    {
+        return (FALSE);
+    }
+
+    /* Check distance away from stairs, used later */
+    /* Check for an existing "up stairs" */
+    for (i = 0; i < track_less_num; i++)
+    {
+        x = track_less_x[i];
+        y = track_less_y[i];
+
+        /* How far is the nearest up stairs */
+        j = distance(c_y, c_x, y, x);
+
+        /* skip the closer ones */
+        if (b_j >= j) continue;
+
+        /* track it */
+        b_j =j;
+        b_stair = i;
+    }
+
+    /* Near */
+    if (neer)
+    {
+        /* Method 1 */
+		if (borg_flow_dark_1(b_stair)) return (TRUE);
+
+        /* Method 2 */
+        if (borg_flow_dark_2()) return (TRUE);
+
+        /* Method 3 */
+        if (borg_flow_dark_3(b_stair)) return (TRUE);
+    }
+    /* Far */
+    else
+    {
+        /* Method 4 */
+        if (borg_flow_dark_4(b_stair)) return (TRUE);
+
+        /* Method 5 */
+        if (borg_flow_dark_5(b_stair)) return (TRUE);
+    }
+
+    /* Fail */
+    return (FALSE);
+}
+
+
+
+/*
+ * Hack -- spastic searching
+ */
+
+static byte spastic_x;
+static byte spastic_y;
+
+
+
+/*
+ * Search carefully for secret doors and such
+ */
+bool borg_flow_spastic(bool bored)
+{
+    int cost;
+
+    int i, x, y, v;
+
+    int b_x = c_x;
+    int b_y = c_y;
+    int b_v = -1;
+    int j, b_j = -1;
+    int b_stair = -1;
+
+    borg_grid *ag;
+
+
+    /* Hack -- not in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+	/* Hack -- Not if starving */
+	if (borg_skill[BI_ISWEAK]) return (FALSE);
+
+	/* Hack -- Not if hopeless */
+	if (borg_t - borg_began > 3000) return (FALSE);
+
+    /* Not bored */
+    if (!bored)
+    {
+        /* Look around for danger */
+        int p = borg_danger(c_y, c_x, 1, TRUE);
+
+        /* Avoid searching when in danger */
+        if (p > avoidance / 4) return (FALSE);
+    }
+
+    /* Check distance away from stairs, used later */
+    /* Check for an existing "up stairs" */
+    for (i = 0; i < track_less_num; i++)
+    {
+        x = track_less_x[i];
+        y = track_less_y[i];
+
+        /* How far is the nearest up stairs */
+        j = distance(c_y, c_x, y, x);
+
+        /* skip the closer ones */
+        if (b_j >= j) continue;
+
+        /* track it */
+        b_j =j;
+        b_stair = i;
+    }
+
+    /* We have arrived */
+    if ((spastic_x == c_x) && (spastic_y == c_y))
+    {
+        /* Cancel */
+        spastic_x = 0;
+        spastic_y = 0;
+
+		ag = &borg_grids[c_y][c_x];
+
+        /* Take note */
+        borg_note(format("# Spastic Searching at (%d,%d)...value:%d", c_x, c_y, ag->xtra));
+
+        /* Count searching */
+        for (i = 0; i < 9; i++)
+        {
+            /* Extract the location */
+            int xx = c_x + ddx_ddd[i];
+            int yy = c_y + ddy_ddd[i];
+
+            /* Current grid */
+            ag = &borg_grids[yy][xx];
+
+            /* Tweak -- Remember the search */
+            if (ag->xtra < 100) ag->xtra += 5;
+        }
+
+        /* Tweak -- Search a little */
+        borg_keypress('0');
+        borg_keypress('5');
+        borg_keypress('s');
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /* Reverse flow */
+    borg_flow_reverse();
+
+    /* Scan the entire map */
+    for (y = 1; y < AUTO_MAX_Y-1; y++)
+    {
+        for (x = 1; x < AUTO_MAX_X-1; x++)
+        {
+            borg_grid *ag_ptr[8];
+
+            int wall = 0;
+            int supp = 0;
+            int diag = 0;
+			int monsters = 0;
+
+            /* Acquire the grid */
+            ag = &borg_grids[y][x];
+
+            /* Skip unknown grids */
+            if (ag->feat == FEAT_NONE) continue;
+
+            /* Skip trap grids */
+            if (ag->feat == FEAT_TRAP_HEAD) continue;
+
+            /* Skip walls/doors */
+            if (!borg_cave_floor_grid(ag)) continue;
+
+            /* Acquire the cost */
+            cost = borg_data_cost->data[y][x];
+
+            /* Skip "unreachable" grids */
+            if (cost >= 250) continue;
+
+            /* Skip grids that are really far away.  He probably
+             * won't find anything and it takes lots of turns
+             */
+            if (cost >= 25 && borg_skill[BI_CLEVEL] < 30) continue;
+            if (cost >= 50) continue;
+
+            /* Tweak -- Limit total searches */
+            if (ag->xtra >= 50) continue;
+
+            /* Limit initial searches until bored */
+            if (!bored && (ag->xtra > 5)) continue;
+
+            /* Avoid searching detected sectors */
+            if (borg_detect_door[y/11][x/33]) continue;
+
+            /* Skip ones that make me wander too far */
+            if (b_stair != -1 && borg_skill[BI_CLEVEL < 10])
+            {
+                /* Check the distance of this grid to the stair */
+                j = distance (track_less_y[b_stair], track_less_x[b_stair],
+                              y, x);
+                /* Distance of me to the stairs */
+                b_j = distance (c_y, c_x, track_less_y[b_stair], track_less_x[b_stair]);
+
+                /* skip far away grids while I am close to stair*/
+                if (b_j <= borg_skill[BI_CLEVEL] * 5 + 9 &&
+                      j >= borg_skill[BI_CLEVEL] * 5 + 9 ) continue;
+
+				/* If really low level don't do this much */
+                if (borg_skill[BI_CLEVEL] <= 3 &&
+                	b_j <= borg_skill[BI_CLEVEL] + 9 &&
+                      j >= borg_skill[BI_CLEVEL] + 9 ) continue;
+
+				/* Do not Venture too far from stair */
+                if (borg_skill[BI_CLEVEL] <= 3 &&
+                      j >= borg_skill[BI_CLEVEL] + 5 ) continue;
+
+				/* Do not Venture too far from stair */
+                if (borg_skill[BI_CLEVEL] <= 10 &&
+                      j >= borg_skill[BI_CLEVEL] + 9 ) continue;
+            }
+
+
+            /* Extract adjacent locations */
+            for (i = 0; i < 8; i++)
+            {
+                /* Extract the location */
+                int xx = x + ddx_ddd[i];
+                int yy = y + ddy_ddd[i];
+
+                /* Get the grid contents */
+                ag_ptr[i] = &borg_grids[yy][xx];
+            }
+
+
+            /* Count possible door locations */
+            for (i = 0; i < 4; i++)
+            {
+                ag = ag_ptr[i];
+                if (ag->feat >= FEAT_WALL_EXTRA) wall++;
+            }
+
+            /* No possible secret doors */
+            if (wall < 1) continue;
+
+
+            /* Count supporting evidence for secret doors */
+            for (i = 0; i < 4; i++)
+            {
+                ag = ag_ptr[i];
+
+                /* Rubble */
+                if (ag->feat == FEAT_RUBBLE) continue;
+
+                /* Walls, Doors */
+                if (((ag->feat >= FEAT_SECRET) && (ag->feat <= FEAT_PERM_SOLID)) ||
+                    ((ag->feat == FEAT_OPEN) || (ag->feat == FEAT_BROKEN)) ||
+                    ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_DOOR_TAIL)))
+                {
+                    supp++;
+                }
+            }
+
+            /* Count supporting evidence for secret doors */
+            for (i = 4; i < 8; i++)
+            {
+                ag = ag_ptr[i];
+
+                /* Rubble */
+                if (ag->feat == FEAT_RUBBLE) continue;
+
+                /* Walls */
+                if (ag->feat >= FEAT_SECRET)
+                {
+                    diag++;
+                }
+            }
+
+            /* No possible secret doors */
+            if (diag < 2) continue;
+
+            /* Count monsters */
+            for (i = 0; i < 8; i++)
+            {
+                ag = ag_ptr[i];
+
+                /* monster */
+                if (ag->kill) monsters ++;
+            }
+
+			/* No search near monsters */
+			if (monsters >= 1) continue;
+
+            /* Tweak -- Reward walls, punish visitation and distance */
+            v = (supp * 500) + (diag * 100) - (ag->xtra * 20) - (cost * 1);
+
+            /* The grid is not searchable */
+            if (v <= 0) continue;
+
+
+            /* Tweak -- Minimal interest until bored */
+            if (!bored && (v < 1500)) continue;
+
+
+            /* Track "best" grid */
+            if ((b_v >= 0) && (v < b_v)) continue;
+
+            /* Save the data */
+            b_v = v; b_x = x; b_y = y;
+        }
+    }
+
+    /* Clear the flow codes */
+    borg_flow_clear();
+
+    /* Hack -- Nothing found */
+    if (b_v < 0) return (FALSE);
+
+
+    /* Access grid */
+    ag = &borg_grids[b_y][b_x];
+
+    /* Memorize */
+    spastic_x = b_x;
+    spastic_y = b_y;
+
+
+    /* Enqueue the grid */
+    borg_flow_enqueue_grid(b_y, b_x);
+
+    /* Spread the flow */
+    borg_flow_spread(250, TRUE, FALSE, FALSE);
+
+    /* Attempt to Commit the flow */
+    if (!borg_flow_commit("spastic", GOAL_XTRA)) return (FALSE);
+
+    /* Take one step */
+    if (!borg_flow_old(GOAL_XTRA)) return (FALSE);
+
+    /* Success */
+    return (TRUE);
+}
+
+
+
+
+/*
+ * Initialize this file
+ */
+void borg_init_6(void)
+{
+    /* Nothing */
+}
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg6.h angband-3.0.6-borg/src/borg6.h
--- angband-3.0.6/src/borg6.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg6.h	2003-09-03 17:56:16.000000000 -0700
@@ -0,0 +1,131 @@
+/* File: borg6.h */
+
+/* Purpose: Header file for "borg6.c" -BEN- */
+
+#ifndef INCLUDED_BORG6_H
+#define INCLUDED_BORG6_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg6.c".
+ */
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+
+/*
+ * Possible values of "goal"
+ */
+#define GOAL_KILL   1       /* Monsters */
+#define GOAL_TAKE   2       /* Objects */
+#define GOAL_MISC   3       /* Stores */
+#define GOAL_DARK   4       /* Exploring */
+#define GOAL_XTRA   5       /* Searching */
+#define GOAL_BORE   6       /* Leaving */
+#define GOAL_FLEE   7       /* Fleeing */
+
+
+/*
+ * Minimum "harmless" food
+ */
+
+#define SV_FOOD_MIN_OKAY    SV_FOOD_CURE_POISON
+
+
+
+/*
+ * Attempt to induce "word of recall"
+ */
+extern bool borg_recall(void);
+
+/*
+ * Low level goals
+ */
+extern bool borg_caution(void);
+extern bool borg_attack(bool boosted_bravery);
+extern bool borg_recover(void);
+
+extern bool borg_offset_ball(void);
+extern bool borg_defend(int p);
+extern bool borg_perma_spell(void);
+
+extern bool borg_check_rest(void);
+
+/*
+ * Twitchy goals
+ */
+extern bool borg_charge_kill(void);
+extern bool borg_charge_take(void);
+extern bool borg_twitchy(void);
+
+
+
+/*
+ * Continue a high level goal
+ */
+extern bool borg_flow_old(int why);
+
+/*
+ * Flow to stairs
+ */
+extern bool borg_flow_stair_both(int why);
+extern bool borg_flow_stair_less(int why);
+extern bool borg_flow_stair_more(int why);
+
+
+extern bool borg_flow_glyph(int why);
+extern bool borg_flow_light(int why);
+extern bool borg_check_lite_only(void);
+extern bool borg_backup_swap(int p);
+
+/*
+ * Flow to shops
+ */
+extern bool borg_flow_shop_visit(void);
+extern bool borg_flow_shop_entry(int n);
+
+/*
+ * Flow towards monsters/objects
+ */
+extern bool borg_flow_kill(bool viewable, int nearness);
+extern bool borg_flow_kill_aim(bool viewable);
+extern bool borg_flow_kill_corridor(bool viewable);
+extern bool borg_flow_take(bool viewable, int nearness);
+extern bool borg_flow_take_lunal(bool viewable, int nearness);
+extern void borg_flow_direct_dig(int m_y, int m_x);
+
+/*
+ * Flow towards "interesting" grids
+ */
+extern bool borg_flow_dark(bool neer);
+
+/*
+ * Search for secret doors
+ */
+extern bool borg_flow_spastic(bool bored);
+
+extern bool borg_target(int y, int x);
+extern int borg_launch_damage_one(int i, int dam, int typ);
+extern int borg_attack_aux_thrust(void);
+
+
+extern void borg_log_battle(bool);
+extern void borg_log_event(cptr event);
+extern bool borg_target_unknown_wall(int g_y,int g_x);
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_6(void);
+
+
+
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg7.c angband-3.0.6-borg/src/borg7.c
--- angband-3.0.6/src/borg7.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg7.c	2005-10-24 20:15:26.000000000 -0700
@@ -0,0 +1,5048 @@
+/* File: borg7.c */
+/* Purpose: High level functions for the Borg -BEN- */
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg4.h"
+#include "borg5.h"
+#include "borg6.h"
+#include "borg7.h"
+
+
+/*
+ * This file handles various high level inventory related goals.
+ *
+ * Problems:
+ *   Use "time stamps" (and not "random" checks) for several routines,
+ *   including "kill junk" and "wear stuff", and maybe even "free space".
+ *   But be careful with the "free space" routine, wear stuff first.
+ *   Make sure nothing is "destroyed" if we do not do them every turn.
+ *   Consider some special routines in stores (and in the home).
+ *
+ * Hack -- We should perhaps consider wearing "harmless" items into empty
+ * slots when in the dungeon, to allow rings/amulets to be brought back up
+ * to town to be sold.
+ *
+ * We should take account of possible combinations of equipment.  This may
+ * be a potentially expensive computation, but could be done occasionally.
+ * It is important to use a "state-less" formula to allow the exchange to
+ * be spread over multiple turns.
+ *
+ * Hack -- We should attempt to only collect non-discounted items, at least
+ * for the "expensive" slots, such as books, since we do not want to lose
+ * value due to stacking.  We seem to sell the non-discounted items first,
+ * and to buy the discounted items first, since they are cheap.  Oh well,
+ * we may just be stuck with using discounted books.  Unless we actually
+ * do correct "combining" in the simulations, and reward free slots.  Ick!
+ *
+ * XXX XXX XXX We really need a better "twitchy" function.
+ *
+ * XXX XXX XXX We need a better "flee this level" function
+ *
+ * XXX XXX XXX We need to stockpile possible useful items at home.
+ *
+ * XXX XXX XXX Perhaps we could simply maintain a list of abilities
+ * that we might need at some point, such as the ability to identify, and
+ * simply allow the Borg to "sell" items to the home which satisfy this
+ * desire for "abilities".
+ *
+ * XXX XXX XXX Also, we should probably attempt to track the "best" item
+ * in the home for each equipment slot, using some form of heuristic, and
+ * reward that item based on its power, so that the Borg would always
+ * have a "backup" item in case of disenchantment.
+ *
+ * XXX XXX XXX Also, we could reward equipment based on possible enchantment,
+ * up to the maximal amount available in the home, which would induce item
+ * switching when the item could be enchanted sufficiently.
+ *
+ * Fleeing from fast spell-casters is probably not a very smart idea, nor is
+ * fleeing from fast monsters, nor is attempting to clear a room full of fast
+ * moving breeding monsters, such as lice.
+ */
+
+
+
+/*
+ * Hack -- importance of the various "level feelings"
+ * Try to explore the level for at least this many turns
+ */
+static s16b value_feeling[] =
+{
+    500,
+    8000,
+    8000,
+    6000,
+    4000,
+    2000,
+    1000,
+    800,
+    600,
+    400,
+    200,
+    0
+};
+
+
+
+
+/*
+ * Determine if an item is "probably" worthless
+ *
+ * This (very heuristic) function is a total hack, designed only to prevent
+ * a very specific annoying situation described below.
+ *
+ * Note that a "cautious" priest (or low level mage/ranger) will leave town
+ * with a few identify scrolls, wander around dungeon level 1 for a few turns,
+ * and use all of the scrolls on leather gloves and broken daggers, and must
+ * then return to town for more scrolls.  This may repeat indefinitely.
+ *
+ * The problem is that some characters (priests, mages, rangers) never get an
+ * "average" feeling about items, and have no way to keep track of how long
+ * they have been holding a given item for, so they cannot even attempt to
+ * gain knowledge from the lack of "good" or "cursed" feelings.  But they
+ * cannot afford to just identify everything they find by using scrolls of
+ * identify, because, in general, some items are, on average, "icky", and
+ * not even worth the price of a new scroll of identify.
+ *
+ * Even worse, the current algorithm refuses to sell un-identified items, so
+ * the poor character will throw out all his good stuff to make room for crap.
+ *
+ * This function simply examines the item and assumes that certain items are
+ * "icky", which is probably a total hack.  Perhaps we could do something like
+ * compare the item to the item we are currently wearing, or perhaps we could
+ * analyze the expected value of the item, or guess at the likelihood that the
+ * item might be a blessed, or something.
+ *
+ */
+bool borg_item_icky(borg_item *item)
+{
+    int slot;
+
+
+    /* if its average, dump it if you want to.*/
+    if (streq(item->note, "{average}")) return (TRUE);
+
+    /* Mega-Hack -- allow "icky" items */
+    if (borg_class == CLASS_PRIEST ||
+        borg_class == CLASS_RANGER ||
+        borg_class == CLASS_MAGE ||
+        borg_skill[BI_CLEVEL] < 20)
+    {
+        /* things that are good/excelent/special */
+        if (strstr(item->note, "special}") ||
+            strstr(item->note, "terrible}") ||
+            strstr(item->note, "indestructible}") ||
+            streq(item->note, "{excellent}"))
+            /* not icky */
+            return (FALSE);
+
+        /* Broken dagger/sword, Filthy rag */
+        if (((item->tval == TV_SWORD) && (item->sval == SV_BROKEN_DAGGER)) ||
+            ((item->tval == TV_SWORD) && (item->sval == SV_BROKEN_SWORD)) ||
+            ((item->tval == TV_SOFT_ARMOR) && (item->sval == SV_FILTHY_RAG)))
+        {
+            return (TRUE);
+        }
+
+        /* Dagger */
+        if ((item->tval == TV_SWORD) && (item->sval == SV_DAGGER))
+        {
+            return (TRUE);
+        }
+
+        /* Sling (and I already got one) */
+        if ((item->tval == TV_BOW) && (item->sval == SV_SLING) &&
+        	borg_items[INVEN_BOW].tval == TV_BOW)
+        {
+            return (TRUE);
+        }
+
+        /* Cloak, (and I already got one)*/
+        if ((item->tval == TV_CLOAK) && (item->sval == SV_CLOAK) &&
+        	borg_items[INVEN_OUTER].tval == TV_CLOAK)
+        {
+            return (TRUE);
+        }
+
+        /* Robe (and I already got one)*/
+        if ((item->tval == TV_SOFT_ARMOR) && (item->sval == SV_ROBE) &&
+        	borg_items[INVEN_BODY].tval >= TV_SOFT_ARMOR)
+        {
+            return (TRUE);
+        }
+
+        /* Leather Gloves (and I already got one)*/
+        if ((item->tval == TV_GLOVES) &&
+            (item->sval == SV_SET_OF_LEATHER_GLOVES) &&
+        	borg_items[INVEN_HANDS].tval == TV_GLOVES)
+        {
+            return (TRUE);
+        }
+
+        /* Assume the item is not icky */
+        return (FALSE);
+    }
+
+    /* Process other classes which do get pseudo ID */
+        /* things that are good/excelent/special/no P-ID */
+        if  (strstr(item->note, "special}") ||
+             strstr(item->note, "terrible}") ||
+             streq(item->note, "{excellent}") ||
+             strstr(item->note, "indestructible}") ||
+             !item->note )  /* no pseudo-id yet */
+             /* not icky */
+             return (FALSE);
+
+
+        /*** {Good} items in inven, But I have {excellent} in equip ***/
+
+        if (streq(item->note, "{good}"))
+        {
+            /* Obtain the slot of the suspect item */
+            slot = borg_wield_slot(item);
+
+			/* safety check incase slot = -1 */
+			if (slot < 0) return (FALSE);
+
+            /* Obtain my equipped item in the slot */
+            item = &borg_items[slot];
+
+            /* Is my item an ego or artifact? */
+            if (item->name2 || item->name1) return (TRUE);
+        }
+    /* Assume not icky, I should have extra ID for the item */
+    return (FALSE);
+}
+
+
+
+
+/*
+ * Use things in a useful, but non-essential, manner
+ */
+bool borg_use_things(void)
+{
+    int i;
+
+    /* Quaff experience restoration potion */
+    if (borg_skill[BI_ISFIXEXP] &&
+       (borg_prayer(6,4) ||
+        borg_activate_artifact(ACT_RESTORE_LIFE, INVEN_OUTER) ||
+        borg_quaff_potion(SV_POTION_RESTORE_EXP)))
+    {
+        return (TRUE);
+    }
+
+    /* just drink the stat gains, at this dlevel we wont need cash */
+    if ( borg_quaff_potion(SV_POTION_INC_STR) ||
+         borg_quaff_potion(SV_POTION_INC_INT) ||
+         borg_quaff_potion(SV_POTION_INC_WIS) ||
+         borg_quaff_potion(SV_POTION_INC_DEX) ||
+         borg_quaff_potion(SV_POTION_INC_CON) ||
+         borg_quaff_potion(SV_POTION_INC_CHR))
+    {
+        return (TRUE);
+    }
+
+    /* Quaff potions of "restore" stat if needed */
+    if ( (borg_skill[BI_ISFIXSTR] &&
+         (borg_quaff_potion(SV_POTION_RES_STR) ||
+          borg_quaff_potion(SV_POTION_INC_STR) ||
+          borg_eat_food(SV_FOOD_RESTORE_STR)||
+          borg_eat_food(SV_FOOD_RESTORING))) ||
+        (borg_skill[BI_ISFIXINT] &&
+         (borg_quaff_potion(SV_POTION_RES_INT) ||
+          borg_quaff_potion(SV_POTION_INC_INT) ||
+          borg_eat_food(SV_FOOD_RESTORING))) ||
+        (borg_skill[BI_ISFIXWIS] &&
+         (borg_quaff_potion(SV_POTION_RES_WIS) ||
+          borg_quaff_potion(SV_POTION_INC_WIS) ||
+          borg_eat_food(SV_FOOD_RESTORING))) ||
+        (borg_skill[BI_ISFIXDEX] &&
+         (borg_quaff_potion(SV_POTION_RES_DEX) ||
+          borg_quaff_potion(SV_POTION_INC_DEX) ||
+          borg_eat_food(SV_FOOD_RESTORING))) ||
+        (borg_skill[BI_ISFIXCON] &&
+         (borg_quaff_potion(SV_POTION_RES_CON) ||
+          borg_quaff_potion(SV_POTION_INC_CON) ||
+          borg_eat_food(SV_FOOD_RESTORE_CON) ||
+          borg_eat_food(SV_FOOD_RESTORING))) ||
+        ((borg_skill[BI_ISFIXCHR]) &&
+         (borg_quaff_potion(SV_POTION_RES_CHR) ||
+          borg_quaff_potion(SV_POTION_INC_CHR)||
+          borg_eat_food(SV_FOOD_RESTORING))))
+    {
+        return (TRUE);
+    }
+
+
+    /* Use some items right away */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Process "force" items */
+        switch (item->tval)
+        {
+            case TV_POTION:
+            {
+                /* Check the scroll */
+                switch (item->sval)
+                {
+                    case SV_POTION_ENLIGHTENMENT:
+
+                        /* Never quaff these in town */
+                        if (!borg_skill[BI_CDEPTH]) break;
+
+                    case SV_POTION_AUGMENTATION:
+                    case SV_POTION_EXPERIENCE:
+
+                        /* Try quaffing the potion */
+                        if (borg_quaff_potion(item->sval)) return (TRUE);
+                }
+
+                break;
+            }
+            case TV_SCROLL:
+            {
+                /* Hack -- check Blind/Confused */
+                if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) break;
+
+                /* XXX XXX XXX Dark */
+
+                /* Check the scroll */
+                switch (item->sval)
+                {
+                    case SV_SCROLL_MAPPING:
+                    case SV_SCROLL_DETECT_TRAP:
+                    case SV_SCROLL_DETECT_DOOR:
+                    case SV_SCROLL_ACQUIREMENT:
+                    case SV_SCROLL_STAR_ACQUIREMENT:
+                    {
+                        /* Never read these in town */
+                        if (!borg_skill[BI_CDEPTH]) break;
+
+                        /* Try reading the scroll */
+                        if (borg_read_scroll(item->sval)) return (TRUE);
+                        break;
+                    }
+                }
+
+                break;
+            }
+        }
+    }
+
+    /* Eat food */
+    if (borg_skill[BI_ISHUNGRY])
+    {
+        /* Attempt to satisfy hunger */
+        if (borg_spell(2, 0) ||
+            borg_prayer(1, 5)||
+            borg_eat_food(SV_FOOD_SLIME_MOLD)||
+            borg_eat_food(SV_FOOD_BISCUIT)||
+            borg_eat_food(SV_FOOD_JERKY) ||
+            borg_eat_food(SV_FOOD_WAYBREAD) ||
+            borg_eat_food(SV_FOOD_RATION))
+        {
+            return (TRUE);
+        }
+    }
+
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+
+
+/*
+ * Refuel, call lite, detect traps/doors/walls/evil, etc
+ *
+ * Note that we refuel whenever our lite starts to get low.
+ *
+ * Note that we detect traps/doors/walls/evil at least once in each
+ * panel, as soon as possible after entering a new panel.
+ *
+ * Note that we call lite whenever the current grid is dark, and
+ * all the grids touching the current grid diagonally are known
+ * floors, which catches all rooms, including "checkerboard" rooms,
+ * and only occasionally calls lite in corridors, and then only once.
+ *
+ * Note that we also sometimes call lite whenever we are using a
+ * lantern or artifact lite, and when all of the grids in the box
+ * of grids containing the maximal torch-lit region (the 5x5 or 7x7
+ * region centered at the player) are non-glowing floor grids, and
+ * when at least one of them is known to be "dark".  This catches
+ * most of the "probable rooms" before the standard check succeeds.
+ *
+ * We use the special "SELF" messages to "borg_react()" to delay the
+ * processing of "detection" and "call lite" until we know if it has
+ * worked or not.
+ *
+ * The matching function borg_check_lite_only is used only with resting
+ * to heal.  I don't want him teleporting into a room, resting to heal while
+ * there is a dragon sitting in a dark corner waiting to breathe on him.
+ * So now he will check for lite.
+ *
+ */
+bool borg_check_lite(void)
+{
+    int i, x, y;
+    int corners, floors;
+	int floor_goal;
+	byte feat;
+
+    int q_x, q_y;
+
+    borg_grid *ag;
+
+
+    bool do_lite;
+
+    bool do_trap;
+    bool do_door;
+    bool do_wall;
+    bool do_evil;
+
+    bool do_lite_aux = FALSE;
+
+    /* Never in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Never when comprimised, save your mana */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED] || borg_skill[BI_ISIMAGE] || borg_skill[BI_ISPOISONED] ||
+        borg_skill[BI_ISCUT] || borg_skill[BI_ISWEAK]) return (FALSE);
+
+    /* XXX XXX XXX Dark */
+
+
+    /* Extract the panel */
+    q_x = w_x / 33;
+    q_y = w_y / 11;
+
+
+    /* Start */
+    do_trap = FALSE;
+
+    /* Determine if we need to detect traps */
+    if (!borg_detect_trap[q_y+0][q_x+0]) do_trap = TRUE;
+    if (!borg_detect_trap[q_y+0][q_x+1]) do_trap = TRUE;
+    if (!borg_detect_trap[q_y+1][q_x+0]) do_trap = TRUE;
+    if (!borg_detect_trap[q_y+1][q_x+1]) do_trap = TRUE;
+
+    /* Hack -- check traps every few turns anyway */
+    if (!when_detect_traps || (borg_t - when_detect_traps >= 183)) do_trap = TRUE;
+
+
+    /* Start */
+    do_door = FALSE;
+
+    /* Determine if we need to detect doors */
+    if (!borg_detect_door[q_y+0][q_x+0]) do_door = TRUE;
+    if (!borg_detect_door[q_y+0][q_x+1]) do_door = TRUE;
+    if (!borg_detect_door[q_y+1][q_x+0]) do_door = TRUE;
+    if (!borg_detect_door[q_y+1][q_x+1]) do_door = TRUE;
+
+    /* Hack -- check doors every few turns anyway */
+    if (!when_detect_doors || (borg_t - when_detect_doors >= 731)) do_door = TRUE;
+
+    /* Start */
+    do_wall = FALSE;
+
+    /* Determine if we need to detect walls */
+    if (!borg_detect_wall[q_y+0][q_x+0]) do_wall = TRUE;
+    if (!borg_detect_wall[q_y+0][q_x+1]) do_wall = TRUE;
+    if (!borg_detect_wall[q_y+1][q_x+0]) do_wall = TRUE;
+    if (!borg_detect_wall[q_y+1][q_x+1]) do_wall = TRUE;
+
+    /* Hack -- check walls every few turns anyway */
+    if (!when_detect_walls || (borg_t - when_detect_walls >= 937)) do_wall = TRUE;
+
+
+    /* Start */
+    do_evil = FALSE;
+
+    /* Determine if we need to detect evil */
+    if (!borg_detect_evil[q_y+0][q_x+0]) do_evil = TRUE;
+    if (!borg_detect_evil[q_y+0][q_x+1]) do_evil = TRUE;
+    if (!borg_detect_evil[q_y+1][q_x+0]) do_evil = TRUE;
+    if (!borg_detect_evil[q_y+1][q_x+1]) do_evil = TRUE;
+
+    /* Hack -- check evil every few turns anyway- more fq if low level */
+    if (!when_detect_evil ||
+       (borg_t - when_detect_evil  >= 183 - (80 - borg_skill[BI_MAXCLEVEL]))) do_evil = TRUE;
+	/* Really low level */
+    if (borg_skill[BI_CLEVEL] <= 3 &&
+    	(!when_detect_evil ||
+        (borg_t - when_detect_evil  >= 50))) do_evil = TRUE;
+
+	/* Not too frequent in town */
+    if (borg_skill[BI_CDEPTH] == 0 &&
+    	(!when_detect_evil ||
+        (borg_t - when_detect_evil  >= 250))) do_evil = TRUE;
+
+    /* Dont bother if I have ESP */
+    if (borg_skill[BI_ESP]) do_evil = FALSE;
+
+    /*** Do Things ***/
+
+    /* Hack -- find traps and doors and evil*/
+    if ((do_trap || do_door || do_evil) &&
+        ((!when_detect_traps || (borg_t - when_detect_traps >= 5)) ||
+         (!when_detect_evil || (borg_t - when_detect_evil >= 5)) ||
+         (!when_detect_doors || (borg_t - when_detect_doors >= 5))) &&
+         borg_skill[BI_CDEPTH]) 	/* Never in town */
+    {
+
+
+        /* Check for traps and doors and evil*/
+        if (borg_activate_artifact(ACT_DETECT, INVEN_WIELD) ||
+            borg_zap_rod(SV_ROD_DETECTION) ||
+            borg_prayer_fail(5, 1, 40))
+        {
+            borg_note("# Checking for traps, doors, and evil.");
+
+            borg_react("SELF:TDE", "SELF:TDE");
+
+            when_detect_traps = borg_t;
+            when_detect_doors = borg_t;
+            when_detect_evil =  borg_t;
+
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- find evil */
+    if (do_evil &&
+        (!when_detect_evil || (borg_t - when_detect_evil >= 5)))
+    {
+        /* Check for evil */
+        if (borg_prayer_fail(0, 0, 40) ||
+            borg_spell_fail(0, 1, 40))
+        {
+            borg_note("# Checking for monsters.");
+
+            borg_react("SELF:evil", "SELF:evil");
+
+            when_detect_evil = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+    /* Hack -- find traps and doors */
+    if ((do_trap || do_door) &&
+        ((!when_detect_traps || (borg_t - when_detect_traps >= 5)) ||
+         (!when_detect_doors || (borg_t - when_detect_doors >= 5))) &&
+         borg_skill[BI_CDEPTH]) 	/* Never in town */
+    {
+        /* Check for traps and doors */
+        if (borg_activate_artifact(ACT_DETECT, INVEN_WIELD) ||
+            borg_spell_fail(0, 7, 40) ||
+            borg_prayer_fail(0, 6, 40))
+        {
+            borg_note("# Checking for traps and doors.");
+
+            borg_react("SELF:both", "SELF:both");
+
+            when_detect_traps = borg_t;
+            when_detect_doors = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+
+    /* Hack -- find traps */
+    if (do_trap &&
+        (!when_detect_traps || (borg_t - when_detect_traps >= 7)) &&
+         borg_skill[BI_CDEPTH]) 	/* Never in town */
+    {
+        /* Check for traps */
+        if (borg_activate_artifact(ACT_DETECT, INVEN_WIELD) ||
+        	borg_read_scroll(SV_SCROLL_DETECT_TRAP) ||
+            borg_use_staff(SV_STAFF_DETECT_TRAP) ||
+            borg_zap_rod(SV_ROD_DETECT_TRAP) ||
+            borg_prayer_fail(0, 5, 40))
+        {
+            borg_note("# Checking for traps.");
+
+            borg_react("SELF:trap", "SELF:trap");
+
+            when_detect_traps = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+
+    /* Hack -- find doors */
+    if (do_door &&
+        (!when_detect_doors || (borg_t - when_detect_doors >= 9)) &&
+         borg_skill[BI_CDEPTH]) 	/* Never in town */
+    {
+        /* Check for traps */
+        if (borg_activate_artifact(ACT_DETECT, INVEN_WIELD) ||
+        	borg_read_scroll(SV_SCROLL_DETECT_DOOR) ||
+            borg_use_staff(SV_STAFF_DETECT_DOOR) ||
+            borg_zap_rod(SV_ROD_DETECT_DOOR) ||
+            borg_prayer_fail(0, 6, 40))
+        {
+            borg_note("# Checking for doors.");
+
+            borg_react("SELF:door", "SELF:door");
+
+            when_detect_doors = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+
+    /* Hack -- find walls */
+    if (do_wall &&
+        (!when_detect_walls || (borg_t - when_detect_walls >= 15)) &&
+         borg_skill[BI_CDEPTH]) 	/* Never in town */
+    {
+        /* Check for walls */
+        if (borg_activate_artifact(ACT_MAGIC_MAP, INVEN_LITE) ||
+            borg_read_scroll(SV_SCROLL_MAPPING) ||
+            borg_use_staff(SV_STAFF_MAPPING) ||
+            borg_zap_rod(SV_ROD_MAPPING) ||
+            borg_prayer(2, 6))
+        {
+            borg_note("# Checking for walls.");
+
+            borg_react("SELF:wall", "SELF:wall");
+
+            when_detect_walls = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+    /* Never in town for the rest of this check */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Start */
+    do_lite = FALSE;
+
+    /* Get central grid */
+    ag = &borg_grids[c_y][c_x];
+
+    corners = 0;
+    floors = 0;
+
+    /* Scan diagonal neighbors */
+    for (i = 4; i < 8; i++)
+    {
+        /* Get location */
+        x = c_x + ddx_ddd[i];
+        y = c_y + ddy_ddd[i];
+
+		/* Bounds check */
+        if (!in_bounds_fully(y,x)) continue;
+
+        /* Get grid */
+        ag = &borg_grids[y][x];
+
+        /* Location must be known */
+        if (ag->feat == FEAT_NONE) corners ++;
+
+        /* Location must not be a wall/door */
+        if (!borg_cave_floor_grid(ag)) corners ++;
+
+     }
+     /* Add them up */
+     if (corners <= 2) do_lite = TRUE;
+
+    /* Hack are we in a dark room? */
+    if (do_lite && (borg_skill[BI_CURLITE] >= 2) &&
+        (c_x >= borg_skill[BI_CURLITE]) && (c_x < AUTO_MAX_X - borg_skill[BI_CURLITE]) &&
+        (c_y >= borg_skill[BI_CURLITE]) && (c_y < AUTO_MAX_Y - borg_skill[BI_CURLITE]) &&
+        (rand_int(100) < 90))
+    {
+		/*       #.#
+		 *       #.#
+		 *  ######@######
+		 *  #...........#
+		 *  #...........#
+		 *  #...........#
+		 *  #...........#
+		 *  #...........#
+		 *  #############
+		 */
+
+		/* Lantern */
+		if (borg_skill[BI_CURLITE] ==2) floor_goal = 11;
+
+		/* lantern and glowing items */
+		if (borg_skill[BI_CURLITE] == 3) floor_goal = 11;
+
+        floors = 0;
+        /* Scan the "local" grids (5x5) 2 same as lantern/torch grid*/
+        for (y = c_y - 2; y <= c_y + 2; y++)
+        {
+            /* Scan the "local" grids (5x5) */
+            for (x = c_x - 2; x <= c_x + 2; x++)
+            {
+
+				/* Bounds check */
+            	if (!in_bounds_fully(y,x)) continue;
+
+            	/* Get grid */
+                ag = &borg_grids[y][x];
+                feat = cave_feat[y][x]; /* Cheat this grid from game */
+
+                /* Location must be a lit floor */
+                if (ag->info & BORG_LITE) floors ++;
+
+                /* Location must not be glowing */
+                if (ag->info & BORG_GLOW ||
+                    feat == CAVE_GLOW) floors --;
+
+                /* Location must not be a wall/door */
+                if (!borg_cave_floor_grid(ag)) floors --;
+
+            }
+        }
+    }
+    /* add them up */
+    if (floors <= 11) do_lite = do_lite_aux = FALSE;
+
+
+    /* Hack -- call lite */
+    if (do_lite &&
+        (!when_call_lite || (borg_t - when_call_lite >= 7)))
+    {
+        /* Call light */
+        if (borg_activate_artifact(ACT_ILLUMINATION, INVEN_LITE) ||
+            borg_zap_rod(SV_ROD_ILLUMINATION) ||
+            borg_use_staff(SV_STAFF_LITE) ||
+            borg_read_scroll(SV_SCROLL_LIGHT) ||
+            borg_spell(0, 3) ||
+            borg_prayer(0, 4))
+        {
+            borg_note("# Illuminating the room");
+            borg_react("SELF:lite", "SELF:lite");
+
+            when_call_lite = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+
+    /* Hack -- Wizard Lite */
+    if (TRUE &&
+        (!when_wizard_lite || (borg_t - when_wizard_lite >= 1000)))
+    {
+        /* Wizard lite */
+        if (borg_activate_artifact(ACT_CLAIRVOYANCE, INVEN_LITE) ||
+            borg_prayer(5, 4))
+        {
+            borg_note("# Illuminating the dungeon");
+
+            /* borg_react("SELF:wizard lite", "SELF:wizard lite"); */
+
+            when_wizard_lite = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+
+    /* Oops */
+    return (FALSE);
+}
+bool borg_check_lite_only(void)
+{
+    int i, x, y;
+    int corners, floors;
+
+    int q_x, q_y;
+
+    borg_grid *ag;
+
+
+    bool do_lite;
+
+    bool do_lite_aux = FALSE;
+
+
+    /* Never in town */
+    if (!borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Never when blind or hallucinating */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISIMAGE]) return (FALSE);
+
+    /* XXX XXX XXX Dark */
+
+
+    /* Extract the panel */
+    q_x = w_x / 33;
+    q_y = w_y / 11;
+
+    /* Start */
+    do_lite = FALSE;
+
+    /* Get central grid */
+    ag = &borg_grids[c_y][c_x];
+
+    corners = 0;
+    floors = 0;
+
+    /* Scan diagonal neighbors */
+    for (i = 4; i < 8; i++)
+    {
+        /* Get location */
+        x = c_x + ddx_ddd[i];
+        y = c_y + ddy_ddd[i];
+
+		/* Bounds check */
+        if (!in_bounds_fully(y,x)) continue;
+
+        /* Get grid */
+        ag = &borg_grids[y][x];
+
+        /* Location must be known */
+        if (ag->feat == FEAT_NONE) corners ++;
+
+        /* Location must not be a wall/door */
+        if (!borg_cave_floor_grid(ag)) corners ++;
+
+     }
+     /* Add them up ..2*/
+     if (corners <= 2) do_lite = TRUE;
+
+    /* Hack */
+    if (do_lite && (borg_skill[BI_CURLITE] >= 2) &&
+        (c_x >= borg_skill[BI_CURLITE]) && (c_x < AUTO_MAX_X - borg_skill[BI_CURLITE]) &&
+        (c_y >= borg_skill[BI_CURLITE]) && (c_y < AUTO_MAX_Y - borg_skill[BI_CURLITE]) &&
+        (rand_int(100) < 90))
+    {
+
+        floors = 0;
+        /* Scan the "local" grids (5x5) 2 same as torch grid*/
+        for (y = c_y - 2; y <= c_y + 2; y++)
+        {
+            /* Scan the "local" grids (5x5) */
+            for (x = c_x - 2; x <= c_x + 2; x++)
+            {
+				/* Bounds check */
+	            if (!in_bounds_fully(y,x)) continue;
+
+                /* Get grid */
+                ag = &borg_grids[y][x];
+
+                /* Location must be a lit floor */
+                if (ag->info & BORG_LITE) floors ++;
+
+                /* Location must not be glowing */
+                if (ag->info & BORG_GLOW) floors --;
+
+                /* Location must not be a wall/door */
+                if (!borg_cave_floor_grid(ag)) floors --;
+
+            }
+        }
+    }
+    /* add them up */
+    if (floors <= 11) do_lite = do_lite_aux = FALSE;
+
+    /* Hack -- call lite */
+    if (do_lite &&
+        (!when_call_lite || (borg_t - when_call_lite >= 7)))
+    {
+        /* Call light */
+        if (borg_activate_artifact(ACT_ILLUMINATION, INVEN_LITE) ||
+            borg_zap_rod(SV_ROD_ILLUMINATION) ||
+            borg_use_staff(SV_STAFF_LITE) ||
+            borg_read_scroll(SV_SCROLL_LIGHT) ||
+            borg_spell_fail(0, 3, 40) ||
+            borg_prayer_fail(0, 4, 40))
+        {
+            borg_note("# Illuminating the room prior to resting");
+
+            borg_react("SELF:lite", "SELF:lite");
+
+            when_call_lite = borg_t;
+
+            /* dont rest. call light instead */
+            return (TRUE);
+        }
+    }
+
+
+    /* Hack -- Wizard Lite */
+    if (TRUE &&
+        (!when_wizard_lite || (borg_t - when_wizard_lite >= 1000)))
+    {
+        /* Wizard lite */
+        if (borg_activate_artifact(ACT_CLAIRVOYANCE, INVEN_LITE) ||
+            borg_prayer_fail(5, 4, 40))
+        {
+            borg_note("# Illuminating the dungeon prior to resting");
+
+            /* borg_react("SELF:wizard lite", "SELF:wizard lite"); */
+
+            when_wizard_lite = borg_t;
+
+            return (TRUE);
+        }
+    }
+
+
+    /* nothing to light up.  OK to rest. */
+    return (FALSE);
+}
+
+
+
+/*
+ * Enchant armor, not including my swap armour
+ */
+static bool borg_enchant_to_a(void)
+{
+    int i, b_i = -1;
+    int a, b_a = 99;
+
+    /* Nothing to enchant */
+    if (!my_need_enchant_to_a) return (FALSE);
+
+    /* Need "enchantment" ability */
+    if ((!amt_enchant_to_a) &&
+        (!amt_enchant_armor)) return (FALSE);
+
+
+    /* Look for armor that needs enchanting */
+    for (i = INVEN_BODY; i < INVEN_TOTAL; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip non-identified items */
+        if (!item->able) continue;
+
+        /* Obtain the bonus */
+        a = item->to_a;
+
+        /* Skip "boring" items */
+        if (borg_spell_okay_fail(7, 2, 65) ||
+            borg_prayer_okay_fail(7, 4, 65) ||
+           amt_enchant_armor >=1)
+        {
+            if (a >= 15) continue;
+        }
+        else
+        {
+            if (a >= 8) continue;
+        }
+
+        /* Find the least enchanted item */
+        if ((b_i >= 0) && (b_a < a)) continue;
+
+        /* Save the info */
+        b_i = i; b_a = a;
+
+    }
+
+    /* Nothing */
+    if (b_i < 0) return (FALSE);
+
+    /* Enchant it */
+    if (borg_spell_fail(7, 2, 65) ||
+        borg_prayer_fail(7, 4, 65) ||
+        borg_read_scroll(SV_SCROLL_STAR_ENCHANT_ARMOR) ||
+        borg_read_scroll(SV_SCROLL_ENCHANT_ARMOR))
+    {
+        /* Choose from equipment */
+        if (b_i >= INVEN_WIELD)
+        {
+            borg_keypress('/');
+
+            /* Choose that item */
+            borg_keypress(I2A(b_i - INVEN_WIELD));
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+
+/*
+ * Enchant weapons to hit
+ */
+static bool borg_enchant_to_h(void)
+{
+    int i, b_i = -1;
+    int a, s_a, b_a = 99;
+
+
+    /* Nothing to enchant */
+    if (!my_need_enchant_to_h &&
+        !enchant_weapon_swap_to_h) return (FALSE);
+
+    /* Need "enchantment" ability */
+    if ( (!amt_enchant_to_h) &&
+         (!amt_enchant_weapon) ) return (FALSE);
+
+
+    /* Look for a weapon that needs enchanting */
+    for (i = INVEN_WIELD; i <= INVEN_BOW; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip non-identified items */
+        if (!item->able) continue;
+
+        /* Obtain the bonus */
+        a = item->to_h;
+
+        /* Skip "boring" items */
+        if (borg_prayer_okay_fail(7, 3, 65) ||
+            borg_spell_okay_fail(7, 3, 65) ||
+            amt_enchant_weapon >= 1 )
+        {
+            if (a >= 15) continue;
+        }
+        else
+        {
+            if (a >= 8) continue;
+        }
+
+		/* Most classes store the enchants until they get
+		 * a 3x shooter (like a long bow).
+		 * Generally, we do not want the x2 shooter enchanted,
+		 * since it wastes scrolls.  But if the sword is at +5
+		 * and the sling at +2, then the sling will be selected
+		 * because its enchantment is lower.  The borg tries to
+		 * enchant the least enchanted item.  This will make sure
+		 * the x2 shooter is skipped and the sword is enchanted,
+		 * if needed.  If the sword is at +9,+9, and the sling at
+		 * +0,+0 and the borg has some enchant scrolls, he should
+		 * store them instead of wasting them on the sling.
+		 */
+		if (i == INVEN_BOW &&  /* bow */
+			my_ammo_power < 3) /* 3x shooter */
+			continue;
+
+        /* Find the least enchanted item */
+        if ((b_i >= 0) && (b_a < a)) continue;
+
+        /* Save the info */
+        b_i = i; b_a = a;
+
+    }
+    if (weapon_swap > 1)
+    {
+    for (i=weapon_swap; i <= weapon_swap; i++)
+    {
+        borg_item *item = &borg_items[weapon_swap];
+
+        /* Obtain the bonus */
+        s_a = item->to_h;
+
+        /* Skip "boring" items */
+        if (borg_prayer_okay_fail(7, 3, 65) ||
+            borg_spell_okay_fail(7, 3, 65) ||
+            amt_enchant_weapon >= 1 )
+        {
+            if (s_a >= 15) continue;
+        }
+        else
+        {
+            if (s_a >= 8) continue;
+        }
+
+        /* Find the least enchanted item */
+        if ((b_i >= 0) && (b_a < s_a)) continue;
+
+        /* Save the info */
+        b_i = weapon_swap; b_a = s_a;
+    }
+    }
+    /* Nothing, check ammo */
+    if (b_i < 0)
+    {
+        /* look through inventory for ammo */
+        for (i = 0; i < INVEN_PACK; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+			/* Only enchant ammo if we have a good shooter,
+			 * otherwise, store the enchants in the home.
+			 */
+			if (my_ammo_power < 3) continue;
+
+            /* Only enchant if qty >= 5 */
+            if (item->iqty < 5) continue;
+
+            /* Skip non-identified items  */
+            if (!item->able) continue;
+
+            /* Make sure it is the right type if missile */
+            if (item->tval != my_ammo_tval) continue;
+
+            /* Obtain the bonus  */
+            a = item->to_h;
+
+            /* Skip items that are already enchanted */
+            if (borg_prayer_okay_fail(7, 3, 65) ||
+                borg_spell_okay_fail(7, 3, 65) ||
+                amt_enchant_weapon >= 1 )
+            {
+                if (a >= 10) continue;
+            }
+            else
+            {
+                if (a >= 8) continue;
+            }
+
+            /* Find the least enchanted item */
+            if ((b_i >= 0) && (b_a < a)) continue;
+
+            /* Save the info  */
+            b_i = i; b_a = a;
+
+        }
+    }
+
+    /* Nothing */
+    if (b_i < 0) return (FALSE);
+
+    /* Enchant it */
+    if (borg_prayer_fail(7, 3, 65) ||
+        borg_spell_fail(7, 3, 65) ||
+        borg_read_scroll(SV_SCROLL_STAR_ENCHANT_WEAPON) ||
+        borg_read_scroll(SV_SCROLL_ENCHANT_WEAPON_TO_HIT))
+    {
+        /* Choose from equipment */
+        if (b_i >= INVEN_WIELD)
+        {
+            borg_keypress('/');
+
+            /* Choose that item */
+            borg_keypress(I2A(b_i - INVEN_WIELD));
+        }
+        else  /* choose the swap or ammo */
+        {
+            borg_keypress(I2A(b_i));
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+
+/*
+ * Enchant weapons to dam
+ */
+static bool borg_enchant_to_d(void)
+{
+    int i, b_i = -1;
+    int a, s_a, b_a = 99;
+
+
+    /* Nothing to enchant */
+    if (!my_need_enchant_to_d &&
+        !enchant_weapon_swap_to_d) return (FALSE);
+
+    /* Need "enchantment" ability */
+    if ( (!amt_enchant_to_d) &&
+         (!amt_enchant_weapon) ) return (FALSE);
+
+
+    /* Look for a weapon that needs enchanting */
+    for (i = INVEN_WIELD; i <= INVEN_BOW; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip non-identified items */
+        if (!item->able) continue;
+
+        /* Obtain the bonus */
+        a = item->to_d;
+
+        /* Skip "boring" items */
+        if (borg_prayer_okay_fail(7, 3, 65) ||
+            borg_spell_okay_fail(7, 3, 65) ||
+            amt_enchant_weapon >= 1 )
+        {
+            if (a >= 15) continue;
+        }
+        else
+        {
+            if (a >= 8) continue;
+        }
+
+		/* Most classes store the enchants until they get
+		 * a 3x shooter (like a long bow).
+		 * Generally, we do not want the x2 shooter enchanted,
+		 * since it wastes scrolls.  But if the sword is at +5
+		 * and the sling at +2, then the sling will be selected
+		 * because its enchantment is lower.  The borg tries to
+		 * enchant the least enchanted item.  This will make sure
+		 * the x2 shooter is skipped and the sword is enchanted,
+		 * if needed.  If the sword is at +9,+9, and the sling at
+		 * +0,+0 and the borg has some enchant scrolls, he should
+		 * store them instead of wasting them on the sling.
+		 */
+		if (i == INVEN_BOW &&  /* bow */
+			my_ammo_power < 3) /* 3x shooter */
+			continue;
+
+        /* Find the least enchanted item */
+        if ((b_i >= 0) && (b_a < a)) continue;
+
+        /* Save the info */
+        b_i = i; b_a = a;
+    }
+    if (weapon_swap > 1)
+    {
+    for (i = weapon_swap; i <= weapon_swap; i++)
+    {
+        borg_item *item = &borg_items[weapon_swap];
+
+        /* Skip non-identified items */
+        if (!item->able) continue;
+
+        /* Obtain the bonus */
+        s_a = item->to_d;
+
+        /* Skip "boring" items */
+        if (borg_prayer_okay_fail(7, 3, 65) ||
+            borg_spell_okay_fail(7, 3, 65) ||
+            amt_enchant_weapon >= 1 )
+        {
+            if (s_a >= 15) continue;
+        }
+        else
+        {
+            if (s_a >= 8) continue;
+        }
+
+        /* Find the least enchanted item */
+        if ((b_i >= 0) && (b_a < s_a)) continue;
+
+        /* Save the info */
+        b_i = weapon_swap; b_a = s_a;
+    }
+    }
+    /* Nothing, check ammo */
+    if (b_i < 0)
+    {
+        /* look through inventory for ammo */
+        for (i = 0; i < INVEN_PACK; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+			/* Only enchant ammo if we have a good shooter,
+			 * otherwise, store the enchants in the home.
+			 */
+			if (my_ammo_power < 3) continue;
+
+            /* Only enchant if qty >= 5 */
+            if (item->iqty < 5) continue;
+
+            /* Skip non-identified items  */
+            if (!item->able) continue;
+
+            /* Make sure it is the right type if missile */
+            if (item->tval != my_ammo_tval) continue;
+
+            /* Obtain the bonus  */
+            a = item->to_d;
+
+            /* Skip items that are already enchanted */
+            if (borg_prayer_okay_fail(7, 3, 65) ||
+                borg_spell_okay_fail(7, 3, 65) ||
+                amt_enchant_weapon >= 1 )
+            {
+                if (a >= 10) continue;
+            }
+            else
+            {
+                if (a >= 8) continue;
+            }
+
+            /* Find the least enchanted item */
+            if ((b_i >= 0) && (b_a < a)) continue;
+
+            /* Save the info  */
+            b_i = i; b_a = a;
+
+        }
+    }
+
+    /* Nothing */
+    if (b_i < 0) return (FALSE);
+
+    /* Enchant it */
+    if (borg_prayer_fail(7, 3, 65) ||
+        borg_spell_fail(7, 3, 65) ||
+        borg_read_scroll(SV_SCROLL_STAR_ENCHANT_WEAPON) ||
+        borg_read_scroll(SV_SCROLL_ENCHANT_WEAPON_TO_DAM))
+    {
+        /* Choose from equipment */
+        if (b_i >= INVEN_WIELD)
+        {
+            borg_keypress('/');
+
+            /* Choose that item */
+            borg_keypress(I2A(b_i - INVEN_WIELD));
+        }
+        else  /* choose the swap or ammo */
+        {
+            borg_keypress(I2A(b_i));
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+/*
+ * Brand Bolts
+ */
+static bool borg_brand_weapon(void)
+{
+    int i, b_i = -1;
+    int a, b_a = 0;
+
+    /* Nothing to brand */
+    if (!my_need_brand_weapon) return (FALSE);
+
+    /* Need "brand" ability */
+    if (!amt_brand_weapon) return (FALSE);
+
+	/* Do this in the dungeon.  Otherwise, he will buy
+	 * 5 missiles in town then brand them.  Buy 5 more,
+	 * enchant those, etc.  He does this until he has 4 or
+	 * more slots of 5 branded arrows, instead of 1 slot of
+	 * 35 arrows.  Waste of slots.
+	 */
+	if (borg_skill[BI_CDEPTH] == 0) return (FALSE);
+
+    /* look through inventory for ammo */
+        for (i = 0; i < INVEN_PACK; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+            /* Only enchant if qty >= 5 */
+            if (item->iqty < 5) continue;
+
+            /* Skip non-identified items  */
+            if (!item->able) continue;
+
+            /* Make sure it is the right type if missile */
+            if (item->tval != my_ammo_tval) continue;
+
+            /* Obtain the bonus  */
+            a = item->to_h;
+
+            /* Skip branded items */
+            if (item->name2) continue;
+
+            /* Find the most enchanted item */
+            if ((b_i >= 0) && (b_a > a)) continue;
+
+            /* Save the info  */
+            b_i = i; b_a = a;
+
+    }
+
+    /* Enchant it */
+    if (borg_activate_artifact(ACT_FIREBRAND, INVEN_BOW) ||
+        borg_spell_fail(7, 5, 65))
+    {
+
+        /* 291 would like a location of the brand */
+        /* choose the or ammo */
+        {
+            borg_keypress(I2A(b_i));
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+/*
+ * Remove Curse
+ */
+static bool borg_decurse_armour(void)
+{
+    /* Nothing to decurse */
+    if (decurse_armour_swap == -1 && !borg_wearing_cursed) return (FALSE);
+
+    /* Ability for heavy curse */
+    if (decurse_armour_swap == 1)
+    {
+        if (-1 == borg_slot(TV_SCROLL,SV_SCROLL_STAR_REMOVE_CURSE) &&
+            !borg_prayer_okay_fail(7,2,40))
+        {
+                return (FALSE);
+        }
+
+        else if (decurse_armour_swap ==1)
+        {
+
+            /* First wear the item */
+            borg_keypress('w');
+            borg_keypress(I2A(armour_swap));
+
+            /* ooops it feels deathly cold */
+            borg_keypress(' ');
+        }
+
+        /* remove the curse */
+        if (borg_read_scroll(SV_SCROLL_STAR_REMOVE_CURSE) ||
+            borg_prayer(7,2) )
+        {
+            /* Shekockazol! */
+            borg_wearing_cursed = FALSE;
+            return (TRUE);
+        }
+
+    }
+
+    /* Ability for light curse */
+    if (decurse_armour_swap == 0 || borg_wearing_cursed)
+    {
+        if (-1 == borg_slot(TV_SCROLL,SV_SCROLL_REMOVE_CURSE) &&
+           (-1 == borg_slot(TV_STAFF,SV_STAFF_REMOVE_CURSE) &&
+            -1 == borg_items[borg_slot(TV_STAFF, SV_STAFF_REMOVE_CURSE)].pval) &&
+           !borg_prayer_okay_fail(1,6,40) )
+            {
+                return (FALSE);
+            }
+
+        if (borg_wearing_cursed)
+        {
+            /* no need to wear it first */
+        }
+        else
+        {
+            /* First wear the item */
+            borg_keypress('w');
+            borg_keypress(I2A(armour_swap));
+
+            /* ooops it feels deathly cold */
+            borg_keypress(' ');
+        }
+        /* remove the curse */
+        if (borg_read_scroll(SV_SCROLL_REMOVE_CURSE) ||
+            borg_use_staff(SV_STAFF_REMOVE_CURSE)||
+            borg_prayer(1,6) )
+        {
+            /* Shekockazol! */
+            borg_wearing_cursed = FALSE;
+            return (TRUE);
+        }
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+/*
+ * Remove Curse
+ * apw
+ */
+static bool borg_decurse_weapon(void)
+{
+    /* Nothing to decurse */
+    if (decurse_weapon_swap == -1) return (FALSE);
+
+    /* Ability for heavy curse */
+    if (decurse_weapon_swap == 1)
+    {
+        if (-1 == borg_slot(TV_SCROLL,SV_SCROLL_STAR_REMOVE_CURSE) &&
+            !borg_prayer_okay_fail(7,2,40))
+            {
+                return (FALSE);
+            }
+
+        /* First wear the item */
+        borg_keypress('w');
+        borg_keypress(I2A(weapon_swap));
+
+        /* ooops it feels deathly cold */
+        borg_keypress(' ');
+
+        /* remove the curse */
+        if (borg_read_scroll(SV_SCROLL_STAR_REMOVE_CURSE) ||
+            borg_prayer(7,2) )
+            {
+                /* Shekockazol! */
+                return (TRUE);
+            }
+    }
+
+        /* Ability for light curse */
+        if (decurse_weapon_swap == 0)
+        {
+            if (-1 == borg_slot(TV_SCROLL,SV_SCROLL_REMOVE_CURSE) &&
+               (-1 == borg_slot(TV_STAFF,SV_STAFF_REMOVE_CURSE) &&
+                -1 == borg_items[borg_slot(TV_STAFF, SV_STAFF_REMOVE_CURSE)].pval) &&
+               !borg_prayer_okay_fail(1,6,40) )
+            {
+                return (FALSE);
+            }
+
+        /* First wear the item */
+        borg_keypress('w');
+        borg_keypress(I2A(weapon_swap));
+
+        /* ooops it feels deathly cold */
+        borg_keypress(' ');
+
+        /* remove the curse */
+        if (borg_read_scroll(SV_SCROLL_REMOVE_CURSE) ||
+            borg_use_staff(SV_STAFF_REMOVE_CURSE)||
+            borg_prayer(1,6) )
+        {
+            /* Shekockazol! */
+            return (TRUE);
+        }
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+/*
+ * Enchant things
+ */
+bool borg_enchanting(void)
+{
+    /* Forbid blind/confused */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+	/* Forbid if Risky Borg (in a hurry) */
+    if (borg_plays_risky &&
+		(borg_t - borg_began > 25 && borg_skill[BI_CDEPTH]) ||
+        (borg_t-borg_began > 50 && !borg_skill[BI_CDEPTH])) return (FALSE);
+
+    /*apw Forbid if been sitting on level forever */
+    /*    Just come back and finish the job later */
+    if ((borg_t - borg_began > 150 && borg_skill[BI_CDEPTH]) ||
+        (borg_t-borg_began > 350 && !borg_skill[BI_CDEPTH])) return (FALSE);
+
+    /* Remove Curses */
+    if (borg_decurse_armour()) return (TRUE);
+    if (borg_decurse_weapon()) return (TRUE);
+
+    /* Enchant things */
+    if (borg_brand_weapon()) return (TRUE);
+    if (borg_enchant_to_h()) return (TRUE);
+    if (borg_enchant_to_d()) return (TRUE);
+    if (borg_enchant_to_a()) return (TRUE);
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Recharge things
+ *
+ * XXX XXX XXX Prioritize available items
+ */
+bool borg_recharging(void)
+{
+    int i = -1;
+    bool charge = FALSE;
+
+
+    /* Forbid blind/confused */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+    /* XXX XXX XXX Dark */
+
+    /* Look for an item to recharge */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip non-identified items */
+        if (!item->able) continue;
+
+        /* assume we can't charge it. */
+        charge = FALSE;
+
+        /* Wands with no charges can be charged */
+        if ((item->tval == TV_WAND) && (item->pval < 1))
+            charge = TRUE;
+
+        /* recharge staves sometimes */
+        if (item->tval == TV_STAFF)
+        {
+            /* Allow staves to be recharged at 2 charges if
+             * the borg has the big recharge spell. And its not a *Dest*
+             */
+            if ((item->pval < 3) &&
+                (borg_spell_okay(7, 4) || borg_spell_okay(2, 1)) &&
+                item->sval < SV_STAFF_POWER)
+                charge = TRUE;
+
+            /* recharge any staff at 0 charges */
+            if (item->pval < 1)
+                charge = TRUE;
+
+            /* Staves of teleport get recharged at 2 charges in town */
+            if ((item->sval == SV_STAFF_TELEPORTATION) &&
+                (item->pval < 3) &&
+                !borg_skill[BI_CDEPTH])
+                charge = TRUE;
+
+            /* They stack.  If quantity is 4 and pval is 1, then there are 4 charges. */
+            if ((item->iqty + item->pval >= 5) && item->pval >= 1) charge = FALSE;
+        }
+
+        /* get the next item if we are not to charge this one */
+        if (!charge) continue;
+
+        /* Attempt to recharge */
+        if (borg_spell(7, 4) ||
+            borg_read_scroll(SV_SCROLL_RECHARGING) ||
+            borg_spell(2, 1) ||
+            borg_prayer(7, 1) ||
+            borg_activate_artifact(ACT_RECHARGE1, INVEN_OUTER))
+        {
+            /* Message */
+            borg_note(format("Recharging %s with current charge of %d", item->desc, item->pval));
+
+            /* Recharge the item */
+            borg_keypress(I2A(i));
+
+            /* Success */
+            return (TRUE);
+        }
+        else
+            /* if we fail once, no need to try again. */
+            break;
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Attempt to consume an item
+ */
+static bool borg_consume(int i)
+{
+    borg_item *item = &borg_items[i];
+
+
+    /* Special destruction */
+    switch (item->tval)
+    {
+        case TV_POTION:
+
+        /* Check the potion */
+        switch (item->sval)
+        {
+            case SV_POTION_WATER:
+            case SV_POTION_APPLE_JUICE:
+            case SV_POTION_SLIME_MOLD:
+            case SV_POTION_CURE_LIGHT:
+            case SV_POTION_CURE_SERIOUS:
+            case SV_POTION_CURE_CRITICAL:
+            case SV_POTION_HEALING:
+            case SV_POTION_STAR_HEALING:
+            case SV_POTION_LIFE:
+            case SV_POTION_RES_STR:
+            case SV_POTION_RES_INT:
+            case SV_POTION_RES_WIS:
+            case SV_POTION_RES_DEX:
+            case SV_POTION_RES_CON:
+            case SV_POTION_RES_CHR:
+            case SV_POTION_RESTORE_EXP:
+            case SV_POTION_RESTORE_MANA:
+            case SV_POTION_HEROISM:
+            case SV_POTION_BERSERK_STRENGTH:
+            case SV_POTION_RESIST_HEAT:
+            case SV_POTION_RESIST_COLD:
+            case SV_POTION_INFRAVISION:
+            case SV_POTION_DETECT_INVIS:
+            case SV_POTION_SLOW_POISON:
+            case SV_POTION_CURE_POISON:
+            case SV_POTION_SPEED:
+
+            /* Try quaffing the potion */
+            if (borg_quaff_potion(item->sval)) return (TRUE);
+        }
+
+        break;
+
+        case TV_SCROLL:
+
+        /* Check the scroll */
+        switch (item->sval)
+        {
+            case SV_SCROLL_REMOVE_CURSE:
+            case SV_SCROLL_LIGHT:
+            case SV_SCROLL_MONSTER_CONFUSION:
+            case SV_SCROLL_STAR_REMOVE_CURSE:
+            case SV_SCROLL_DETECT_GOLD:
+            case SV_SCROLL_DETECT_ITEM:
+            case SV_SCROLL_TRAP_DOOR_DESTRUCTION:
+            case SV_SCROLL_SATISFY_HUNGER:
+            case SV_SCROLL_DISPEL_UNDEAD:
+            case SV_SCROLL_BLESSING:
+            case SV_SCROLL_HOLY_CHANT:
+            case SV_SCROLL_HOLY_PRAYER:
+            /* XXX maybe consume Enchant scrolls on items */
+
+            /* Try reading the scroll */
+            if (borg_read_scroll(item->sval)) return (TRUE);
+        }
+
+        break;
+
+        case TV_FOOD:
+
+        /* Check the grub */
+        switch (item->sval)
+        {
+            case SV_FOOD_CURE_POISON:
+            case SV_FOOD_CURE_BLINDNESS:
+            case SV_FOOD_CURE_PARANOIA:
+            case SV_FOOD_CURE_CONFUSION:
+            case SV_FOOD_CURE_SERIOUS:
+            case SV_FOOD_RESTORE_STR:
+            case SV_FOOD_RESTORE_CON:
+            case SV_FOOD_RESTORING:
+            case SV_FOOD_BISCUIT:
+            case SV_FOOD_JERKY:
+            case SV_FOOD_RATION:
+            case SV_FOOD_SLIME_MOLD:
+            case SV_FOOD_WAYBREAD:
+            case SV_FOOD_PINT_OF_ALE:
+            case SV_FOOD_PINT_OF_WINE:
+
+            /* Try eating the food (unless Bloated) */
+            if (!borg_skill[BI_ISFULL] && borg_eat_food(item->sval)) return (TRUE);
+        }
+
+        break;
+    }
+
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+
+
+/*
+ * Destroy "junk" items
+ */
+bool borg_crush_junk(void)
+{
+    int i;
+    bool fix = FALSE;
+    s32b p;
+    s32b value;
+
+    /* Hack -- no need */
+    if (!borg_do_crush_junk) return (FALSE);
+
+    /* No crush if even slightly dangerous */
+    if (borg_danger(c_y,c_x,1, TRUE) > borg_skill[BI_CURHP] / 10) return (FALSE);
+
+    /* Destroy actual "junk" items */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* dont crush the swap weapon */
+        if (i == weapon_swap && item->iqty == 1 && item->tval != TV_FOOD) continue;
+        if (i == armour_swap && item->tval != TV_FOOD) continue;
+
+        /* Dont crush weapons if we are weilding a digger */
+#if 0
+            if (item->tval >=TV_DIGGING && item->tval <= TV_SWORD &&
+            borg_items[INVEN_WIELD].tval == TV_DIGGING) continue;
+#endif
+
+        /* dont crush our spell books */
+        if (item->tval == cp_ptr->spell_book) continue;
+
+		/* dont crush my missiles if they are half good */
+		if (item->tval == my_ammo_tval && item->value > 0L) continue;
+
+        /* save the items value */
+        value = item->value;
+
+		/* Crush Stacked Wands and Staves that are empty.
+		 * ie. 5 Staffs of Teleportation (2 charges).
+		 * Only 2 charges in 5 staves means top 3 are empty.
+		 */
+		if (item->tval == TV_STAFF || item->tval == TV_WAND)
+		{
+			if (item->iqty > item->pval) value = 0L;
+		}
+
+        /* Skip non "worthless" items */
+        if (item->tval >= TV_CHEST)
+        {
+            /* unknown and not worthless */
+            if (!item->able && !streq(item->note, "{average}") &&
+                 value > 0)
+                continue;
+
+            /* skip items that are 'valuable'.  This is level dependent */
+            /* try to make the borg junk +1,+1 dagger at level 40 */
+
+            /* if the item gives a bonus to a stat, boost its value */
+            if (((item->flags1 & TR1_STR) ||
+                (item->flags1 & TR1_INT) ||
+                (item->flags1 & TR1_WIS) ||
+                (item->flags1 & TR1_DEX) ||
+                (item->flags1 & TR1_CON)) && value > 0)
+            {
+                value += 2000L;
+            }
+
+            /* Keep some stuff */
+            if ( (item->tval == my_ammo_tval && value > 0) ||
+            ((item->tval == TV_POTION && item->sval == SV_POTION_RESTORE_MANA) &&
+             (borg_skill[BI_MAXSP] >= 1)) ||
+            (item->tval == TV_POTION && item->sval == SV_POTION_HEALING) ||
+            (item->tval == TV_POTION && item->sval == SV_POTION_STAR_HEALING) ||
+            (item->tval == TV_POTION && item->sval == SV_POTION_LIFE) ||
+            (item->tval == TV_POTION && item->sval == SV_POTION_SPEED) ||
+            (item->tval == TV_ROD && item->sval == SV_ROD_DRAIN_LIFE)||
+            (item->tval == TV_ROD && (item->sval == SV_ROD_HEALING  ||
+             item->sval == SV_ROD_MAPPING) && borg_class == CLASS_WARRIOR) ||
+            (item->tval == TV_STAFF && item->sval == SV_STAFF_DISPEL_EVIL) ||
+            (item->tval == TV_STAFF && item->sval == SV_STAFF_POWER) ||
+            (item->tval == TV_STAFF && item->sval == SV_STAFF_HOLINESS) ||
+            (item->tval == TV_WAND && item->sval == SV_WAND_DRAIN_LIFE) ||
+            (item->tval == TV_WAND && item->sval == SV_WAND_ANNIHILATION) ||
+            (item->tval == TV_WAND && item->sval == SV_WAND_TELEPORT_AWAY && borg_class == CLASS_WARRIOR) ||
+            (item->tval == TV_CLOAK && item->name2 == EGO_AMAN) ||
+            (item->tval == TV_SCROLL && item->sval == SV_SCROLL_TELEPORT_LEVEL &&
+             borg_skill[BI_ATELEPORTLVL] < 1000) ||
+            (item->tval == TV_SCROLL && item->sval == SV_SCROLL_PROTECTION_FROM_EVIL))
+
+            {
+                value +=5000L;
+            }
+
+			/* Go Ahead and crush diggers */
+			if (item->tval == TV_DIGGING) value = 0L;
+
+	        /* Crush missiles that aren't mine */
+	        if (item->tval == TV_SHOT ||
+	            item->tval == TV_ARROW ||
+	            item->tval == TV_BOLT)
+	        {
+	            if (item->tval != my_ammo_tval) value = 0L;
+	        }
+
+            /* borg_worships_gold will sell all kinds of stuff,
+             * except {cursed} is junk
+             */
+            if (item->value > 0 &&
+                ((borg_worships_gold || borg_skill[BI_MAXCLEVEL] < 10) ||
+                 (borg_money_scum_amount < borg_gold && borg_money_scum_amount != 0)) &&
+                borg_skill[BI_MAXCLEVEL] <= 20 &&
+                !(streq(item->note, "{cursed}")) ) continue;
+
+
+            /* up to level 5, keep anything of any value */
+            if (borg_skill[BI_CDEPTH] < 5 && value > 0)
+                continue;
+            /* up to level 15, keep anything of value 100 or better */
+            if (borg_skill[BI_CDEPTH] < 15 && value > 100)
+                continue;
+            /* up to level 30, keep anything of value 500 or better */
+            if (borg_skill[BI_CDEPTH] < 30 && value > 500)
+                continue;
+            /* up to level 40, keep anything of value 1000 or better */
+            if (borg_skill[BI_CDEPTH] < 40 && value > 1000)
+                continue;
+            /* up to level 60, keep anything of value 1200 or better */
+            if (borg_skill[BI_CDEPTH] < 60 && value > 1200)
+                continue;
+            /* up to level 80, keep anything of value 1400 or better */
+            if (borg_skill[BI_CDEPTH] < 80 && value > 1400)
+                continue;
+            /* up to level 90, keep anything of value 1600 or better */
+            if (borg_skill[BI_CDEPTH] < 90 && value > 1600)
+                continue;
+            /* up to level 95, keep anything of value 4800 or better */
+            if (borg_skill[BI_CDEPTH] < 95 && value > 4800)
+                continue;
+            /* below level 127, keep anything of value 2000 or better */
+            if (borg_skill[BI_CDEPTH] < 127 && value > 5600)
+                continue;
+
+            /* Save the item */
+            COPY(&safe_items[i], &borg_items[i], borg_item);
+
+            /* Destroy the item */
+            WIPE(&borg_items[i], borg_item);
+
+            /* Fix later */
+            fix = TRUE;
+
+            /* Examine the inventory */
+            borg_notice(FALSE);
+
+            /* Evaluate the inventory */
+            p = borg_power();
+
+            /* Restore the item */
+            COPY(&borg_items[i], &safe_items[i], borg_item);
+
+            /* skip things we are using */
+            if (p < my_power) continue;
+        }
+
+        /* re-examine the inventory */
+        if (fix) borg_notice(TRUE);
+
+        /* Hack -- skip good un-id'd "artifacts" */
+        if (strstr(item->note, "special}")) continue;
+        if (strstr(item->note, "terrible}")) continue;
+        if (strstr(item->note, "indestructible}")) continue;
+
+        /* hack -- apw with random artifacts some are good and bad */
+        /*         so check them all */
+        if ((birth_rand_artifacts || adult_rand_artifacts) && item->name1 && !item->fully_identified) continue;
+
+        /* Message */
+        borg_note(format("# Junking junk (valued at %d)",value));
+        /* Message */
+        borg_note(format("# Destroying %s.", item->desc));
+
+        if (item->tval == TV_STAFF || item->tval == TV_WAND)
+        {
+	        /* Destroy one item */
+	        borg_keypresses("01");
+		}
+		else
+		{
+			/* Destroy all items */
+        	borg_keypresses("099");
+		}
+
+        /* Destroy that item */
+        if (!item->name1)
+                borg_keypress('k');
+        else
+        {
+            int a;
+
+            /* worthless artifacts are dropped. */
+            borg_keypress('d');
+
+            /* mark the spot that the object was dropped so that  */
+            /* it will not be picked up again. */
+            for (a = 0; a < 50; a++)
+            {
+                if (bad_obj_x[a] != -1) continue;
+                if (bad_obj_y[a] != -1) continue;
+
+                bad_obj_x[a] = c_x;
+                bad_obj_y[a] = c_y;
+                borg_note(format("# Crappy artifact at %d,%d",bad_obj_x[a],bad_obj_y[a]));
+                break;
+            }
+        }
+        borg_keypress(I2A(i));
+
+        /* Verify destruction */
+        borg_keypress('y');
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* re-examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Hack -- no need */
+    borg_do_crush_junk = FALSE;
+
+
+    /* Nothing to destroy */
+    return (FALSE);
+}
+
+
+
+/*
+ * Destroy something to make a free inventory slot.
+ *
+ * This function evaluates the possible worlds that result from
+ * the destruction of each inventory slot, and attempts to destroy
+ * that slot which causes the best possible resulting world.
+ *
+ * We attempt to avoid destroying unknown items by "rewarding" the
+ * presence of unknown items by a massively heuristic value.
+ *
+ * If the Borg cannot find something to destroy, which should only
+ * happen if he fills up with artifacts, then he will probably act
+ * rather twitchy for a while.
+ *
+ * This function does not have to be very efficient.
+ */
+bool borg_crush_hole(void)
+{
+    int i, b_i = -1;
+    s32b p, b_p = 0L;
+
+    s32b value;
+
+    bool fix = FALSE;
+
+
+    /* Do not destroy items unless we need the space */
+    if (!borg_items[INVEN_PACK-1].iqty) return (FALSE);
+
+    /* No crush if even slightly dangerous */
+    if (borg_skill[BI_CDEPTH] && (borg_danger(c_y,c_x,1, TRUE) > borg_skill[BI_CURHP] / 10 &&
+         (borg_skill[BI_CURHP] != borg_skill[BI_MAXHP] ||
+         borg_danger(c_y,c_x,1, TRUE) > (borg_skill[BI_CURHP] * 2) / 3)))
+        return (FALSE);
+
+    /* Scan the inventory */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Hack -- skip "artifacts" */
+        if (item->name1) continue;
+
+		/* skip food */
+		if (item->tval == TV_FOOD && borg_skill[BI_FOOD] < 5) continue;
+
+        /* dont crush the swap weapon */
+        if (i == weapon_swap && item->tval != TV_FOOD) continue;
+        if (i == armour_swap && item->tval != TV_FOOD) continue;
+
+        /* dont crush our spell books */
+        if (item->tval == cp_ptr->spell_book) continue;
+
+        /* Dont crush weapons if we are weilding a digger */
+        if (item->tval >=TV_DIGGING && item->tval <= TV_SWORD &&
+            borg_items[INVEN_WIELD].tval == TV_DIGGING) continue;
+
+        /* Hack -- skip "artifacts" */
+        if (item->name1 && !item->fully_identified) continue;
+        if (strstr(item->note, "special}")) continue;
+        if (strstr(item->note, "terrible}")) continue;
+        if (strstr(item->note, "indestructible}")) continue;
+
+        /* never crush cool stuff that we might be needing later */
+        if ((item->tval == TV_POTION && item->sval == SV_POTION_RESTORE_MANA) &&
+            (borg_skill[BI_MAXSP] >= 1)) continue;
+        if (item->tval == TV_POTION && item->sval == SV_POTION_HEALING) continue;
+        if (item->tval == TV_POTION && item->sval == SV_POTION_STAR_HEALING) continue;
+        if (item->tval == TV_POTION && item->sval == SV_POTION_LIFE) continue;
+        if (item->tval == TV_POTION && item->sval == SV_POTION_SPEED) continue;
+        if (item->tval == TV_SCROLL && item->sval == SV_SCROLL_PROTECTION_FROM_EVIL) continue;
+        if (item->tval == TV_SCROLL && item->sval == SV_SCROLL_RUNE_OF_PROTECTION) continue;
+        if (item->tval == TV_SCROLL && item->sval == SV_SCROLL_TELEPORT_LEVEL &&
+            borg_skill[BI_ATELEPORTLVL] < 1000 ) continue;
+        if (item->tval == TV_CLOAK && item->name2 == EGO_AMAN) continue;
+        if (item->tval == TV_ROD && (item->sval == SV_ROD_HEALING ||
+            item->sval == SV_ROD_MAPPING) && borg_class == CLASS_WARRIOR &&
+            item->iqty <= 5) continue;
+        if (item->tval == TV_WAND && item->sval == SV_WAND_TELEPORT_AWAY &&
+            borg_class == CLASS_WARRIOR && borg_skill[BI_ATPORTOTHER] <= 8) continue;
+
+        /* save the items value */
+        value = item->value;
+
+        /* Save the item */
+        COPY(&safe_items[i], &borg_items[i], borg_item);
+
+        /* Destroy the item */
+        WIPE(&borg_items[i], borg_item);
+
+        /* Fix later */
+        fix = TRUE;
+
+        /* Examine the inventory */
+        borg_notice(FALSE);
+
+        /* Evaluate the inventory */
+        p = borg_power();
+
+        /* power is much more important than gold. */
+        p *= 100;
+
+		/* If I have no food, and in town, I must have a free spot to buy food */
+		if (borg_skill[BI_CDEPTH] == 0 && borg_skill[BI_FOOD] ==0)
+		{
+			/* Power is way more important than gold */
+			p *= 500;
+		}
+        /* Restore the item */
+        COPY(&borg_items[i], &safe_items[i], borg_item);
+
+        /* Penalize loss of "gold" */
+
+        /* if the item gives a bonus to a stat, boost its value */
+        if ((item->flags1 & TR1_STR) ||
+            (item->flags1 & TR1_INT) ||
+            (item->flags1 & TR1_WIS) ||
+            (item->flags1 & TR1_DEX) ||
+            (item->flags1 & TR1_CON))
+        {
+            value += 20000L;
+        }
+
+        /* Keep the correct types of missiles which have value
+         * if we do have have tons already. unless in town, you can junk em in town.
+         */
+        if ((item->tval == my_ammo_tval) && (value > 0) &&
+            (borg_skill[BI_AMISSILES] <= 35) &&
+            borg_skill[BI_CDEPTH] >=1)
+        {
+            value +=5000L;
+        }
+
+        /* Hack  show prefrence for destroying things we will not use */
+        /* if we are high enough level not to worry about gold. */
+        if (borg_skill[BI_CLEVEL] > 35)
+        {
+            switch (item->tval)
+            {
+                /* rings are under valued. */
+                case TV_RING:
+                    p -= (item->iqty * value * 10);
+                    break;
+
+                case TV_AMULET:
+                case TV_BOW:
+                case TV_HAFTED:
+                case TV_POLEARM:
+                case TV_SWORD:
+                case TV_BOOTS:
+                case TV_GLOVES:
+                case TV_HELM:
+                case TV_CROWN:
+                case TV_SHIELD:
+                case TV_SOFT_ARMOR:
+                case TV_HARD_ARMOR:
+                case TV_DRAG_ARMOR:
+                    p -= (item->iqty * value * 5);
+                    break;
+                case TV_CLOAK:
+                    if (item->name2 != EGO_AMAN)
+                    p -=(item->iqty *(300000L));
+                    else
+                    p -= (item->iqty * value);
+                    break;
+
+                case TV_ROD:
+                    /* BIG HACK! don't crush cool stuff. */
+                    if ((item->sval != SV_ROD_DRAIN_LIFE) ||
+                        (item->sval != SV_ROD_ACID_BALL) ||
+                        (item->sval != SV_ROD_ELEC_BALL) ||
+                        (item->sval != SV_ROD_FIRE_BALL) ||
+                        (item->sval != SV_ROD_COLD_BALL) )
+                        p -= (item->iqty * (300000L));  /* value at 30k */
+                    else
+                    p -= (item->iqty * value);
+                    break;
+
+                case TV_STAFF:
+                    /* BIG HACK! don't crush cool stuff. */
+                    if (item->sval != SV_STAFF_DISPEL_EVIL ||
+                        ((item->sval != SV_STAFF_POWER ||
+                          item->sval != SV_STAFF_HOLINESS) &&
+                          amt_cool_staff < 2) ||
+                        (item->sval != SV_STAFF_DESTRUCTION &&
+                         borg_skill[BI_ASTFDEST] < 2))
+                        p -= (item->iqty * (300000L));  /* value at 30k */
+                    else
+                    p -= (item->iqty * (value/2));
+                case TV_WAND:
+                    /* BIG HACK! don't crush cool stuff. */
+                    if ((item->sval != SV_WAND_DRAIN_LIFE) ||
+                        (item->sval != SV_WAND_TELEPORT_AWAY) ||
+                        (item->sval != SV_WAND_ACID_BALL) ||
+                        (item->sval != SV_WAND_ELEC_BALL) ||
+                        (item->sval != SV_WAND_FIRE_BALL) ||
+                        (item->sval != SV_WAND_COLD_BALL) ||
+                        (item->sval != SV_WAND_ANNIHILATION) ||
+                        (item->sval != SV_WAND_DRAGON_FIRE) ||
+                        (item->sval != SV_WAND_DRAGON_COLD) )
+                        p -= (item->iqty * (300000L));  /* value at 30k */
+                    else
+                    p -= (item->iqty * (value/2));
+                    break;
+
+                /* scrolls and potions crush easy */
+                case TV_SCROLL:
+                    if ((item->sval != SV_SCROLL_PROTECTION_FROM_EVIL) ||
+                        (item->sval != SV_SCROLL_RUNE_OF_PROTECTION))
+                        p -=(item->iqty * (30000L));
+                    else
+                        p -= (item->iqty * (value/10));
+                    break;
+
+                case TV_POTION:
+                    /* BIG HACK! don't crush heal/mana potions.  It could be */
+                    /* that we are in town and are collecting them. */
+                    if ((item->sval != SV_POTION_HEALING) ||
+                        (item->sval != SV_POTION_STAR_HEALING) ||
+                        (item->sval != SV_POTION_LIFE) ||
+                        (item->sval != SV_POTION_RESTORE_MANA))
+                        p -= (item->iqty * (300000L));  /* value at 30k */
+                    else
+                        p -= (item->iqty * (value/10));
+                    break;
+
+                default:
+                    p -= (item->iqty * (value/3));
+                    break;
+            }
+        }
+        else
+        {
+            p -= (item->iqty * value);
+        }
+
+        /* Hack -- try not to destroy "unaware" items
+		 * unless deep
+		 */
+        if (!item->kind && (value > 0))
+        {
+            /* Hack -- Reward "unaware" items */
+            switch (item->tval)
+            {
+                case TV_RING:
+                case TV_AMULET:
+                p -= (borg_skill[BI_MAXDEPTH] * 5000L);
+                break;
+
+                case TV_ROD:
+                p -= (borg_skill[BI_MAXDEPTH] * 3000L);
+                break;
+
+                case TV_STAFF:
+                case TV_WAND:
+                p -= (borg_skill[BI_MAXDEPTH] * 2000L);
+                break;
+
+                case TV_SCROLL:
+                case TV_POTION:
+                p -= (borg_skill[BI_MAXDEPTH] * 500L);
+                break;
+
+                case TV_FOOD:
+                p -= (borg_skill[BI_MAXDEPTH] * 10L);
+                break;
+            }
+        }
+
+        /* Hack -- try not to destroy "unknown" items (unless "icky") */
+        if (!item->able && (value > 0) && !borg_item_icky(item))
+        {
+            /* Reward "unknown" items */
+            switch (item->tval)
+            {
+                case TV_SHOT:
+                case TV_ARROW:
+                case TV_BOLT:
+                p -= 100L;
+                break;
+
+                case TV_BOW:
+                p -= 20000L;
+                break;
+
+                case TV_DIGGING:
+                p -= 10L;
+                break;
+
+                case TV_HAFTED:
+                case TV_POLEARM:
+                case TV_SWORD:
+                p -= 10000L;
+                break;
+
+                case TV_BOOTS:
+                case TV_GLOVES:
+                case TV_HELM:
+                case TV_CROWN:
+                case TV_SHIELD:
+                case TV_CLOAK:
+                p -= 15000L;
+                break;
+
+                case TV_SOFT_ARMOR:
+                case TV_HARD_ARMOR:
+                case TV_DRAG_ARMOR:
+                p -= 15000L;
+                break;
+
+                case TV_AMULET:
+                case TV_RING:
+                p -= 5000L;
+                break;
+
+                case TV_STAFF:
+                case TV_WAND:
+                p -= 1000L;
+                break;
+            }
+        }
+
+        /* Ignore "bad" swaps */
+        if ((b_i >= 0) && (p < b_p)) continue;
+
+        /* Maintain the "best" */
+        b_i = i; b_p = p;
+    }
+
+    /* Examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Attempt to destroy it */
+    if (b_i >= 0)
+    {
+        borg_item *item = &borg_items[b_i];
+
+        /* Debug */
+        borg_note(format("# Junking %ld gold (full)", my_power*100 - b_p));
+
+        /* Try to consume the junk */
+        if (borg_consume(b_i)) return (TRUE);
+
+        /* Message */
+        borg_note(format("# Destroying %s.", item->desc));
+
+        /* Destroy all items */
+        borg_keypresses("099");
+
+        /* Destroy that item */
+        borg_keypress('k');
+        borg_keypress(I2A(b_i));
+
+        /* Verify destruction */
+        borg_keypress('y');
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /* Hack -- no need */
+    borg_do_crush_hole = FALSE;
+
+
+    /* Paranoia */
+    return (FALSE);
+}
+
+
+
+/*
+ * Destroy "junk" when slow (in the dungeon).
+ *
+ * We penalize the loss of both power and monetary value, and reward
+ * the loss of weight that may be slowing us down.  The weight loss
+ * is worth one gold per tenth of a pound.  This causes things like
+ * lanterns and chests and spikes to be considered "annoying".
+ */
+bool borg_crush_slow(void)
+{
+    int i, b_i = -1;
+    s32b p, b_p = 0L;
+
+    s32b temp;
+
+    s32b greed;
+
+    bool fix = FALSE;
+
+    /* No crush if even slightly dangerous */
+    if (borg_danger(c_y,c_x,1, TRUE) > borg_skill[BI_CURHP] / 20) return (FALSE);
+
+    /* Hack -- never in town */
+    if (borg_skill[BI_CDEPTH] == 0) return (FALSE);
+
+    /* Do not crush items unless we are slow */
+    if (borg_skill[BI_SPEED] >= 110) return (FALSE);
+
+    /* Calculate "greed" factor */
+    greed = (borg_gold / 100L) + 100L;
+
+    /* Minimal and maximal greed */
+    if (greed < 500L && borg_skill[BI_CLEVEL] > 35) greed = 500L;
+    if (greed > 25000L) greed = 25000L;
+
+    /* Decrease greed by our slowness */
+    greed -= (110 - borg_skill[BI_SPEED]) * 500;
+    if (greed <=0) greed = 0L;
+
+    /* Scan for junk */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* dont crush the swap weapon */
+        if (i == weapon_swap && item->iqty == 1) continue;
+        if (i == armour_swap) continue;
+
+        /* Skip "good" unknown items (unless "icky") */
+        if (!item->able && !borg_item_icky(item)) continue;
+
+        /* Hack -- Skip artifacts */
+        if ((birth_rand_artifacts || adult_rand_artifacts) && item->name1 && !item->fully_identified) continue;
+        if (strstr(item->note, "special}")) continue;
+        if (strstr(item->note, "terrible}")) continue;
+        if (strstr(item->note, "indestructible}")) continue;
+
+        /* Dont crush weapons if we are weilding a digger */
+        if (item->tval >=TV_DIGGING && item->tval <= TV_SWORD &&
+            borg_items[INVEN_WIELD].tval == TV_DIGGING) continue;
+
+        /* Save the item */
+        COPY(&safe_items[i], &borg_items[i], borg_item);
+
+        /* Destroy one of the items */
+        borg_items[i].iqty--;
+
+        /* Fix later */
+        fix = TRUE;
+
+        /* Examine the inventory */
+        borg_notice(FALSE);
+
+        /* Evaluate the inventory */
+        p = borg_power();
+
+        /* Restore the item */
+        COPY(&borg_items[i], &safe_items[i], borg_item);
+
+        /* Obtain the base price */
+        temp = ((item->value < 30000L) ? item->value : 30000L);
+
+        /* Hack -- ignore very cheap items */
+        if (temp < greed) temp = 0L;
+
+        /* Penalize */
+        p -= temp;
+
+        /* Obtain the base weight */
+        temp = item->weight;
+
+        /* Reward */
+        p += (temp*100);
+
+        /* Ignore "bad" swaps */
+        if (p < b_p) continue;
+
+        /* Maintain the "best" */
+        b_i = i; b_p = p;
+    }
+
+    /* Examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Destroy "useless" things */
+    if ((b_i >= 0) && (b_p >= (my_power)))
+    {
+        borg_item *item = &borg_items[b_i];
+
+        /* Message */
+        borg_note(format("# Junking %ld gold (slow)", (my_power) - b_p));
+
+        /* Attempt to consume it */
+        if (borg_consume(b_i)) return (TRUE);
+
+        /* Message */
+        borg_note(format("# Destroying %s.", item->desc));
+
+        /* Destroy one item */
+        borg_keypress('0');
+        borg_keypress('1');
+
+        /* Destroy that item */
+        borg_keypress('k');
+        borg_keypress(I2A(b_i));
+
+        /* Verify destruction */
+        borg_keypress('y');
+    }
+
+
+    /* Hack -- no need */
+    borg_do_crush_slow = FALSE;
+
+
+    /* Nothing to destroy */
+    return (FALSE);
+}
+
+
+/*
+ * Identify items if possible
+ *
+ * Note that "borg_parse()" will "cancel" the identification if it
+ * detects a "You failed..." message.  This is VERY important!!!
+ * Otherwise the "identify" might induce bizarre actions by sending
+ * the "index" of an item as a command.
+ *
+ * Hack -- recover from mind blanking by re-identifying the equipment.
+ *
+ * We instantly identify items known to be "good" (or "terrible").
+ *
+ * We identify most un-aware items as soon as possible.
+ *
+ * We identify most un-known items as soon as possible.
+ *
+ * We play games with items that get "feelings" to try and wait for
+ * "sensing" to take place if possible.
+ *
+ * XXX XXX XXX Make sure not to sell "non-aware" items, unless
+ * we are really sure we want to lose them.  For example, we should
+ * wait for feelings on (non-icky) wearable items or else make sure
+ * that we identify them before we try and sell them.
+ *
+ * Mega-Hack -- the whole "sometimes identify things" code is a total
+ * hack.  Slightly less bizarre would be some form of "occasionally,
+ * pick a random item and identify it if necessary", which might lower
+ * the preference for identifying items that appear early in the pack.
+ * Also, preventing inventory motion would allow proper time-stamping.
+ *
+ * This function is also repeated to *ID* objects.  Right now only objects
+ * with random high resist or random powers are *ID*'d
+ */
+bool borg_test_stuff(bool star_id)
+{
+    int i, b_i = -1;
+    s32b v, b_v = -1;
+
+    /* don't ID stuff when you can't recover spent spell point immediately */
+    if ((!star_id) &&
+        ((borg_skill[BI_CURSP] < 50 && borg_spell_legal(2, 5)) ||
+         (borg_skill[BI_CURSP] < 50 && borg_prayer_legal(5, 2))) &&
+        !borg_check_rest())
+        return (FALSE);
+
+    /* No ID if in danger */
+    if (borg_danger(c_y,c_x,1, TRUE) > 1) return (FALSE);
+
+    /* Look for an item to identify (equipment) */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip known items */
+        if (!star_id)
+        {
+            if (item->able) continue;
+        }
+        else
+        /* go ahead and check egos and artifacts */
+        {
+            if (item->fully_identified) continue;
+            if (!item->name2 &&
+                !item->name1) continue;
+            if (item->name2)
+            {
+              switch (item->name2)
+               {
+                /* Weapon (Blessed) */
+                case EGO_BLESS_BLADE:
+                /* Armor of Permanence */
+                case EGO_PERMANENCE:
+                /* Armor of Elvenkind */
+                case EGO_ELVENKIND:
+                /* Crown of the Magi */
+                case EGO_MAGI:
+                /* Cloak of Aman */
+                case EGO_AMAN:
+                     break;
+                /* Weapon (Holy Avenger) */
+                case EGO_HA:
+                /* Weapon (Defender) */
+                case EGO_DF:
+                /* anything else */
+                default:
+                    continue;
+               }
+            }
+            if (item->name1)
+            {
+                switch (item->name1)
+                {
+                    /* we will id all artifacts */
+                    default:
+                       break;
+                }
+            }
+        }
+
+        /* Get the value */
+        v = item->value + 100000L;
+
+        /* Track the best */
+        if (v < b_v) continue;
+
+        /* Track it */
+        b_i = i; b_v = v;
+    }
+
+
+
+    /* Look for an ego or artifact item to identify (inventory) */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip known items */
+        if (!star_id)
+        {
+            if (item->able) continue;
+        }
+        else
+        {
+            if (item->fully_identified) continue;
+            if (!item->name2 &&
+                !item->name1) continue;
+            if (item->name2)
+            {
+               switch (item->name2)
+               {
+                /* Weapon (Blessed) */
+                case EGO_BLESS_BLADE:
+                /* Armor of Permanence */
+                case EGO_PERMANENCE:
+                /* Armor of Elvenkind */
+                case EGO_ELVENKIND:
+                /* Crown of the Magi */
+                case EGO_MAGI:
+                /* Cloak of Aman */
+                case EGO_AMAN:
+                    break;
+                /* Weapon (Holy Avenger) */
+                case EGO_HA:
+                /* Weapon (Defender) */
+                case EGO_DF:
+                /* anything else */
+                default:
+                    continue;
+               }
+            }
+            if (item->name1)
+            {
+                switch (item->name1)
+                {
+                    /* check all artifacts */
+                    default:
+                       break;
+                }
+            }
+
+        }
+
+
+        /* Assume nothing */
+        v = 0;
+
+        /* Identify "good" (and "terrible") items */
+        /* weak pseudo id */
+        if (streq(item->note, "{good}") && (!cp_ptr->flags & CF_PSEUDO_ID_HEAVY)) v = item->value + 10000L;
+        /* heavy pseudo id */
+        else if (streq(item->note, "{good}") && borg_gold < 10000) v = item->value +1000L;
+        else if (streq(item->note, "{excellent}")) v = item->value + 20000L;
+        else if (strstr(item->note, "special}")) v = item->value + 50000L;
+        else if (strstr(item->note, "terrible}")) v = item->value + 50000L;
+        else if (strstr(item->note, "indestructible}")) v = item->value + 50000L;
+        /* Nothing */
+        if (!v) continue;
+
+        /* Track the best */
+        if (v < b_v) continue;
+
+        /* Track it */
+        b_i = i; b_v = v;
+    }
+
+    /* Look for an ego item to identify (equipment) */
+    for (i = 0; i <= INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        if (!star_id) continue;
+        if (item->fully_identified) continue;
+        if (!item->name2 &&
+            !item->name1) continue;
+        if (item->name2)
+        {
+            switch (item->name2)
+               {
+                /* Weapon (Blessed) */
+                case EGO_BLESS_BLADE:
+                /* Armor of Permanence */
+                case EGO_PERMANENCE:
+                /* Armor of Elvenkind */
+                case EGO_ELVENKIND:
+                /* Crown of the Magi */
+                case EGO_MAGI:
+                /* Cloak of Aman */
+                case EGO_AMAN:
+                    break;
+                /* Weapon (Holy Avenger) */
+                case EGO_HA:
+                /* Weapon (Defender) */
+                case EGO_DF:
+                /* anything else */
+                default:
+                    continue;
+               }
+        }
+            if (item->name1)
+            {
+                switch (item->name1)
+                {
+                    default:
+                       break;
+                }
+            }
+        /* Get the value */
+        v = item->value + 100000L;
+
+        /* Track the best */
+        if (v < b_v) continue;
+
+        /* Track it */
+        b_i = i; b_v = v;
+    }
+
+
+    /* Look for an item to identify (inventory) */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip known items */
+        if (!star_id)
+        {
+            if (item->able) continue;
+        }
+        else
+        {
+            if (item->fully_identified) continue;
+            if (!item->name2 &&
+                !item->name1) continue;
+            if (item->name2)
+                {
+                switch (item->name2)
+                    {
+                        case EGO_BLESS_BLADE:
+                        case EGO_PERMANENCE:
+                        case EGO_ELVENKIND:
+                        case EGO_MAGI:
+                        case EGO_AMAN:
+                            break;
+                        case EGO_HA:
+                        /* Weapon (Defender) */
+                        case EGO_DF:
+                        /* anything else */
+                        default:
+                            continue;
+                    }
+                }
+            if (item->name1)
+            {
+                switch (item->name1)
+                {
+                    default:
+                       break;
+                }
+            }
+        }
+
+        /* Hack -- never identify "average" things, unless Ammo */
+        if (streq(item->note, "{average}") && item->tval != my_ammo_tval) continue;
+
+        /* If I have tons of cash dont worry about some "good" items */
+        if (streq(item->note, "{good}") &&
+            borg_gold > 20000 && borg_skill[BI_AID] <= 5 &&
+            (cp_ptr->flags & CF_PSEUDO_ID_HEAVY)) continue;
+
+        /* Hack -- assume no value */
+        v = 0;
+
+        /* Hack -- reward "unaware" items */
+        if (!item->kind && !star_id)
+        {
+            /* Analyze the type */
+            switch (item->tval)
+            {
+                case TV_RING:
+                case TV_AMULET:
+
+                /* Hack -- reward depth */
+                v += (borg_skill[BI_MAXDEPTH] * 5000L);
+
+                break;
+
+                case TV_ROD:
+
+                /* Hack -- reward depth */
+                v += (borg_skill[BI_MAXDEPTH] * 3000L);
+
+                break;
+
+                case TV_WAND:
+                case TV_STAFF:
+
+                /* Hack -- reward depth */
+                v += (borg_skill[BI_MAXDEPTH] * 2000L);
+
+                break;
+
+                case TV_POTION:
+                case TV_SCROLL:
+
+                /* Hack -- boring levels */
+                if (borg_skill[BI_MAXDEPTH] < 5) break;
+
+                /* Hack -- reward depth */
+                v += (borg_skill[BI_MAXDEPTH] * 500L);
+
+                break;
+
+                case TV_FOOD:
+
+                /* Hack -- reward depth */
+                v += (borg_skill[BI_MAXDEPTH] * 10L);
+
+                break;
+            }
+        }
+
+        /* Analyze the type */
+        switch (item->tval)
+        {
+            case TV_CHEST:
+
+            /* Hack -- Always identify chests */
+            v = item->value;
+            break;
+
+            case TV_WAND:
+            case TV_STAFF:
+
+            /* Hack -- Always identify (get charges) */
+            v = item->value;
+            break;
+
+            case TV_RING:
+            case TV_AMULET:
+
+            /* Hack -- Always identify (get information) */
+            v = item->value;
+            break;
+
+            case TV_LITE:
+
+            /* Hack -- Always identify (get artifact info) */
+            v = item->value;
+            break;
+
+            case TV_SHOT:
+            case TV_ARROW:
+            case TV_BOLT:
+            case TV_BOW:
+            case TV_DIGGING:
+            case TV_HAFTED:
+            case TV_POLEARM:
+            case TV_SWORD:
+            case TV_BOOTS:
+            case TV_GLOVES:
+            case TV_HELM:
+            case TV_CROWN:
+            case TV_SHIELD:
+            case TV_CLOAK:
+            case TV_SOFT_ARMOR:
+            case TV_HARD_ARMOR:
+            case TV_DRAG_ARMOR:
+
+            /* Mega-Hack -- use identify spell/prayer */
+            if (borg_spell_legal(2, 5) || borg_prayer_legal(5, 2) ||
+                borg_equips_artifact(ACT_IDENTIFY, INVEN_WIELD))
+            {
+                v = item->value;
+            }
+
+			/* Certain items needs ID'ing if low level */
+			if (borg_skill[BI_CLEVEL] <= 5)
+			{
+                /* Mega-Hack -- ignore "icky" items */
+                if (!borg_item_icky(item)) v = item->value;
+			}
+
+            /* Mega-Hack -- mages get bored */
+            if ((borg_class == CLASS_MAGE) && (rand_int(1000) < borg_skill[BI_CLEVEL]))
+            {
+
+                /* Mega-Hack -- ignore "icky" items */
+                if (!borg_item_icky(item)) v = item->value;
+            }
+
+            /* Mega-Hack -- rangers get bored */
+            if ((borg_class == CLASS_RANGER) && (rand_int(3000) < borg_skill[BI_CLEVEL]))
+            {
+
+                /* Mega-Hack -- ignore "icky" items */
+                if (!borg_item_icky(item)) v = item->value;
+            }
+
+            /* Mega-Hack -- priests get bored */
+            if ((borg_class == CLASS_PRIEST) && (rand_int(5000) < borg_skill[BI_CLEVEL]))
+            {
+
+                /* Mega-Hack -- ignore "icky" items */
+                if (!borg_item_icky(item)) v = item->value;
+            }
+
+            /* try to ID shovels */
+            if (item->tval == TV_DIGGING) v = item->value;
+
+            /* try to ID my ammo type to stack them up */
+            if (item->tval == my_ammo_tval && borg_skill[BI_CLEVEL] >= 15) v = item->value;
+
+            break;
+        }
+
+        /* Ignore */
+        if (!v) continue;
+
+        /* Track the best */
+        if (v < b_v) continue;
+
+        /* Track it */
+        b_i = i; b_v = v;
+    }
+
+    /* Found something */
+    if (b_i >= 0)
+    {
+        borg_item *item = &borg_items[b_i];
+
+        if (star_id)
+        {
+            if (borg_read_scroll(SV_SCROLL_STAR_IDENTIFY))
+            {
+                /* Log -- may be cancelled */
+                borg_note(format("# *IDENTIFY*ing %s.", item->desc));
+
+                /* we need to look at the screen next time through */
+                borg_do_star_id = TRUE;
+                item->needs_I = FALSE;
+                item->fully_identified = TRUE;
+
+                /* Equipment */
+                if (b_i >= INVEN_WIELD)
+                {
+                    /* Select the equipment */
+                    borg_keypress('/');
+
+                    /* Select the item */
+                    borg_keypress(I2A(b_i - INVEN_WIELD));
+
+                    /* HACK need to recheck stats if we id something on us. */
+                    for (i = 0;i < 6; i++)
+                    {
+                        my_need_stat_check[i] = TRUE;
+                        my_stat_max[i] = 0;
+                    }
+                }
+
+                /* Inventory */
+                else
+                {
+                    /* Select the item */
+                    borg_keypress(I2A(b_i));
+                }
+
+                /* press enter a few time (get rid of display) */
+                borg_keypress('\r');
+                borg_keypress('\r');
+                borg_keypress('\r');
+                borg_keypress('\r');
+                borg_keypress(ESCAPE);
+
+                /* Success */
+                return (TRUE);
+            }
+
+        }
+        else
+        {
+            /* Use a Spell/Prayer/Rod/Staff/Scroll of Identify */
+            if (borg_spell(2, 5) ||
+                borg_prayer(5, 2) ||
+                borg_zap_rod(SV_ROD_IDENTIFY) ||
+                borg_use_staff(SV_STAFF_IDENTIFY) ||
+                borg_activate_artifact(ACT_IDENTIFY, INVEN_WIELD) ||
+                borg_read_scroll(SV_SCROLL_IDENTIFY) )
+            {
+                /* Log -- may be cancelled */
+                borg_note(format("# Identifying %s.", item->desc));
+
+                /* Equipment */
+                if (b_i >= INVEN_WIELD)
+                {
+                    /* Select the equipment */
+                    borg_keypress('/');
+
+                    /* Select the item */
+                    borg_keypress(I2A(b_i - INVEN_WIELD));
+
+                    /* HACK need to recheck stats if we id something on us. */
+                    for (i = 0; i < 6; i++)
+                    {
+                        my_need_stat_check[i] = TRUE;
+                        my_stat_max[i] = 0;
+                    }
+                }
+
+                /* Inventory */
+                else
+                {
+                    /* Select the item */
+                    borg_keypress(I2A(b_i));
+                }
+
+                borg_keypress(ESCAPE);
+                /* Success */
+                return (TRUE);
+            }
+        }
+    }
+
+    /* Nothing to do */
+    return (FALSE);
+}
+
+/*
+ * This function is responsible for making sure that, if possible,
+ * the "best" ring we have is always on the "right" (tight) finger,
+ * so that the other functions, such as "borg_best_stuff()", do not
+ * have to think about the "tight" ring, but instead, can just assume
+ * that the "right" ring is "good for us" and should never be removed.
+ *
+ * In general, this will mean that our "best" ring of speed will end
+ * up on the "right" finger, if we have one, or a ring of free action,
+ * or a ring of see invisible, or some other "useful" ring.
+ *
+ */
+bool borg_swap_rings(void)
+{
+    int hole = INVEN_PACK - 1;
+    int icky = INVEN_PACK - 2;
+	int i;
+
+    s32b v1, v2;
+
+    bool fix = FALSE;
+
+	char current_right_ring[80];
+	char current_left_ring[80];
+
+    borg_item *item;
+
+    /*** Check conditions ***/
+
+    /* Require two empty slots */
+    if (borg_items[icky].iqty) return (FALSE);
+
+    /*apw Forbid if been sitting on level forever */
+    /*    Just come back and work through the loop later */
+    if (borg_t - borg_began > 1000) return (FALSE);
+    if (time_this_panel > 350) return (FALSE);
+    if (borg_skill[BI_CDEPTH] != 0) return (FALSE);
+
+	/* Forbid if cursed */
+	if (borg_wearing_cursed) return (FALSE);
+
+    /*** Remove naked "loose" rings ***/
+
+    /* Remove any naked loose ring */
+    if (borg_items[INVEN_LEFT].iqty &&
+        !borg_items[INVEN_RIGHT].iqty &&
+         borg_items[INVEN_LEFT].activation != ACT_BIZZARE)
+    {
+        /* Log */
+        borg_note("# Taking off naked loose ring.");
+
+        /* Remove it */
+        borg_keypress('t');
+        borg_keypress(I2A(INVEN_LEFT - INVEN_WIELD));
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /*** Check conditions ***/
+
+    /* Require "tight" ring */
+    if (!borg_items[INVEN_RIGHT].iqty) return (FALSE);
+
+
+    /* Cannot remove the One Ring */
+    if (!borg_items[INVEN_RIGHT].activation == ACT_BIZZARE) return (FALSE);
+
+
+    /*** Remove nasty "tight" rings ***/
+
+    /* Save the hole */
+    COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+    /* Save the ring */
+    COPY(&safe_items[INVEN_LEFT], &borg_items[INVEN_LEFT], borg_item);
+
+    /* Take off the ring */
+    COPY(&borg_items[hole], &borg_items[INVEN_LEFT], borg_item);
+
+    /* Erase left ring */
+    WIPE(&borg_items[INVEN_LEFT], borg_item);
+
+    /* Fix later */
+    fix = TRUE;
+
+    /* Examine the inventory */
+    borg_notice(FALSE);
+
+    /* Evaluate the inventory */
+    v1 = borg_power();
+
+    /* Restore the ring */
+    COPY(&borg_items[INVEN_LEFT], &safe_items[INVEN_LEFT], borg_item);
+
+    /* Restore the hole */
+    COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+
+    /*** Consider taking off the "right" ring ***/
+
+    /* Save the hole */
+    COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+    /* Save the ring */
+    COPY(&safe_items[INVEN_RIGHT], &borg_items[INVEN_RIGHT], borg_item);
+
+    /* Take off the ring */
+    COPY(&borg_items[hole], &borg_items[INVEN_RIGHT], borg_item);
+
+    /* Erase the ring */
+    WIPE(&borg_items[INVEN_RIGHT], borg_item);
+
+    /* Fix later */
+    fix = TRUE;
+
+    /* Examine the inventory */
+    borg_notice(FALSE);
+
+    /* Evaluate the inventory */
+    v2 = borg_power();
+
+    /* Restore the ring */
+    COPY(&borg_items[INVEN_RIGHT], &safe_items[INVEN_RIGHT], borg_item);
+
+    /* Restore the hole */
+    COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+
+
+    /*** Swap rings if necessary ***/
+
+	/* Define the rings and descriptions.  */
+	strcpy(current_right_ring, borg_items[INVEN_RIGHT].desc);
+	strcpy(current_left_ring, borg_items[INVEN_LEFT].desc);
+
+    /* Remove "useless" ring */
+    if (v2 > v1)
+    {
+        /* Log */
+        borg_note("# Taking off less valuable right ring.");
+
+        /* Take it off */
+        borg_keypress('t');
+        borg_keypress(I2A(INVEN_RIGHT - INVEN_WIELD));
+
+		/* make sure one is on the left */
+		if (borg_items[INVEN_LEFT].iqty)
+		{
+			borg_note("# Taking off more valuable left ring.");
+        	/* Take it off */
+        	borg_keypress('t');
+        	borg_keypress(I2A(INVEN_LEFT - INVEN_WIELD));
+		}
+
+	    /* update the borg's inventory */
+	    (void)borg_notice(TRUE);
+
+		/* Wear the nice ring on the Right Hand */
+		for (i=0; i < INVEN_PACK; i++)
+		{
+			/*get the item*/
+			item = &borg_items[i];
+
+ 			/*Compare this item to the ring I want on Right side */
+			if (!streq(current_left_ring, item->desc)) continue;
+
+			/* Found it, stick it on right hand */
+/* 	        borg_keypress('w'); */
+/* Borg is not reading inven correctly 	        borg_keypress(I2A(i)); */
+		}
+
+	    /* update the borg's inventory */
+	    (void)borg_notice(TRUE);
+
+		/* Wear the nice ring on the Right Hand */
+		for (i=0; i< INVEN_PACK; i++)
+		{
+			/*get the item*/
+			item = &borg_items[i];
+
+			/*Compare this item to the ring I want on Left side */
+			if (!streq(current_right_ring, item->desc)) continue;
+
+			/* Found it, stick it on right hand */
+/* 	        borg_keypress('w'); */
+/*Borg is not reading inven correctly 	        borg_keypress(I2A(i)); */
+		}
+
+	    /* update the borg's inventory */
+	    borg_notice(TRUE);
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+
+/*
+ * Place our "best" ring on the "tight" finger if needed
+ *
+ * This function is adopted from "borg_wear_stuff()"
+ *
+ * Basically, we evaluate the world in which each ring is added
+ * to the current set of equipment, and we wear the ring, if any,
+ * that gives us the most "power".
+ *
+ * The "borg_swap_rings()" code above occasionally allows us to remove
+ * both rings, at which point this function will place the "best" ring
+ * on the "tight" finger, and then the "borg_best_stuff()" function will
+ * allow us to put on our second "best" ring on the "loose" finger.
+ *
+ * This function should only be used when a ring finger is empty.
+ */
+bool borg_wear_rings(void)
+{
+    int slot;
+    int hole = INVEN_PACK - 1;
+
+    s32b p, b_p = 0L;
+
+    int i, b_i = -1;
+
+    borg_item *item;
+
+    bool fix = FALSE;
+
+
+    /* Require no rings */
+    if (borg_items[INVEN_LEFT].iqty) return (FALSE);
+    if (borg_items[INVEN_RIGHT].iqty) return (FALSE);
+
+    /* Require two empty slots */
+    if (borg_items[hole-1].iqty) return (FALSE);
+
+    /* hack prevent the swap till you drop loop */
+    if (borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) return (FALSE);
+
+    /*apw Forbid if been sitting on level forever */
+    /*    Just come back and work through the loop later */
+    if (borg_t - borg_began > 2000) return (FALSE);
+    if (time_this_panel > 350) return (FALSE);
+
+    /* Scan inventory */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        item = &borg_items[i];
+
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+
+        /* Require "aware" */
+        if (!item->kind) continue;
+
+        /* Require "known" (or average) */
+        if (!item->able && !streq(item->note, "{average}")) continue;
+
+        /* Hack -- ignore "worthless" items */
+        if (!item->value) continue;
+
+        /* skip artifact rings not star id'd  */
+        if ((birth_rand_artifacts || adult_rand_artifacts) && !item->fully_identified && item->name1) continue;
+
+        /* Where does it go */
+        slot = borg_wield_slot(item);
+
+        /* Only process "rings" */
+        if (slot != INVEN_LEFT) continue;
+
+        /* Occassionally evaluate swapping into the tight finger */
+        if (rand_int(100) > 75 || item->activation == ACT_BIZZARE)
+        {
+            slot = INVEN_RIGHT;
+        }
+
+        /* Need to be careful not to put the One Ring onto
+         * the Left Hand
+         */
+        if (item->activation == ACT_BIZZARE &&
+           (borg_items[INVEN_RIGHT].iqty))
+            continue;
+
+        /* Save the old item (empty) */
+        COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+        /* Save the new item */
+        COPY(&safe_items[i], &borg_items[i], borg_item);
+
+        /* Wear new item */
+        COPY(&borg_items[slot], &safe_items[i], borg_item);
+
+        /* Only a single item */
+        borg_items[slot].iqty = 1;
+
+        /* Reduce the inventory quantity by one */
+        borg_items[i].iqty--;
+
+        /* Fix later */
+        fix = TRUE;
+
+        /* Examine the inventory */
+        borg_notice(FALSE);
+
+        /* Evaluate the inventory */
+        p = borg_power();
+
+		/* the One Ring would be awsome */
+		if (item->activation == ACT_BIZZARE) p = my_power * 2;
+
+        /* Restore the old item (empty) */
+        COPY(&borg_items[slot], &safe_items[slot], borg_item);
+
+        /* Restore the new item */
+        COPY(&borg_items[i], &safe_items[i], borg_item);
+
+        /* Ignore "bad" swaps */
+        if ((b_i >= 0) && (p < b_p)) continue;
+
+        /* Maintain the "best" */
+        b_i = i; b_p = p;
+    }
+
+    /* Restore bonuses */
+    if (fix) borg_notice(TRUE);
+
+    /* No item */
+    if ((b_i >= 0) && (b_p > my_power))
+    {
+        /* Get the item */
+        item = &borg_items[b_i];
+
+        /* Log */
+        borg_note("# Putting on best tight ring.");
+
+        /* Log */
+        borg_note(format("# Wearing %s.", item->desc));
+
+        /* Wear it */
+        borg_keypress('w');
+        borg_keypress(I2A(b_i));
+
+        /* Did something */
+        time_this_panel ++;
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+/*
+ * Place our "swap" if needed.   We check both the armour and the weapon
+ * then wear the one that give the best result (lowest danger).
+ * This function is adopted from "borg_wear_stuff()" and borg_wear_rings
+ *
+ * Basically, we evaluate the world in which the swap is added
+ * to the current set of equipment, and we use weapon,
+ * that gives the largest drop in danger---based mostly on resists.
+ *
+ * The borg is forbidden to swap out certain resistances.
+ *
+ */
+bool borg_backup_swap(int p)
+{
+    int slot;
+    int swap;
+
+    s32b b_p = 0L;
+    s32b b_p1 = 0L;
+    s32b b_p2 = 0L;
+
+    int i;
+
+	int save_rconf = 0;
+	int save_rblind = 0;
+	int save_fract = 0;
+
+    borg_item *item;
+
+    bool fix = FALSE;
+
+    /* hack prevent the swap till you drop loop */
+    if (borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) return (FALSE);
+
+    /*apw Forbid if been sitting on level forever */
+    /*    Just come back and work through the loop later */
+    if (time_this_panel > 300) return (FALSE);
+
+    /* make sure we have an appropriate swap */
+    if (armour_swap < 1 && weapon_swap < 1) return (FALSE);
+
+	/* Save our normal condition */
+	save_rconf = borg_skill[BI_RCONF];
+	save_rblind = borg_skill[BI_RBLIND];
+	save_fract = borg_skill[BI_FRACT];
+
+    /* Check the items, first armour then weapon */
+    i = armour_swap;
+
+    /* make sure it is not a -1 */
+    if (i == -1) i = 0;
+
+    /* get the item */
+    item = &borg_items[i];
+
+    /* Where does it go */
+    slot = borg_wield_slot(item);
+
+	/* safety check incase slot = -1 */
+	if (slot < 0) return (FALSE);
+
+    /* Save the old item (empty) */
+    COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+    /* Save the new item */
+    COPY(&safe_items[i], &borg_items[i], borg_item);
+
+    /* Wear new item */
+    COPY(&borg_items[slot], &safe_items[i], borg_item);
+
+    /* Only a single item */
+    borg_items[slot].iqty = 1;
+
+    /* Reduce the inventory quantity by one */
+    borg_items[i].iqty--;
+
+    /* Fix later */
+    fix = TRUE;
+
+    /* Examine the benefits of the swap item */
+    borg_notice(FALSE);
+
+    /* Evaluate the power with the new item worn */
+    b_p1 = borg_danger(c_y,c_x,1, TRUE);
+
+    /* Restore the old item (empty) */
+    COPY(&borg_items[slot], &safe_items[slot], borg_item);
+
+    /* Restore the new item */
+    COPY(&borg_items[i], &safe_items[i], borg_item);
+
+	/* Examine the critical skills */
+	if ((save_rconf) && borg_skill[BI_RCONF] == 0) b_p1 = 9999;
+	if ((save_rblind) &&
+	    (!borg_skill[BI_RBLIND] &&
+	     !borg_skill[BI_RLITE] &&
+	     !borg_skill[BI_RDARK] &&
+	      borg_skill[BI_SAV] < 100)) b_p1 = 9999;
+	if ((save_fract) &&
+		(!borg_skill[BI_FRACT] &&
+		  borg_skill[BI_SAV] < 100)) b_p1 = 9999;
+
+    /* Restore bonuses */
+    if (fix) borg_notice(TRUE);
+
+    /* apw skip random artifact not star id'd  */
+    if ((birth_rand_artifacts || adult_rand_artifacts) && !item->fully_identified && item->name1) b_p1 = 9999;
+
+    /* skip it if it has not been decursed */
+    if ((item->cursed) ||
+        (item->flags3 & TR3_HEAVY_CURSE)) b_p1 = 9999;
+
+    /* Now we check the weapon */
+
+    /* get the item */
+    i = weapon_swap;
+
+    /* make sure it is not a -1 */
+    if (i == -1) i = 0;
+
+    item = &borg_items[i];
+
+    /* Where does it go */
+    slot = borg_wield_slot(item);
+
+	/* safety check incase slot = -1 */
+	if (slot < 0) return (FALSE);
+
+    /* Save the old item (empty) */
+    COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+    /* Save the new item */
+    COPY(&safe_items[i], &borg_items[i], borg_item);
+
+    /* Wear new item */
+    COPY(&borg_items[slot], &safe_items[i], borg_item);
+
+    /* Only a single item */
+    borg_items[slot].iqty = 1;
+
+    /* Reduce the inventory quantity by one */
+    borg_items[i].iqty--;
+
+    /* Fix later */
+    fix = TRUE;
+
+    /* Examine the inventory */
+    borg_notice(FALSE);
+
+
+    /* Evaluate the power with the new item worn */
+    b_p2 = borg_danger(c_y,c_x,1, TRUE);
+
+	/* Examine the critical skills */
+	/* Examine the critical skills */
+	if ((save_rconf) && borg_skill[BI_RCONF] == 0) b_p2 = 9999;
+	if ((save_rblind) &&
+	    (!borg_skill[BI_RBLIND] &&
+	     !borg_skill[BI_RLITE] &&
+	     !borg_skill[BI_RDARK] &&
+	      borg_skill[BI_SAV] < 100)) b_p2 = 9999;
+	if ((save_fract) &&
+		(!borg_skill[BI_FRACT] &&
+		  borg_skill[BI_SAV] < 100)) b_p2 = 9999;
+
+    /* Restore the old item (empty) */
+    COPY(&borg_items[slot], &safe_items[slot], borg_item);
+
+    /* Restore the new item */
+    COPY(&borg_items[i], &safe_items[i], borg_item);
+
+    /* Restore bonuses */
+    if (fix) borg_notice(TRUE);
+
+    /* apw skip random artifact not star id'd  */
+    if ((birth_rand_artifacts || adult_rand_artifacts) && !item->fully_identified && item->name1) b_p2 = 9999;
+
+    /* skip it if it has not been decursed */
+    if ((item->cursed) ||
+        (item->flags3 & TR3_HEAVY_CURSE)) b_p2 = 9999;
+
+    /* Pass on the swap which yields the best result */
+    if (b_p1 <= b_p2)
+    {
+        b_p = b_p1;
+        swap = armour_swap;
+    }
+    else
+    {
+        b_p = b_p2;
+        swap = weapon_swap;
+    }
+
+    /* good swap.  Make sure it helps a significant amount */
+    if (p > b_p &&
+        b_p <= (borg_fighting_unique?((avoidance*2)/3): (avoidance/2)))
+    {
+        /* Log */
+        borg_note(format("# Swapping backup.  (%d < %d).", b_p, p));
+
+        /* Wear it */
+        borg_keypress('w');
+        borg_keypress(I2A(swap));
+
+        /* Did something */
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+/*
+ * Remove useless equipment.
+ *
+ * Look through the inventory for equipment that is reducing power.
+ *
+ * Basically, we evaluate the world both with the current set of
+ * equipment, and in the alternate world in which various items
+ * are removed, and we take
+ * one step towards the world in which we have the most "power".
+ */
+bool borg_remove_stuff(void)
+{
+    int hole = INVEN_PACK - 1;
+
+    s32b p, b_p = 0L, w_p= 0L;
+
+    int i, b_i = -1;
+
+    borg_item *item;
+
+    bool fix = FALSE;
+
+    /* apw hack to prevent the swap till you drop loop */
+    if (borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) return (FALSE);
+
+    /*apw Forbid if been sitting on level forever */
+    /*    Just come back and work through the loop later */
+    if (borg_t - borg_began > 2000) return (FALSE);
+    if (time_this_panel > 150) return (FALSE);
+
+    /* Start with good power */
+    b_p = my_power;
+
+    /* Scan equip */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        item = &borg_items[i];
+
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require "aware" */
+        if (!item->kind) continue;
+
+        /* Require "known" (or average, good, etc) */
+        if (!item->able &&
+            !streq(item->note, "{average}") &&
+            !streq(item->note, "{good}") &&
+            !strstr(item->note, "excellent}") &&
+            !strstr(item->note, "indestructible}") &&
+            !strstr(item->note, "special}")) continue;
+
+        /* skip it if it has not been decursed */
+        if ((item->cursed) ||
+            (item->flags3 & TR3_HEAVY_CURSE) ||
+            (inventory[i].ident & IDENT_CURSED)) continue;
+
+
+        /* Save the hole */
+        COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+        /* Save the item */
+        COPY(&safe_items[i], &borg_items[i], borg_item);
+
+        /* Take off the item */
+        COPY(&borg_items[hole], &safe_items[i], borg_item);
+
+        /* Erase the item from equip */
+        WIPE(&borg_items[i], borg_item);
+
+        /* Fix later */
+        fix = TRUE;
+
+        /* Examine the inventory */
+        borg_notice(FALSE);
+
+        /* Evaluate the inventory */
+        p = borg_power();
+
+        /* Restore the item */
+        COPY(&borg_items[i], &safe_items[i], borg_item);
+
+        /* Restore the hole */
+        COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+
+        /* Track the crappy items */
+        /* crappy includes things that do not add to power */
+
+        if (p >= b_p)
+        {
+            b_i = i;
+            w_p = p;
+        }
+
+    }
+
+    /* Restore bonuses */
+    if (fix) borg_notice(TRUE);
+
+    /* No item */
+    if (b_i >= 0)
+    {
+        /* Get the item */
+        item = &borg_items[b_i];
+
+#if 0
+		/* dump list and power...  for debugging */
+        borg_note(format("Equip Item %d %s.",  i, safe_items[i].desc));
+        borg_note(format("With Item     (borg_power %ld)", b_p));
+        borg_note(format("Removed Item  (best power %ld)", p));
+#endif
+
+        /* Log */
+        borg_note(format("# Removing %s.  Power with: (%ld) Power w/o (%ld)",
+            item->desc, b_p, w_p));
+
+        /* Wear it */
+        borg_keypress('t');
+        borg_keypress(I2A(b_i- INVEN_WIELD));
+
+        /* Did something */
+        time_this_panel ++;
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Wear useful equipment.
+ *
+ * Look through the inventory for equipment that is better than
+ * the current equipment, and wear it, in an optimal order.
+ *
+ * Basically, we evaluate the world both with the current set of
+ * equipment, and in the alternate world in which various items
+ * are used instead of the items they would replace, and we take
+ * one step towards the world in which we have the most "power".
+ *
+ * The "borg_swap_rings()" code above occasionally allows us to remove
+ * both rings, at which point this function will replace the "best" ring
+ * on the "tight" finger, and the second "best" ring on the "loose" finger.
+ */
+bool borg_wear_stuff(void)
+{
+    int hole = INVEN_PACK - 1;
+
+    int slot;
+    int d;
+
+    s32b p, b_p = 0L;
+
+    int i, b_i = -1;
+    int ii, b_ii =  -1;
+    int danger;
+    int itemm, to;
+
+	char target_ring_desc[80];
+
+    borg_item *item;
+
+    bool fix = FALSE;
+
+	/* Start with current power */
+	b_p = my_power;
+
+    /* Require an empty slot */
+    if (borg_items[hole].iqty) return (FALSE);
+
+    /* apw hack to prevent the swap till you drop loop */
+    if (borg_skill[BI_ISHUNGRY] || borg_skill[BI_ISWEAK]) return (FALSE);
+
+    /* Forbid if cursed */
+    if (borg_wearing_cursed) return (FALSE);
+
+    /*apw Forbid if been sitting on level forever */
+    /*    Just come back and work through the loop later */
+    if (borg_t - borg_began > 2000) return (FALSE);
+    if (time_this_panel > 300) return (FALSE);
+
+#if 0
+    itemm = z_info->k_max + z_info->k_max + z_info->a_max;
+    to = z_info->k_max + z_info->k_max + z_info->a_max + BI_MAX;
+	borg_note("# Dumping my actual skills");
+    for (;itemm < to; itemm++)
+    {
+        borg_note(format("skill %d (%s) value= %d.",itemm,
+            prefix_pref[itemm -
+            z_info->k_max -
+            z_info->k_max -
+            z_info->a_max], borg_has[itemm]));
+    }
+#endif
+
+
+    /* Scan inventory */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        item = &borg_items[i];
+
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require "aware" */
+        if (!item->kind) continue;
+
+        /* Require "known" (or average, good, etc) */
+        if (!item->able &&
+            !streq(item->note, "{average}") &&
+            !streq(item->note, "{good}") &&
+            !streq(item->note, "{excellent}") &&
+            !strstr(item->note, "indestructible}") &&
+            !strstr(item->note, "special}")) continue;
+
+        /* Hack -- ignore "worthless" items */
+        if (!item->value) continue;
+
+        /* apw do not wear not *idd* artifacts */
+        if ((birth_rand_artifacts || adult_rand_artifacts) &&
+            !item->fully_identified && item->name1) continue;
+
+        /* skip it if it has not been decursed, unless the One Ring */
+        if (((item->cursed) ||
+            (item->flags3 & TR3_HEAVY_CURSE) ||
+            (inventory[i].ident & IDENT_CURSED)) &&
+            (item->activation != ACT_BIZZARE)) continue;
+
+        /* Where does it go */
+        slot = borg_wield_slot(item);
+
+        /* Cannot wear this item */
+        if (slot < 0) continue;
+
+        /* Obtain danger */
+        danger = borg_danger(c_y,c_x,1, TRUE);
+
+        /* If this is a ring and both hands are full, then check each hand
+         * and compare the two.  If needed the tight ring can be removed then
+         * the better ring placed there on.
+         */
+
+        /*** Process regular items and non full rings ***/
+
+        /* Non ring, non full hands */
+        if (slot != INVEN_LEFT ||
+            (!borg_items[INVEN_LEFT].tval || !borg_items[INVEN_RIGHT].tval))
+        {
+            /* Save the old item */
+            COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+            /* Save the new item */
+            COPY(&safe_items[i], &borg_items[i], borg_item);
+
+            /* Save the hole */
+            COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+            /* Take off old item */
+            COPY(&borg_items[hole], &safe_items[slot], borg_item);
+
+            /* Wear new item */
+            COPY(&borg_items[slot], &safe_items[i], borg_item);
+
+            /* Only a single item */
+            borg_items[slot].iqty = 1;
+
+            /* Reduce the inventory quantity by one */
+            borg_items[i].iqty--;
+
+            /* Fix later */
+            fix = TRUE;
+
+            /* Examine the inventory */
+            borg_notice(FALSE);
+
+            /* Evaluate the inventory */
+            p = borg_power();
+
+            /* Evaluate local danger */
+            d = borg_danger(c_y,c_x,1, TRUE);
+#if 0
+            /* dump list and power...  for debugging */
+            borg_note(format("Trying Item %s (best power %ld)",borg_items[slot].desc, p));
+            borg_note(format("Against Item %s   (borg_power %ld)",safe_items[slot].desc, b_p));
+#endif
+
+            /* Restore the old item */
+            COPY(&borg_items[slot], &safe_items[slot], borg_item);
+
+            /* Restore the new item */
+            COPY(&borg_items[i], &safe_items[i], borg_item);
+
+            /* Restore the hole */
+            COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+	        /* Need to be careful not to put the One Ring onto
+	         * the Left Hand
+	         */
+	        if (item->activation == ACT_BIZZARE &&
+	        	!borg_items[INVEN_LEFT].tval)
+	            p = -99999;
+
+            /* Ignore "bad" swaps */
+            if (p < b_p) continue;
+
+            /* Ignore if more dangerous */
+            if (danger < d) continue;
+
+            /* XXX XXX XXX Consider if slot is empty */
+
+            /* Hack -- Ignore "equal" swaps */
+            if ((b_i >= 0) && (p == b_p)) continue;
+
+            /* Maintain the "best" */
+            b_i = i; b_p = p;
+        } /* non-rings, non full */
+
+
+	if (rand_int(100)==1 || item->activation == ACT_BIZZARE)
+	{
+        /* ring, full hands */
+        if (slot == INVEN_LEFT &&
+            borg_items[INVEN_LEFT].tval && borg_items[INVEN_RIGHT].tval)
+        {
+                for (ii = INVEN_LEFT; ii <= INVEN_RIGHT; ii++)
+                {
+                    slot = ii;
+
+                    /* Does One Ring need to be handled here? */
+
+                    /* Save the old item */
+                    COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+                    /* Save the new item */
+                    COPY(&safe_items[i], &borg_items[i], borg_item);
+
+                    /* Save the hole */
+                    COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+                    /* Take off old item */
+                    COPY(&borg_items[hole], &safe_items[slot], borg_item);
+
+                    /* Wear new item */
+                    COPY(&borg_items[slot], &safe_items[i], borg_item);
+
+                    /* Only a single item */
+                    borg_items[slot].iqty = 1;
+
+                    /* Reduce the inventory quantity by one */
+                    borg_items[i].iqty--;
+
+                    /* Fix later */
+                    fix = TRUE;
+
+                    /* Examine the inventory */
+                    borg_notice(FALSE);
+
+                    /* Evaluate the inventory */
+                    p = borg_power();
+
+                    /* Evaluate local danger */
+                    d = borg_danger(c_y,c_x,1, TRUE);
+
+                    /* Restore the old item */
+                    COPY(&borg_items[slot], &safe_items[slot], borg_item);
+
+                    /* Restore the new item */
+                    COPY(&borg_items[i], &safe_items[i], borg_item);
+
+                    /* Restore the hole */
+                    COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+			        /* Need to be careful not to put the One Ring onto
+			         * the Left Hand
+			         */
+			        if (ii == INVEN_LEFT &&
+			            item->activation == ACT_BIZZARE)
+			            p = -99999;
+
+                    /* Ignore "bad" swaps */
+                    if (p < b_p) continue;
+
+                    /* no swapping into more danger */
+                    if (danger <= d && danger != 0) continue;
+
+                    /* Maintain the "best" */
+                    b_i = i; b_p = p; b_ii = ii;
+
+                }
+            } /* ring, looking at replacing each ring */
+		} /* Random ring check */
+
+    } /* end scanning inventory */
+
+    /* Restore bonuses */
+    if (fix) borg_notice(TRUE);
+
+    /* item */
+    if ((b_i >= 0) && (b_p > my_power))
+    {
+        /* Get the item */
+        item = &borg_items[b_i];
+
+		/* Define the desc of the nice ring */
+		strcpy(target_ring_desc, item->desc);
+
+        /* Remove old ring to make room for good one */
+        if (b_ii >= INVEN_RIGHT && item->tval == TV_RING)
+        {
+            /* Log */
+            borg_note(format("# Removing %s to make room for %s.", &borg_items[b_ii].desc, item->desc));
+
+            /* Make room */
+            borg_keypress('t');
+            borg_keypress(I2A(b_ii-INVEN_WIELD));
+
+	        /* Did something */
+	        time_this_panel ++;
+	        return (TRUE);
+        }
+
+        /* Log */
+        borg_note(format("# Wearing %s.", item->desc));
+
+        /* Wear it */
+        borg_keypress('w');
+        borg_keypress(I2A(b_i));
+        time_this_panel ++;
+        return (TRUE);
+
+	}
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+
+/*
+ * Hack -- order of the slots
+ *
+ * XXX XXX XXX Note that we ignore the "tight" ring, and we
+ * assume that we will always be wearing our "best" ring on
+ * our "right" (tight) finger, and if we are not, then the
+ * "borg_swap_rings()" function will remove both the rings,
+ * which will induce the "borg_best_stuff()" function to put
+ * the rings back on in the "optimal" order.
+ */
+static byte borg_best_stuff_order[] =
+{
+    INVEN_BOW,
+    INVEN_WIELD,
+    INVEN_BODY,
+    INVEN_OUTER,
+    INVEN_ARM,
+    INVEN_HEAD,
+    INVEN_HANDS,
+    INVEN_FEET,
+    INVEN_LEFT,
+    INVEN_LITE,
+    INVEN_NECK,
+
+    255
+};
+
+
+/*
+ * Helper function (see below)
+ */
+static void borg_best_stuff_aux(int n, byte *test, byte *best, s32b *vp)
+{
+    int i;
+
+    int slot;
+
+
+    /* Extract the slot */
+    slot = borg_best_stuff_order[n];
+
+    /* All done */
+    if (slot == 255)
+    {
+        s32b p;
+
+        /* Examine */
+        borg_notice(FALSE);
+
+        /* Evaluate */
+        p = borg_power();
+
+        /* Track best */
+        if (p > *vp)
+        {
+
+#if 0
+            /* dump list and power...  for debugging */
+            borg_note(format("Trying Combo (best power %ld)", *vp));
+            borg_note(format("             (borg_power %ld)", p));
+            for (i = 0; i < INVEN_PACK; i++)
+                borg_note(format("inv %d %s.",  i, borg_items[i].desc));
+            for (i=0; borg_best_stuff_order[i] != 255; i++)
+                borg_note(format("stuff %s.",
+                    borg_items[borg_best_stuff_order[i]].desc));
+#endif
+            /* Save the results */
+            for (i = 0; i < n; i++) best[i] = test[i];
+
+            /* Use it */
+            *vp = p;
+        }
+
+        /* Success */
+        return;
+    }
+
+
+    /* Note the attempt */
+    test[n] = slot;
+
+    /* Evaluate the default item */
+    borg_best_stuff_aux(n + 1, test, best, vp);
+
+
+    /* Try other possible objects */
+    for (i = 0; i < ((shop_num == 7) ? (INVEN_PACK + STORE_INVEN_MAX) : INVEN_PACK); i++)
+    {
+        borg_item *item;
+        if (i < INVEN_PACK)
+            item = &borg_items[i];
+        else
+            item = &borg_shops[7].ware[i - INVEN_PACK];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Require "aware" */
+        if (!item->kind) continue;
+
+        /* Require "known" (or average, good, etc) */
+        if (!item->able &&
+            !streq(item->note, "{average}") &&
+            !streq(item->note, "{good}") &&
+            !streq(item->note, "{excellent}") &&
+            !strstr(item->note, "indestructible}") &&
+            !strstr(item->note, "special}")) continue;
+
+        /* Hack -- ignore "worthless" items */
+        if (!item->value) continue;
+
+        /* Skip it if it has not been decursed */
+        if ((item->cursed) ||
+            (item->flags3 & TR3_HEAVY_CURSE) ||
+            (inventory[i].ident & IDENT_CURSED)) continue;
+
+        /* Do not wear not *idd* artifacts */
+        if ((birth_rand_artifacts || adult_rand_artifacts) &&
+            !item->fully_identified && item->name1) continue;
+
+        /* Make sure it goes in this slot, special consideration for checking rings */
+        if (slot != borg_wield_slot(item)) continue;
+
+        /* Make sure that slot does not have a cursed item */
+        if ((borg_items[slot].cursed) ||
+            (borg_items[slot].flags3 & TR3_HEAVY_CURSE) ||
+            (inventory[slot].ident & IDENT_CURSED)) continue;
+
+        /* Wear the new item */
+        COPY(&borg_items[slot], item, borg_item);
+
+        /* Note the attempt */
+        if (i < INVEN_PACK)
+            test[n] = i;
+        else
+            /* if in home, note by adding 100 to item number. */
+            test[n] = (i - INVEN_PACK) + 100;
+
+
+        /* Evaluate the possible item */
+        borg_best_stuff_aux(n + 1, test, best, vp);
+
+        /* Restore equipment */
+        COPY(&borg_items[slot], &safe_items[slot], borg_item);
+    }
+}
+
+
+/*
+ * Attempt to instantiate the *best* possible equipment.
+ */
+bool borg_best_stuff(void)
+{
+    int hole = INVEN_PACK - 1;
+
+    int k;
+
+    s32b value;
+
+    int i;
+
+    byte test[12];
+    byte best[12];
+
+
+    /* Hack -- Anti-loop */
+    if (time_this_panel >= 300) return (FALSE);
+
+    /* Hack -- Initialize */
+    for (k = 0; k < 12; k++)
+    {
+        /* Initialize */
+        best[k] = test[k] = 255;
+    }
+
+    /* Hack -- Copy all the slots */
+    for (i = 0; i < INVEN_TOTAL; i++)
+    {
+        /* Save the item */
+        COPY(&safe_items[i], &borg_items[i], borg_item);
+    }
+
+    if (shop_num == 7)
+    {
+        /* Hack -- Copy all the store slots */
+        for (i = 0; i < STORE_INVEN_MAX; i++)
+        {
+            /* Save the item */
+            COPY(&safe_home[i], &borg_shops[7].ware[i], borg_item);
+        }
+    }
+
+    /* Evaluate the inventory */
+    value = my_power;
+
+    /* Determine the best possible equipment */
+    (void)borg_best_stuff_aux(0, test, best, &value);
+
+    /* Restore bonuses */
+    borg_notice(TRUE);
+
+    /* Make first change. */
+    for (k = 0; k < 12; k++)
+    {
+        /* Get choice */
+        i = best[k];
+
+        /* Ignore non-changes */
+        if (i == borg_best_stuff_order[k] || 255 == i) continue;
+
+        if (i < 100)
+        {
+            /* weild the item */
+            borg_item *item = &borg_items[i];
+            borg_note(format("# Best Combo %s.", item->desc));
+
+            borg_keypress('w');
+            borg_keypress(I2A(i));
+            time_this_panel ++;
+            return (TRUE);
+        }
+        else
+        {
+            borg_item *item;
+
+            /* can't get an item if full. */
+            if (borg_items[hole].iqty) return (FALSE);
+
+            i-=100;
+
+            item = &borg_shops[7].ware[i];
+
+            /* Dont do it if you just sold this item */
+            if (sold_item_tval == item->tval && sold_item_sval == item->sval &&
+                sold_item_pval == item->pval && sold_item_store == 7) return (FALSE);
+
+            /* Get the item */
+            borg_note(format("# Getting (Best Fit) %s.", item->desc));
+
+            /* Take the stuff from home and put in inv. and try again. */
+#if 0 /* 285 has m-x on page two */
+            /* Minor Hack -- Go to the correct page */
+            if ((i / 12) != borg_shops[7].page)
+            {
+                borg_keypress(' ');
+            }
+#endif
+
+            borg_keypress('p');
+            borg_keypress(I2A(i));
+
+            /* press enter a few time (mulitple objects) */
+            borg_keypress('\r');
+            borg_keypress('\r');
+            borg_keypress('\r');
+            borg_keypress('\r');
+
+
+            /* tick the clock */
+            time_this_panel ++;
+
+            return (TRUE);
+        }
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+
+
+
+
+/*
+ * Study and/or Test spells/prayers
+ */
+bool borg_play_magic(bool bored)
+{
+    int book, b_book = -1;
+    int what;
+
+    int i, b_i = -1;
+    int j, b_j = -1;
+    int r, b_r = -1;
+
+
+    /* Hack -- must use magic or prayers */
+    if (!cp_ptr->spell_book) return (FALSE);
+
+
+    /* Hack -- blind/confused */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) return (FALSE);
+
+    /* Dark */
+    if (!borg_skill[BI_CURLITE]) return (FALSE);
+/*    if (borg_grids[c_y][c_x].info == BORG_DARK) return (FALSE); */
+
+    /* Check each book (backwards) */
+    for (book = 9 - 1; book >= 0; book--)
+    {
+        /* Look for the book in inventory*/
+        i = borg_book[book];
+
+        /* No such book */
+        if (i < 0) continue;
+
+        /* Check each spells */
+        for (what = 9 - 1 ; what >= 0; what--)
+        {
+            borg_magic *as = &borg_magics[book][what];
+
+            /* Require "learnable" status */
+            if (as->status != BORG_MAGIC_OKAY) continue;
+
+            /* Obtain "index" */
+            j = what;
+
+            /* Obtain "rating" */
+            r = as->rating;
+
+            /* Skip "boring" spells/prayers */
+            if (!bored && (r <= 50)) continue;
+
+            /* Skip "icky" spells/prayers */
+            if (r <= 0) continue;
+
+            /* Skip "worse" spells/prayers */
+            if (r <= b_r) continue;
+
+            /* Track it */
+            b_i = i;
+            b_j = j;
+            b_r = r;
+            b_book = book;
+        }
+    }
+
+
+    /* Study */
+    if (borg_skill[BI_ISSTUDY] && (b_r > 0))
+    {
+        borg_magic *as = &borg_magics[b_book][b_j];
+
+        /* Debugging Info */
+        borg_note(format("# Studying spell/prayer %s.", as->name));
+
+        /* Learn the spell */
+        borg_keypress('G');
+
+        /* Specify the book */
+        borg_keypress(I2A(b_i));
+
+        /* Specify the spell (but not the prayer) */
+        if (cp_ptr->flags & CF_CHOOSE_SPELLS)
+        {
+            /* Specify the spell */
+            borg_keypress(I2A(b_j));
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /* Hack -- only in town */
+    if (borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /* Hack -- only when bored */
+    if (!bored) return (FALSE);
+
+
+    /* Check each book (backwards) */
+    for (book = 9 - 1; book >= 0; book--)
+    {
+        /* Look for the book */
+        i = borg_book[book];
+
+        /* No such book */
+        if (i < 0) continue;
+
+        /* Check every spell (backwards) */
+        for (what = 9 - 1; what >= 0; what--)
+        {
+            borg_magic *as = &borg_magics[book][what];
+
+            /* Only try "untried" spells/prayers */
+            if (as->status != BORG_MAGIC_TEST) continue;
+
+            /* Ignore "bizarre" spells/prayers */
+            if (as->method == BORG_MAGIC_OBJ) continue;
+
+            /* Make sure I have enough mana */
+            if (borg_skill[BI_CURSP] < as->power) continue;
+
+            /* Note */
+            borg_note("# Testing untried spell/prayer");
+
+            /* Hack -- Use spell or prayer */
+            if (borg_spell(book, what) ||
+                borg_prayer(book, what))
+            {
+                /* Hack -- Allow attack spells */
+                if (as->method == BORG_MAGIC_AIM)
+                {
+                    /* Hack -- target self */
+                    borg_keypress('*');
+                    borg_keypress('p');
+                    borg_keypress('t');
+                }
+
+                /* Hack -- Allow genocide spells */
+                if (as->method == BORG_MAGIC_WHO)
+                {
+                    /* Hack -- target Maggot */
+                    borg_keypress('h');
+                }
+
+                /* Success */
+                return (TRUE);
+            }
+        }
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Count the number of items worth "selling"
+ *
+ * This determines the choice of stairs.
+ *
+ * XXX XXX XXX Total hack, by the way...
+ */
+int borg_count_sell(void)
+{
+    int i, k = 0;
+
+    s32b price;
+    s32b greed;
+
+
+    /* Calculate "greed" factor */
+    greed = (borg_gold / 100L) + 100L;
+
+    /* Minimal greed */
+    if (greed < 1000L) greed = 1000L;
+    if (greed > 25000L) greed = 25000L;
+	if (borg_skill[BI_MAXDEPTH] >= 50) greed = 75000;
+
+    /* Count "sellable" items */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip "crappy" items */
+        if (item->value <= 0) continue;
+
+        /* skip our swap weapon */
+        if (i == weapon_swap) continue;
+        if (i == armour_swap) continue;
+
+		/* Skip our books */
+        if (item->tval == cp_ptr->spell_book) continue;
+
+        /* Obtain the base price */
+        price = ((item->value < 30000L) ? item->value : 30000L);
+
+        /* Skip cheap "known" (or "average") items */
+        if ((price * item->iqty < greed) &&
+            (item->able || streq(item->note, "{average}"))) continue;
+
+        /* Count remaining items */
+        k++;
+    }
+
+    /* Result */
+    return (k);
+}
+
+
+/*
+ * Scan the item list and recharge items before leaving the
+ * level.  Right now rod are not recharged from this.
+ */
+bool borg_wear_recharge(void)
+{
+    int i, b_i = -1;
+
+
+    /* No resting in danger */
+    if (!borg_check_rest()) return (FALSE);
+
+    /* Not if hungry */
+    if (borg_skill[BI_ISWEAK]) return (FALSE);
+
+    /* Look for an (wearable- non rod) item to recharge */
+    for (i = 0; i < INVEN_TOTAL; i++)
+    {
+        borg_item *item = &borg_items[i];
+        object_type *o_ptr;  /* cheat */
+        o_ptr = &inventory[i]; /* cheat */
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* skip items that are charged */
+        if (!item->timeout) continue;
+
+        /* Cheat-- the borg is misreading his equip.
+         * So this is pulling the info right from the game.
+         */
+        if (!o_ptr->timeout) continue;
+
+        /* note this one */
+        b_i = i;
+    }
+
+    if (b_i>= INVEN_WIELD)
+    {
+        /* Item is worn, no swap is nec. */
+        borg_note(format("# Waiting for '%s' to Recharge.", borg_items[b_i].desc));
+
+        /* Rest for a while */
+        borg_keypress('R');
+        borg_keypress('7');
+        borg_keypress('5');
+        borg_keypress('\n');
+
+        /* done */
+        return (TRUE);
+    }
+    /* Item must be worn to be recharged
+     * But, none if some equip is cursed
+     */
+    else if (b_i >= 0 && b_i <= INVEN_PACK && !borg_wearing_cursed)
+    {
+
+        /* wear the item */
+        borg_note("# Swapping Item for Recharge.");
+        borg_keypress(ESCAPE);
+        borg_keypress('w');
+        borg_keypress(I2A(b_i));
+        borg_keypress(' ');
+        borg_keypress(' ');
+
+        /* rest for a while */
+        borg_keypress('R');
+        borg_keypress('7');
+        borg_keypress('5');
+        borg_keypress('\n');
+
+        /* done */
+        return (TRUE);
+
+    }
+
+    /* nothing to recharge */
+    return (FALSE);
+}
+
+/*
+ * Leave the level if necessary (or bored)
+ * Scumming defined in borg_prepared.
+ */
+bool borg_leave_level(bool bored)
+{
+    int k, g = 0;
+
+	bool need_restock = FALSE;
+
+    /* Hack -- waiting for "recall" other than depth 1 */
+    if (goal_recalling && borg_skill[BI_DEPTH] > 1) return (FALSE);
+
+    /* There is a great concern about recalling back to level 100.
+     * Often the borg will fall down a trap door to level 100 when he is not
+     * prepared to be there.  Some classes can use Teleport Level to get
+     * back up to 99,  But Warriors cannot.  Realistically the borg needs
+     * be be able to scum deep in the dungeon.  But he cannot risk being
+     * on 100 and using the few *Healing* pots that he managed to collect.
+     * It is better for warriors to walk all the way down to 98 and scum.
+     * It seems like a long and nasty crawl, but it is the best way to
+     * make sure the borg survives.  Along the way he will collect the
+     * Healing, Life and *Healing* that he needs.
+     *
+     * The other classes (or at least those who can use the Teleport Level
+     * spell) will not need to do this nasty crawl.  Risky Borgs will
+     * not crawl either.
+     */
+
+    /* Town */
+    if (!borg_skill[BI_CDEPTH])
+    {
+        /* Cancel rising */
+        goal_rising = FALSE;
+
+        /* Wait until bored */
+        if (!bored) return (FALSE);
+
+        /* Case for those who cannot Teleport Level */
+        if (borg_skill[BI_MAXDEPTH] == 100 && !borg_plays_risky)
+        {
+	        if (borg_skill[BI_ATELEPORTLVL] == 0)
+            {
+                /* These pple must crawl down to 100, Sorry */
+                goal_fleeing = TRUE;
+                goal_leaving = TRUE;
+                stair_more = TRUE;
+
+                /* Note */
+                borg_note("# Borg must crawl to deep dungeon- no recall to 100.");
+
+                /* Attempt to use those stairs */
+                if (borg_flow_stair_more(GOAL_BORE)) return (TRUE);
+
+                /* Oops */
+                return (FALSE);
+            }
+        }
+
+
+        /* Hack -- Recall into dungeon */
+        if ((borg_skill[BI_MAXDEPTH] >= (borg_worships_gold ? 8 : 5)) &&
+             (borg_skill[BI_RECALL] >= 3) &&
+             (((cptr)NULL == borg_prepared(borg_skill[BI_MAXDEPTH]*6/10))||
+                borg_plays_risky) &&
+            borg_recall())
+        {
+            /* Note */
+            borg_note("# Recalling into dungeon.");
+
+            /* Give it a shot */
+            return (TRUE);
+        }
+        else
+        {
+            /* note why we didn't recall. */
+            if (borg_skill[BI_MAXDEPTH] < (borg_worships_gold ? 8 : 5))
+            {
+				borg_note("# Not deep enough to recall");
+			}
+            else
+            {
+                if (borg_skill[BI_RECALL] <= 2)
+                {
+					borg_note("# Not enough recalls to recall");
+				}
+                else
+                {
+                	/* recall unless way out of our league */
+                    if ((cptr)NULL != borg_prepared(borg_skill[BI_MAXDEPTH]*6/10))
+                    {
+                        borg_note(format("# Way too scary to recall down there!   %s",
+                            borg_prepared(borg_skill[BI_MAXDEPTH])));
+                    }
+                    else
+                    {
+						borg_note("# failed to recall when I wanted to");
+					}
+                }
+			}
+        goal_fleeing = TRUE;
+        goal_leaving = TRUE;
+        }
+
+        stair_more = TRUE;
+
+        /* Attempt to use those stairs */
+        if (borg_flow_stair_more(GOAL_BORE)) return (TRUE);
+
+        /* Oops */
+        return (FALSE);
+    }
+
+    /** In the Dungeon **/
+
+    /* do not hangout on boring levels for *too* long */
+    if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH] + 1)) g = 1;
+
+    /* Count sellable items */
+    k = borg_count_sell();
+
+    /* Do not dive when "full" of items */
+    if (g && (k >= 12)) g = 0;
+
+    /* Do not dive when drained */
+    if (g && borg_skill[BI_ISFIXEXP]) g = 0;
+
+
+    /* Hack -- Stay on each level for a minimal amount of time */
+    if (borg_skill[BI_CLEVEL] > 10 &&
+        g != 0 &&
+        (borg_t - borg_began < value_feeling[borg_feeling]))
+    {
+        g = 0;
+    }
+
+    /* Rise a level if bored and unable to dive. */
+    if (bored && ((cptr)NULL != borg_prepared(borg_skill[BI_CDEPTH] + 1)))
+    {
+        g = -1;
+        borg_slow_return = TRUE;
+        borg_note(format("# heading up (bored and unable to dive: %s)",
+                    borg_prepared(borg_skill[BI_CDEPTH] + 1)));
+        borg_slow_return = FALSE;
+    }
+
+    /* Power dive if I am playing too shallow*/
+    if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH] + 5) ) g = 1;
+
+    /* Power dive if I am playing deep */
+    if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH] + 1) &&
+         borg_skill[BI_CDEPTH] >= 75) g = 1;
+
+    /* Hack -- Power-climb upwards when needed */
+    if ((cptr)NULL != borg_prepared(borg_skill[BI_CDEPTH]))
+    {
+		/* Certain checks are bypassed if Unique monster on level */
+		if (!unique_on_level)
+		{
+	        borg_slow_return = TRUE;
+	        borg_note(format("# Climbing (too deep: %s)",
+                            borg_prepared(borg_skill[BI_CDEPTH])));
+        	borg_slow_return = FALSE;
+        	g = -1;
+
+	        /* if I am really out of depth go to town */
+	        if ((cptr)NULL != borg_prepared(borg_skill[BI_MAXDEPTH]*5/10) &&
+	            borg_skill[BI_MAXDEPTH] > 65)
+	        {
+	            borg_slow_return = TRUE;
+	            borg_note(format("# Returning to town (too deep: %s)",
+	                            borg_prepared(borg_skill[BI_CDEPTH])));
+	            goal_rising = TRUE;
+	            borg_slow_return = FALSE;
+	        }
+		}
+
+        /* if I must  go to town without delay */
+        if ((cptr)NULL != borg_restock(borg_skill[BI_CDEPTH]))
+        {
+            borg_note(format("# returning to town to restock(too deep: %s)",
+                            borg_restock(borg_skill[BI_CDEPTH])));
+            goal_rising = TRUE;
+            need_restock = TRUE;
+        }
+    }
+
+    /* Hack -- if I am playing way too shallow return to town */
+    if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH] + 20) &&
+        (cptr)NULL == borg_prepared(borg_skill[BI_MAXDEPTH] *6/10) &&
+        borg_skill[BI_MAXDEPTH] > borg_skill[BI_CDEPTH] + 10)
+    {
+        borg_note("# returning to town to recall back down (too shallow)");
+        goal_rising = TRUE;
+    }
+
+    /* Hack -- It is much safer to scum for items on 98
+     * Check to see if depth 99, if Sauron is dead and Im not read to fight
+     * the final battle
+     */
+    if (borg_skill[BI_CDEPTH] == 99 && borg_race_death[546] == 1 &&
+        borg_ready_morgoth !=1)
+    {
+        borg_note("# Returning to level 98 to scum for items.");
+        g = -1;
+    }
+
+    /* Power dive if Morgoth is dead */
+    if (borg_skill[BI_KING]) g = 1;
+
+    /* Power dive to 99 if ready */
+    if ((cptr)NULL == borg_prepared(99)) g = 1;
+
+	/* Climb if deeper than I want to be */
+	if (borg_skill[BI_CDEPTH] > borg_no_deeper)
+    {
+        borg_note(format("# Going up a bit (No Deeper than %d).", borg_no_deeper));
+        g = -1;
+    }
+
+    /* Return to town to sell stuff -- No recall allowed.*/
+    if (((borg_worships_gold || borg_skill[BI_MAXCLEVEL] < 5) &&
+         borg_skill[BI_MAXCLEVEL] <= 20) && (k >= 12))
+    {
+        borg_note("# Going to town (Sell Stuff, Worshipping Gold).");
+        g = -1;
+    }
+
+    /* Return to town to sell stuff */
+    if (bored && (k >= 12))
+    {
+        borg_note("# Going to town (Sell Stuff).");
+        goal_rising = TRUE;
+    }
+
+    /* Return to town when level drained */
+    if (borg_skill[BI_ISFIXLEV])
+    {
+        borg_note("# Going to town (Fix Level).");
+        goal_rising = TRUE;
+    }
+
+    /* Return to town to restore experience */
+    if (bored && borg_skill[BI_ISFIXEXP] && borg_skill[BI_CLEVEL] !=50)
+    {
+        borg_note("# Going to town (Fix Experience).");
+        goal_rising = TRUE;
+    }
+
+    /* return to town if it has been a while */
+    if ((!goal_rising && bored && !vault_on_level && !borg_fighting_unique &&
+         borg_time_town + borg_t - borg_began > 8000) ||
+        (borg_time_town + borg_t - borg_began > 12000))
+    {
+        borg_note("# Going to town (I miss my home).");
+        goal_rising = TRUE;
+    }
+
+    /* return to town if been scumming for a bit */
+    if (borg_skill[BI_MAXDEPTH] >= borg_skill[BI_CDEPTH] + 10 &&
+        borg_skill[BI_CDEPTH] <= 12 &&
+        borg_time_town + borg_t - borg_began > 3500)
+    {
+        borg_note("# Going to town (scumming check).");
+        goal_rising = TRUE;
+    }
+
+	/* Low level dudes need to visit town more frequently to keep up on food */
+	if (borg_skill[BI_CLEVEL] < 25)
+	{
+		if (borg_time_town + (borg_t - borg_began) > (borg_skill[BI_CLEVEL] * 250) ||
+			borg_time_town + (borg_t - borg_began) > 2500 ||
+			(borg_time_town + (borg_t - borg_began) > 2000 && borg_skill[BI_REG]))
+		{
+	        borg_note("# Going to town (short trips).");
+	        goal_rising = TRUE;
+	    }
+	}
+
+    /* if returning to town, try to go upstairs */
+    if (goal_rising) g = -1;
+
+    /* Mega-Hack -- spend time on the first level to rotate shops */
+    if (borg_skill[BI_CLEVEL] > 10 &&
+        (borg_skill[BI_CDEPTH] == 1) &&
+        (borg_t - borg_began < 100) &&
+        (g < 0) &&
+        (borg_skill[BI_FOOD] > 1))
+    {
+        borg_note("# Staying on level to rotate shops.");
+        g = 0;
+    }
+
+    /* Use random stairs when really bored */
+    if (bored && (borg_t - borg_began >= 5000))
+    {
+        /* Note */
+        borg_note("# Choosing random stairs.");
+
+        /* Use random stairs */
+        g = ((rand_int(100) < 50) ? -1 : 1);
+    }
+
+    /* Go Up */
+    if (g < 0)
+    {
+        /* Take next stairs */
+		borg_note("# Looking for up stairs.  Going up.");
+        stair_less = TRUE;
+
+        /* Hack -- recall if going to town */
+        if (goal_rising &&
+            ((borg_time_town + (borg_t - borg_began)) > 200) &&
+            (borg_skill[BI_CDEPTH] >= 5) &&
+            borg_recall())
+        {
+            borg_note("# Recalling to town (goal rising)");
+            return (TRUE);
+        }
+
+		/* Hack -- Recall if needing to Restock */
+		if (need_restock &&
+		    borg_skill[BI_CDEPTH] >= 5 &&
+			borg_recall())
+		{
+			borg_note("# Recalling to town (need to restock)");
+		}
+
+        /* Attempt to use stairs */
+        if (borg_flow_stair_less(GOAL_BORE)) return (TRUE);
+
+        /* Cannot find any stairs */
+        if (goal_rising && bored && (borg_t - borg_began) >= 1000)
+        {
+            if (borg_recall())
+            {
+                borg_note("# Recalling to town (no stairs)");
+                return (TRUE);
+            }
+        }
+    }
+
+
+    /* Go Down */
+    if (g > 0)
+    {
+        /* Take next stairs */
+        stair_more = TRUE;
+
+        /* Attempt to use those stairs */
+        if (borg_flow_stair_more(GOAL_BORE)) return (TRUE);
+    }
+
+
+    /* Failure */
+    return (FALSE);
+}
+
+
+
+
+
+/*
+ * Initialize this file
+ */
+void borg_init_7(void)
+{
+    /* Nothing */
+}
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg7.h angband-3.0.6-borg/src/borg7.h
--- angband-3.0.6/src/borg7.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg7.h	2003-10-20 08:43:34.000000000 -0700
@@ -0,0 +1,63 @@
+/* File: borg7.h */
+
+/* Purpose: Header file for "borg7.c" -BEN- */
+
+#ifndef INCLUDED_BORG7_H
+#define INCLUDED_BORG7_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg7.c".
+ */
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+
+
+/*
+ * Determine if an item is "icky"
+ */
+extern bool borg_item_icky(borg_item *item);
+
+/*
+ * Various functions
+ */
+extern bool borg_use_things(void);
+extern bool borg_check_lite(void);
+extern bool borg_check_lite_only(void);
+
+extern bool borg_enchanting(void);
+extern bool borg_recharging(void);
+extern bool borg_crush_junk(void);
+extern bool borg_crush_hole(void);
+extern bool borg_crush_slow(void);
+extern bool borg_test_stuff(bool star_id);
+extern bool borg_takeoff_stuff(void);
+extern bool borg_swap_rings(void);
+extern bool borg_wear_rings(void);
+extern bool borg_wear_stuff(void);
+extern bool borg_best_stuff(void);
+extern bool borg_play_magic(bool bored);
+extern bool borg_remove_stuff(void);
+extern bool borg_wear_recharge(void);
+extern int borg_count_sell(void);
+/*
+ * Attempt to leave the level
+ */
+extern bool borg_leave_level(bool bored);
+
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_7(void);
+
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg8.c angband-3.0.6-borg/src/borg8.c
--- angband-3.0.6/src/borg8.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg8.c	2005-09-07 09:44:44.000000000 -0700
@@ -0,0 +1,4512 @@
+/* File: borg8.c */
+/* Purpose: High level functions for the Borg -BEN- */
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg4.h"
+#include "borg5.h"
+#include "borg6.h"
+#include "borg7.h"
+#include "borg8.h"
+
+#ifdef BABLOS
+extern bool borg_clock_over;
+#endif /* bablos */
+
+
+byte *test;
+byte *best;
+s32b *b_home_power;
+
+
+/* money Scumming is a type of town scumming for money */
+void borg_money_scum(void)
+{
+
+    int dir;
+
+	borg_grid *ag;
+
+    /* Take note */
+    borg_note(format("# Waiting for towns people to breed.  I need %d...",borg_money_scum_amount - borg_gold));
+
+    /* Rest for 9 months */
+    if (borg_skill[BI_CLEVEL] >= 35)
+    {
+        borg_keypress(ESCAPE);
+        borg_keypress('R');
+        borg_keypress('9');
+        borg_keypress('9');
+        borg_keypress('9');
+        borg_keypress('9');
+        borg_keypress('\n');
+    }
+    else if (borg_skill[BI_CLEVEL] >= 15)
+    {
+        borg_keypress(ESCAPE);
+        borg_keypress('R');
+        borg_keypress('7');
+        borg_keypress('5');
+        borg_keypress('\n');
+    }
+    else /* Low level, dont want to get mobbed */
+    {
+        borg_keypress(ESCAPE);
+        borg_keypress('R');
+        borg_keypress('2');
+        borg_keypress('5');
+        borg_keypress('\n');
+    }
+
+    /* sometimes twitch in order to move around some */
+    if (borg_t % 10)
+    {
+        borg_keypress(ESCAPE);
+
+         /* Pick a random direction */
+		while (1)
+		{
+        	dir = randint(9);
+
+        	/* Hack -- set goal */
+        	g_x = c_x + ddx[dir];
+        	g_y = c_y + ddy[dir];
+
+			ag = &borg_grids[g_y][g_x];
+
+			/* Skip walls and shops */
+			if (ag->feat == FEAT_FLOOR) break;
+		}
+
+
+        /* Maybe alter */
+        if (rand_int(100) < 10 && dir != 5)
+        {
+            /* Send action (alter) */
+            borg_keypress('+');
+
+            /* Send direction */
+            borg_keypress(I2D(dir));
+        }
+
+        /* Normally move */
+        else
+        {
+            /* Send direction */
+            borg_keypress(I2D(dir));
+        }
+     }
+
+     /* reset the clocks */
+     borg_t = 10;
+     time_this_panel = 1;
+     borg_began = 1;
+
+     /* Done */
+     return;
+}
+
+
+/*
+ * Determine if an item can "absorb" a second item
+ *
+ * See "object_absorb()" for the actual "absorption" code.
+ *
+ * If permitted, we allow wands/staffs (if they are known to have equal
+ * charges) and rods (if fully charged) to combine.
+ *
+ * Note that rods/staffs/wands are then unstacked when they are used.
+ *
+ * If permitted, we allow weapons/armor to stack, if they both known.
+ *
+ * Food, potions, scrolls, and "easy know" items always stack.
+ *
+ * Chests never stack (for various reasons).
+ *
+ * We do NOT allow activatable items (artifacts or dragon scale mail)
+ * to stack, to keep the "activation" code clean.  Artifacts may stack,
+ * but only with another identical artifact (which does not exist).
+ *
+ * Ego items may stack as long as they have the same ego-item type.
+ * This is primarily to allow ego-missiles to stack.
+ */
+static bool borg_object_similar(borg_item  *o_ptr, borg_item  *j_ptr)
+{
+    /* NOTE: This assumes the giving of one item at a time */
+    int total = o_ptr->iqty + 1;
+
+
+    /* Require identical object types */
+    if (o_ptr->kind != j_ptr->kind) return (0);
+
+
+    /* Analyze the items */
+    switch (o_ptr->tval)
+    {
+        /* Chests */
+        case TV_CHEST:
+        {
+            /* Never okay */
+            return (0);
+        }
+
+        /* Food and Potions and Scrolls */
+        case TV_FOOD:
+        case TV_POTION:
+        case TV_SCROLL:
+        {
+            /* Assume okay */
+            break;
+        }
+
+        /* Staffs and Wands */
+        case TV_STAFF:
+        case TV_WAND:
+        {
+            /* Require knowledge */
+            if ((!o_ptr->able) || (!j_ptr->able)) return (0);
+
+            /* Fall through */
+        }
+
+        /* Staffs and Wands and Rods */
+        case TV_ROD:
+        {
+            /* Require permission */
+/*            if (!testing_stack) return (0);*/
+
+            /* Require identical charges */
+/*            if (o_ptr->pval != j_ptr->pval) return (0); */
+
+            /* Probably okay */
+            break;
+        }
+
+        /* Weapons and Armor */
+        case TV_BOW:
+        case TV_DIGGING:
+        case TV_HAFTED:
+        case TV_POLEARM:
+        case TV_SWORD:
+        case TV_BOOTS:
+        case TV_GLOVES:
+        case TV_HELM:
+        case TV_CROWN:
+        case TV_SHIELD:
+        case TV_CLOAK:
+        case TV_SOFT_ARMOR:
+        case TV_HARD_ARMOR:
+        case TV_DRAG_ARMOR:
+        {
+            /* Require permission */
+/*            if (!testing_stack) return (0);*/
+
+            /* XXX XXX XXX Require identical "sense" status */
+            /* if ((o_ptr->ident & ID_SENSE) != */
+            /*     (j_ptr->ident & ID_SENSE)) return (0); */
+
+            /* Fall through */
+        }
+
+        /* Rings, Amulets, Lites */
+        case TV_RING:
+        case TV_AMULET:
+        case TV_LITE:
+        {
+            /* Require full knowledge of both items */
+            if ((!o_ptr->able) || (!j_ptr->able)) return (0);
+
+            /* Fall through */
+        }
+
+        /* Missiles */
+        case TV_BOLT:
+        case TV_ARROW:
+        case TV_SHOT:
+        {
+            /* Require identical "bonuses" */
+            if (o_ptr->to_h != j_ptr->to_h) return (FALSE);
+            if (o_ptr->to_d != j_ptr->to_d) return (FALSE);
+            if (o_ptr->to_a != j_ptr->to_a) return (FALSE);
+
+            /* Require identical "pval" code */
+            if (o_ptr->pval != j_ptr->pval) return (FALSE);
+
+            /* Require identical "artifact" names */
+            if (o_ptr->name1 != j_ptr->name1) return (FALSE);
+
+            /* Require identical "ego-item" names */
+            if (o_ptr->name2 != j_ptr->name2) return (FALSE);
+
+            /* Hack -- Never stack "powerful" items */
+            if (o_ptr->flags1 || j_ptr->flags1) return (FALSE);
+            if (o_ptr->flags2 || j_ptr->flags2) return (FALSE);
+            if (o_ptr->flags3 || j_ptr->flags3) return (FALSE);
+
+            /* Hack -- Never stack recharging items */
+            if (o_ptr->timeout || j_ptr->timeout) return (FALSE);
+
+            /* Require identical "values" */
+            if (o_ptr->ac != j_ptr->ac) return (FALSE);
+            if (o_ptr->dd != j_ptr->dd) return (FALSE);
+            if (o_ptr->ds != j_ptr->ds) return (FALSE);
+
+            /* Probably okay */
+            break;
+        }
+
+        /* Various */
+        default:
+        {
+            /* Require knowledge */
+            if ((!o_ptr->able) || (!j_ptr->able)) return (0);
+
+            /* Probably okay */
+            break;
+        }
+    }
+
+
+    /* Hack -- Require identical "broken" status */
+    if ((o_ptr->fully_identified) != (j_ptr->fully_identified)) return (0);
+
+    /* The stuff with 'note' is not right but it is close.  I think it */
+    /* has him assuming that he can't stack sometimes when he can.  This */
+    /* is alright, it just causes him to take a bit more time to do */
+    /* some exchanges. */
+    /* Hack -- require semi-matching "inscriptions" */
+    if (o_ptr->note[0] && j_ptr->note[0] &&
+        (!streq(o_ptr->note, j_ptr->note)))
+        return (0);
+
+    /* Hack -- normally require matching "inscriptions" */
+    if (!stack_force_notes && (!streq(o_ptr->note, j_ptr->note))) return (0);
+
+    /* Hack -- normally require matching "discounts" */
+    if (!stack_force_costs && (o_ptr->discount != j_ptr->discount)) return (0);
+
+
+    /* Maximal "stacking" limit */
+    if (total >= MAX_STACK_SIZE) return (0);
+
+
+    /* They match, so they must be similar */
+    return (TRUE);
+}
+
+/*
+ * Find the mininum amount of some item to buy/sell. For most
+ * items this is 1, but for certain items (such as ammunition)
+ * it may be higher.  -- RML
+ */
+static int borg_min_item_quantity(borg_item *item)
+{
+    /* Only trade in bunches if sufficient cash */
+    if (borg_gold < 250) return (1);
+
+    /* Don't trade expensive items in bunches */
+    if (item->cost > 5) return (1);
+
+    /* Don't trade non-known items in bunches */
+    if (!item->able) return (1);
+
+    /* Only allow some types */
+    switch (item->tval)
+    {
+    case TV_SPIKE:
+    case TV_SHOT:
+    case TV_ARROW:
+    case TV_BOLT:
+        /* Maximum number of items */
+        if (item->iqty < 5)
+            return (item->iqty);
+        return (5);
+
+    case TV_FOOD:
+        if (item->iqty < 3)
+            return (item->iqty);
+        return (3);
+#if 0
+    case TV_POTION:
+    case TV_SCROLL:
+        if (item->iqty < 2)
+            return (item->iqty);
+        return (2);
+#endif
+
+    default:
+        return (1);
+    }
+}
+
+/*
+ * This file handles the highest level goals, and store interaction.
+ *
+ * Store interaction strategy
+ *
+ *   (1) Sell items to the home (for later use)
+ ** optimize the stuff in the home... this involves buying and selling stuff
+ ** not in the 'best' list.
+ *       We sell anything we may need later (see step 4)
+ *
+ *   (2) Sell items to the shops (for money)
+ *       We sell anything we do not actually need
+ *
+ *   (3) Buy items from the shops (for the player)
+ *       We buy things that we actually need
+ *
+ *   (4) Buy items from the home (for the player)
+ *       We buy things that we actually need (see step 1)
+ *
+ *   (5) Buy items from the shops (for the home)
+ *       We buy things we may need later (see step 1)
+ *
+ *   (6) Buy items from the home (for the stores)
+ *       We buy things we no longer need (see step 2)
+ *
+ *   The basic principle is that we should always act to improve our
+ *   "status", and we should sometimes act to "maintain" our status,
+ *   especially if there is a monetary reward.  But first we should
+ *   attempt to use the home as a "stockpile", even though that is
+ *   not worth any money, since it may save us money eventually.
+ */
+
+/* this optimized the home storage by trying every combination... it was too slow.*/
+/* put this code back when running this on a Cray. */
+static void borg_think_home_sell_aux2_slow(  int n, int start_i )
+{
+    int i;
+
+    /* All done */
+    if (n == STORE_INVEN_MAX)
+    {
+        s32b home_power;
+
+        /* Examine the home  */
+        borg_notice_home(NULL, FALSE);
+
+        /* Evaluate the home */
+        home_power = borg_power_home();
+
+        /* Track best */
+        if (home_power > *b_home_power)
+        {
+            /* Save the results */
+            for (i = 0; i < STORE_INVEN_MAX; i++) best[i] = test[i];
+
+#if 0
+            /* dump, for debugging */
+            borg_note(format("Trying Combo (best home power %ld)",
+                              *b_home_power));
+            borg_note(format("             (test home power %ld)",home_power));
+            for (i = 0; i < STORE_INVEN_MAX; i++)
+            {
+                if (borg_shops[7].ware[i].iqty)
+                    borg_note(format("store %d %s (qty-%d).",  i,
+                                       borg_shops[7].ware[i].desc,
+                                       borg_shops[7].ware[i].iqty ));
+                else
+                    borg_note(format("store %d (empty).",  i));
+            }
+            borg_note(" "); /* add a blank line */
+#endif
+
+            /* Use it */
+            *b_home_power = home_power;
+        }
+
+        /* Success */
+        return;
+    }
+
+    /* Note the attempt */
+    test[n] = n;
+
+    /* Evaluate the default item */
+    borg_think_home_sell_aux2_slow(n + 1, start_i );
+
+    /* if this slot and the previous slot is empty, move on to previous slot*/
+    /* this will prevent trying a thing in all the empty slots to see if */
+    /* empty slot b is better than empty slot a.*/
+    if ((n != 0) && !borg_shops[7].ware[n].iqty && !borg_shops[7].ware[n-1].iqty)
+        return;
+
+    /* try other combinations */
+    for (i = start_i; i < INVEN_PACK; i++)
+    {
+        borg_item *item;
+        borg_item *item2;
+        bool stacked = FALSE;
+
+        item = &borg_items[i];
+        item2= &borg_shops[7].ware[n];
+
+        /* Skip empty items */
+        /* Require "aware" */
+        /* Require "known" */
+        if (!item->iqty || !item->kind || !item->able)
+            continue;
+
+        /* Hack -- ignore "worthless" items */
+        if (!item->value) continue;
+
+        if (i==weapon_swap && weapon_swap !=0) continue;
+        if (i==armour_swap && armour_swap !=0) continue;
+
+        /* stacking? */
+        if (borg_object_similar(item2, item))
+        {
+            item2->iqty++;
+            item->iqty--;
+            stacked = TRUE;
+        }
+        else
+        {
+            int k;
+            bool found_match = FALSE;
+
+            /* eliminate items that would stack else where in the list. */
+            for (k = 0; k < STORE_INVEN_MAX; k++)
+            {
+                if (borg_object_similar(&safe_home[k], item))
+                {
+                    found_match = TRUE;
+                    break;
+                }
+            }
+            if (found_match)
+                continue;
+
+            /* replace current item with this item */
+            COPY(item2, item, borg_item);
+
+            /* only move one into a non-stack slot */
+            item2->iqty = 1;
+
+            /* remove item from pack */
+            item->iqty--;
+        }
+
+        /* Note the attempt */
+        test[n] = i + STORE_INVEN_MAX;
+
+        /* Evaluate the possible item */
+        borg_think_home_sell_aux2_slow( n + 1, i+1 );
+
+        /* restore stuff */
+        COPY(item2, &safe_home[n], borg_item);
+
+        /* put item back into pack */
+        item->iqty++;
+    }
+}
+
+
+/*
+ * this will see what single addition/substitution is best for the home.
+ * The formula is not as nice as the one above because it will
+ * not check all possible combinations of items. but it is MUCH faster.
+ */
+
+static void borg_think_home_sell_aux2_fast(  int n, int start_i )
+{
+    borg_item *item;
+    borg_item *item2;
+    s32b home_power;
+    int i, k;
+    bool stacked = FALSE;
+
+    /* get the starting best (current) */
+    /* Examine the home  */
+    borg_notice_home(NULL, FALSE);
+
+    /* Evaluate the home  */
+    *b_home_power = borg_power_home();
+
+    /* try individual substitutions/additions.   */
+    for (n = 0; n < STORE_INVEN_MAX; n++)
+    {
+        item2 = &borg_shops[7].ware[n];
+        for (i = 0; i < INVEN_PACK; i++)
+        {
+            item = &borg_items[i];
+
+            /* Skip empty items */
+            /* Require "aware" */
+            /* Require "known" */
+
+            if (!item->iqty || !item->kind || !item->able)
+                continue;
+            if (i==weapon_swap && weapon_swap !=0) continue;
+            if (i==armour_swap && armour_swap !=0) continue;
+
+            /* Do not dump stuff at home that is not fully id'd and should be  */
+            /* this is good with random artifacts. */
+            if ((birth_rand_artifacts || adult_rand_artifacts) && !item->fully_identified && item->name1) continue;
+
+            /* Hack -- ignore "worthless" items */
+            if (!item->value) continue;
+
+
+            /* stacking? */
+            if (borg_object_similar(item2, item))
+            {
+                /* if this stacks with what was previously here */
+                item2->iqty++;
+                stacked = TRUE;
+            }
+            else
+            {
+                bool found_match = FALSE;
+
+                /* eliminate items that would stack else where in the list. */
+                for (k = 0; k < STORE_INVEN_MAX; k++)
+                {
+                    if (borg_object_similar(&safe_home[k], item))
+                    {
+                        found_match = TRUE;
+                        break;
+                    }
+                }
+                if (found_match)
+                    continue;
+
+                /* replace current item with this item */
+                COPY(item2, item, borg_item);
+
+                /* only move one into a non-stack slot */
+                item2->iqty = 1;
+            }
+
+            /* remove item from pack */
+            item->iqty--;
+
+            /* Note the attempt */
+            test[n] = i + STORE_INVEN_MAX;
+
+            /* Test to see if this is a good substitution. */
+            /* Examine the home  */
+            borg_notice_home(NULL, FALSE);
+
+            /* Evaluate the home  */
+            home_power = borg_power_home();
+
+            /* Track best */
+            if (home_power > *b_home_power)
+            {
+                /* Save the results */
+                for (k = 0; k < STORE_INVEN_MAX; k++) best[k] = test[k];
+
+#if 0
+                /* dump, for debugging */
+                borg_note(format("Trying Combo (best home power %ld)",
+                                    *b_home_power));
+                borg_note(format("             (test home power %ld)",
+                                    home_power));
+                for (i = 0; i < STORE_INVEN_MAX; i++)
+                    if (borg_shops[7].ware[i].iqty)
+                        borg_note(format("store %d %s (qty-%d).",  i,
+                                           borg_shops[7].ware[i].desc,
+                                           borg_shops[7].ware[i].iqty ));
+                    else
+                    borg_note(format("store %d (empty).",  i));
+
+                borg_note(" "); /* add a blank line */
+#endif
+
+                /* Use it */
+                *b_home_power = home_power;
+            }
+
+            /* restore stuff */
+            COPY(item2, &safe_home[n], borg_item);
+
+            /* put item back into pack */
+            item->iqty++;
+
+            /* put the item back in the test array */
+            test[n] = n;
+        }
+    }
+}
+
+/* locate useless item */
+static void borg_think_home_sell_aux3( )
+{
+    int     i;
+    s32b    borg_empty_home_power;
+    s32b    power;
+
+    /* get the starting power */
+    borg_notice(TRUE);
+    power = borg_power();
+
+    /* get what an empty home would have for power */
+    borg_notice_home( NULL, TRUE );
+    borg_empty_home_power = borg_power_home();
+
+    /* go through the inventory and eliminate items that either  */
+    /* 1) will not increase the power of an empty house. */
+    /* 2) will reduce borg_power if given to home */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        int num_items_given;
+        num_items_given = 0;
+
+        /* if there is no item here, go to next slot */
+        if (!borg_items[i].iqty)
+            continue;
+
+
+        /* 1) eliminate garbage items (items that add nothing to an */
+        /*     empty house) */
+        borg_notice_home( &borg_items[i], FALSE );
+        if (borg_power_home() <= borg_empty_home_power)
+        {
+            safe_items[i].iqty = 0;
+            continue;
+        }
+
+        /* 2) will reduce borg_power if given to home */
+        while (borg_items[i].iqty)
+        {
+            /* reduce inventory by this item */
+            num_items_given++;
+            borg_items[i].iqty--;
+
+            /* Examine borg */
+            borg_notice(FALSE);
+
+            /* done if this reduces the borgs power */
+            if (borg_power() < power)
+            {
+                /* we gave up one to many items */
+                num_items_given--;
+                break;
+            }
+        }
+
+        /* restore the qty */
+        borg_items[i].iqty = safe_items[i].iqty;
+
+        /* set the qty to number given without reducing borg power */
+        safe_items[i].iqty = num_items_given;
+    }
+}
+
+/*
+ * Step 1 -- sell "useful" things to the home (for later)
+ */
+static bool borg_think_home_sell_aux( bool save_best )
+{
+    int icky = STORE_INVEN_MAX - 1;
+
+    s32b home_power = -1L;
+
+    int i = -1;
+
+    byte test_a[STORE_INVEN_MAX];
+    byte best_a[STORE_INVEN_MAX];
+
+    /* if the best is being saved (see borg_think_shop_grab_aux) */
+    /* !FIX THIS NEEDS TO BE COMMENTED BETTER */
+    if (!save_best)
+        b_home_power = &home_power;
+    test = test_a;
+    best = best_a;
+
+    /* if I have not been to home, do not try this yet. */
+    if (!borg_shops[7].when) return FALSE;
+
+    /* Hack -- the home is full */
+    /* and pack is full */
+    if (borg_shops[7].ware[icky].iqty &&
+        borg_items[INVEN_PACK-1].iqty)
+        return (FALSE);
+
+    /* Copy all the store slots */
+    for (i = 0; i < STORE_INVEN_MAX; i++)
+    {
+        /* Save the item */
+        COPY(&safe_home[i], &borg_shops[7].ware[i], borg_item);
+
+        /* clear test arrays (test[i] == i is no change) */
+        best[i] = test[i] = i;
+    }
+
+    /* Hack -- Copy all the slots */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        /* Save the item */
+        if (i==weapon_swap && weapon_swap !=0) continue;
+        if (i==armour_swap && armour_swap !=0) continue;
+        COPY(&safe_items[i], &borg_items[i], borg_item);
+    }
+
+    /* get rid of useless items */
+    borg_think_home_sell_aux3();
+
+    /* Examine the borg once more with full inventory then swap in the */
+    /* safe_items for the home optimization */
+    borg_notice(FALSE);
+
+    /* swap quantities (this should be all that is different) */
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+        byte save_qty;
+        if (i==weapon_swap && weapon_swap !=0) continue;
+        if (i==armour_swap && armour_swap !=0) continue;
+
+        save_qty = safe_items[i].iqty;
+        safe_items[i].iqty = borg_items[i].iqty;
+        borg_items[i].iqty = save_qty;
+    }
+
+    *b_home_power = -1;
+
+    /* find best combo for home. */
+    if (borg_slow_optimizehome)
+    {
+        borg_think_home_sell_aux2_slow( 0, 0 );
+    }
+    else
+    {
+        borg_think_home_sell_aux2_fast( 0, 0 );
+    }
+
+    /* restore bonuses and such */
+    for (i = 0; i < STORE_INVEN_MAX; i++)
+    {
+        COPY(&borg_shops[7].ware[i], &safe_home[i], borg_item);
+    }
+
+    for (i = 0; i < INVEN_TOTAL; i++)
+    {
+        if (i==weapon_swap && weapon_swap !=0) continue;
+        if (i==armour_swap && armour_swap !=0) continue;
+        COPY(&borg_items[i], &safe_items[i], borg_item);
+    }
+
+    borg_notice(FALSE);
+    borg_notice_home(NULL, FALSE);
+
+    /* Drop stuff that will stack in the home */
+    for (i = 0; i < STORE_INVEN_MAX; i++)
+    {
+        /* if this is not the item that was there, */
+        /* drop off the item that replaces it. */
+        if (best[i] != i && best[i] != 255)
+        {
+            borg_item *item = &borg_items[best[i]-STORE_INVEN_MAX];
+            borg_item *item2 = &borg_shops[7].ware[i];
+
+            /* if this item is not the same as what was */
+            /* there before take it. */
+            if (!borg_object_similar(item2, item))
+                continue;
+
+            goal_shop = 7;
+            goal_item = best[i] - STORE_INVEN_MAX;
+
+            return (TRUE);
+        }
+    }
+
+    /* Get rid of stuff in house but not in 'best' house if  */
+    /* pack is not full */
+    if (!borg_items[INVEN_PACK-1].iqty)
+    {
+        for (i = 0; i < STORE_INVEN_MAX; i++)
+        {
+            /* if this is not the item that was there, */
+            /* get rid of the item that was there */
+            if ((best[i] != i) &&
+                (borg_shops[7].ware[i].iqty))
+            {
+                borg_item *item = &borg_items[best[i]-STORE_INVEN_MAX];
+                borg_item *item2 = &borg_shops[7].ware[i];
+
+                /* if this item is not the same as what was */
+                /* there before take it. */
+                if (borg_object_similar(item, item2))
+                    continue;
+
+                /* skip stuff if we sold bought it */
+                if (sold_item_tval == item2->tval && sold_item_sval == item2->sval &&
+                sold_item_pval == item2->pval && sold_item_store == 7) return (FALSE);
+
+                goal_shop = 7;
+                goal_ware = i;
+
+                return TRUE;
+            }
+        }
+    }
+
+    /* Drop stuff that is in best house but currently in inventory */
+    for (i = 0; i < STORE_INVEN_MAX; i++)
+    {
+        /* if this is not the item that was there,  */
+        /* drop off the item that replaces it. */
+        if (best[i] != i && best[i] != 255)
+        {
+            /* hack dont sell DVE */
+            if (!borg_items[best[i]-STORE_INVEN_MAX].iqty) return (FALSE);
+
+            goal_shop = 7;
+            goal_item = best[i] - STORE_INVEN_MAX;
+
+            return (TRUE);
+        }
+    }
+
+    /* Return our num_ counts to normal */
+    borg_notice_home(NULL, FALSE);
+
+    /* Assume not */
+    return (FALSE);
+}
+
+
+/*
+ * Determine if an item can be sold in the given store
+ *
+ * XXX XXX XXX Consider use of "icky" test on items
+ */
+static bool borg_good_sell(borg_item *item, int who)
+{
+    /* Never sell worthless items */
+    if (item->value <= 0) return (FALSE);
+
+
+    /* Worshipping gold or scumming will allow the sale */
+    if (item->value > 0 &&
+       ((borg_worships_gold || borg_skill[BI_MAXCLEVEL] < 5) ||
+        (borg_money_scum_amount < borg_gold && borg_money_scum_amount != 0)) &&
+        !(streq(item->note, "{cursed}")) )
+	{
+		/* Borg is allowed to continue in this routine to sell non-ID items */
+	}
+	else /* Some items must be ID, or at least 'known' */
+	{
+		/* Analyze the type */
+	    switch (item->tval)
+	    {
+	        case TV_POTION:
+	        case TV_SCROLL:
+
+	        /* Never sell if not "known" and interesting */
+	        if (!item->able && (borg_skill[BI_MAXDEPTH] > 5)) return (FALSE);
+
+	        /* Spell casters should not sell ResMana to shop unless
+	         * they have tons in the house
+	         */
+	        if (item->tval == TV_POTION &&
+	            item->sval == SV_POTION_RESTORE_MANA &&
+	            borg_skill[BI_MAXSP] > 100 &&
+	            borg_has[266] + num_mana > 99) return (FALSE);
+
+	        break;
+
+	        case TV_FOOD:
+	        case TV_ROD:
+	        case TV_WAND:
+	        case TV_STAFF:
+	        case TV_RING:
+	        case TV_AMULET:
+	        case TV_LITE:
+
+	        /* Never sell if not "known" */
+	        if (!item->able) return (FALSE);
+
+	        break;
+
+	        case TV_BOW:
+	        case TV_DIGGING:
+	        case TV_HAFTED:
+	        case TV_POLEARM:
+	        case TV_SWORD:
+	        case TV_BOOTS:
+	        case TV_GLOVES:
+	        case TV_HELM:
+	        case TV_CROWN:
+	        case TV_SHIELD:
+	        case TV_CLOAK:
+	        case TV_SOFT_ARMOR:
+	        case TV_HARD_ARMOR:
+	        case TV_DRAG_ARMOR:
+
+	        /* Only sell "known" items (unless "icky") */
+	        if (!item->able && !borg_item_icky(item)) return (FALSE);
+
+	        break;
+	    }
+	}
+
+    /* Do not sell stuff that is not fully id'd and should be  */
+    if ((birth_rand_artifacts || adult_rand_artifacts) && !item->fully_identified && item->name1)
+    {
+              /* CHECK THE ARTIFACTS */
+                   /* For now check all artifacts */
+                      return (FALSE);
+    }
+    /* Do not sell stuff that is not fully id'd and should be  */
+    if (!item->fully_identified && item->name2)
+    {
+           switch (item->name2)
+           {
+            /* Robe of Permanance */
+            case EGO_PERMANENCE:
+            /* Armor of Elvenkind */
+            case EGO_ELVENKIND:
+            /* Cloak of Aman */
+            case EGO_AMAN:
+                return (FALSE);
+
+            /* Weapon (Defender) */
+            /* Weapon (Blessed) */
+            /* Weapon (Holy Avenger) */
+            case EGO_HA:
+            case EGO_BLESS_BLADE:
+            case EGO_DF:
+            /* Crown of the Magi */
+            case EGO_MAGI:
+            /* anything else */
+            default:
+                break;
+           }
+    }
+
+    /* Switch on the store */
+    switch (who + 1)
+    {
+        /* General Store */
+        case 1:
+
+            /* Analyze the type */
+            switch (item->tval)
+            {
+                case TV_DIGGING:
+                case TV_CLOAK:
+                case TV_FOOD:
+                case TV_FLASK:
+                case TV_LITE:
+                case TV_SPIKE:
+                return (TRUE);
+            }
+            break;
+
+        /* Armoury */
+        case 2:
+
+            /* Analyze the type */
+            switch (item->tval)
+            {
+                case TV_BOOTS:
+                case TV_GLOVES:
+                case TV_HELM:
+                case TV_CROWN:
+                case TV_SHIELD:
+                case TV_SOFT_ARMOR:
+                case TV_HARD_ARMOR:
+                case TV_DRAG_ARMOR:
+                return (TRUE);
+            }
+            break;
+
+        /* Weapon Shop */
+        case 3:
+
+            /* Analyze the type */
+            switch (item->tval)
+            {
+                case TV_SHOT:
+                case TV_BOLT:
+                case TV_ARROW:
+                case TV_BOW:
+                case TV_DIGGING:
+                case TV_HAFTED:
+                case TV_POLEARM:
+                case TV_SWORD:
+                return (TRUE);
+            }
+            break;
+
+        /* Temple */
+        case 4:
+
+            /* Analyze the type */
+            switch (item->tval)
+            {
+                case TV_HAFTED:
+                case TV_PRAYER_BOOK:
+                case TV_SCROLL:
+                case TV_POTION:
+                return (TRUE);
+            }
+            break;
+
+        /* book store --Alchemist */
+        case 5:
+
+            /* Analyze the type */
+            switch (item->tval)
+            {
+                case TV_SCROLL:
+                case TV_POTION:
+                return (TRUE);
+            }
+            break;
+
+        /* Magic Shop */
+        case 6:
+
+            /* Analyze the type */
+            switch (item->tval)
+            {
+                case TV_AMULET:
+                case TV_RING:
+                case TV_SCROLL:
+                case TV_POTION:
+                case TV_STAFF:
+                case TV_WAND:
+                case TV_ROD:
+                case TV_MAGIC_BOOK:
+                return (TRUE);
+            }
+            break;
+
+
+    }
+
+    /* Assume not */
+    return (FALSE);
+}
+
+
+
+/*
+ * Step 2 -- sell "useless" items to a shop (for cash)
+ */
+static bool borg_think_shop_sell_aux(void)
+{
+    int icky = STORE_INVEN_MAX - 1;
+
+    int k, b_k = -1;
+    int i, b_i = -1;
+    int qty = 1;
+    s32b p, b_p = 0L;
+    s32b c = 0L;
+    s32b b_c = 30001L;
+
+    bool fix = FALSE;
+
+
+    /* Evaluate */
+    b_p = my_power;
+
+    /* Check each shop */
+    for (k = 0; k < (MAX_STORES -1) ; k++)
+    {
+        /* Hack -- Skip "full" shops */
+        if (borg_shops[k].ware[icky].iqty) continue;
+
+        /* Save the store hole */
+        COPY(&safe_shops[k].ware[icky], &borg_shops[k].ware[icky], borg_item);
+
+        /* Sell stuff */
+        for (i = 0; i < INVEN_PACK; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+            /* Skip empty items */
+            if (!item->iqty) continue;
+
+            /* Skip some important type items */
+            if ((item->tval == my_ammo_tval) && (borg_skill[BI_AMISSILES] < 45)) continue;
+            if ((borg_class == CLASS_WARRIOR || borg_class == CLASS_ROGUE) &&
+                item->tval == TV_ROD && item->sval == SV_ROD_HEALING &&
+                borg_has[374] <= 3) continue;
+
+            if (borg_class == CLASS_WARRIOR &&
+                item->tval == TV_ROD && item->sval == SV_ROD_MAPPING &&
+                item->iqty <= 2) continue;
+
+            /* Avoid selling staff of dest*/
+            if (item->tval == TV_STAFF && item->sval == SV_STAFF_DESTRUCTION &&
+                borg_skill[BI_ASTFDEST] < 2) continue;
+
+            /* dont sell our swap items */
+            if (i==weapon_swap && weapon_swap !=0) continue;
+            if (i==armour_swap && armour_swap !=0) continue;
+
+            /* Skip "bad" sales */
+            if (!borg_good_sell(item, k)) continue;
+
+            /* Save the item */
+            COPY(&safe_items[i], &borg_items[i], borg_item);
+
+            /* Give the item to the shop */
+            COPY(&borg_shops[k].ware[icky], &safe_items[i], borg_item);
+
+            /* get the quantity */
+            qty = borg_min_item_quantity(item);
+
+            /* Give a single item */
+            borg_shops[k].ware[icky].iqty = qty;
+
+            /* Lose a single item */
+            borg_items[i].iqty -=qty;
+
+            /* Fix later */
+            fix = TRUE;
+
+            /* Examine the inventory */
+            borg_notice(FALSE);
+
+            /* Evaluate the inventory */
+            p = borg_power();
+
+            /* Restore the item */
+            COPY(&borg_items[i], &safe_items[i], borg_item);
+
+            /* Ignore "bad" sales */
+            if (p < b_p) continue;
+
+            /* Extract the "price" */
+            c = ((item->value < 30000L) ? item->value : 30000L);
+
+            /* sell cheap items first.  This is done because we may have to */
+            /* buy the item back in some very strange cercemstances. */
+            if ((p == b_p) && (c >= b_c)) continue;
+
+            /* Maintain the "best" */
+            b_k = k; b_i = i; b_p = p; b_c = c;
+        }
+
+        /* Restore the store hole */
+        COPY(&borg_shops[k].ware[icky], &safe_shops[k].ware[icky], borg_item);
+    }
+
+    /* Examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Sell something (if useless) */
+    if ((b_k >= 0) && (b_i >= 0))
+    {
+        /* Visit that shop */
+        goal_shop = b_k;
+
+        /* Sell that item */
+        goal_item = b_i;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Assume not */
+    return (FALSE);
+}
+
+
+
+/*
+ * Help decide if an item should be bought from a real store
+ *
+ * We prevent the purchase of enchanted (or expensive) ammo,
+ * so we do not spend all our money on temporary power.
+ *
+ * if level 35, who needs cash?  buy the expecive ammo!
+ *
+ * We prevent the purchase of low level discounted books,
+ * so we will not waste slots on cheap books.
+ *
+ * We prevent the purchase of items from the black market
+ * which are often available at normal stores, currently,
+ * this includes low level books, and all wands and staffs.
+ */
+static bool borg_good_buy(borg_item *item, int who)
+{
+
+    /* Check the object */
+    switch (item->tval)
+    {
+        case TV_SHOT:
+        case TV_ARROW:
+        case TV_BOLT:
+        if (borg_skill[BI_CLEVEL] < 35)
+        {
+            if (item->to_h) return (FALSE);
+            if (item->to_d) return (FALSE);
+        }
+        break;
+
+        case TV_MAGIC_BOOK:
+        case TV_PRAYER_BOOK:
+        if (item->sval >= 4) break;
+        if (item->discount) return (FALSE);
+        break;
+
+        case TV_WAND:
+        case TV_STAFF:
+        break;
+    }
+
+    /* Don't buy from the BM until we are rich */
+    if (who == 6)
+    {
+        /* buying Remove Curse scroll is acceptable */
+        if (item->tval == TV_SCROLL && item->sval == SV_SCROLL_REMOVE_CURSE &&
+            borg_wearing_cursed) return (TRUE);
+
+		/* Buying certain special items are acceptable */
+		if ((item->tval == TV_POTION &&
+			 ((item->sval == SV_POTION_STAR_HEALING) ||
+			  (item->sval == SV_POTION_LIFE) ||
+			  (item->sval == SV_POTION_HEALING) ||
+			  (item->sval == SV_POTION_INC_STR && my_stat_cur[A_STR] < (18+100)) ||
+			  (item->sval == SV_POTION_INC_INT && my_stat_cur[A_INT] < (18+100)) ||
+			  (item->sval == SV_POTION_INC_WIS && my_stat_cur[A_WIS] < (18+100)) ||
+			  (item->sval == SV_POTION_INC_DEX && my_stat_cur[A_DEX] < (18+100)) ||
+			  (item->sval == SV_POTION_INC_CON && my_stat_cur[A_CON] < (18+100)))) ||
+			(item->tval == TV_ROD &&
+			 ((item->sval == SV_ROD_HEALING) ||
+			  (item->sval == SV_ROD_RECALL && (borg_class == CLASS_WARRIOR || borg_class == CLASS_ROGUE)) ||
+			  (item->sval == SV_ROD_SPEED && (borg_class == CLASS_WARRIOR || borg_class == CLASS_ROGUE)) ||
+			  (item->sval == SV_ROD_TELEPORT_AWAY && (borg_class == CLASS_WARRIOR || borg_class == CLASS_ROGUE)) ||
+			  (item->sval == SV_ROD_ILLUMINATION && (!borg_skill[BI_ALITE])))) ||
+			(item->tval == TV_PRAYER_BOOK && cp_ptr->spell_book == TV_PRAYER_BOOK &&
+			  (amt_book[item->sval] == 0 && item->sval >= 5)) ||
+			(item->tval == TV_MAGIC_BOOK && cp_ptr->spell_book == TV_MAGIC_BOOK &&
+			  (amt_book[item->sval] == 0 && item->sval >= 5)) ||
+			(item->tval == TV_SCROLL &&
+			  (item->sval == SV_SCROLL_TELEPORT_LEVEL ||
+			   item->sval == SV_SCROLL_TELEPORT)))
+		{
+			/* Hack-- Allow the borg to scum for this Item */
+			if (borg_self_scum &&  /* borg is allowed to scum */
+			    borg_skill[BI_CLEVEL] >= 10 && /* Be of sufficient level */
+				borg_skill[BI_LITE] &&   /* Have some Perma lite source */
+				borg_skill[BI_FOOD] + num_food >= 100  && /* Have plenty of food */
+			    adj_dex_safe[borg_skill[BI_DEX]] + borg_skill[BI_CLEVEL] > 85 ) /* Good chance to thwart mugging */
+			{
+				/* Make a note in the log */
+				if (!borg_money_scum_amount &&
+				    borg_gold < item->cost) borg_log_event(format("Money Scum on ($%d)",item->cost));
+
+				/* Record the amount that I need to make purchase */
+				borg_money_scum_amount = item->cost;
+			}
+
+			/* Ok to buy this */
+			return (TRUE);
+		}
+
+        if ((borg_skill[BI_CLEVEL] < 15) && (borg_gold < 20000))
+            return (FALSE);
+        if ((borg_skill[BI_CLEVEL] < 35) && (borg_gold < 15000))
+            return (FALSE);
+        if (borg_gold < 10000)
+            return (FALSE);
+    }
+
+    /* do not buy the item if I just sold it. */
+    if (sold_item_tval == item->tval && sold_item_sval == item->sval &&
+        sold_item_pval == item->pval && sold_item_store == who)
+    {
+#if 0
+              borg_note(format("# Choosing not to buy back %s",item->desc));
+#endif
+        return (FALSE);
+    }
+
+    /* Do not buy a second digger */
+    if (item->tval == TV_DIGGING)
+    {
+        int ii;
+
+        /* scan for an existing digger */
+         for (ii = 0; ii < INVEN_PACK; ii++)
+         {
+             borg_item *item2 = &borg_items[ii];
+
+
+            /* skip non diggers */
+            if (item2->tval == TV_DIGGING) return (FALSE);
+#if 0
+            /* perhaps let him buy a digger with a better
+             * pval than his current digger
+             */
+            {if (item->pval <= item2->pval) return (FALSE);}
+#endif
+        }
+     }
+
+    /* Low level borgs should not waste the money on certain things */
+    if (borg_skill[BI_MAXCLEVEL] < 5)
+    {
+        /* next book, cant read it */
+        if ((item->tval == TV_MAGIC_BOOK || item->tval == TV_PRAYER_BOOK) &&
+            item->sval >=1) return (FALSE);
+
+        /* Too much food is heavy and spendy */
+        if (item->tval == TV_FOOD && borg_skill[BI_FOOD] >= 7 &&
+            borg_skill[BI_SDIG]) return (FALSE);
+
+        /* Too many torches are heavy and spendy */
+        if (item->tval == TV_LITE && item->sval == SV_LITE_TORCH &&
+            borg_skill[BI_AFUEL] >= 3) return (FALSE);
+    }
+
+    /* Rangers and Paladins and the extra books */
+    if ((borg_class == CLASS_PALADIN || borg_class == CLASS_RANGER) &&
+        borg_skill[BI_MAXCLEVEL] <= 8)
+    {
+        if ((item->tval == TV_MAGIC_BOOK || item->tval == TV_PRAYER_BOOK) &&
+            item->sval >=1) return (FALSE);
+    }
+
+
+
+    /* Okay */
+    return (TRUE);
+}
+
+
+
+/*
+ * Step 3 -- buy "useful" things from a shop (to be used)
+ */
+static bool borg_think_shop_buy_aux(void)
+{
+    int hole = INVEN_PACK - 1;
+
+    int slot;
+    int qty =1;
+
+    int k, b_k = -1;
+    int n, b_n = -1;
+    s32b p, b_p = 0L;
+    s32b c, b_c = 0L;
+
+    bool fix = FALSE;
+
+    /* Require one empty slot */
+    if (borg_items[hole].iqty) return (FALSE);
+
+	/* Already have a target 9-4-05*/
+	if (goal_ware != -1) return (FALSE);
+
+    /* Extract the "power" */
+    b_p = my_power;
+
+    /* Check the shops */
+    for (k = 0; k < (MAX_STORES -1 ); k++)
+    {
+        /* Scan the wares */
+        for (n = 0; n < STORE_INVEN_MAX; n++)
+        {
+            borg_item *item = &borg_shops[k].ware[n];
+
+            /* Skip empty items */
+            if (!item->iqty) continue;
+
+            /* Skip "bad" buys */
+            if (!borg_good_buy(item, k)) continue;
+
+            /* Hack -- Require "sufficient" cash */
+            if (borg_gold < item->cost) continue;
+
+            /* Skip it if I just sold this item. XXX XXX*/
+
+            /* Save shop item */
+            COPY(&safe_shops[k].ware[n], &borg_shops[k].ware[n], borg_item);
+
+            /* Save hole */
+            COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+            /* Save the number to trade */
+            qty = borg_min_item_quantity(item);
+
+            /* Remove one item from shop (sometimes) */
+            borg_shops[k].ware[n].iqty -= qty;
+
+            /* Obtain "slot" */
+            slot = borg_wield_slot(item);
+
+/* what if the item is a ring?  we have 2 ring slots --- copy it from the Home code */
+
+            /* Hack, we keep diggers as a back-up, not to
+             * replace our current weapon
+             */
+            if (item->tval == TV_DIGGING) slot = -1;
+
+            /* if our current equip is cursed, then I can't
+             * buy a new replacement.
+             * XXX  Perhaps he should not buy anything but save
+             * money for the Remove Curse Scroll.
+             */
+            if (slot >= INVEN_WIELD)
+            {
+                if (borg_items[slot].cursed) continue;
+                if (borg_items[slot].flags3 & TR3_HEAVY_CURSE) continue;
+                if (borg_items[slot].flags3 & TR3_PERMA_CURSE) continue;
+            }
+
+
+            /* Consider new equipment */
+            if (slot >= 0)
+            {
+                /* Save old item */
+                COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+                /* Move equipment into inventory */
+                COPY(&borg_items[hole], &safe_items[slot], borg_item);
+
+                /* Move new item into equipment */
+                COPY(&borg_items[slot], &safe_shops[k].ware[n], borg_item);
+
+                /* Only a single item */
+                borg_items[slot].iqty = qty;
+
+                /* Fix later */
+                fix = TRUE;
+
+                /* Examine the inventory */
+                borg_notice(FALSE);
+
+                /* Evaluate the inventory */
+                p = borg_power();
+
+                /* Restore old item */
+                COPY(&borg_items[slot], &safe_items[slot], borg_item);
+            }
+
+            /* Consider new inventory */
+            else
+            {
+                /* Move new item into inventory */
+                COPY(&borg_items[hole], &safe_shops[k].ware[n], borg_item);
+
+                /* Only a single item */
+                borg_items[hole].iqty = qty;
+
+                /* Fix later */
+                fix = TRUE;
+
+                /* Examine the inventory */
+                borg_notice(FALSE);
+
+                /* Evaluate the equipment */
+                p = borg_power();
+            }
+
+
+            /* Restore hole */
+            COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+            /* Restore shop item */
+            COPY(&borg_shops[k].ware[n], &safe_shops[k].ware[n], borg_item);
+
+            /* Obtain the "cost" of the item */
+            c = item->cost * qty;
+
+            /* Penalize the cost of expensive items */
+            if (c > borg_gold / 10) p -= c;
+
+            /* Ignore "bad" purchases */
+            if (p < b_p) continue;
+
+            /* Ignore "expensive" purchases */
+            if ((p == b_p) && (c >= b_c)) continue;
+
+            /* Save the item and cost */
+            b_k = k; b_n = n; b_p = p; b_c = c;
+        }
+    }
+
+
+    /* Examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Buy something */
+    if ((b_k >= 0) && (b_n >= 0))
+    {
+        /* Visit that shop */
+        goal_shop = b_k;
+
+        /* Buy that item */
+        goal_ware = b_n;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Step 4 -- buy "useful" things from the home (to be used)
+ */
+static bool borg_think_home_buy_aux(void)
+{
+    int hole = INVEN_PACK - 1;
+
+    int slot;
+    int qty=1;
+    int n, b_n = -1;
+    s32b p, b_p = 0L;
+    s32b p_left = 0;
+    s32b p_right = 0;
+
+    bool fix = FALSE;
+
+
+    /* Require one empty slot */
+    if (borg_items[hole].iqty) return (FALSE);
+
+
+    /* Extract the "power" */
+    b_p = my_power;
+
+    /* Scan the home */
+    for (n = 0; n < STORE_INVEN_MAX; n++)
+    {
+        borg_item *item = &borg_shops[7].ware[n];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Skip it if I just sold it */
+        if (sold_item_tval == item->tval && sold_item_sval == item->sval &&
+            sold_item_pval == item->pval && sold_item_store == 7)
+        {
+#if 0
+            borg_note(format("# Choosing not to buy back '%s' from home.", item->desc));
+#endif
+            continue;
+        }
+
+		/* borg_note(format("# Considering buying (%d)'%s' (pval=%d) from home.", item->iqty,item->desc, item->pval)); */
+
+        /* Save shop item */
+        COPY(&safe_shops[7].ware[n], &borg_shops[7].ware[n], borg_item);
+
+        /* Save hole */
+        COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+        /* Save the number */
+        qty = borg_min_item_quantity(item);
+
+        /* Remove one item from shop (sometimes) */
+        borg_shops[7].ware[n].iqty -= qty;
+
+        /* Obtain "slot" */
+        slot = borg_wield_slot(item);
+
+        /* Consider new equipment-- Must check both ring slots */
+        if (slot >= 0)
+        {
+
+            /* Check Rings */
+            if (slot == INVEN_LEFT)
+            {
+                /** First Check Left Hand **/
+
+                /* special curse check for left ring */
+                if (!borg_items[INVEN_LEFT].cursed)
+                {
+                    /* Save old item */
+                    COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+                    /* Move equipment into inventory */
+                    COPY(&borg_items[hole], &safe_items[slot], borg_item);
+
+                    /* Move new item into equipment */
+                    COPY(&borg_items[slot], &safe_shops[7].ware[n], borg_item);
+
+                    /* Only a single item */
+                    borg_items[slot].iqty = qty;
+
+                    /* Fix later */
+                    fix = TRUE;
+
+                    /* Examine the inventory */
+                    borg_notice(FALSE);
+
+                    /* Evaluate the inventory */
+                    p_left = borg_power();
+#if 0
+            /* dump list and power...  for debugging */
+            borg_note(format("Trying Item %s (best power %ld)",borg_items[slot].desc, p_left));
+            borg_note(format("   Against Item %s   (borg_power %ld)",safe_items[slot].desc, my_power));
+#endif
+                    /* Restore old item */
+                    COPY(&borg_items[slot], &safe_items[slot], borg_item);
+                }
+
+
+                /** Second Check Right Hand **/
+                /* special curse check for right ring */
+                if (!borg_items[INVEN_RIGHT].cursed)
+                {
+                    /* Save old item */
+                    COPY(&safe_items[INVEN_RIGHT], &borg_items[INVEN_RIGHT], borg_item);
+
+                    /* Move equipment into inventory */
+                    COPY(&borg_items[hole], &safe_items[INVEN_RIGHT], borg_item);
+
+                    /* Move new item into equipment */
+                    COPY(&borg_items[INVEN_RIGHT], &safe_shops[7].ware[n], borg_item);
+
+                    /* Only a single item */
+                    borg_items[INVEN_RIGHT].iqty = qty;
+
+                    /* Fix later */
+                    fix = TRUE;
+
+                    /* Examine the inventory */
+                    borg_notice(FALSE);
+
+                    /* Evaluate the inventory */
+                    p_right = borg_power();
+
+#if 0
+					/* dump list and power...  for debugging */
+                    borg_note(format("Trying Item %s (best power %ld)",borg_items[INVEN_RIGHT].desc, p_right));
+                    borg_note(format("   Against Item %s   (borg_power %ld)",safe_items[INVEN_RIGHT].desc, my_power));
+#endif
+                    /* Restore old item */
+                    COPY(&borg_items[INVEN_RIGHT], &safe_items[INVEN_RIGHT], borg_item);
+                }
+
+                /* Is this ring better than one of mine? */
+                p = MAX(p_right, p_left);
+
+            }
+
+            else /* non rings */
+            {
+
+                /* do not consider if my current item is cursed */
+                if (slot != -1 && borg_items[slot].cursed) continue;
+
+                /* Save old item */
+                COPY(&safe_items[slot], &borg_items[slot], borg_item);
+
+                /* Move equipment into inventory */
+                COPY(&borg_items[hole], &safe_items[slot], borg_item);
+
+                /* Move new item into equipment */
+                COPY(&borg_items[slot], &safe_shops[7].ware[n], borg_item);
+
+                /* Only a single item */
+                borg_items[slot].iqty = qty;
+
+                /* Fix later */
+                fix = TRUE;
+
+                /* Examine the inventory */
+                borg_notice(FALSE);
+
+                /* Evaluate the inventory */
+                p = borg_power();
+#if 0
+                /* dump list and power...  for debugging */
+                borg_note(format("Trying Item %s (best power %ld)",borg_items[slot].desc, p));
+                borg_note(format("   Against Item %s   (borg_power %ld)",safe_items[slot].desc, my_power));
+#endif
+                /* Restore old item */
+                COPY(&borg_items[slot], &safe_items[slot], borg_item);
+            } /* non rings */
+        } /* equip */
+
+        /* Consider new inventory */
+        else
+        {
+            /* Move new item into inventory */
+            COPY(&borg_items[hole], &safe_shops[7].ware[n], borg_item);
+
+            /* Only a single item */
+            borg_items[hole].iqty = qty;
+
+            /* Fix later */
+            fix = TRUE;
+
+            /* Examine the inventory */
+            borg_notice(FALSE);
+
+            /* Evaluate the equipment */
+            p = borg_power();
+        }
+
+        /* Restore hole */
+        COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+        /* Restore shop item */
+        COPY(&borg_shops[7].ware[n], &safe_shops[7].ware[n], borg_item);
+
+        /* Ignore "silly" purchases */
+        if (p <= b_p) continue;
+
+        /* Save the item and cost */
+        b_n = n; b_p = p;
+    }
+
+    /* Examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Buy something */
+    if ((b_n >= 0) && (b_p > my_power))
+    {
+        /* Go to the home */
+        goal_shop = 7;
+
+        /* Buy that item */
+        goal_ware = b_n;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+
+/*
+ * Step 5 -- buy "interesting" things from a shop (to be used later)
+ */
+static bool borg_think_shop_grab_aux(void)
+{
+
+    int k, b_k = -1;
+    int n, b_n = -1;
+    int qty=1;
+
+    s32b s, b_s = 0L;
+    s32b c, b_c = 0L;
+    s32b borg_empty_home_power;
+
+
+    /* Dont do this if Sauron is dead */
+    if (borg_race_death[546] != 0) return (FALSE);
+
+
+    /* get what an empty home would have for power */
+    borg_notice_home( NULL, TRUE );
+    borg_empty_home_power = borg_power_home();
+
+    b_home_power = &s;
+
+    /* Require two empty slots */
+    if (borg_items[INVEN_PACK-1].iqty) return (FALSE);
+    if (borg_items[INVEN_PACK-2].iqty) return (FALSE);
+
+    /* Examine the home */
+    borg_notice_home(NULL, FALSE);
+
+    /* Evaluate the home */
+    b_s = borg_power_home();
+
+    /* Check the shops */
+    for (k = 0; k < (MAX_STORES-1); k++)
+    {
+        /* Scan the wares */
+        for (n = 0; n < STORE_INVEN_MAX; n++)
+        {
+            borg_item *item = &borg_shops[k].ware[n];
+
+            /* Skip empty items */
+            if (!item->iqty) continue;
+
+            /* Skip "bad" buys */
+            if (!borg_good_buy(item, k)) continue;
+
+            /* Dont buy easy spell books late in the game */
+            /* Hack -- Require some "extra" cash */
+            if (borg_gold < 1000L + item->cost * 5) continue;
+
+            /* make this the next to last item that the player has */
+            /* (can't make it the last or it thinks that both player and */
+            /*  home are full) */
+            COPY(&borg_items[INVEN_PACK-2], &borg_shops[k].ware[n], borg_item);
+
+            /* Save the number */
+            qty = borg_min_item_quantity(item);
+
+            /* Give a single item */
+            borg_items[INVEN_PACK-2].iqty = qty;
+
+            /* make sure this item would help an empty home */
+            borg_notice_home( &borg_shops[k].ware[n], FALSE );
+            if (borg_empty_home_power >= borg_power_home()) continue;
+
+            /* optimize the home inventory */
+            if (!borg_think_home_sell_aux( TRUE )) continue;
+
+            /* Obtain the "cost" of the item */
+            c = item->cost * qty;
+
+            /* Penalize expensive items */
+            if (c > borg_gold / 10) s -= c;
+
+            /* Ignore "bad" sales */
+            if (s < b_s) continue;
+
+            /* Ignore "expensive" purchases */
+            if ((s == b_s) && (c >= b_c)) continue;
+
+            /* Save the item and cost */
+            b_k = k; b_n = n; b_s = s; b_c = c;
+        }
+    }
+
+    /* restore inventory hole (just make sure the last slot goes back to */
+    /* empty) */
+    borg_items[INVEN_PACK-2].iqty = 0;
+
+    /* Examine the real home */
+    borg_notice_home(NULL, FALSE);
+
+    /* Evaluate the home */
+    s = borg_power_home();
+
+    /* remove the target that optimizing the home gave */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* Buy something */
+    if ((b_k >= 0) && (b_n >= 0))
+    {
+        /* Visit that shop */
+        goal_shop = b_k;
+
+        /* Buy that item */
+        goal_ware = b_n;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Step 6 -- take "useless" things from the home (to be sold)
+ */
+static bool borg_think_home_grab_aux(void)
+{
+    int n, b_n = -1;
+    s32b s, b_s = 0L;
+    int qty=1;
+
+
+    /* Require two empty slots */
+    if (borg_items[INVEN_PACK-1].iqty) return (FALSE);
+    if (borg_items[INVEN_PACK-2].iqty) return (FALSE);
+
+
+    /* Examine the home */
+    borg_notice_home(NULL, FALSE);
+
+    /* Evaluate the home */
+    b_s = borg_power_home();
+
+
+    /* Scan the home */
+    for (n = 0; n < STORE_INVEN_MAX; n++)
+    {
+        borg_item *item = &borg_shops[7].ware[n];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* skip stuff if we sold bought it */
+        if (sold_item_tval == item->tval && sold_item_sval == item->sval &&
+            sold_item_pval == item->pval && sold_item_store == 7) continue;
+
+        /* Save shop item */
+        COPY(&safe_shops[7].ware[n], &borg_shops[7].ware[n], borg_item);
+
+        /* Save the number */
+        qty = borg_min_item_quantity(item);
+
+        /* Remove one item from shop */
+        borg_shops[7].ware[n].iqty -= qty;
+
+        /* Examine the home */
+        borg_notice_home(NULL, FALSE);
+
+        /* Evaluate the home */
+        s = borg_power_home();
+
+        /* Restore shop item */
+        COPY(&borg_shops[7].ware[n], &safe_shops[7].ware[n], borg_item);
+
+        /* Ignore "bad" sales */
+        if (s < b_s) continue;
+
+        /* Maintain the "best" */
+        b_n = n; b_s = s;
+    }
+
+    /* Examine the home */
+    borg_notice_home(NULL, FALSE);
+
+    /* Evaluate the home */
+    s = borg_power_home();
+
+    /* Stockpile */
+    if (b_n >= 0)
+    {
+        /* Visit the home */
+        goal_shop = 7;
+
+        /* Grab that item */
+        goal_ware = b_n;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Assume not */
+    return (FALSE);
+}
+
+/*
+ * Step 7A -- buy "useful" weapons from the home (to be used as a swap)
+ */
+static bool borg_think_home_buy_swap_weapon(void)
+{
+    int hole;
+
+    int slot;
+    int old_weapon_swap;
+    s32b old_weapon_swap_value;
+    int old_armour_swap;
+    s32b old_armour_swap_value;
+    int n, b_n = -1;
+    s32b p, b_p = 0L;
+
+    bool fix = FALSE;
+
+
+    /* save the current values */
+    old_weapon_swap = weapon_swap;
+    old_weapon_swap_value =  weapon_swap_value;
+    old_armour_swap = armour_swap;
+    old_armour_swap_value =  armour_swap_value;
+
+    if (weapon_swap <= 0 || weapon_swap_value <=0)
+    {
+        hole = INVEN_PACK - 1;
+        weapon_swap_value = -1L;
+    }
+    else
+    {
+        hole = weapon_swap;
+    }
+
+    /* Extract the "power" */
+    b_p = weapon_swap_value;
+
+    /* Scan the home */
+    for (n = 0; n < STORE_INVEN_MAX; n++)
+    {
+        borg_item *item = &borg_shops[7].ware[n];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Obtain "slot" make sure its a weapon */
+        slot = borg_wield_slot(item);
+        if (slot != INVEN_WIELD) continue;
+
+        /* Save shop item */
+        COPY(&safe_shops[7].ware[n], &borg_shops[7].ware[n], borg_item);
+
+        /* Save hole */
+        COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+        /* Remove one item from shop */
+        borg_shops[7].ware[n].iqty--;
+
+
+        /* Consider new equipment */
+        if (slot == INVEN_WIELD)
+        {
+            /* Move new item into inventory */
+            COPY(&borg_items[hole], &safe_shops[7].ware[n], borg_item);
+
+            /* Only a single item */
+            borg_items[hole].iqty = 1;
+
+            /* Fix later */
+            fix = TRUE;
+
+            /* Examine the iventory and swap value*/
+            borg_notice(TRUE);
+
+            /* Evaluate the new equipment */
+            p = weapon_swap_value;
+        }
+
+        /* Restore hole */
+        COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+        /* Restore shop item */
+        COPY(&borg_shops[7].ware[n], &safe_shops[7].ware[n], borg_item);
+
+        /* Ignore "silly" purchases */
+        if (p <= b_p) continue;
+
+        /* Save the item and value */
+        b_n = n; b_p = p;
+    }
+
+    /* Examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Buy something */
+    if ((b_n >= 0) && (b_p > weapon_swap_value))
+    {
+        /* Go to the home */
+        goal_shop = 7;
+
+        /* Buy that item */
+        goal_ware = b_n;
+
+        /* Restore the values */
+        weapon_swap = old_weapon_swap;
+        weapon_swap_value =  old_weapon_swap_value;
+        armour_swap = old_armour_swap;
+        armour_swap_value =  old_armour_swap_value;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Restore the values */
+        weapon_swap = old_weapon_swap;
+        weapon_swap_value =  old_weapon_swap_value;
+        armour_swap = old_armour_swap;
+        armour_swap_value =  old_armour_swap_value;
+
+    /* Nope */
+    return (FALSE);
+}
+/*
+ * Step 7B -- buy "useful" armour from the home (to be used as a swap)
+ */
+static bool borg_think_home_buy_swap_armour(void)
+{
+    int hole;
+
+    int slot;
+
+    int n, b_n = -1;
+    s32b p, b_p = 0L;
+    bool fix = FALSE;
+    int old_weapon_swap;
+    s32b old_weapon_swap_value;
+    int old_armour_swap;
+    s32b old_armour_swap_value;
+
+
+
+    /* save the current values */
+    old_weapon_swap = weapon_swap;
+    old_weapon_swap_value =  weapon_swap_value;
+    old_armour_swap = armour_swap;
+    old_armour_swap_value =  armour_swap_value;
+
+    if (armour_swap <= 1 || armour_swap_value <=0 )
+    {
+        hole = INVEN_PACK - 1;
+        armour_swap_value = -1L;
+    }
+    else
+    {
+        hole = armour_swap;
+    }
+
+
+    /* Extract the "power" */
+    b_p = armour_swap_value;
+
+
+    /* Scan the home */
+    for (n = 0; n < STORE_INVEN_MAX; n++)
+    {
+        borg_item *item = &borg_shops[7].ware[n];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* Obtain "slot".  Elimination of non armours in borg4.c*/
+        slot = borg_wield_slot(item);
+
+
+        /* Save shop item */
+        COPY(&safe_shops[7].ware[n], &borg_shops[7].ware[n], borg_item);
+
+        /* Save hole */
+        COPY(&safe_items[hole], &borg_items[hole], borg_item);
+
+        /* Remove one item from shop */
+        borg_shops[7].ware[n].iqty--;
+
+        /* Move new item into inventory */
+        COPY(&borg_items[hole], &safe_shops[7].ware[n], borg_item);
+
+        /* Only a single item */
+        borg_items[hole].iqty = 1;
+
+        /* Fix later */
+        fix = TRUE;
+
+        /* Examine the inventory (false)*/
+        borg_notice(TRUE);
+
+        /* Evaluate the new equipment */
+        p = armour_swap_value;
+
+        /* Restore hole */
+        COPY(&borg_items[hole], &safe_items[hole], borg_item);
+
+        /* Restore shop item */
+        COPY(&borg_shops[7].ware[n], &safe_shops[7].ware[n], borg_item);
+
+        /* Ignore "silly" purchases */
+        if (p <= b_p) continue;
+
+        /* Save the item and value */
+        b_n = n; b_p = p;
+    }
+
+    /* Examine the inventory */
+    if (fix) borg_notice(TRUE);
+
+    /* Buy something */
+    if ((b_n >= 0) && (b_p > armour_swap_value))
+    {
+        /* Go to the home */
+        goal_shop = 7;
+
+        /* Buy that item */
+        goal_ware = b_n;
+
+        /* Restore the values */
+        weapon_swap = old_weapon_swap;
+        weapon_swap_value =  old_weapon_swap_value;
+        armour_swap = old_armour_swap;
+        armour_swap_value =  old_armour_swap_value;
+
+        /* Success */
+        return (TRUE);
+    }
+    /* Restore the values */
+    weapon_swap = old_weapon_swap;
+    weapon_swap_value =  old_weapon_swap_value;
+    armour_swap = old_armour_swap;
+    armour_swap_value =  old_armour_swap_value;
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+
+
+/*
+ * Choose a shop to visit (see above)
+ */
+static bool borg_choose_shop(void)
+{
+    int i;
+
+
+    /* Must be in town */
+    if (borg_skill[BI_CDEPTH]) return (FALSE);
+
+    /*apw Forbid if been sitting on level forever */
+    /*    Just come back and work through the loop later */
+    if (borg_t - borg_began > 2000) return (FALSE);
+    if (time_this_panel > 350) return (FALSE);
+
+    /* If poisoned or bleeding -- flow to temple */
+    if (borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) goal_shop = 3;
+
+    /* If Starving  -- flow to general store */
+    if (borg_skill[BI_FOOD] == 0 ||
+        (borg_skill[BI_CURLITE] == 0 && borg_skill[BI_CLEVEL] >= 2))
+    {
+		/* G Store first */
+		goal_shop = 0;
+
+		/* If I have tried the general store, then home */
+		if (borg_shops[0].when && borg_food_onsale == 0)
+		{
+			goal_shop = 7;
+		}
+	}
+
+	/* if No Lantern -- flow to general store */
+    if (borg_skill[BI_CURLITE] == 1 && borg_gold >= 75 &&
+    	!borg_shops[0].when) goal_shop = 0;
+
+    /* If poisoned, bleeding, or needing to shop instantly
+     * Buy items straight away, without having to see each shop
+     */
+    if ((borg_skill[BI_CURLITE] == 0 || borg_skill[BI_FOOD] == 0 ||
+         borg_skill[BI_ISCUT] || borg_skill[BI_ISPOISONED]) ||
+        (borg_skill[BI_CURLITE] == 1 && borg_gold >= 100))
+    {
+       if (borg_think_shop_buy_aux())
+       {
+            /* Message */
+            borg_note(format("# Buying '%s' at '%s' (for player 'a')",
+                         borg_shops[goal_shop].ware[goal_ware].desc,
+                         (f_name + f_info[0x08+goal_shop].name)));
+
+            /* Success */
+            return (TRUE);
+        }
+
+        /* if temple is out of healing stuff, try the house */
+        if (borg_think_home_buy_aux())
+        {
+            /* Message */
+            borg_note(format("# Buying '%s' from the home",
+                         borg_shops[goal_shop].ware[goal_ware].desc));
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+	/* Must have visited all shops first---complete information */
+    for (i = 0; i < (MAX_STORES); i++)
+    {
+        borg_shop *shop = &borg_shops[i];
+
+        /* Skip "visited" shops */
+        if (!shop->when) return (FALSE);
+    }
+
+    /* if we are already flowing toward a shop do not check again... */
+    if (goal_shop != -1)
+        return TRUE;
+
+    /* Assume no important shop */
+    goal_shop = goal_ware = goal_item = -1;
+
+    /* if the borg is scumming for cash for the human player and not himself,
+     * we dont want him messing with the home inventory
+     */
+    if (borg_gold < borg_money_scum_amount && borg_money_scum_amount != 0 &&
+            !borg_skill[BI_CDEPTH] && borg_skill[BI_LITE] && !borg_self_scum)
+    {
+        /* Step 0 -- Buy items from the shops (for the player while scumming) */
+        if (borg_think_shop_buy_aux())
+        {
+            /* Message */
+            borg_note(format("# Buying '%s' at '%s' (money scumming)",
+                             borg_shops[goal_shop].ware[goal_ware].desc,
+                             (f_name + f_info[0x08+goal_shop].name)));
+
+            /* Success */
+            return (TRUE);
+        }
+        else return (FALSE);
+    }
+
+    /* Step 1 -- Sell items to the home */
+    if (borg_think_home_sell_aux( FALSE ))
+    {
+        /* Message */
+        if (goal_item != -1)
+            borg_note(format("# Selling '%s' to the home",
+                             borg_items[goal_item].desc));
+        else
+            borg_note(format("# Buying '%s' from the home (step 1)",
+                             borg_shops[goal_shop].ware[goal_ware].desc));
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /* Step 2 -- Sell items to the shops */
+    if (borg_think_shop_sell_aux())
+    {
+        /* Message */
+        borg_note(format("# Selling '%s' at '%s'",
+                         borg_items[goal_item].desc,
+                         (f_name + f_info[0x08+goal_shop].name)));
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Step 3 -- Buy items from the shops (for the player) */
+    if (borg_think_shop_buy_aux())
+    {
+
+        /* Message */
+        borg_note(format("# Buying '%s' at '%s' (for player 'b')",
+                         borg_shops[goal_shop].ware[goal_ware].desc,
+                         (f_name + f_info[0x08+goal_shop].name)));
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /* Step 4 -- Buy items from the home (for the player) */
+    if (borg_think_home_buy_aux())
+    {
+        /* Message */
+        borg_note(format("# Buying '%s' from the home (step 4)",
+                         borg_shops[goal_shop].ware[goal_ware].desc));
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* get rid of junk from home first.  That way the home is 'uncluttered' */
+    /* before you buy stuff for it.  This will prevent the problem where an */
+    /* item has become a negative value and swapping in a '0' gain item */
+    /* (like pottery) is better. */
+
+    /* Step 5 -- Grab items from the home (for the shops) */
+    if (borg_think_home_grab_aux())
+    {
+        /* Message */
+        borg_note(format("# Grabbing (to sell) '%s' from the home",
+                         borg_shops[goal_shop].ware[goal_ware].desc));
+
+        /* Success */
+        return (TRUE);
+    }
+
+	/* Do not Stock Up the home while money scumming */
+	if (borg_money_scum_amount) return (FALSE);
+
+    /* Step 6 -- Buy items from the shops (for the home) */
+    if (borg_think_shop_grab_aux())
+    {
+        /* Message */
+        borg_note(format("# Grabbing (for home) '%s' at '%s'",
+                         borg_shops[goal_shop].ware[goal_ware].desc,
+                         (f_name + f_info[0x08+goal_shop].name)));
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Step 7A -- Buy weapons from the home (as a backup item) */
+    if (borg_uses_swaps && borg_think_home_buy_swap_weapon())
+    {
+        /* Message */
+        borg_note(format("# Buying '%s' from the home as a backup",
+                         borg_shops[goal_shop].ware[goal_ware].desc));
+
+        /* Success */
+        return (TRUE);
+    }
+    /* Step 7B -- Buy armour from the home (as a backup item) */
+    if (borg_uses_swaps && borg_think_home_buy_swap_armour())
+    {
+        /* Message */
+        borg_note(format("# Buying '%s' from the home as a backup",
+                         borg_shops[goal_shop].ware[goal_ware].desc));
+
+        /* Success */
+        return (TRUE);
+    }
+
+
+    /* Failure */
+    return (FALSE);
+
+}
+
+
+
+
+/*
+ * Sell items to the current shop, if desired
+ */
+static bool borg_think_shop_sell(void)
+{
+    int qty= 1;
+
+    /* Sell something if requested */
+    if ((goal_shop == shop_num) && (goal_item >= 0))
+    {
+        borg_item *item = &borg_items[goal_item];
+
+        qty = borg_min_item_quantity(item);
+
+        /* Remove the inscription */
+        if (item->tval == TV_FOOD) borg_send_deinscribe(goal_item);
+
+        /* Log */
+        borg_note(format("# Selling %s", item->desc));
+
+        /* Buy an item */
+        borg_keypress('s');
+
+        /* Buy the desired item */
+        borg_keypress(I2A(goal_item));
+
+        /* Hack -- Sell a single item */
+        if (qty >= 2)
+        {
+            if (qty == 5) borg_keypress('5');
+            if (qty == 4) borg_keypress('4');
+            if (qty == 3) borg_keypress('3');
+            if (qty == 2) borg_keypress('2');
+        }
+
+        /* Mega-Hack -- Accept the price */
+        borg_keypress('\n');
+        borg_keypress('\n');
+        borg_keypress('\n');
+        borg_keypress('\n');
+
+        /* Mark our last item sold but not ezheals*/
+        if (item->tval != TV_POTION &&
+            item->sval != SV_POTION_STAR_HEALING &&
+            item->sval != SV_POTION_LIFE)
+        {
+            sold_item_pval = item->pval;
+            sold_item_tval = item->tval;
+            sold_item_sval = item->sval;
+            sold_item_store = goal_shop;
+        }
+
+
+        /* The purchase is complete */
+        goal_shop = goal_ware = goal_item = -1;
+
+        /* Go back to the first page and rebrowse this store AJG */
+        if (borg_shops[shop_num].page)
+            borg_keypress(' ');
+            borg_do_browse_what = -1;
+
+        /* tick the anti-loop clock */
+        time_this_panel ++;
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nope */
+    return (FALSE);
+}
+
+
+/*
+ * Buy items from the current shop, if desired
+ */
+static bool borg_think_shop_buy(void)
+{
+    int qty =1;
+
+    /* Buy something if requested */
+    if ((goal_shop == shop_num) && (goal_ware >= 0))
+    {
+        borg_shop *shop = &borg_shops[goal_shop];
+
+        borg_item *item = &shop->ware[goal_ware];
+
+        qty = borg_min_item_quantity(item);
+
+        /* Paranoid */
+        if (item->tval == 0)
+        {
+            /* The purchase is complete */
+			goal_shop = goal_ware = goal_item = -1;
+
+            /* rebrowse this store */
+            borg_do_browse_what = -1;
+
+            /* Increment our clock to avoid loops */
+            time_this_panel ++;
+
+            return (FALSE);
+        }
+
+        /* Log */
+        borg_note(format("# Buying %s.", item->desc));
+
+        /* Buy an item */
+        borg_keypress('p');
+
+        /* Buy the desired item */
+        borg_keypress(I2A(goal_ware));
+
+        /* Hack -- Buy a single item (sometimes)*/
+        if (qty >= 2)
+        {
+            if (qty == 5) borg_keypress('5');
+            if (qty == 4) borg_keypress('4');
+            if (qty == 3) borg_keypress('3');
+            if (qty == 2) borg_keypress('2');
+        }
+
+        /* Mega-Hack -- Accept the price */
+        borg_keypress('\n');
+        borg_keypress('\n');
+        borg_keypress('\n');
+        borg_keypress('\n');
+
+		/* if the borg is scumming and bought it.,
+		 * reset the scum amount.
+		 */
+		if (borg_money_scum_amount &&
+			(borg_money_scum_amount == item->cost ||
+		     (goal_shop == 6 || goal_shop == 7))) /* home or black market */
+		{
+			borg_money_scum_amount = 0;
+		}
+
+        /* The purchase is complete */
+        goal_shop = goal_ware = goal_item = -1;
+
+        /* rebrowse this store */
+        borg_do_browse_what = -1;
+
+        /* Increment our clock to avoid loops */
+        time_this_panel ++;
+
+        /*
+         * It is easier for the borg to wear the Equip if he exits
+         * the shop after buying it, even though there may be a few
+         * more items he'd like to buy.
+         */
+        if (borg_wield_slot(item) >= INVEN_WIELD || time_this_panel > 100 ||
+            item->tval == TV_FOOD)
+        {
+            /* leave the store */
+            borg_keypress(ESCAPE);
+
+            /* rebrowse this store */
+            borg_do_browse_what = -1;
+
+        }
+
+        /* Success */
+        return (TRUE);
+    }
+
+    /* Nothing to buy */
+    return (FALSE);
+}
+
+
+/*
+ * Deal with being in a store
+ */
+bool borg_think_store(void)
+{
+    /* Hack -- prevent clock wrapping */
+    if (borg_t >= 20000 && borg_t <=20010)
+    {
+        /* Clear Possible errors */
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+
+        /* Re-examine inven and equip */
+        borg_do_inven = TRUE;
+        borg_do_equip = TRUE;
+    }
+
+    /* update all my equipment and swap items */
+    borg_notice(TRUE);
+
+    /* Stamp the shop with a time stamp */
+    borg_shops[shop_num].when = borg_t;
+
+    /* Remove "backwards" rings */
+    if (borg_swap_rings()) return (TRUE);
+
+    /* Repair "backwards" rings */
+    if (borg_wear_rings()) return (TRUE);
+
+    /* Wear "optimal" equipment */
+    if (borg_best_stuff()) return (TRUE);
+
+    /* If using a digger, Wear "useful" equipment.
+     * unless that digger is an artifact, then treat
+     * it as a normal weapon
+     */
+    if (borg_items[INVEN_WIELD].tval == TV_DIGGING &&
+        !borg_items[INVEN_WIELD].name1 &&
+        borg_wear_stuff()) return (TRUE);
+
+    /* Remove "useless" equipment */
+    if (borg_remove_stuff()) return (TRUE);
+
+    /* Choose a shop to visit */
+    if (borg_choose_shop())
+    {
+        /* Try to sell stuff */
+        if (borg_think_shop_sell()) return (TRUE);
+
+        /* Try to buy stuff */
+        if (borg_think_shop_buy()) return (TRUE);
+    }
+
+    /* No shop */
+	goal_shop = goal_ware = goal_item = -1;
+
+
+    /* Leave the store */
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+    borg_keypress(ESCAPE);
+
+
+    /* Done */
+    return (TRUE);
+}
+
+/* This is an exploitation function.  The borg will stair scum
+ * in the dungeon to get to the bottom of the dungeon asap.
+ * Once down there, he can be told to do something.
+ *
+ * Dive if stairs are close and safe.
+ * Retreat off level if monster has LOS to borg.
+ * Fill Lantern
+ * Eat food
+ * Call light.  might be dangerous because monster get a chance to hit us.
+ */
+bool borg_think_dungeon_lunal(void)
+{
+	bool safe_place = FALSE;
+
+	int j, b_j = -1;
+	int i;
+
+	borg_grid *ag = &borg_grids[c_y][c_x];
+
+    byte feat = cave_feat[c_y][c_x];
+
+    /* examine equipment and swaps */
+    borg_notice(TRUE);
+
+	/* No Lunal mode if starving or in town */
+	if (borg_skill[BI_CDEPTH] == 0 ||
+		borg_skill[BI_ISWEAK])
+	{
+		borg_note("# Leaving Lunal Mode. (Town or Weak)");
+		borg_lunal_mode = FALSE;
+		return (FALSE);
+	}
+
+	/* if borg is just starting on this level, he may not
+	 * know that a stair is under him.  Cheat to see if one is
+	 * there
+	 */
+	if (feat == FEAT_MORE && ag->feat != FEAT_MORE)
+	{
+
+       /* Check for an existing "down stairs" */
+       for (i = 0; i < track_more_num; i++)
+       {
+           /* We already knew about that one */
+           if ((track_more_x[i] == c_x) && (track_more_y[i] == c_y)) break;
+       }
+
+       /* Track the newly discovered "down stairs" */
+       if ((i == track_more_num) && (i < track_more_size))
+       {
+          track_more_x[i] = c_x;
+          track_more_y[i] = c_y;
+          track_more_num++;
+       }
+       /* tell the array */
+       ag->feat = FEAT_MORE;
+
+	}
+
+	if (feat == FEAT_LESS && ag->feat != FEAT_LESS)
+	{
+
+       /* Check for an existing "up stairs" */
+       for (i = 0; i < track_less_num; i++)
+       {
+            /* We already knew about this one */
+            if ((track_less_x[i] == c_x) && (track_less_y[i] == c_y)) continue;
+		}
+
+	   /* Track the newly discovered "up stairs" */
+ 	   if ((i == track_less_num) && (i < track_less_size))
+       {
+          track_less_x[i] = c_x;
+          track_less_y[i] = c_y;
+          track_less_num++;
+       }
+
+		/* Tell the array */
+       ag->feat = FEAT_LESS;
+
+	}
+
+	/* Act normal on 1 unless stairs are seen*/
+	if (borg_skill[BI_CDEPTH] == 1 && track_more_num == 0)
+	{
+		borg_lunal_mode = FALSE;
+		return (FALSE);
+	}
+
+	/* If no down stair is known, act normal */
+	if (track_more_num ==0 && track_less_num == 0)
+	{
+		borg_note("# Leaving Lunal Mode. (No Stairs seen)");
+		borg_lunal_mode = FALSE;
+		return (FALSE);
+	}
+
+	/* If self scumming and getting closer to zone, act normal */
+    if (borg_self_lunal)
+    {
+		if (borg_skill[BI_MAXDEPTH] <= borg_skill[BI_CDEPTH] + 15 ||
+    	    (cptr)NULL != borg_prepared(borg_skill[BI_CDEPTH] - 5) ||
+    	    borg_skill[BI_CDEPTH] >= 50 ||
+	        borg_skill[BI_CDEPTH] == 0 ||
+			borg_skill[BI_ISWEAK])
+    	{
+			borg_lunal_mode = FALSE;
+			goal_fleeing = FALSE;
+			goal_fleeing_lunal = FALSE;
+			borg_note("# Self Lunal mode disengaged normally.");
+			return (FALSE);
+		}
+	}
+
+
+	/** First deal with staying alive **/
+
+    /* Hack -- require light */
+    if (!borg_skill[BI_LITE])
+    {
+        borg_item *item = &borg_items[INVEN_LITE];
+
+        /* Must have light -- Refuel current torch */
+        if ((item->tval == TV_LITE) && (item->sval == SV_LITE_TORCH))
+        {
+            /* Try to refuel the torch */
+            if ((item->pval < 500) &&
+                 borg_refuel_torch()) return (TRUE);
+        }
+
+        /* Must have light -- Refuel current lantern */
+        if ((item->tval == TV_LITE) && (item->sval == SV_LITE_LANTERN))
+        {
+            /* Try to refill the lantern */
+            if ((item->pval < 1000) && borg_refuel_lantern()) return (TRUE);
+        }
+
+        if (item->pval < 250)
+        {
+            borg_note("# Lunal. (need fuel)");
+        }
+    }
+
+	/* Define if safe_place is true or not */
+	safe_place = borg_check_rest();
+
+	/* Light Room, looking for monsters */
+	if (safe_place && borg_check_lite_only()) return (TRUE);
+
+	/* Check for stairs and doors and such */
+	if (safe_place && borg_check_lite()) return (TRUE);
+
+	/* Recover from any nasty condition */
+	if (safe_place && borg_recover()) return (TRUE);
+
+	/* Consume needed things */
+	if (safe_place && borg_use_things()) return (TRUE);
+
+	/* Consume needed things */
+	if (borg_skill[BI_ISHUNGRY] && borg_use_things()) return (TRUE);
+
+	/** Track down some interesting gear **/
+/* XXX Should we allow him great flexibility in retreiving loot? (not always safe?)*/
+    /* Continue flowing towards objects */
+    if (safe_place && borg_flow_old(GOAL_TAKE)) return (TRUE);
+
+    /* Find a (viewable) object */
+    if (safe_place && borg_flow_take_lunal(TRUE, 4)) return (TRUE);
+
+	/*leave level right away. */
+	borg_note("# Fleeing level. Lunal Mode");
+	goal_fleeing_lunal = TRUE;
+	goal_fleeing = TRUE;
+
+    /* Lunal Mode - Going down */
+    if (track_more_num &&
+        (safe_place || ag->feat == FEAT_MORE ||
+         ag->feat == FEAT_LESS ||
+         borg_skill[BI_CDEPTH] < 30))
+    {
+        int y, x;
+
+		if (track_more_num >= 2) borg_note("# Lunal Mode: I know of a down stair.");
+
+        /* Check for an existing "down stairs" */
+        for (i = 0; i < track_more_num; i++)
+        {
+            x = track_more_x[i];
+            y = track_more_y[i];
+
+            /* How far is the nearest down stairs */
+            j = distance(c_y, c_x, y, x);
+
+            /* skip the far ones */
+            if (b_j <= j && b_j != -1) continue;
+
+            /* track it */
+            b_j =j;
+        }
+
+
+        /* if the downstair is close and path is safe, continue on */
+        if ((b_j < 8 && safe_place) ||
+             ag->feat == FEAT_MORE ||
+             borg_skill[BI_CDEPTH] < 30)
+		{
+        	/* Note */
+        	borg_note("# Lunal Mode.  Power Diving. ");
+
+	       	/* Continue leaving the level */
+        	if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+			/* Flow to DownStair */
+        	if (borg_flow_stair_more(GOAL_FLEE)) return (TRUE);
+
+			/* if standing on a stair */
+			if (ag->feat == FEAT_MORE)
+			{
+				/* Take the DownStair */
+	        	borg_on_upstairs = TRUE;
+	        	borg_keypress('>');
+
+	        	return (TRUE);
+			}
+		}
+    }
+
+    /* Lunal Mode - Going up */
+    if (track_less_num && borg_skill[BI_CDEPTH] != 1 &&
+        (safe_place || ag->feat == FEAT_MORE ||
+         ag->feat == FEAT_LESS))
+    {
+        int y, x;
+
+	    borg_grid *ag = &borg_grids[c_y][c_x];
+
+        /* Check for an existing "up stairs" */
+        for (i = 0; i < track_less_num; i++)
+        {
+            x = track_less_x[i];
+            y = track_less_y[i];
+
+            /* How far is the nearest up stairs */
+            j = distance(c_y, c_x, y, x);
+
+            /* skip the far ones */
+            if (b_j <= j && b_j != -1) continue;
+
+            /* track it */
+            b_j =j;
+        }
+
+        /* if the upstair is close and safe path, continue */
+        if ((b_j < 8 && safe_place) ||
+        	ag->feat == FEAT_LESS)
+        {
+
+	        /* Note */
+	        borg_note("# Lunal Mode.  Power Climb. ");
+
+			/* Set to help borg move better */
+			goal_less = TRUE;
+
+	        /* Continue leaving the level */
+	        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+			/* Flow to UpStair */
+	        if (borg_flow_stair_less(GOAL_FLEE))
+	        {
+		        /* Success */
+		        return (TRUE);
+			}
+
+			if (ag->feat == FEAT_LESS)
+			{
+				/* Take the Up Stair */
+		        borg_on_dnstairs = TRUE;
+		        borg_keypress('<');
+				return (TRUE);
+			}
+
+		}
+    }
+
+	/* Special case where the borg is off a stair and there
+	 * is a monster in LOS.  He could freeze and unhook, or
+	 * move to the closest stair and risk the run.
+	 */
+	if (borg_skill[BI_CDEPTH] >= 2)
+	{
+    	/* Continue fleeing to stair */
+    	if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Note */
+        borg_note("# Lunal Mode.  Any Stair. ");
+
+    	/* Try to find some stairs */
+    	if (borg_flow_stair_both(GOAL_FLEE)) return (TRUE);
+	}
+
+
+	/* Lunal Mode - Reached 99 */
+	if (borg_skill[BI_CDEPTH] == 99)
+	{
+		borg_note("# Lunal Mode ended at depth.");
+	}
+
+	/* Unable to do it */
+	if (borg_skill[BI_CDEPTH] > 1)
+	{
+		borg_note("# Lunal Mode ended incorrectly.");
+	}
+
+	/* return to normal borg_think_dungeon */
+	borg_note("Leaving Lunal Mode. (End of Lunal Mode)");
+	borg_lunal_mode = FALSE;
+	goal_fleeing = goal_fleeing_lunal = FALSE;
+	return (FALSE);
+}
+
+/*
+ * Hack -- perform an action in the dungeon under boosted bravery
+ *
+ * This function is a sub-set of the standard dungeon goals, and is
+ * only executed when all of the standard dungeon goals fail, because
+ * of excessive danger, or because the level is "bizarre".
+ */
+static bool borg_think_dungeon_brave(void)
+{
+    /*** Local stuff ***/
+	int p1 =  borg_danger(c_y, c_x, 1, TRUE);
+
+	/* Try a defence manuever on 100 */
+	if (borg_skill[BI_CDEPTH] == 100 &&
+	    borg_defend(p1)) return TRUE;
+
+    /* Attack monsters */
+    if (borg_attack(TRUE)) return (TRUE);
+
+    /* Cast a light beam to remove fear of an area */
+    if (borg_lite_beam(FALSE)) return (TRUE);
+
+    /*** Flee (or leave) the level ***/
+
+    /* Take stairs down from town */
+    if (borg_skill[BI_CDEPTH] == 0)
+    {
+        /* Current grid */
+        borg_grid *ag = &borg_grids[c_y][c_x];
+
+        /* Usable stairs */
+        if (ag->feat == FEAT_MORE)
+        {
+
+            /* Take the stairs */
+            borg_on_upstairs = TRUE;
+            borg_note("# Fleeing town via Stairs.");
+            borg_keypress('>');
+
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+    /* Return to Stairs, but not use them */
+    if (goal_less)
+    {
+        /* Continue fleeing to stair */
+        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs */
+        if (scaryguy_on_level && !borg_skill[BI_CDEPTH] && borg_flow_stair_both(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs up */
+        if (borg_flow_stair_less(GOAL_FLEE)) return (TRUE);
+    }
+
+
+    /* Flee the level */
+    if (goal_fleeing || goal_leaving || scaryguy_on_level)
+    {
+        /* Hack -- Take the next stairs */
+        stair_less = goal_fleeing;
+
+        if (borg_ready_morgoth == 0)
+            stair_less = TRUE;
+
+		if (stair_less == TRUE)
+		{
+			borg_note("# Fleeing and leaving the level. Brave Thinking.");
+		}
+
+        /* Only go down if fleeing or prepared. */
+        stair_more = goal_fleeing;
+        if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH]+1))
+            stair_more = TRUE;
+
+        /* Continue fleeing the level */
+        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs up */
+        if (stair_less)
+            if (borg_flow_stair_less(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs down */
+        if (stair_more)
+            if (borg_flow_stair_more(GOAL_FLEE)) return (TRUE);
+
+    }
+
+    /* Do short looks on special levels */
+    if (vault_on_level)
+    {
+        /* Continue flowing towards monsters */
+        if (borg_flow_old(GOAL_KILL)) return (TRUE);
+
+        /* Find a (viewable) monster */
+        if (borg_flow_kill(TRUE, 35)) return (TRUE);
+
+        /* Continue flowing towards objects */
+        if (borg_flow_old(GOAL_TAKE)) return (TRUE);
+
+        /* Find a (viewable) object */
+        if (borg_flow_take(TRUE, 35)) return (TRUE);
+    }
+
+    /* Continue flowing towards monsters */
+    if (borg_flow_old(GOAL_KILL)) return (TRUE);
+
+    /* Find a (viewable) monster */
+    if (borg_flow_kill(TRUE, 250)) return (TRUE);
+
+    /* Continue flowing towards objects */
+    if (borg_flow_old(GOAL_TAKE)) return (TRUE);
+
+    /* Find a (viewable) object */
+    if (borg_flow_take(TRUE, 250)) return (TRUE);
+
+    /*** Exploration ***/
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_MISC)) return (TRUE);
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_DARK)) return (TRUE);
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_XTRA)) return (TRUE);
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_BORE)) return (TRUE);
+
+
+    /*** Explore the dungeon ***/
+
+    /* Explore interesting grids */
+    if (borg_flow_dark(TRUE)) return (TRUE);
+
+    /* Explore interesting grids */
+    if (borg_flow_dark(FALSE)) return (TRUE);
+
+    /* Search for secret door via spell before spastic */
+    if (!when_detect_doors || (borg_t - when_detect_doors >= 500))
+    {
+		if (borg_check_lite()) return (TRUE);
+	}
+
+    /* Search for secret doors */
+    if (borg_flow_spastic(FALSE)) return (TRUE);
+
+
+    /*** Track down old stuff ***/
+
+    /* Chase old objects */
+    if (borg_flow_take(FALSE,250)) return (TRUE);
+
+    /* Chase old monsters */
+    if (borg_flow_kill(FALSE,250)) return (TRUE);
+
+    /* Search for secret door via spell before spastic */
+    if (!when_detect_doors || (borg_t - when_detect_doors >= 500))
+    {
+		if (borg_check_lite()) return (TRUE);
+	}
+
+    /* Search for secret doors */
+    if (borg_flow_spastic(TRUE)) return (TRUE);
+
+
+    /* Nothing */
+    return (FALSE);
+}
+
+
+/*
+ * Perform an action in the dungeon
+ *
+ * Return TRUE if a "meaningful" action was performed
+ * Otherwise, return FALSE so we will be called again
+ *
+ * Strategy:
+ *   Make sure we are happy with our "status" (see above)
+ *   Attack and kill visible monsters, if near enough
+ *   Open doors, disarm traps, tunnel through rubble
+ *   Pick up (or tunnel to) gold and useful objects
+ *   Explore "interesting" grids, to expand the map
+ *   Explore the dungeon and revisit old grids
+ *
+ * Fleeing:
+ *   Use word of recall when level is "scary"
+ *   Flee to stairs when there is a chance of death
+ *   Avoid "stair bouncing" if at all possible
+ *
+ * Note that the various "flow" actions allow the Borg to flow
+ * "through" closed doors, which will be opened when he attempts
+ * to pass through them, so we do not have to pursue terrain until
+ * all monsters and objects have been dealt with.
+ *
+ * XXX XXX XXX The poor Borg often kills a nasty monster, and
+ * then takes a nap to recover from damage, but gets yanked
+ * back to town before he can collect his reward.
+ */
+bool borg_think_dungeon(void)
+{
+    int i, j, ii;
+    int b_j = -1;
+	int y,x;
+    borg_grid *ag;
+
+	bool not_safe = FALSE;
+
+    byte feat = cave_feat[c_y][c_x];
+
+#ifdef BORG_TK
+    extern byte borgtk_delay_factor;
+    int msec = borgtk_delay_factor * borgtk_delay_factor;
+#else /* not BORG_TK */
+    int msec = ((op_ptr->delay_factor * op_ptr->delay_factor) +
+                (borg_delay_factor * borg_delay_factor));
+#endif /* not BORG_TK */
+
+
+
+    /* HACK allows user to stop the borg on certain levels */
+    if (borg_skill[BI_CDEPTH] == borg_stop_dlevel) borg_oops("Auto-stop for user DLevel.");
+    if (borg_skill[BI_CLEVEL] == borg_stop_clevel) borg_oops("Auto-stop for user CLevel.");
+
+    /* HACK to end all hacks,,, allow the borg to stop if money scumming */
+    if (borg_gold > borg_money_scum_amount && borg_money_scum_amount != 0 &&
+        !borg_skill[BI_CDEPTH] && !borg_self_scum)
+    {
+        borg_oops("Money Scum complete.");
+    }
+
+    /* Hack -- Stop the borg if money scumming and the shops are out of food. */
+    if (!borg_skill[BI_CDEPTH] && borg_money_scum_amount != 0 &&
+        (borg_food_onsale == 0 || borg_skill[BI_FOOD] < 5))
+    {
+ 		/* Town out of food.  If player initiated borg, stop here */
+ 		if (borg_self_scum == FALSE)
+ 		{
+			borg_oops("Money Scum stopped.  No more food in shop.");
+			return (TRUE);
+		}
+		else
+		/* Borg doing it himself */
+		{
+			/* move money goal to 0 and leave the level */
+			borg_money_scum_amount = 0;
+		}
+    }
+
+    /* Hack -- prevent clock wrapping Step 1*/
+    if (borg_t >= 12000 && borg_t <=12025)
+    {
+        /* Clear Possible errors */
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+
+        /* Re-examine inven and equip */
+        borg_do_inven = TRUE;
+        borg_do_equip = TRUE;
+
+        /* enter a special routine to handle this behavior.  Messing with
+         * the old_level forces him to re-explore this level, and reshop,
+         * if in town.
+         */
+        old_depth = 126;
+
+        /* Continue on */
+        return (TRUE);
+    }
+
+    /* Hack -- prevent clock wrapping Step 2*/
+    if (borg_t >= 30000)
+    {
+        /* Panic */
+        borg_oops("clock overflow");
+
+#ifdef BABLOS
+    /* Clock overflow escape code */
+    printf("Clock overflow code!\n");
+    p_ptr->playing = FALSE;
+    p_ptr->leaving = TRUE;
+    borg_clock_over = TRUE;
+#endif /* BABLOS */
+
+        /* Oops */
+        return (TRUE);
+    }
+
+    /* Allow respawning borgs to update their variables */
+    if (borg_respawning > 1)
+    {
+        borg_note(format("# Pressing 'escape' to catch up and get in sync (%d).", borg_respawning));
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        borg_respawning --;
+        return (TRUE);
+    }
+#ifdef BORG_TK
+    if (msec)
+#endif /* BORG_TK */
+    /* add a short pause to slow the borg down for viewing */
+    Term_xtra(TERM_XTRA_DELAY, msec);
+
+    /* redraw the screen if we need to */
+    if (my_need_redraw)
+    {
+        borg_note(format("#  Redrawing screen."));
+        do_cmd_redraw();
+        my_need_redraw = FALSE;
+    }
+
+    /* Prevent clock overflow */
+    if (borg_t - borg_began >= 10000)
+    {
+        /* Start leaving */
+        if (!goal_leaving)
+        {
+            /* Note */
+            borg_note("# Leaving (boredom)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+
+        /* Start fleeing */
+        if (!goal_fleeing)
+        {
+            /* Note */
+            borg_note("# Fleeing (boredom)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+    }
+
+    /* Allow borg to jump back up to town if needed */
+    if (borg_skill[BI_CDEPTH] == 1 && borg_fleeing_town)
+    {
+        /* Start leaving */
+        if (!goal_leaving)
+        {
+            /* Note */
+            borg_note("# Leaving (finish shopping)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+
+        /* Start fleeing */
+        if (!goal_fleeing)
+        {
+            /* Note */
+            borg_note("# Fleeing (finish shopping)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+    }
+
+    /* Prevent a "bouncing Borg" bug. Where borg with telepathy
+     * will sit in a narrow area bouncing between 2 or 3 places
+     * tracking and flowing to a bouncing monster behind a wall.
+     * First, reset goals.
+     * Second, clear all known monsters/takes
+     * Third, Flee the level
+     */
+    if (borg_skill[BI_CDEPTH] &&
+        (time_this_panel >= 300 && time_this_panel <= 303))
+    {
+        /* Clear Goals */
+        goal = 0;
+    }
+    if (borg_skill[BI_CDEPTH] &&
+        (time_this_panel >= 500 && time_this_panel <= 503))
+    {
+        /* No objects here */
+        borg_takes_cnt = 0;
+        borg_takes_nxt = 1;
+
+        /* Forget old objects */
+        C_WIPE(borg_takes, 256, borg_take);
+
+        /* No monsters here */
+        borg_kills_cnt = 0;
+        borg_kills_nxt = 1;
+
+        /* Forget old monsters */
+        C_WIPE(borg_kills, 256, borg_kill);
+    }
+    if (borg_skill[BI_CDEPTH] &&
+        (time_this_panel >= 700))
+    {
+        /* Start leaving */
+        if (!goal_leaving)
+        {
+            /* Note */
+            borg_note("# Leaving (bouncing-borg)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+
+        /* Start fleeing */
+        if (!goal_fleeing)
+        {
+            /* Note */
+            borg_note("# Fleeing (bouncing-borg)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+
+    }
+
+
+    /* Count the awake breeders */
+    for (j = 0, i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Skip sleeping monsters */
+        if (!kill->awake) continue;
+
+        /* Count the monsters which are "breeders" */
+        if (r_info[kill->r_idx].flags2 & RF2_MULTIPLY) j++;
+    }
+
+    /* hack -- close doors on breeder levels */
+    if (j >= 3)
+    {
+        /* set the flag to close doors */
+        breeder_level = TRUE;
+    }
+
+
+    /* Hack -- caution from breeders*/
+    if ((j >= MIN(borg_skill[BI_CLEVEL] + 2, 5)) &&
+        (borg_skill[BI_RECALL] <= 0 || borg_skill[BI_CLEVEL] < 35))
+    {
+        /* Ignore monsters from caution */
+        if (!goal_ignoring)
+        {
+            /* Flee */
+            borg_note("# Ignoring breeders (no recall)");
+
+            /* Ignore multipliers */
+            goal_ignoring = TRUE;
+        }
+
+        /* Start leaving */
+        if (!goal_leaving)
+        {
+            /* Note */
+            borg_note("# Leaving (no recall)");
+
+            /* Start leaving */
+            goal_leaving = TRUE;
+        }
+
+        /* Start fleeing */
+        if (!goal_fleeing)
+        {
+            /* Note */
+            borg_note("# Fleeing (no recall)");
+
+            /* Start fleeing */
+            goal_fleeing = TRUE;
+        }
+
+
+    }
+
+    /* Reset avoidance */
+    if (avoidance != borg_skill[BI_CURHP])
+    {
+        /* Reset "avoidance" */
+        avoidance = borg_skill[BI_CURHP];
+
+        /* Re-calculate danger */
+        borg_danger_wipe = TRUE;
+
+        /* Forget goals */
+    }
+
+    /* Keep borg on a short leash */
+    if (track_less_num &&
+        (borg_skill[BI_MAXHP] < 30 || borg_skill[BI_CLEVEL] < 10) &&
+        !goal_less)
+    {
+        int y, x;
+
+        /* Check for an existing "up stairs" */
+        for (i = 0; i < track_less_num; i++)
+        {
+            x = track_less_x[i];
+            y = track_less_y[i];
+
+            /* How far is the nearest up stairs */
+            j = distance(c_y, c_x, y, x);
+
+            /* skip the far ones */
+            if (b_j <= j && b_j != -1) continue;
+
+            /* track it */
+            b_j = j;
+        }
+
+        /* is the upstair too far away? */
+        if (b_j > borg_skill[BI_CLEVEL] * 5 + 14)
+        {
+            /* Return to Stairs */
+            if (!goal_less)
+            {
+                /* Note */
+                borg_note(format("# Return to Stair (wandered too far.  Leash: %d)",borg_skill[BI_CLEVEL] * 5 + 14));
+
+                /* Start returning */
+                goal_less = TRUE;
+            }
+
+        }
+    }
+
+
+	/* Quick check to see if borg needs to engage his lunal mode */
+    if (borg_self_lunal && !borg_plays_risky)  /* Risky borg in a hurry */
+    {
+		if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH] + 15) &&
+			borg_skill[BI_MAXDEPTH] >= borg_skill[BI_CDEPTH] + 15 &&
+			borg_skill[BI_CDEPTH] >=1)
+	    {
+			borg_lunal_mode = TRUE;
+
+			/* Enter the Lunal scumming mode */
+			if (borg_lunal_mode && borg_think_dungeon_lunal()) return (TRUE);
+		}
+	}
+
+
+	/*** crucial goals ***/
+
+    /* examine equipment and swaps */
+    borg_notice(TRUE);
+
+    /* require light-- */
+    if (borg_skill[BI_CURLITE] <= 0 && borg_skill[BI_CDEPTH] >= 1)
+    {
+        /* I am recalling, sit here till it engages. */
+        if (goal_recalling)
+        {
+            /* just wait */
+            borg_keypress('R');
+            borg_keypress('9');
+            borg_keypress('\n');
+            return (TRUE);
+        }
+
+        /* wear stuff and see if it glows */
+        if (borg_wear_stuff()) return (TRUE);
+
+        /* attempt to refuel */
+        if (borg_refuel_torch() || borg_refuel_lantern()) return (TRUE);
+
+        /* Can I recall out with a rod */
+        if (!goal_recalling && borg_zap_rod(SV_ROD_RECALL)) return (TRUE);
+
+        /* Can I recall out with a spell */
+        if (!goal_recalling && borg_recall()) return (TRUE);
+
+		/* Log */
+		borg_note("# Testing for stairs .");
+
+        /* Test for stairs */
+        borg_keypress('<');
+
+		/* If on a glowing grid, can S.H., and low mana, then rest here */
+		if ((borg_skill[BI_CURSP] < borg_skill[BI_MAXSP] && borg_skill[BI_MAXSP] > 0) &&
+		    (borg_grids[c_y][c_x].info & BORG_GLOW) &&
+		    (borg_prayer_legal(1, 5) || borg_spell_legal(2, 0)) &&
+		    (borg_prayer_legal(0, 4) || borg_spell_legal(0, 3)) &&
+		    (!borg_prayer_okay(0, 4) && !borg_spell_okay(0, 3)))
+		{
+			/* Scan grids adjacent to me */
+			for (ii = 0; ii < 8; ii++)
+			{
+	           	x = c_x + ddx_ddd[ii];
+	           	y = c_y + ddy_ddd[ii];
+
+				/* Bounds check */
+	            if (!in_bounds_fully(y,x)) continue;
+
+	           	/* Access the grid */
+	           	ag = &borg_grids[y][x];
+
+	           	/* Check for adjacent Monster */
+	           	if (ag->kill)
+	           	{
+					not_safe = TRUE;
+				}
+			}
+
+			/* rest here to gain some mana */
+       	    if (not_safe == FALSE)
+       	    {
+				borg_note("# Resting on this Glowing Grid to gain mana.");
+            	borg_keypress('R');
+            	borg_keypress('*');
+            	borg_keypress('\n');
+            	return (TRUE);
+			}
+        }
+
+		/* If I have the capacity to Call Light, then do so if adjacent to a dark grid.
+		 * We can illuminate the entire dungeon, looking for stairs.
+		 */
+		/* Scan grids adjacent to me */
+		for (ii = 0; ii < 8; ii++)
+		{
+           	x = c_x + ddx_ddd[ii];
+           	y = c_y + ddy_ddd[ii];
+
+
+			/* Bounds check */
+            if (!in_bounds_fully(y,x)) continue;
+
+           	/* Access the grid */
+           	ag = &borg_grids[y][x];
+
+			/* Problem with casting Call Light on Open Doors */
+			if ((ag->feat == FEAT_OPEN || ag->feat == FEAT_BROKEN) &&
+				(y == c_y && x == c_x))
+			{
+				/* Cheat the grid info to see if the door is lit */
+				if (feat == CAVE_GLOW) ag->info |= BORG_GLOW;
+				continue;
+			}
+
+        	/* Look for a dark one */
+        	if ((ag->info & BORG_DARK) || ag->feat == FEAT_NONE)
+        	{
+				/* Attempt to Call Light */
+	        	if (borg_activate_artifact(ACT_ILLUMINATION, INVEN_LITE) ||
+	        	    borg_zap_rod(SV_ROD_ILLUMINATION) ||
+	        	    borg_use_staff(SV_STAFF_LITE) ||
+	        	    borg_read_scroll(SV_SCROLL_LIGHT) ||
+	        	    borg_spell(0, 3) ||
+	        	    borg_prayer(0, 4))
+	        	{
+	        	    borg_note("# Illuminating the region while dark.");
+		            borg_react("SELF:lite", "SELF:lite");
+
+	        	    return (TRUE);
+	        	}
+			}
+		}
+
+
+        /* Try to flow to upstairs if on level one */
+        if (borg_flow_stair_less(GOAL_FLEE))
+        {
+            /* Take the stairs */
+			/* Log */
+			borg_note("# Taking up Stairs stairs (low Light).");
+            borg_keypress('<');
+            return (TRUE);
+        }
+
+        /* Try to flow to a lite */
+        if (borg_skill[BI_RECALL] && borg_flow_light(GOAL_FLEE))
+        {
+            return (TRUE);
+        }
+
+    }
+
+    /* Decrease the amount of time not allowed to retreat */
+    if (borg_no_retreat > 0)
+        borg_no_retreat--;
+
+    /*** Important goals ***/
+
+    /* Try not to die */
+    if (borg_caution()) return (TRUE);
+
+    /*** if returning from dungeon in bad shape...***/
+    if (borg_skill[BI_CURLITE] == 0 || borg_skill[BI_ISCUT] ||
+        borg_skill[BI_ISPOISONED] || borg_skill[BI_FOOD] == 0)
+    {
+        /* First try to wear something */
+        if (borg_skill[BI_CURLITE] == 0)
+        {
+            /* attempt to refuel */
+            if (borg_refuel_torch() || borg_refuel_lantern()) return (TRUE);
+
+            /* wear stuff and see if it glows */
+            if (borg_wear_stuff()) return (TRUE);
+
+        }
+
+        /* Recover from damage */
+        if (borg_recover()) return (TRUE);
+
+		/* If full of items, we wont be able to buy stuff, crush stuff */
+	    if (borg_items[INVEN_PACK-1].iqty && borg_crush_hole()) return (TRUE);
+
+        /* shop for something that will help us */
+        if (borg_flow_shop_visit()) return (TRUE);
+        if (borg_choose_shop())
+        {
+            /* Try and visit a shop, if so desired */
+            if (borg_flow_shop_entry(goal_shop)) return (TRUE);
+        }
+    }
+
+    /* Learn useful spells immediately */
+    if (borg_play_magic(FALSE)) return (TRUE);
+
+    /* If using a digger, Wear "useful" equipment before fighting monsters */
+    if (borg_items[INVEN_WIELD].tval == TV_DIGGING && borg_wear_stuff()) return (TRUE);
+
+    /* If not using anything, Wear "useful" equipment before fighting monsters */
+    if (!borg_items[INVEN_WIELD].tval && borg_wear_stuff()) return (TRUE);
+
+    /* Attack monsters */
+    if (borg_attack(FALSE)) return (TRUE);
+
+    /* Wear things that need to be worn, but try to avoid swap loops */
+    if (borg_wear_stuff()) return (TRUE);
+
+    /* Remove "backwards" rings */
+    /* Only do this in Stores to avoid loops     if (borg_swap_rings()) return (TRUE); */
+
+    /* Repair "backwards" rings */
+    if (borg_wear_rings()) return (TRUE);
+
+    /* Remove stuff that is useless or detrimental */
+    if (borg_remove_stuff()) return (TRUE);
+
+    /* Check the light */
+    if (borg_check_lite()) return (TRUE);
+
+    /* Recover from damage */
+    if (borg_recover()) return (TRUE);
+
+    /* Perform "cool" perma spells */
+    if (borg_perma_spell()) return (TRUE);
+
+    /* Try to stick close to stairs if weak */
+    if (borg_skill[BI_CLEVEL] < 10 && borg_skill[BI_MAXSP] &&
+        borg_skill[BI_CURSP] == 0 && borg_no_rest_prep <= 1  &&
+        !borg_bless && !borg_hero && !borg_berserk)
+    {
+        if (borg_skill[BI_CDEPTH])
+        {
+            int i, y, x;
+
+            /* Check for an existing "up stairs" */
+            for (i = 0; i < track_less_num; i++)
+            {
+                x = track_less_x[i];
+                y = track_less_y[i];
+
+                /* Not on a stair */
+                if (c_y != y || c_x != x) continue;
+
+                /* I am standing on a stair */
+
+                /* reset the goal_less flag */
+                goal_less = FALSE;
+
+                /* if not dangerous, wait here */
+                if (borg_danger(c_y,c_x,1, TRUE) == 0)
+                {
+                    /* rest here a moment */
+                    borg_note("# Resting on stair to gain Mana.");
+                    borg_keypress(',');
+                    return (TRUE);
+                }
+            }
+        }
+        else /* in town */
+        {
+            int i, y, x;
+
+            /* Check for an existing "dn stairs" */
+            for (i = 0; i < track_more_num; i++)
+            {
+                x = track_more_x[i];
+                y = track_more_y[i];
+
+                /* Not on a stair */
+                if (c_y != y || c_x != x) continue;
+
+                /* I am standing on a stair */
+
+                /* if not dangerous, wait here */
+                if (borg_danger(c_y,c_x,1, TRUE) == 0)
+                {
+                    /* rest here a moment */
+                    borg_note("# Resting on town stair to gain Mana.");
+                    borg_keypress(',');
+                    return (TRUE);
+                }
+            }
+        }
+
+        /* In town, standing on stairs, sit tight */
+        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs up */
+        if (borg_flow_stair_less(GOAL_FLEE)) return (TRUE);
+
+    }
+
+	/* If in town and have no money, and nothing to sell,
+	 * then do not stay in town, its too dangerous.
+	 */
+	if (borg_skill[BI_CDEPTH] == 0 &&
+	    borg_skill[BI_CLEVEL] < 5 && borg_gold < 3 &&
+	    borg_count_sell() < 3)
+	{
+		borg_note("# Nothing to sell in town (leaving).");
+        goal_leaving = TRUE;
+
+        /* Continue fleeing the level */
+        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs down */
+        if (borg_flow_stair_more(GOAL_FLEE)) return (TRUE);
+	}
+
+    /*** Flee the level XXX XXX XXX ***/
+
+    /* Return to Stairs, but not use them */
+    if (goal_less)
+    {
+        /* Continue fleeing to stair */
+        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs */
+        if (scaryguy_on_level && borg_flow_stair_both(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs up */
+        if (borg_flow_stair_less(GOAL_FLEE)) return (TRUE);
+    }
+
+    /* Flee the level */
+    if (goal_fleeing && !goal_recalling)
+    {
+        /* Hack -- Take the next stairs */
+        stair_less = stair_more = TRUE;
+		borg_note("# Fleeing and leaving the level. (2)");
+
+        /* Continue fleeing the level */
+        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs */
+        if (scaryguy_on_level &&
+            borg_flow_stair_both(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs up */
+        if (borg_flow_stair_less(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs down */
+        if (borg_flow_stair_more(GOAL_FLEE)) return (TRUE);
+
+    }
+
+	/* Flee to a safe Morgoth grid if appropriate */
+	if (!borg_skill[BI_KING] && morgoth_on_level && !borg_morgoth_position &&
+	    (borg_skill[BI_AGLYPH] >= 10 &&
+         (!borg_skill[BI_ISBLIND] && !borg_skill[BI_ISCONFUSED])))
+	{
+		/* Continue flowing towards good morgoth grid */
+		if (borg_flow_old(GOAL_MISC)) return (TRUE);
+
+		/* Attempt to locate a good Glyphed grid */
+		if (borg_flow_glyph(GOAL_MISC)) return (TRUE);
+
+		/* Have the borg excavate the dungeon with Stone to Mud */
+	}
+
+/* should he chase down the close items before chasing down far monsters ? */
+    /* Continue flowing towards (the hopefully close) monsters */
+    if (borg_flow_old(GOAL_KILL)) return (TRUE);
+
+    /* Find a really close monster */
+    if (borg_flow_kill(TRUE, 20)) return (TRUE);
+
+    /* Continue flowing towards objects */
+    if (borg_flow_old(GOAL_TAKE)) return (TRUE);
+
+    /* Find a really close object */
+    if (borg_flow_take(TRUE, 10)) return (TRUE);
+
+    /* Continue flowing towards monsters */
+    if (borg_flow_old(GOAL_KILL)) return (TRUE);
+
+    /* Find a (viewable) monster */
+    if (borg_flow_kill(TRUE, 250)) return (TRUE);
+
+    /* Find a viewable monster and line up a shot on him */
+    if (borg_flow_kill_aim(TRUE)) return (TRUE);
+
+    /* Dig an anti-summon corridor */
+    if (borg_flow_kill_corridor(TRUE)) return (TRUE);
+
+
+    /*** Deal with inventory objects ***/
+
+    /* check for anything that should be inscribed */
+    /* if (borg_inscribe_food()) return (TRUE); */
+
+    /* Use things */
+    if (borg_use_things()) return (TRUE);
+
+    /* Identify unknown things */
+    if (borg_test_stuff(FALSE)) return (TRUE);
+
+    /* *Id* unknown things */
+    if (borg_test_stuff(TRUE)) return (TRUE);
+
+    /* Enchant things */
+    if (borg_enchanting()) return (TRUE);
+
+    /* Recharge things */
+    if (borg_recharging()) return (TRUE);
+
+    /* Destroy junk */
+    if (borg_crush_junk()) return (TRUE);
+
+    /* Destroy items to make space */
+    if (borg_crush_hole()) return (TRUE);
+
+    /* Destroy items if we are slow */
+    if (borg_crush_slow()) return (TRUE);
+
+    /* Power dive if I am playing too shallow
+     * This is also seen in leave_level().  If
+     * this formula is modified here, change it
+     * in leave_level too.
+     */
+    if (borg_skill[BI_CDEPTH] != 0 &&
+        (cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH] + 5))
+    {
+        /* Take next stairs */
+        stair_more = TRUE;
+
+        /* Continue leaving the level */
+        if (borg_flow_old(GOAL_BORE)) return (TRUE);
+
+        /* Attempt to use those stairs */
+        if (borg_flow_stair_more(GOAL_BORE))
+        {
+			/* Leave a note */
+			borg_note("# Powerdiving.");
+			return (TRUE);
+		}
+    }
+
+
+    /*** Flow towards objects ***/
+
+    /* Continue flowing towards objects */
+    if (borg_flow_old(GOAL_TAKE)) return (TRUE);
+
+    /* Find a (viewable) object */
+    if (borg_flow_take(TRUE, 250)) return (TRUE);
+
+
+    /*** Leave the level XXX XXX XXX ***/
+
+    /* Leave the level */
+    if (goal_leaving && !goal_recalling && !unique_on_level)
+    {
+        /* Hack -- Take the next stairs */
+        if (borg_ready_morgoth == 0)
+        {
+            borg_note("# Fleeing and leaving the level (1).");
+			stair_less = TRUE;
+		}
+
+        /* Only go down if fleeing or prepared. */
+        if ((cptr)NULL == borg_prepared(borg_skill[BI_CDEPTH]+1))
+            stair_more = TRUE;
+
+        /* Continue leaving the level */
+        if (borg_flow_old(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs up */
+        if (stair_less)
+            if (borg_flow_stair_less(GOAL_FLEE)) return (TRUE);
+
+        /* Try to find some stairs down */
+        if (stair_more)
+            if (borg_flow_stair_more(GOAL_FLEE)) return (TRUE);
+    }
+
+
+    /*** Exploration ***/
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_MISC)) return (TRUE);
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_DARK)) return (TRUE);
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_XTRA)) return (TRUE);
+
+    /* Continue flowing (see below) */
+    if (borg_flow_old(GOAL_BORE)) return (TRUE);
+
+
+    /*** Explore the dungeon ***/
+
+    if (vault_on_level)
+    {
+
+        /* Chase close monsters */
+        if (borg_flow_kill(FALSE, 35)) return (TRUE);
+
+        /* Chase close objects */
+        if (borg_flow_take(FALSE, 35)) return (TRUE);
+
+        /* Explore close interesting grids */
+        if (borg_flow_dark(TRUE)) return (TRUE);
+    }
+
+    /* Chase old monsters */
+    if (borg_flow_kill(FALSE, 250)) return (TRUE);
+
+    /* Chase old objects */
+    if (borg_flow_take(FALSE, 250)) return (TRUE);
+
+    /* Explore interesting grids */
+    if (borg_flow_dark(TRUE)) return (TRUE);
+
+    /* Leave the level (if needed) */
+    if (borg_gold < borg_money_scum_amount && borg_money_scum_amount != 0 &&
+            !borg_skill[BI_CDEPTH] && borg_skill[BI_LITE])
+    {
+        /* Stay in town and scum for money after shopping */
+    }
+    else
+    {
+        if (borg_leave_level(FALSE)) return (TRUE);
+    }
+
+    /* Explore interesting grids */
+    if (borg_flow_dark(FALSE)) return (TRUE);
+
+
+    /*** Deal with shops ***/
+
+    /* Hack -- visit all the shops */
+    if (borg_flow_shop_visit()) return (TRUE);
+
+    /* Hack -- Visit the shops */
+    if (borg_choose_shop())
+    {
+        /* Try and visit a shop, if so desired */
+        if (borg_flow_shop_entry(goal_shop)) return (TRUE);
+    }
+
+
+    /*** Leave the Level ***/
+
+    /* Study/Test boring spells/prayers */
+    if (!goal_fleeing && borg_play_magic(TRUE)) return (TRUE);
+
+    /* Search for secret door via spell before spastic */
+    if (!when_detect_doors || (borg_t - when_detect_doors >= 500))
+    {
+		if (borg_check_lite()) return (TRUE);
+	}
+
+    /* Search for secret doors */
+    if (borg_flow_spastic(FALSE)) return (TRUE);
+
+	/* Flow directly to a monster if not able to be spastic */
+	if (borg_flow_kill_direct(FALSE)) return (TRUE);
+
+    /* Recharge items before leaving the level */
+    if (borg_wear_recharge()) return (TRUE);
+
+    /* Leave the level (if possible) */
+    if (borg_gold < borg_money_scum_amount && borg_money_scum_amount != 0 &&
+            !borg_skill[BI_CDEPTH] && borg_skill[BI_LITE] &&
+            !borg_plays_risky) /* risky borgs are in a hurry */
+    {
+        /* Stay in town, scum for money now that shopping is done. */
+        borg_money_scum();
+
+        /* Done */
+        return (TRUE);
+    }
+    else
+    {
+        if (borg_leave_level(TRUE)) return (TRUE);
+    }
+
+    /* Search for secret door via spell before spastic */
+    if (!when_detect_doors || (borg_t - when_detect_doors >= 500))
+    {
+		if (borg_check_lite()) return (TRUE);
+	}
+
+    /* Search for secret doors */
+    if (borg_flow_spastic(TRUE)) return (TRUE);
+
+	/* Flow directly to a monster if not able to be spastic */
+	if (borg_flow_kill_direct()) return (TRUE);
+
+
+    /*** Wait for recall ***/
+
+    /* Wait for recall, unless in danger */
+    if (goal_recalling && (borg_danger(c_y, c_x, 1, TRUE) <= 0))
+    {
+        /* Take note */
+        borg_note("# Waiting for Recall...");
+
+        if (borg_skill[BI_CDEPTH])
+        {
+            /* Rest until done */
+            borg_keypress('R');
+            borg_keypress('&');
+            borg_keypress('\n');
+        }
+        else
+        {
+            /* Rest one round-- we keep count of turns while in town */
+            borg_keypress('0');
+            borg_keypress('1');
+            borg_keypress('R');
+            borg_keypress('\n');
+        }
+
+        /* Done */
+        return (TRUE);
+    }
+
+    /*** Nothing to do ***/
+
+    /* Twitching in town can be fatal.  Really he should not become twitchy
+     * but sometimes he cant recall to the dungeon and that may induce the
+     * twitchy behavior.  So we reset the level if this happens.  That will
+     * force him to go shopping all over again.
+     */
+     if ((borg_skill[BI_CDEPTH] == 0 && borg_t - borg_began > 800) || borg_t > 28000) old_depth = 126;
+
+    /* Set a flag that the borg is  not allowed to retreat for 5 rounds */
+    borg_no_retreat = 5;
+
+    /* Boost slightly */
+    if (avoidance < borg_skill[BI_CURHP] * 2)
+    {
+        bool done = FALSE;
+
+        /* Note */
+        borg_note(format("# Boosting bravery (1) from %d to %d!",
+                         avoidance, borg_skill[BI_CURHP] * 2));
+
+        /* Hack -- ignore some danger */
+        avoidance = (borg_skill[BI_CURHP] * 2);
+
+        /* Forget the danger fields */
+        borg_danger_wipe = TRUE;
+
+        /* Try anything */
+        if (borg_think_dungeon_brave()) done = TRUE;
+
+        /* Reset "avoidance" */
+        avoidance = borg_skill[BI_CURHP];
+
+        /* Re-calculate danger */
+        borg_danger_wipe = TRUE;
+
+        /* Forget goals */
+/*        goal = 0;*/
+
+        /* Done */
+        if (done) return (TRUE);
+    }
+
+    /* try phase before boosting bravery further and acting goofy */
+    borg_times_twitch++;
+
+    /* Phase to get out of being twitchy up to 3 times per level. */
+    if (borg_times_twitch < 3)
+    {
+        borg_note("# Considering Phase (twitchy)");
+
+        /* Phase */
+        if (borg_spell(0, 2)  ||
+            borg_prayer(4, 0) ||
+            borg_activate_artifact(ACT_PHASE,INVEN_BODY)||
+            borg_read_scroll(SV_SCROLL_PHASE_DOOR) ||
+            borg_spell(1, 5) ||
+            borg_prayer(1, 1) ||
+            borg_prayer(4, 1))
+        {
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+    /* Set a flag that the borg is not allowed */
+    /*  to retreat for 10 rounds */
+    borg_no_retreat = 10;
+
+    /* Boost some more */
+    if (avoidance < borg_skill[BI_MAXHP] * 4)
+    {
+        bool done = FALSE;
+
+        /* Note */
+        borg_note(format("# Boosting bravery (2) from %d to %d!",
+                         avoidance, borg_skill[BI_MAXHP] * 4));
+
+        /* Hack -- ignore some danger */
+        avoidance = (borg_skill[BI_MAXHP] * 4);
+
+        /* Forget the danger fields */
+        borg_danger_wipe = TRUE;
+
+		/* Reset the spastic searching counts */
+        for (y = 0; y < AUTO_MAX_Y; y++)
+        {
+            for (x = 0; x < AUTO_MAX_X; x++)
+            {
+                borg_grids[y][x].xtra = 0;
+            }
+        }
+
+        /* Try anything */
+        if (borg_think_dungeon_brave()) done = TRUE;
+
+        /* Reset "avoidance" */
+        avoidance = borg_skill[BI_CURHP];
+
+        /* Re-calculate danger */
+        borg_danger_wipe = TRUE;
+
+        /* Forget goals */
+/*        goal = 0;*/
+
+        /* Done */
+        if (done) return (TRUE);
+    }
+
+    /* Boost a lot */
+    if (avoidance < 30000)
+    {
+        bool done = FALSE;
+
+        /* Note */
+        borg_note(format("# Boosting bravery (3) from %d to %d!",
+                         avoidance, 30000));
+
+        /* Hack -- ignore some danger */
+        avoidance = 30000;
+
+        /* Forget the danger fields */
+        borg_danger_wipe = TRUE;
+
+		/* Reset the spastic searching counts */
+        for (y = 0; y < AUTO_MAX_Y; y++)
+        {
+            for (x = 0; x < AUTO_MAX_X; x++)
+            {
+                borg_grids[y][x].xtra = 0;
+            }
+        }
+
+		/* Reset multiple factors to jumpstart the borg */
+        unique_on_level = 0;
+        scaryguy_on_level = FALSE;
+
+        /* reset our breeder flag */
+        breeder_level = FALSE;
+
+        /* Hack -- Clear "panel" flags */
+        for (y = 0; y < 6; y++)
+        {
+            for (x = 0; x < 6; x++)
+            {
+                borg_detect_wall[y][x] = FALSE;
+                borg_detect_trap[y][x] = FALSE;
+                borg_detect_door[y][x] = FALSE;
+                borg_detect_evil[y][x] = FALSE;
+            }
+        }
+
+        /* Hack -- Clear "fear" */
+        for (y = 0; y < 6; y++)
+        {
+            for (x = 0; x < 18; x++)
+            {
+                borg_fear_region[y][x] = 0;
+            }
+        }
+
+        /* Remove regional fear from monsters, it gets added back in later. */
+        for (y = 0; y < AUTO_MAX_Y; y++)
+        {
+            for (x = 0; x < AUTO_MAX_X; x++)
+            {
+                borg_fear_monsters[y][x] = 0;
+            }
+        }
+
+        /* Forget goals */
+        goal = 0;
+
+        /* Do not use any stairs */
+        stair_less = stair_more = FALSE;
+
+        /* Hack -- cannot rise past town */
+        if (!borg_skill[BI_CDEPTH]) goal_rising = FALSE;
+
+        /* Assume not leaving the level */
+        goal_leaving = FALSE;
+
+        /* Assume not fleeing the level */
+        goal_fleeing = FALSE;
+		goal_fleeing_lunal = FALSE;
+
+        /* Assume not fleeing the level */
+        if (!borg_skill[BI_CDEPTH]) borg_fleeing_town = FALSE;
+
+        /* Assume not ignoring monsters */
+        goal_ignoring = FALSE;
+
+        /* No known stairs */
+        track_less_num = 0;
+        track_more_num = 0;
+
+        /* No known glyph */
+        track_glyph_num = 0;
+
+        /* No known steps */
+        track_step_num = 0;
+
+        /* No known doors */
+        track_door_num = 0;
+
+        /* No known doors */
+        track_closed_num = 0;
+
+        /* No objects here */
+        borg_takes_cnt = 0;
+        borg_takes_nxt = 1;
+
+        /* Forget old objects */
+        C_WIPE(borg_takes, 256, borg_take);
+
+        /* Try anything */
+        if (borg_think_dungeon_brave()) done = TRUE;
+
+        /* Reset "avoidance" */
+        avoidance = borg_skill[BI_CURHP];
+
+        /* Re-calculate danger */
+        borg_danger_wipe = TRUE;
+
+        /* Done */
+        if (done) return (TRUE);
+    }
+
+    /* try teleporting before acting goofy */
+    borg_times_twitch++;
+
+
+    /* Teleport to get out of being twitchy up to 5 times per level. */
+    if (borg_times_twitch < 5)
+    {
+        borg_note("# Teleport (twitchy)");
+
+        /* Teleport */
+        if ( borg_spell(1, 5) ||
+             borg_prayer(4, 1) ||
+             borg_prayer(1, 1) ||
+             borg_use_staff(SV_STAFF_TELEPORTATION) ||
+             borg_read_scroll(SV_SCROLL_TELEPORT) ||
+             borg_read_scroll(SV_SCROLL_TELEPORT_LEVEL) )
+        {
+            /* Success */
+            return (TRUE);
+        }
+    }
+
+    /* Recall to town */
+    if (borg_skill[BI_CDEPTH] && (borg_recall()))
+    {
+        /* Note */
+        borg_note("# Recalling (twitchy)");
+
+        /* Success */
+        return (TRUE);
+    }
+
+		/* Reset the spastic searching counts */
+        for (y = 0; y < AUTO_MAX_Y; y++)
+        {
+            for (x = 0; x < AUTO_MAX_X; x++)
+            {
+                borg_grids[y][x].xtra = 0;
+            }
+        }
+
+		/* Reset multiple factors to jumpstart the borg */
+        unique_on_level = 0;
+        scaryguy_on_level = FALSE;
+
+        /* reset our breeder flag */
+        breeder_level = FALSE;
+
+        /* Hack -- Clear "panel" flags */
+        for (y = 0; y < 6; y++)
+        {
+            for (x = 0; x < 6; x++)
+            {
+                borg_detect_wall[y][x] = FALSE;
+                borg_detect_trap[y][x] = FALSE;
+                borg_detect_door[y][x] = FALSE;
+                borg_detect_evil[y][x] = FALSE;
+            }
+        }
+
+        /* Hack -- Clear "fear" */
+        for (y = 0; y < 6; y++)
+        {
+            for (x = 0; x < 18; x++)
+            {
+                borg_fear_region[y][x] = 0;
+            }
+        }
+
+        /* Remove regional fear from monsters, it gets added back in later. */
+        for (y = 0; y < AUTO_MAX_Y; y++)
+        {
+            for (x = 0; x < AUTO_MAX_X; x++)
+            {
+                borg_fear_monsters[y][x] = 0;
+            }
+        }
+
+        /* No objects here */
+        borg_takes_cnt = 0;
+        borg_takes_nxt = 1;
+
+        /* Forget old objects */
+        C_WIPE(borg_takes, 256, borg_take);
+
+        /* No monsters here */
+        borg_kills_cnt = 0;
+        borg_kills_nxt = 1;
+
+        /* Forget old monsters */
+        C_WIPE(borg_kills, 256, borg_kill);
+
+        /* Hack -- Forget race counters */
+        C_WIPE(borg_race_count, z_info->r_max, s16b);
+
+	/* Attempt to dig to the center of the dungeon */
+	if (borg_flow_kill_direct(TRUE)) return (TRUE);
+
+    /* Twitch around */
+    if (borg_twitchy()) return (TRUE);
+
+    /* Oops */
+    return (FALSE);
+}
+
+
+
+
+/*
+ * Initialize this file
+ */
+void borg_init_8(void)
+{
+    /* Nothing */
+}
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg8.h angband-3.0.6-borg/src/borg8.h
--- angband-3.0.6/src/borg8.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg8.h	2000-10-24 07:43:48.000000000 -0700
@@ -0,0 +1,44 @@
+/* File: borg8.h */
+
+/* Purpose: Header file for "borg8.c" -BEN- */
+
+#ifndef INCLUDED_BORG8_H
+#define INCLUDED_BORG8_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg8.c".
+ */
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg6.h"
+
+
+/*
+ * Think about the stores
+ */
+extern bool borg_think_store(void);
+
+extern bool borg_caution_phase(int, int);
+extern bool borg_lite_beam(bool simulation);
+/*
+ * Think about the dungeon
+ */
+extern bool borg_think_dungeon(void);
+
+
+/*
+ * Initialize this file
+ */
+extern void borg_init_8(void);
+
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg9.c angband-3.0.6-borg/src/borg9.c
--- angband-3.0.6/src/borg9.c	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg9.c	2005-09-06 19:31:32.000000000 -0700
@@ -0,0 +1,8498 @@
+/* File: borg9.c */
+
+/* Purpose: Highest level functions for the Borg -BEN- */
+#include "angband.h"
+
+#ifdef BORG_TK
+#include "tnb.h"
+#endif /* BORG_TK */
+
+
+#ifdef ALLOW_BORG
+
+#include "borg1.h"
+#include "borg2.h"
+#include "borg3.h"
+#include "borg4.h"
+#include "borg5.h"
+#include "borg6.h"
+#include "borg7.h"
+#include "borg8.h"
+#include "borg9.h"
+
+#ifdef BABLOS
+extern bool auto_play;
+extern bool keep_playing;
+#endif /* bablos */
+bool borg_cheat_death;
+
+static s16b stat_use[6];
+
+/*
+ * This file implements the "Ben Borg", an "Automatic Angband Player".
+ *
+ * This version of the "Ben Borg" is designed for use with Angband 2.7.9v6.
+ *
+ * Use of the "Ben Borg" requires re-compilation with ALLOW_BORG defined,
+ * and with the various "borg*.c" files linked into the executable.
+ *
+ * Note that you can only use the Borg if your character has been marked
+ * as a "Borg User".  You can do this, if necessary, by responding "y"
+ * when asked if you really want to use the Borg.  This will (normally)
+ * result in your character being inelligible for the high score list.
+ *
+ * The "do_cmd_borg()" function, called when the user hits "^Z", allows
+ * the user to interact with the Borg.  You do so by typing "Borg Commands",
+ * including 'z' to activate (or re-activate), 'K' to show monsters, 'T' to
+ * show objects, 'd' to toggle "demo mode", 'f' to open/shut the "log file",
+ * 'i' to display internal flags, etc.  See "do_cmd_borg()" for more info.
+ *
+ * The first time you enter a Borg command, the Borg is initialized.  This
+ * consists of three major steps, and requires at least 400K of free memory,
+ * if the memory is not available, the game may abort.
+ *
+ * (1) The various "borg" modules are initialized.
+ *
+ * (2) Some important "state" information is extracted, including the level
+ *     and race/class of the player, and some more initialization is done.
+ *
+ * (3) Some "historical" information (killed uniques, maximum dungeon depth)
+ *     is "stolen" from the game.
+ *
+ * When the Ben Borg is "activated", it uses the "Term_inkey_hook" to steal
+ * control from the user.  Later, if it detects any input from the real user,
+ * it gracefully relinquishes control by clearing the "Term_inkey_hook" after
+ * any pending key-sequences are complete.
+ *
+ * The Borg will abort if it detects any "errors", or if it detects any
+ * "situations" such as "death", or if it detects any "panic" situations,
+ * such as "imminent death", if the appropriate flags are set.
+ *
+ * The Ben Borg is only supposed to "know" what is visible on the screen,
+ * which it learns by using the "term.c" screen access function "Term_what()",
+ * the cursor location function "Term_locate()", and the cursor visibility
+ * extraction function "Term_get_cursor()".
+ *
+ * The Ben Borg is only supposed to "send" keypresses when the "Term_inkey()"
+ * function asks for a keypress, which is accomplished by using a special
+ * function hook in the "z-term.c" file, which allows the Borg to "steal"
+ * control from the "Term_inkey()" and "Term_flush()" functions.  This
+ * allows the Ben Borg to pretend to be a normal user.
+ *
+ * Note that if properly designed, the Ben Borg could be run as an external
+ * process, which would actually examine the screen (or pseudo-terminal),
+ * and send keypresses directly to the keyboard (or pseudo-terminal).  Thus
+ * it should never access any "game variables", unless it is able to extract
+ * those variables for itself by code duplication or complex interactions,
+ * or, in certain situations, if those variables are not actually "required".
+ *
+ * Currently, the Ben Borg is a few steps away from being able to be run as
+ * an external process, primarily in the "low level" details, such as knowing
+ * when the game is ready for a keypress.  Also, the Ben Borg assumes that a
+ * character has already been rolled, and maintains no state between saves,
+ * which is partially offset by "cheating" to "acquire" the maximum dungeon
+ * depth, without which equipment analysis will be faulty.
+ *
+ * The "theory" behind the Borg is that is should be able to run as a
+ * separate process, playing Angband in a window just like a human, that
+ * is, examining the screen for information, and sending keypresses to
+ * the game.  The current Borg does not actually do this, because it would
+ * be very slow and would not run except on Unix machines, but as far as
+ * possible, I have attempted to make sure that the Borg *could* run that
+ * way.  This involves "cheating" as little as possible, where "cheating"
+ * means accessing information not available to a normal Angband player.
+ * And whenever possible, this "cheating" should be optional, that is,
+ * there should be software options to disable the cheating, and, if
+ * necessary, to replace it with "complex" parsing of the screen.
+ *
+ * Thus, the Borg COULD be written as a separate process which runs Angband
+ * in a pseudo-terminal and "examines" the "screen" and sends keypresses
+ * directly (as with a terminal emulator), although it would then have
+ * to explicitly "wait" to make sure that the game was completely done
+ * sending information.
+ *
+ * The Borg is thus allowed to examine the screen directly (by efficient
+ * direct access of the "Term->scr->a" and "Term->scr->c" arrays, which
+ * could be replaced by calls to "Term_grab()"), and to access the cursor
+ * location (via "Term_locate()") and visibility (via "Term_get_cursor()"),
+ * and, as mentioned above, the Borg is allowed to send keypresses directly
+ * to the game, and only when needed, using the "Term_inkey_hook" hook, and
+ * uses the same hook to know when it should discard all pending keypresses.
+ *
+ * The Borg should not know when the game is ready for a keypress, and
+ * should really do something nasty such as "pause" between turns for
+ * some amount of time to ensure that the game is really waiting for
+ * a keypress.
+ *
+ * Various other "cheats" (mostly optional) are described where they are
+ * used, primarily in this file.
+ *
+ * Note that any "user input" will be ignored, and will cancel the Borg,
+ * after the Borg has completed any key-sequences currently in progress.
+ *
+ * Note that the "borg_t" parameter bears a close resemblance to the number of
+ * "player turns" that have gone by.  Except that occasionally, the Borg will
+ * do something that he *thinks* will take time but which actually does not
+ * (for example, attempting to open a hallucinatory door), and that sometimes,
+ * the Borg performs a "repeated" command (rest, open, tunnel, or search),
+ * which may actually take longer than a single turn.  This has the effect
+ * that the "borg_t" variable is slightly lacking in "precision".  Note that
+ * we can store every time-stamp in a 's16b', since we reset the clock to
+ * 1000 on each new level, and we refuse to stay on any level longer than
+ * 30000 turns, unless we are totally stuck, in which case we abort.
+ *
+ * Note that as of 2.7.9, the Borg can play any class, that is, he can make
+ * "effective" use of at least a few spells/prayers, and is not "broken"
+ * by low strength, blind-ness, hallucination, etc.  This does not, however,
+ * mean that he plays all classes equally well, especially since he is so
+ * dependant on a high strength for so many things.  The "demo" mode is useful
+ * for many classes (especially Mage) since it allows the Borg to "die" a few
+ * times, without being penalized.
+ *
+ * The Borg assumes that the "maximize" flag is off, and that the
+ * "preserve" flag is on, since he cannot actually set those flags.
+ * If the "maximize" flag is on, the Borg may not work correctly.
+ * If the "preserve" flag is off, the Borg may miss artifacts.
+ */
+
+
+/*
+ * We currently handle:
+ *   Level changing (intentionally or accidentally)
+ *   Embedded objects (gold) that must be extracted
+ *   Ignore embedded objects if too "weak" to extract
+ *   Traps (disarm), Doors (open/etc), Rubble (tunnel)
+ *   Stores (enter via movement, exit via escape)
+ *   Stores (limited commands, and different commands)
+ *   Always deal with objects one at a time, not in piles
+ *   Discard junk before trying to pick up more stuff
+ *   Use "identify" to obtain knowledge and/or money
+ *   Rely on "sensing" objects as much as possible
+ *   Do not sell junk or worthless items to any shop
+ *   Do not attempt to buy something without the cash
+ *   Use the non-optimal stairs if stuck on a level
+ *   Use "flow" code for all tasks for consistency
+ *   Cancel all goals when major world changes occur
+ *   Use the "danger" code to avoid potential death
+ *   Use the "danger" code to avoid inconvenience
+ *   Try to avoid danger (both actively and passively)
+ *   Handle "Mace of Disruption", "Scythe of Slicing", etc
+ *   Learn spells, and use them when appropriate
+ *   Remember that studying prayers is slightly random
+ *   Do not try to read scrolls when blind or confused
+ *   Do not study/use spells/prayers when blind/confused
+ *   Use spells/prayers at least once for the experience
+ *   Attempt to heal when "confused", "blind", etc
+ *   Attempt to fix "fear", "poison", "cuts", etc
+ *   Analyze potential equipment in proper context
+ *   Priests should avoid edged weapons (spell failure)
+ *   Mages should avoid most gloves (lose mana)
+ *   Non-warriors should avoid heavy armor (lose mana)
+ *   Keep "best" ring on "tight" right finger in stores
+ *   Remove items which do not contribute to total fitness
+ *   Wear/Remove/Sell/Buy items in most optimal order
+ *   Pursue optimal combination of available equipment
+ *   Notice "failure" when using rods/staffs/artifacts
+ *   Notice "failure" when attempting spells/prayers
+ *   Attempt to correctly track terrain, objects, monsters
+ *   Take account of "clear" and "multi-hued" monsters
+ *   Take account of "flavored" (randomly colored) objects
+ *   Handle similar objects/monsters (mushrooms, coins)
+ *   Multi-hued/Clear monsters, and flavored objects
+ *   Keep in mind that some monsters can move (quickly)
+ *   Do not fire at monsters that may not actually exist
+ *   Assume everything is an object until proven otherwise
+ *   Parse messages to correct incorrect assumptions
+ *   Search for secret doors after exploring the level
+ *   React intelligently to changes in the wall structure
+ *   Do not recalculate "flow" information unless required
+ *   Collect monsters/objects/terrain not currently in view
+ *   Keep in mind that word of recall is a delayed action
+ *   Keep track of charging items (rods and artifacts)
+ *   Be very careful not to access illegal locations!
+ *   Do not rest next to dangerous (or immobile) monsters
+ *   Recall into dungeon if prepared for resulting depth
+ *   Do not attempt to destroy cursed ("terrible") artifacts
+ *   Attempted destruction will yield "terrible" inscription
+ *   Use "maximum" level and depth to prevent "thrashing"
+ *   Use "maximum" hp's and sp's when checking "potentials"
+ *   Attempt to recognize large groups of "disguised" monsters
+ *   Beware of firing at a monster which is no longer present
+ *   Stockpile items in the Home, and use those stockpiles
+ *   Discounted spell-books (low level ones are ignored)
+ *   Take items out of the home to sell them when no longer needed
+ *   Trappers and Mimics (now treated as invisible monsters)
+ *   Invisible monsters (induce "fear" of nearby regions)
+ *   Fleeing monsters are "followed" down corridors and such
+ *
+ * We ignore:
+ *   Long object descriptions may have clipped inscriptions
+ *
+ * We need to handle:
+ *   Technically a room can have no exits, requiring digging
+ *   Try to use a shovel/pick to help with tunnelling
+ *   Conserve memory space (each grid byte costs about 15K)
+ *   Conserve computation time (especially with the flow code)
+ *   Becoming "afraid" (attacking takes a turn for no effect)
+ *   Beware of firing missiles at a food ration under a mushroom
+ *
+ * We need to handle "loading" saved games:
+ *   The "max_depth" value is lost if loaded in the town
+ *   If we track "dead uniques" then this information is lost
+ *   The "map" info, "flow" info, "tracking" info, etc is lost
+ *   The contents of the shops (and the home) are lost
+ *   We may be asked to "resume" a non-Borg character (icky)
+ */
+
+
+/*
+ * Currently, the Borg "cheats" in a few situations...
+ *
+ * Cheats that are significant, and possibly unavoidable:
+ *   Knowledge of when we are being asked for a keypress.
+ *   Note that this could be avoided by LONG timeouts/delays
+ *
+ * Cheats "required" by implementation, but not signifant:
+ *   Direct access to the "screen image" (parsing screen)
+ *   Direct access to the "keypress queue" (sending keys)
+ *   Direct access to the "cursor visibility" (game state)
+ *
+ * Cheats that could be avoided by simple (ugly) code:
+ *   Direct modification of the "current options"
+ *
+ * Cheats that could be avoided by duplicating code:
+ *   Use of the tables in "tables.c"
+ *   Use of the arrays initialized in "init.c"
+ *
+ * Cheats that the Borg would love:
+ *   Immunity to hallucination, blindness, confusion
+ *   Unique attr/char codes for every monster and object
+ *   Removal of the "mimic" and "trapper" monsters
+ *   Removal of the "mushroom" and "gold" monsters
+ */
+
+
+/*
+ * Stat advantages:
+ *   High STR (attacks, to-dam, digging, weight limit)
+ *   High DEX (attacks, to-hit, armor class)
+ *   High CON (hitpoints, recovery)
+ *   High WIS (better prayers, saving throws)
+ *   High INT (better spells, disarming, device usage)
+ *   High CHR (better item costs)
+ *
+ * Class advantages:
+ *   Warrior (good fighting, sensing)
+ *   Mage (good spells)
+ *   Priest (good prayers, fighting)
+ *   Ranger (some spells, fighting)
+ *   Rogue (some spells, fighting, sensing)
+ *   Paladin (prayers, fighting, sensing)
+ *
+ * Race advantages:
+ *   Gnome (free action)
+ *   Dwarf (resist blindness)
+ *   High elf (see invisible)
+ *   Non-human (infravision)
+ */
+
+
+
+
+/*
+ * Some variables
+ */
+
+static bool initialized;    /* Hack -- Initialized */
+
+
+
+/*
+ * Mega-Hack -- extract some "hidden" variables
+ *
+ * XXX XXX XXX This step would not be necessary if more info
+ * was available on the screen.
+ *
+ */
+static void borg_hidden(void)
+{
+    int i;
+
+    /* Clear the stat modifiers */
+    for (i = 0; i < 6; i++) my_stat_add[i] = 0;
+
+    /* Scan the usable inventory */
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        borg_item *item = &borg_items[i];
+
+        /* Skip empty items */
+        if (!item->iqty) continue;
+
+        /* if we have on unidentified stuff we may have misguessed our */
+        /* stats. */
+        if (!item->able)
+        {
+            my_need_stat_check[0] = TRUE;
+            my_need_stat_check[1] = TRUE;
+            my_need_stat_check[2] = TRUE;
+            my_need_stat_check[3] = TRUE;
+            my_need_stat_check[4] = TRUE;
+            my_need_stat_check[5] = TRUE;
+            break;
+        }
+
+        /* Affect stats */
+        if (item->flags1 & TR1_STR) my_stat_add[A_STR] += item->pval;
+        if (item->flags1 & TR1_INT) my_stat_add[A_INT] += item->pval;
+        if (item->flags1 & TR1_WIS) my_stat_add[A_WIS] += item->pval;
+        if (item->flags1 & TR1_DEX) my_stat_add[A_DEX] += item->pval;
+        if (item->flags1 & TR1_CON) my_stat_add[A_CON] += item->pval;
+        if (item->flags1 & TR1_CHR) my_stat_add[A_CHR] += item->pval;
+    }
+
+    /* Mega-Hack -- Guess at "my_stat_cur[]" */
+    for (i = 0; i < 6; i++)
+    {
+        int value;
+
+        if (!my_need_stat_check[i]) continue;
+
+        /* Reverse known bonuses to get the base stat value */
+        value = modify_stat_value(borg_stat[i], -my_stat_add[i]);
+
+        /* If the displayed stat is 18/220 this was just a guess.  */
+        /* The player still needs to take off some stuff to get the */
+        /* real value. */
+        if (borg_stat[i] < 238)
+        {
+            my_need_stat_check[i] = FALSE;
+        }
+
+        /* Hack -- save the maximum/current stats */
+#if 0
+        my_stat_cur[i] = value;
+#endif
+        my_stat_cur[i] = p_ptr->stat_cur[i];
+
+        /* Max stat is the max that the cur stat ever is. */
+        if (my_stat_cur[i] > my_stat_max[i])
+            my_stat_max[i] = my_stat_cur[i];
+
+    }
+}
+
+#ifndef BABLOS
+
+void borg_log_death(void)
+{
+   char buf[1024];
+   FILE *borg_log_file;
+   time_t death_time;
+
+#ifdef BORG_TK
+    path_build(buf, 1024, BORG_DIR_DATA, "borg-log.txt");
+#else /* BORG_TK */
+   path_build(buf, 1024, ANGBAND_DIR_USER, "borg-log.txt");
+#endif /* BORG_TK */
+
+   /* Hack -- drop permissions */
+   safe_setuid_drop();
+
+   /* Append to the file */
+   borg_log_file = my_fopen(buf, "a");
+
+    /* Hack -- grab permissions */
+   safe_setuid_grab();
+
+   /* Failure */
+   if (!borg_log_file) return;
+
+   /* Get time of death */
+   (void)time(&death_time);
+
+   /* Save the date */
+   strftime(buf, 80, "%Y/%m/%d %H:%M\n", localtime(&death_time));
+
+   fprintf(borg_log_file, buf);
+
+   fprintf(borg_log_file, "%s the %s %s, Level %d/%d\n", op_ptr->full_name,
+           p_name + p_info[p_ptr->prace].name,
+           c_name + c_info[p_ptr->pclass].name,
+           p_ptr->lev, p_ptr->max_lev);
+
+   fprintf(borg_log_file, "Exp: %lu  Gold: %lu  Turn: %lu\n", (long)total_points(), (long)p_ptr->au, (long)turn);
+   fprintf(borg_log_file, "Killed on level: %d (max. %d) by %s\n", p_ptr->depth, p_ptr->max_depth, p_ptr->died_from);
+
+   fprintf(borg_log_file, "Borg Compile Date: %s\n", borg_engine_date);
+
+   fprintf(borg_log_file, "----------\n\n");
+
+   my_fclose(borg_log_file);
+}
+
+#endif /* BABLOS */
+
+void borg_log_death_data(void)
+{
+   char buf[1024];
+    FILE *borg_log_file;
+   time_t death_time;
+
+#ifdef BORG_TK
+    path_build(buf, 1024, BORG_DIR_DATA, "borg.dat");
+#else /* BORG_TK */
+   path_build(buf, 1024, ANGBAND_DIR_USER, "borg.dat");
+#endif /* BORG_TK */
+
+   /* Hack -- drop permissions */
+   safe_setuid_drop();
+
+   /* Append to the file */
+  borg_log_file = my_fopen(buf, "a");
+
+    /* Hack -- grab permissions */
+   safe_setuid_grab();
+
+   /* Failure */
+   if (!borg_log_file) return;
+
+   /* Get time of death */
+   (void)time(&death_time);
+
+    /* dump stuff for easy import to database */
+   fprintf(borg_log_file, "%s, %s, %s, %d, %d, %s\n",borg_engine_date, p_name + p_info[p_ptr->prace].name,
+   c_name + c_info[p_ptr->pclass].name, p_ptr->lev, p_ptr->depth, p_ptr->died_from);
+
+   my_fclose(borg_log_file);
+}
+
+/*
+ * Think about the world and perform an action
+ *
+ * Check inventory/equipment/spells/panel once per "turn"
+ *
+ * Process "store" and other modes when necessary
+ *
+ * Note that the non-cheating "inventory" and "equipment" parsers
+ * will get confused by a "weird" situation involving an ant ("a")
+ * on line one of the screen, near the left, next to a shield, of
+ * the same color, and using --(-- the ")" symbol, directly to the
+ * right of the ant.  This is very rare, but perhaps not completely
+ * impossible.  I ignore this situation.  :-)
+ *
+ * The handling of stores is a complete and total hack, but seems
+ * to work remarkably well, considering... :-)  Note that while in
+ * a store, time does not pass, and most actions are not available,
+ * and a few new commands are available ("sell" and "purchase").
+ *
+ * Note the use of "cheat" functions to extract the current inventory,
+ * the current equipment, the current panel, and the current spellbook
+ * information.  These can be replaced by (very expensive) "parse"
+ * functions, which cause an insane amount of "screen flashing".
+ *
+ * Technically, we should attempt to parse all the messages that
+ * indicate that it is necessary to re-parse the equipment, the
+ * inventory, or the books, and only set the appropriate flags
+ * at that point.  This would not only reduce the potential
+ * screen flashing, but would also optimize the code a lot,
+ * since the "cheat_inven()" and "cheat_equip()" functions
+ * are expensive.  For paranoia, we could always select items
+ * and spells using capital letters, and keep a global verification
+ * buffer, and induce failure and recheck the inventory/equipment
+ * any time we get a mis-match.  We could even do some of the state
+ * processing by hand, for example, charge reduction and such.  This
+ * might also allow us to keep track of how long we have held objects,
+ * especially if we attempt to do "item tracking" in the inventory
+ * extraction code.
+ */
+static bool borg_think(void)
+{
+    int i;
+
+    byte t_a;
+
+    char buf[128];
+    static char svSavefile[1024];
+    static char svSavefile2[1024];
+    static bool justSaved = FALSE;
+
+
+    /*** Process inventory/equipment ***/
+
+    /* Cheat */
+    if (borg_do_equip)
+    {
+        /* Only do it once */
+        borg_do_equip = FALSE;
+
+        /* Cheat the "equip" screen */
+        borg_cheat_equip();
+
+        /* Done */
+        return (FALSE);
+    }
+
+    /* Cheat */
+    if (borg_do_inven)
+    {
+        /* Only do it once */
+        borg_do_inven = FALSE;
+
+        /* Cheat the "inven" screen */
+        borg_cheat_inven();
+
+        /* Done */
+        return (FALSE);
+    }
+
+    /* save now */
+    if (borg_save && borg_save_game())
+    {
+        /* Log */
+        borg_note("# Auto Save!");
+
+        borg_save = FALSE;
+
+        /* Create a scum file */
+        if (borg_skill[BI_CLEVEL] >= borg_dump_level ||
+            strstr(p_ptr->died_from, "starvation"))
+        {
+            memcpy(svSavefile, savefile, sizeof(savefile));
+            /* Process the player name */
+            for (i = 0; op_ptr->full_name[i]; i++)
+            {
+                char c = op_ptr->full_name[i];
+
+                /* No control characters */
+                if (iscntrl(c))
+                {
+                    /* Illegal characters */
+                    quit_fmt("Illegal control char (0x%02X) in player name", c);
+                }
+
+                /* Convert all non-alphanumeric symbols */
+                if (!isalpha(c) && !isdigit(c)) c = '_';
+
+                /* Build "file_name" */
+                svSavefile2[i] = c;
+            }
+            svSavefile2[i]  = 0;
+#ifdef BORG_TK
+             path_build(savefile, 1024, BORG_DIR_DATA, svSavefile2);
+#else /* BORG_TK */
+             path_build(savefile, 1024, ANGBAND_DIR_USER, svSavefile2);
+#endif /* BORG_TK */
+
+            justSaved = TRUE;
+        }
+        return (TRUE);
+    }
+    if (justSaved)
+    {
+        memcpy(savefile, svSavefile, sizeof(savefile));
+        borg_save_game();
+        justSaved = FALSE;
+        return (TRUE);
+    }
+
+#ifndef BORG_TK
+
+    /* Parse "equip" mode */
+    if ((0 == borg_what_text(0, 0, 10, &t_a, buf)) &&
+        (streq(buf, "(Equipment) ")))
+    {
+        /* Parse the "equip" screen */
+        borg_parse_equip();
+
+        /* Leave this mode */
+        borg_keypress(ESCAPE);
+
+        /* Done */
+        return (TRUE);
+    }
+
+
+    /* Parse "inven" mode */
+    if ((0 == borg_what_text(0, 0, 10, &t_a, buf)) &&
+        (streq(buf, "(Inventory) ")))
+    {
+        /* Parse the "inven" screen */
+        borg_parse_inven();
+
+        /* Leave this mode */
+        borg_keypress(ESCAPE);
+
+        /* Done */
+        return (TRUE);
+    }
+
+
+    /* Check "equip" */
+    if (borg_do_equip)
+    {
+        /* Only do it once */
+        borg_do_equip = FALSE;
+
+        /* Enter "equip" mode */
+        borg_keypress('e');
+
+        /* Done */
+        return (TRUE);
+    }
+
+    /* Check "inven" */
+    if (borg_do_inven)
+    {
+        /* Only do it once */
+        borg_do_inven = FALSE;
+
+        /* Enter "inven" mode */
+        borg_keypress('i');
+
+        /* Done */
+        return (TRUE);
+    }
+#endif /* not BORG_TK */
+
+    /*** Find books ***/
+
+    /* Only if needed */
+    if (borg_do_spell && (borg_do_spell_aux == 0))
+    {
+        /* Assume no books */
+        for (i = 0; i < 9; i++) borg_book[i] = -1;
+
+        /* Scan the pack */
+        for (i = 0; i < INVEN_PACK; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+            /* Skip non-books */
+            if (item->tval != cp_ptr->spell_book) continue;
+
+            /* Note book locations */
+            borg_book[item->sval] = i;
+        }
+    }
+
+    /*** Process books ***/
+
+    /* Hack -- Warriors never browse */
+    if (borg_class == CLASS_WARRIOR) borg_do_spell = FALSE;
+
+    /* Hack -- Blind or Confused prevents browsing */
+    if (borg_skill[BI_ISBLIND] || borg_skill[BI_ISCONFUSED]) borg_do_spell = FALSE;
+
+    /* XXX XXX XXX Dark */
+
+    /* Hack -- Stop doing spells when done */
+    if (borg_do_spell_aux > 8) borg_do_spell = FALSE;
+
+    /* Cheat */
+    if (borg_do_spell)
+    {
+        /* Look for the book */
+        i = borg_book[borg_do_spell_aux];
+
+        /* Cheat the "spell" screens (all of them) */
+        if (i >= 0)
+        {
+            /* Cheat that page */
+            borg_cheat_spell(borg_do_spell_aux);
+        }
+
+        /* Advance to the next book */
+        borg_do_spell_aux++;
+
+        /* Done */
+        return (FALSE);
+    }
+#ifndef BORG_TK
+    /* Check for "browse" mode */
+    if ((0 == borg_what_text(COL_SPELL, ROW_SPELL, -12, &t_a, buf)) &&
+        (streq(buf, "Lv Mana Fail")))
+    {
+        /* Parse the "spell" screen */
+        borg_parse_spell(borg_do_spell_aux);
+
+        /* Advance to the next book */
+        borg_do_spell_aux++;
+
+        /* Leave that mode */
+        borg_keypress(ESCAPE);
+
+        /* Done */
+        return (TRUE);
+    }
+    /* Check "spells" */
+    if (borg_do_spell)
+    {
+        /* Look for the book */
+        i = borg_book[borg_do_spell_aux];
+
+        /* Enter the "spell" screen */
+        if (i >= 0)
+        {
+            /* Enter "browse" mode */
+            borg_keypress('b');
+
+            /* Pick the next book */
+            borg_keypress(I2A(i));
+
+            /* Done */
+            return (TRUE);
+        }
+
+        /* Advance to the next book */
+        borg_do_spell_aux++;
+
+        /* Done */
+        return (FALSE);
+    }
+#endif /* not BORG_TK */
+    /* check for anything that needs *ID* */
+    if ( borg_do_star_id )
+    {
+        if (borg_object_star_id())
+        {
+
+           return (TRUE);
+        }
+        borg_do_star_id = FALSE;
+    }
+    /* If king, maybe retire. */
+    if (borg_skill[BI_KING])
+    {
+        /* Prepare to retire */
+        if (borg_stop_king)
+        {
+#ifndef BABLOS
+            borg_write_map(FALSE);
+#endif /* bablos */
+            borg_oops("retire");
+        }
+        /* Borg will be respawning */
+        if (borg_respawn_winners)
+        {
+#ifndef BABLOS
+            borg_write_map(FALSE);
+
+            /* Note the score */
+            borg_enter_score();
+
+            /* Write to log and borg.dat */
+            borg_log_death();
+            borg_log_death_data();
+
+            /* respawn */
+            resurrect_borg();
+#endif /* bablos */
+        }
+
+    }
+
+    /*** Handle stores ***/
+#ifdef BORG_TK
+
+    /* Hack -- Check for being in a store */
+    if (storedata.shopping)
+    {
+        /* Extract the "store" number */
+        shop_num = storedata.store_num;
+
+        /* Hack -- reset page/more */
+        borg_shops[shop_num].page = 0;
+        borg_shops[shop_num].more = 0;
+
+        /* Hack -- Reset food counter for money scumming */
+        /* I do not know how the tk borg will react to the second page.  It may clear this
+         * flag again to -1.  the non tk borg did this so I had to make a check to only
+         * clear this variable if the page was still page 0
+         */
+        if (shop_num == 0)
+        {
+			borg_food_onsale = 0;
+			borg_fuel_onsale = 0;
+		}
+
+        /* React to new stores */
+        if (borg_do_browse_what != shop_num)
+        {
+            /* Clear all the items */
+            for (i = 0; i < 24; i++)
+            {
+                /* XXX Wipe the ware */
+                WIPE(&borg_shops[shop_num].ware[i], borg_item);
+            }
+
+            /* Save the store */
+            borg_do_browse_what = shop_num;
+        }
+
+        /* Save the gold, if valid */
+        borg_gold = p_ptr->au;
+
+        /* Parse the store (or home) inventory */
+        for (i = 0; i < 24; i++)
+        {
+            int n;
+
+            char desc[80];
+            char cost[10];
+
+            /* Default to "empty" */
+            desc[0] = '\0';
+            cost[0] = '\0';
+
+            /* Extract actual index */
+            n = i;
+
+            /* Require real stock */
+            if (n < storedata.st_ptr->stock_num)
+            {
+                s32b x = 0;
+
+                char o_name[O_NAME_MAX];
+
+                /* Get the object */
+                object_type *o_ptr = &storedata.st_ptr->stock[n];
+
+                int maxwid = (shop_num == STORE_HOME) ? 75 : 65;
+
+                extern s32b price_item(object_type *o_ptr, int greed, bool flip);
+
+                /* Extract the item description */
+                object_desc_spoil(o_name, sizeof(o_ptr), o_ptr, TRUE, 3);
+                o_name[maxwid] = '\0';
+
+                (void) strncpy(desc, o_name, maxwid);
+
+                /* Extract the item cost in stores */
+
+                /* Display a "fixed" cost */
+                if (o_ptr->ident & (IDENT_FIXED))
+                {
+                    /* Extract the "minimum" price */
+                    x = price_item(o_ptr, storedata.ot_ptr->min_inflate, FALSE);
+                }
+
+                /* Display a "taxed" cost */
+           	    /* Extract the "minimum" price */
+           	    x = price_item(o_ptr, storedata.ot_ptr->min_inflate, FALSE);
+
+                (void) sprintf(cost, "%9ld", (long)x);
+            }
+
+            /* Ignore "unchanged" descriptions */
+            if (streq(desc, borg_shops[shop_num].ware[n].desc)) continue;
+
+            /* Analyze the item */
+            borg_item_analyze(&borg_shops[shop_num].ware[n], desc);
+
+            /*need to be able to analize the home inventory to see if it was */
+            /* *fully ID*d. */
+            /* This is a BIG CHEAT!  It will be less of a cheat if code is put*/
+            /* in place to allow 'I' in stores. */
+            if (storedata.st_ptr->stock[n].ident & IDENT_MENTAL)
+            {
+                /* XXX XXX XXX for now, allways cheat to get info on items at */
+                /*   home. */
+                borg_object_star_id_aux( &borg_shops[shop_num].ware[n],
+                                         &storedata.st_ptr->stock[n]);
+                borg_shops[shop_num].ware[n].fully_identified = TRUE;
+            }
+
+            /* hack -- see of store is selling food.  Needed for Money Scumming */
+            if (shop_num == 0 &&
+                borg_shops[shop_num].ware[n].tval == TV_FOOD &&
+                borg_shops[shop_num].ware[n].sval == SV_FOOD_RATION)
+            {
+                borg_food_onsale = borg_shops[shop_num].ware[n].iqty;
+            }
+
+            /* hack -- see of store is selling our fuel. */
+            if (shop_num == 0 &&
+                borg_shops[shop_num].ware[n].tval == TV_FLASK &&
+                borg_items[INVEN_LITE].sval == SV_LITE_LANTERN)
+            {
+                borg_fuel_onsale = borg_shops[shop_num].ware[n].iqty;
+            }
+
+            /* hack -- see of store is selling our fuel. */
+            if (shop_num == 0
+                borg_shops[shop_num].ware[n].tval == TV_LITE &&
+                borg_items[INVEN_LITE].sval == SV_LITE_TORCH)
+            {
+                borg_fuel_onsale = borg_shops[shop_num].ware[n].iqty;
+            }
+
+            /* Hack -- Save the declared cost */
+            borg_shops[shop_num].ware[n].cost = atol(cost);
+        }
+
+        /* Recheck inventory */
+        borg_do_inven = TRUE;
+
+        /* Recheck equipment */
+        borg_do_equip = TRUE;
+
+        /* Recheck spells */
+        borg_do_spell = TRUE;
+
+        /* Restart spells */
+        borg_do_spell_aux = 0;
+
+        /* Hack -- browse again later */
+        borg_do_browse = TRUE;
+
+        /* Examine the inventory */
+        borg_notice(TRUE);
+
+        /* Evaluate the current world */
+        my_power = borg_power();
+
+        /* Hack -- allow user abort */
+        if (borg_cancel) return (TRUE);
+
+        /* Think until done */
+        return (borg_think_store());
+    }
+
+    /*** Determine panel ***/
+
+    /* Hack -- cheat */
+    i = ((p_ptr->py - PANEL_HGT / 2) / PANEL_HGT) * PANEL_HGT;
+    if (i < 0) i = 0;
+    if (i > DUNGEON_HGT - SCREEN_HGT) i = DUNGEON_HGT - SCREEN_HGT;
+    w_y = i;
+
+    i = ((p_ptr->px - PANEL_WID / 2) / PANEL_WID) * PANEL_WID;
+    if (i < 0) i = 0;
+    if (i > DUNGEON_WID - SCREEN_WID) i = DUNGEON_WID - SCREEN_WID;
+    w_x = i;
+
+    /* Done */
+    borg_do_panel = FALSE;
+
+#else /* not BORG_TK */
+
+    /* Hack -- Check for being in a store */
+    if ((0 == borg_what_text(3, 5, 16, &t_a, buf)) &&
+        (streq(buf, "Item Description")))
+    {
+        /* Assume the Home */
+        shop_num = 7;
+
+        /* Clear the goal (the goal was probably going to a shop) */
+        goal = 0;
+
+        /* Extract the "store" name */
+        if (0 == borg_what_text(50, 3, -20, &t_a, buf))
+        {
+            int i;
+
+            /* Check the store names */
+            for (i = 0; i < (MAX_STORES ); i++)
+            {
+                cptr name = (f_name + f_info[0x08+i].name);
+                if (prefix(buf, name)) shop_num = i;
+            }
+        }
+
+        /* Hack -- reset page/more */
+        borg_shops[shop_num].page = 0;
+        borg_shops[shop_num].more = 0;
+
+        /* React to new stores */
+        if (borg_do_browse_what != shop_num)
+        {
+            /* Clear all the items */
+            for (i = 0; i < 24; i++)
+            {
+                /* XXX Wipe the ware */
+                WIPE(&borg_shops[shop_num].ware[i], borg_item);
+            }
+
+            /* Save the store */
+            borg_do_browse_what = shop_num;
+        }
+
+        /* Extract the "page", if any */
+        if ((0 == borg_what_text(20, 5, 8, &t_a, buf)) &&
+            (prefix(buf, "(Page "))) /* --)-- */
+        {
+            /* Take note of the page */
+            borg_shops[shop_num].page = (buf[6] - '0') - 1;
+            if (borg_shops[shop_num].page == 0 &&
+                (0 == borg_what_text(3, 18, 6, &t_a, buf)) &&
+                (prefix(buf, "-more-"))) /* --)-- */
+            {
+                borg_shops[shop_num].more = 1;
+                borg_do_browse = 1;
+            }
+            else
+            {
+                borg_shops[shop_num].more = 0;
+                borg_do_browse = 0;
+            }
+        }
+        else
+        {
+            /* Clear the second page */
+            for (i = 12; i < 24; i++)
+            {
+                /* XXX Wipe the ware */
+                WIPE(&borg_shops[shop_num].ware[i], borg_item);
+            }
+        }
+
+        /* Hack -- Reset food counter for money scumming */
+        if (shop_num == 0 && borg_shops[shop_num].page == 0) borg_food_onsale = 0;
+
+        /* Hack -- Reset fuel counter for money scumming */
+        if (shop_num == 0 && borg_shops[shop_num].page == 0) borg_fuel_onsale = 0;
+
+        /* Extract the current gold (unless in home) */
+        if (0 == borg_what_text(68, 19, -9, &t_a, buf))
+        {
+            /* Save the gold, if valid */
+            if (buf[0]) borg_gold = atol(buf);
+        }
+
+        /* Parse the store (or home) inventory */
+        for (i = 0; i < 12; i++)
+        {
+            int n;
+
+            char desc[80];
+            char cost[10];
+
+            /* Default to "empty" */
+            desc[0] = '\0';
+            cost[0] = '\0';
+
+            /* Extract actual index */
+            n = borg_shops[shop_num].page * 12 + i;
+
+            /* Verify "intro" to the item */
+            if ((0 == borg_what_text(0, i + 6, 3, &t_a, buf)) &&
+                (buf[0] == I2A(n)) && (buf[1] == p2) && (buf[2] == ' '))
+            {
+                int k;
+
+                /* Extract the item description */
+                if (0 != borg_what_text(3, i + 6, -65, &t_a, desc))
+                {
+                    desc[0] = '\0';
+                }
+
+                /* Strip trailing spaces */
+                for (k = strlen(desc); (k > 0) && (desc[k-1] == ' '); k--) /* loop */;
+                desc[k] = '\0';
+
+                /* Extract the item cost in stores */
+                if (shop_num != 7)
+                {
+                    if (0 != borg_what_text(68, i + 6, -9, &t_a, cost))
+                    {
+                        cost[0] = '\0';
+                    }
+                }
+            }
+
+#if 0
+            /* Ignore "unchanged" descriptions */
+            if (streq(desc, borg_shops[shop_num].ware[n].desc)) continue;
+#endif
+            /* Analyze the item */
+            borg_item_analyze(&borg_shops[shop_num].ware[n], desc);
+
+            /*need to be able to analize the home inventory to see if it was */
+            /* *fully ID*d. */
+            /* This is a BIG CHEAT!  It will be less of a cheat if code is put*/
+            /* in place to allow 'I' in stores. */
+            if (store[shop_num].stock[n].ident & IDENT_MENTAL)
+            {
+                /* XXX XXX XXX for now, allways cheat to get info on items at */
+                /*   home. */
+                borg_object_star_id_aux( &borg_shops[shop_num].ware[n],
+                                         &store[shop_num].stock[n]);
+                borg_shops[shop_num].ware[n].fully_identified = TRUE;
+            }
+
+            /* hack -- see of store is selling food.  Needed for Money Scumming */
+            if (shop_num == 0 &&
+                borg_shops[shop_num].ware[n].tval == TV_FOOD &&
+                borg_shops[shop_num].ware[n].sval == SV_FOOD_RATION)
+            {
+                borg_food_onsale = borg_shops[shop_num].ware[n].iqty;
+            }
+
+            /* hack -- see of store is selling our fuel. */
+            if (shop_num == 0 &&
+                borg_shops[shop_num].ware[n].tval == TV_FLASK &&
+                borg_items[INVEN_LITE].sval == SV_LITE_LANTERN)
+            {
+                borg_fuel_onsale = borg_shops[shop_num].ware[n].iqty;
+            }
+
+            /* hack -- see of store is selling our fuel. */
+            if (shop_num == 0 &&
+                borg_shops[shop_num].ware[n].tval == TV_LITE &&
+                borg_items[INVEN_LITE].sval == SV_LITE_TORCH)
+            {
+                borg_fuel_onsale = borg_shops[shop_num].ware[n].iqty;
+            }
+
+            /* Hack -- Save the declared cost */
+            borg_shops[shop_num].ware[n].cost = atol(cost);
+        }
+
+        /* Hack -- browse as needed */
+        if (borg_shops[shop_num].more && borg_do_browse)
+        {
+            /* Check next page */
+            borg_keypress(' ');
+
+            /* Done browsing */
+            borg_do_browse = FALSE;
+
+            /* Done */
+            return (TRUE);
+        }
+
+        /* Recheck inventory */
+        borg_do_inven = TRUE;
+
+        /* Recheck equipment */
+        borg_do_equip = TRUE;
+
+        /* Recheck spells */
+        borg_do_spell = TRUE;
+
+        /* Restart spells */
+        borg_do_spell_aux = 0;
+
+        /* Hack -- browse again later */
+        borg_do_browse = TRUE;
+
+        /* Examine the inventory */
+        borg_notice(TRUE);
+
+        /* Evaluate the current world */
+        my_power = borg_power();
+
+        /* Hack -- allow user abort */
+        if (borg_cancel) return (TRUE);
+
+        /* Think until done */
+        return (borg_think_store());
+    }
+
+
+    /*** Determine panel ***/
+
+    /* Hack -- cheat */
+    w_y = Term->offset_y;
+    w_x = Term->offset_x;
+
+    /* Done */
+    borg_do_panel = FALSE;
+
+    /* Hack -- Check for "sector" mode */
+    if ((0 == borg_what_text(0, 0, 16, &t_a, buf)) &&
+        (prefix(buf, "Map sector ")))
+    {
+        /* Hack -- get the panel info */
+        w_y = (buf[12] - '0') * (SCREEN_HGT / 2);
+        w_x = (buf[14] - '0') * (SCREEN_WID / 2);
+
+        /* Leave panel mode */
+        borg_keypress(ESCAPE);
+
+        /* Done */
+        return (TRUE);
+    }
+    /* Check equipment */
+    if (borg_do_panel)
+    {
+        /* Only do it once */
+        borg_do_panel = FALSE;
+
+        /* Enter "panel" mode */
+        borg_keypress('L');
+
+        /* Done */
+        return (TRUE);
+    }
+#endif /* not BORG_TK */
+
+    /*** Analyze the Frame ***/
+
+    /* Analyze the frame */
+    if (borg_do_frame)
+    {
+        /* Only once */
+        borg_do_frame = FALSE;
+
+        /* Analyze the "frame" */
+        borg_update_frame();
+    }
+
+    /*** Re-activate Tests ***/
+
+    /* Check equip again later */
+    borg_do_equip = TRUE;
+
+    /* Check inven again later */
+    borg_do_inven = TRUE;
+
+    /* Check panel again later */
+    borg_do_panel = TRUE;
+
+    /* Check frame again later */
+    borg_do_frame = TRUE;
+
+    /* Check spells again later */
+    borg_do_spell = TRUE;
+
+    /* Hack -- Start the books over */
+    borg_do_spell_aux = 0;
+
+
+    /*** Analyze status ***/
+
+    /* Track best level */
+    if (borg_skill[BI_CLEVEL] > borg_skill[BI_MAXCLEVEL]) borg_skill[BI_MAXCLEVEL] = borg_skill[BI_CLEVEL];
+    if (borg_skill[BI_CDEPTH] > borg_skill[BI_MAXDEPTH])
+    {
+        borg_skill[BI_MAXDEPTH] = borg_skill[BI_CDEPTH];
+    }
+
+    /*** Think about it ***/
+
+    /* Increment the clock */
+    borg_t++;
+
+    /* Increment the panel clock */
+    time_this_panel++;
+
+    /* Examine the screen */
+    borg_update();
+    /* Extract some "hidden" variables */
+    borg_hidden();
+    /* Examine the equipment/inventory */
+    borg_notice(TRUE);
+    /* Evaluate the current world */
+    my_power = borg_power();
+
+    /* Hack -- allow user abort */
+    if (borg_cancel) return (TRUE);
+
+    /* Do something */
+    return (borg_think_dungeon());
+}
+
+
+
+/*
+ * Hack -- methods of hurting a monster (order not important).
+ *
+ * See "message_pain()" for details.
+ */
+static cptr suffix_pain[] =
+{
+    " is unharmed."
+    " barely notices.",
+    " flinches.",
+    " squelches.",
+    " quivers in pain.",
+    " writhes about.",
+    " writhes in agony.",
+    " jerks limply.",
+
+    " spawns!",
+    " looks healthier.",
+    " starts moving faster.",
+    " starts moving slower.",
+
+    " is unaffected!",
+    " is immune.",
+    " resists a lot.",
+    " resists.",
+    " resists somewhat.",
+
+    " shrugs off the attack.",
+    " snarls with pain.",
+    " yelps in pain.",
+    " howls in pain.",
+    " howls in agony.",
+    /* xxx */
+    " yelps feebly.",
+
+    " ignores the attack.",
+    " grunts with pain.",
+    " squeals in pain.",
+    " shrieks in pain.",
+    " shrieks in agony.",
+    /* xxx */
+    " cries out feebly.",
+
+    /* xxx */
+    /* xxx */
+    " cries out in pain.",
+    " screams in pain.",
+    " screams in agony.",
+    /* xxx */
+    " cringes from the light!",
+    " loses some skin!",
+
+    " is hit hard.",
+
+    NULL
+};
+
+
+/*
+ * Hack -- methods of killing a monster (order not important).
+ *
+ * See "mon_take_hit()" for details.
+ */
+static cptr prefix_kill[] =
+{
+    "You have killed ",
+    "You have slain ",
+    "You have destroyed ",
+    NULL
+};
+
+
+/*
+ * Hack -- methods of monster death (order not important).
+ *
+ * See "project_m()", "do_cmd_fire()", "mon_take_hit()" for details.
+ */
+static cptr suffix_died[] =
+{
+    " dies.",
+    " is destroyed.",
+    " dissolves!",
+    " shrivels away in the light!",
+    NULL
+};
+static cptr suffix_blink[] =
+{
+    " disappears!",      /* from teleport other */
+    " changes!",         /* from polymorph spell */
+    " teleports away.",  /* RF6_TPORT */
+    " blinks away.",                /* RF6_BLINK */
+    NULL
+};
+
+/*
+ * Hack -- methods of hitting the player (order not important).
+ *
+ * The "insult", "moan", and "begs you for money" messages are ignored.
+ *
+ * See "make_attack_normal()" for details.
+ */
+static cptr suffix_hit_by[] =
+{
+    " hits you.",
+    " touches you.",
+    " punches you.",
+    " kicks you.",
+    " claws you.",
+    " bites you.",
+    " stings you.",
+    " butts you.",
+    " crushes you.",
+    " engulfs you.",
+    " crawls on you.",
+    " drools on you.",
+    " spits on you.",
+    " gazes at you.",
+    " wails at you.",
+    " releases spores at you.",
+    NULL
+};
+
+
+/*
+ * Hack -- methods of casting spells at the player (order important).
+ *
+ * See "make_attack_spell()" for details.
+ */
+/* AJG These had gotten out of synch with where they are used. */
+static cptr suffix_spell[] =
+{
+    " makes a high pitched shriek.",        /* 0 RF4_SHRIEK */
+    " tries to cast a spell, but fails.",   /* 1 RF4_FAILS */
+    " does something.",                     /* 2 RF4_XXX3X4 */
+    " does something.",                     /* 3 RF4_XXX4X4 */
+    " fires an arrow.",                     /* 4 RF4_ARROW_1 */
+    " fires an arrow!",                     /* 5 RF4_ARROW_2 */
+    " fires a missile.",                    /* 6 RF4_ARROW_3 */
+    " fires a missile!",                    /* 7 RF4_ARROW_4 */
+    " breathes acid.",                      /* 8 RF4_BR_ACID */
+    " breathes lightning.",                 /* 9 RF4_BR_ELEC */
+    " breathes fire.",                      /*10 RF4_BR_FIRE */
+    " breathes frost.",                     /*11 RF4_BR_COLD */
+    " breathes gas.",                       /*12 RF4_BR_POIS */
+    " breathes nether.",                    /*13 RF4_BR_NETH */
+    " breathes light.",                     /*14 RF4_BR_LITE */
+    " breathes darkness.",                  /*15 RF4_BR_DARK */
+    " breathes confusion.",                 /*16 RF4_BR_CONF */
+    " breathes sound.",                     /*17 RF4_BR_SOUN */
+    " breathes chaos.",                     /*18 RF4_BR_CHAO */
+    " breathes disenchantment.",            /*19 RF4_BR_DISE */
+    " breathes nexus.",                     /*20 RF4_BR_NEXU */
+    " breathes time.",                      /*21 RF4_BR_TIME */
+    " breathes inertia.",                   /*22 RF4_BR_INER */
+    " breathes gravity.",                   /*23 RF4_BR_GRAV */
+    " breathes shards.",                    /*24 RF4_BR_SHAR */
+    " breathes plasma.",                    /*25 RF4_BR_PLAS */
+    " breathes force.",                     /*26 RF4_BR_WALL */
+    " does something.",                     /*27 RF4_BR_MANA */
+    " does something.",                     /*28 RF4_XXX5X4 */
+    " does something.",                     /*29 RF4_XXX6X4 */
+    " does something.",                     /*30 RF4_XXX7X4 */
+    " hurls a boulder at you!",             /*31 RF4_BOULDER */
+    " casts an acid ball.",                 /*32 RF5_BA_ACID */
+    " casts a lightning ball.",             /*33 RF5_BA_ELEC */
+    " casts a fire ball.",                  /*34 RF5_BA_FIRE */
+    " casts a frost ball.",                 /*35 RF5_BA_COLD */
+    " casts a stinking cloud.",             /*36 RF5_BA_POIS */
+    " casts a nether ball.",                /*37 RF5_BA_NETH */
+    " gestures fluidly.",                   /*38 RF5_BA_WATE */
+    " invokes a mana storm.",               /*39 RF5_BA_MANA */
+    " invokes a darkness storm.",           /*40 RF5_BA_DARK */
+    " draws psychic energy from you!",      /*41 RF5_DRAIN_MANA */
+    " gazes deep into your eyes.",          /*42 RF5_MIND_BLAST */
+    " looks deep into your eyes.",          /*43 RF5_BRAIN_SMASH */
+    " points at you and curses.",           /*44 RF5_CAUSE_1 */
+    " points at you and curses horribly.",  /*45 RF5_CAUSE_2 */
+    " points at you, incanting terribly!",  /*46 RF5_CAUSE_3 */
+    " points at you, screaming the word DIE!",  /*47 RF5_CAUSE_4 */
+    " casts a acid bolt.",                  /*48 RF5_BO_ACID */
+    " casts a lightning bolt.",             /*49 RF5_BO_ELEC */
+    " casts a fire bolt.",                  /*50 RF5_BO_FIRE */
+    " casts a frost bolt.",                 /*51 RF5_BO_COLD */
+    " does something.",                     /*52 RF5_BO_POIS */
+    " casts a nether bolt.",                /*53 RF5_BO_NETH */
+    " casts a water bolt.",                 /*54 RF5_BO_WATE */
+    " casts a mana bolt.",                  /*55 RF5_BO_MANA */
+    " casts a plasma bolt.",                /*56 RF5_BO_PLAS */
+    " casts an ice bolt.",                  /*57 RF5_BO_ICEE */
+    " casts a magic missile.",              /*58 RF5_MISSILE */
+    " casts a fearful illusion.",           /*59 RF5_SCARE */
+    " casts a spell, burning your eyes!",   /*60 RF5_BLIND */
+    " creates a mesmerising illusion.",     /*61 RF5_CONF */
+    " drains power from your muscles!",     /*62 RF5_SLOW */
+    " stares deep into your eyes!",         /*63 RF5_HOLD */
+    " concentrates on XXX body.",           /*64 RF6_HASTE */
+    " does something.",                     /*65 RF6_XXX1X6 */
+    " concentrates on XXX wounds.",         /*66 RF6_HEAL */
+    " does something.",                     /*67 RF6_XXX2X6 */
+    " does something.",                     /*68 RF6_XXX3X6 */
+    " does something.",                     /*69 RF6_XXX4X6 */
+    " commands you to return.",             /*70 RF6_TELE_TO */
+    " teleports you away.",                 /*71 RF6_TELE_AWAY */
+    " gestures at your feet.",              /*72 RF6_TELE_LEVEL */
+    " does something.",                     /*73 RF6_XXX5 */
+    " gestures in shadow.",                 /*74 RF6_DARKNESS */
+    " casts a spell and cackles evilly.",   /*75 RF6_TRAPS */
+    " tries to blank your mind.",           /*76 RF6_FORGET */
+    " does something.",                     /*77 RF6_XXX6X6 */
+    " does something.",                     /*78 RF6_XXX7X6 */
+    " does something.",                     /*79 RF6_XXX8X6 */
+    " magically summons help!",             /*80 RF6_S_MONSTER */
+    " magically summons monsters!",         /*81 RF6_S_MONSTERS */
+    " magically summons animals.",             /*82 RF6_S_ANIMAL */
+    " magically summons spiders.",          /*83 RF6_S_SPIDER */
+    " magically summons hounds.",           /*84 RF6_S_HOUND */
+    " magically summons hydras.",           /*85 RF6_S_HYDRA */
+    " magically summons an angel!",         /*86 RF6_S_ANGEL */
+    " magically summons a hellish adversary!",  /*87 RF6_S_DEMON */
+    " magically summons an undead adversary!",  /*88 RF6_S_UNDEAD */
+    " magically summons a dragon!",         /*89 RF6_S_DRAGON */
+    " magically summons greater undead!",   /*90 RF6_S_HI_UNDEAD */
+    " magically summons ancient dragons!",  /*91 RF6_S_HI_DRAGON */
+    " magically summons mighty undead opponents!",  /*92 RF6_S_WRAITH */
+    " magically summons special opponents!",        /*93 RF6_S_UNIQUE */
+
+    NULL
+};
+
+
+
+#if 0
+/* XXX XXX XXX */
+msg_format("%^s looks healthier.", m_name);
+msg_format("%^s looks REALLY healthy!", m_name);
+#endif
+
+
+
+/*
+ * Hack -- Spontaneous level feelings (order important).
+ *
+ * See "do_cmd_feeling()" for details.
+ */
+static cptr prefix_feeling[] =
+{
+    "Looks like any other level",
+    "You feel there is something special",
+    "You have a superb feeling",
+    "You have an excellent feeling",
+    "You have a very good feeling",
+    "You have a good feeling",
+    "You feel strangely lucky",
+    "You feel your luck is turning",
+    "You like the look of this place",
+    "This level can't be all bad",
+    "What a boring place",
+    NULL
+};
+
+
+
+/*
+ * Hack -- Parse a message from the world
+ *
+ * Note that detecting "death" is EXTREMELY important, to prevent
+ * all sorts of errors arising from attempting to parse the "tomb"
+ * screen, and to allow the user to "observe" the "cause" of death.
+ *
+ * Note that detecting "failure" is EXTREMELY important, to prevent
+ * bizarre situations after failing to use a staff of perceptions,
+ * which would otherwise go ahead and send the "item index" which
+ * might be a legal command (such as "a" for "aim").  This method
+ * is necessary because the Borg cannot parse "prompts", and must
+ * assume the success of the prompt-inducing command, unless told
+ * otherwise by a failure message.  Also, we need to detect failure
+ * because some commands, such as detection spells, need to induce
+ * furthur processing if they succeed, but messages are only given
+ * if the command fails.
+ *
+ * Note that certain other messages may contain useful information,
+ * and so they are "analyzed" and sent to "borg_react()", which just
+ * queues the messages for later analysis in the proper context.
+ *
+ * Along with the actual message, we send a special formatted buffer,
+ * containing a leading "opcode", which may contain extra information,
+ * such as the index of a spell, and an "argument" (for example, the
+ * capitalized name of a monster), with a "colon" to separate them.
+ *
+ * XXX XXX XXX Several message strings take a "possessive" of the form
+ * "his" or "her" or "its".  These strings are all represented by the
+ * encoded form "XXX" in the various match strings.  Unfortunately,
+ * the encode form is never decoded, so the Borg currently ignores
+ * messages about several spells (heal self and haste self).
+ *
+ * XXX XXX XXX We notice a few "terrain feature" messages here so
+ * we can acquire knowledge about wall types and door types.
+ */
+static void borg_parse_aux(cptr msg, int len)
+{
+    int i, tmp;
+
+	int y9;
+	int x9;
+ 	int ax,ay;
+	int d;
+
+    char who[256];
+    char buf[256];
+
+    borg_grid *ag = &borg_grids[g_y][g_x];
+
+    /* Log (if needed) */
+    if (borg_fff) borg_info(format("& Msg <%s>", msg));
+
+    /* Hack -- Notice death */
+    if (prefix(msg, "You die."))
+    {
+        /* Abort (unless cheating) */
+        if (!(p_ptr->wizard || cheat_live))
+        {
+            /* Abort */
+            borg_oops("death");
+
+            /* Abort right now! */
+            borg_active = FALSE;
+#ifndef BORG_TK
+            /* Noise XXX XXX XXX */
+            Term_xtra(TERM_XTRA_NOISE, 1);
+#endif /* BORG_TK */
+        }
+
+        /* Done */
+        return;
+    }
+
+
+    /* Hack -- Notice "failure" */
+    if (prefix(msg, "You failed "))
+    {
+        /* Hack -- store the keypress */
+        borg_note("# Normal failure.");
+
+        /* Set the failure flag */
+        borg_failure = TRUE;
+
+        /* Flush our key-buffer */
+        borg_flush();
+
+        /* If we were casting a targetted spell and failed */
+        /* it does not mean we can't target that location */
+        successful_target = 0;
+
+        /* Incase we failed our emergency use of MM */
+        borg_confirm_target = FALSE;
+
+        /* Check to see if it was a door then convert it */
+        if (ag->feat == FEAT_DOOR_HEAD)
+        {
+            /* What is my chance of opening the door? */
+            if (borg_skill[BI_DIS] < 20)
+            {
+                /* Set door as jammed, then bash it */
+                ag->feat = FEAT_DOOR_HEAD + 0x08;
+            }
+        }
+
+        /* check for glyphs since we no longer have a launch message */
+        if (borg_casted_glyph)
+        {
+            /* Forget the newly created-though-failed  glyph */
+            track_glyph_num --;
+            track_glyph_x[track_glyph_num] = 0;
+            track_glyph_y[track_glyph_num] = 0;
+            borg_note("# Removing glyph from array,");
+            borg_casted_glyph = FALSE;
+        }
+
+        /* Incase it was a Resistance refresh */
+        if (borg_attempting_refresh_resist)
+        {
+            if (borg_resistance > 1) borg_resistance -=25000;
+            borg_attempting_refresh_resist = FALSE;
+        }
+
+        return;
+
+    }
+
+
+    /* Ignore teleport trap */
+    if (prefix(msg, "You hit a teleport")) return;
+
+    /* Ignore arrow traps */
+    if (prefix(msg, "An arrow ")) return;
+
+    /* Ignore dart traps */
+    if (prefix(msg, "A small dart ")) return;
+
+    if (prefix(msg, "The cave "))
+    {
+        borg_react(msg, "QUAKE");
+        borg_needs_new_sea = TRUE;
+        return;
+    }
+
+    if (prefix(msg, "Welcome to level "))
+    {
+        if (!borg_skill[BI_ISFIXLEV]) borg_log_event(format("Level up (%d)",p_ptr->lev));
+        return;
+    }
+
+    /* need to check stat */
+    if (prefix(msg, "You feel very") ||
+        prefix(msg, "You feel less") ||
+        prefix(msg, "Wow!  You feel very"))
+    {
+        /* need to check str */
+        if (prefix(msg, "You feel very weak"))
+        {
+            my_need_stat_check[0] = TRUE;
+        }
+        if (prefix(msg, "You feel less weak"))
+        {
+            my_need_stat_check[0] = TRUE;
+        }
+        if (prefix(msg, "Wow!  You feel very strong"))
+        {
+            my_need_stat_check[0] = TRUE;
+        }
+
+        /* need to check int */
+        if (prefix(msg, "You feel very stupid"))
+        {
+            my_need_stat_check[1] = TRUE;
+        }
+        if (prefix(msg, "You feel less stupid"))
+        {
+            my_need_stat_check[1] = TRUE;
+        }
+        if (prefix(msg, "Wow!  You feel very smart"))
+        {
+            my_need_stat_check[1] = TRUE;
+        }
+
+        /* need to check wis */
+        if (prefix(msg, "You feel very naive"))
+        {
+            my_need_stat_check[2] = TRUE;
+        }
+        if (prefix(msg, "You feel less naive"))
+        {
+            my_need_stat_check[2] = TRUE;
+        }
+        if (prefix(msg, "Wow!  You feel very wise"))
+        {
+            my_need_stat_check[2] = TRUE;
+        }
+
+        /* need to check dex */
+        if (prefix(msg, "You feel very clumsy"))
+        {
+            my_need_stat_check[3] = TRUE;
+        }
+        if (prefix(msg, "You feel less clumsy"))
+        {
+            my_need_stat_check[3] = TRUE;
+        }
+        if (prefix(msg, "Wow!  You feel very dextrous"))
+        {
+            my_need_stat_check[3] = TRUE;
+        }
+
+        /* need to check con */
+        if (prefix(msg, "You feel very sickly"))
+        {
+            my_need_stat_check[4] = TRUE;
+        }
+        if (prefix(msg, "You feel less sickly"))
+        {
+            my_need_stat_check[4] = TRUE;
+        }
+        if (prefix(msg, "Wow!  You feel very healthy"))
+        {
+            my_need_stat_check[4] = TRUE;
+        }
+
+        /* need to check cha */
+        if (prefix(msg, "You feel very ugly"))
+        {
+            my_need_stat_check[5] = TRUE;
+        }
+        if (prefix(msg, "You feel less ugly"))
+        {
+            my_need_stat_check[5] = TRUE;
+        }
+        if (prefix(msg, "Wow!  You feel very cute"))
+        {
+            my_need_stat_check[5] = TRUE;
+        }
+    }
+
+    /* time attacks, just do all stats. */
+    if (prefix(msg, "You're not as"))
+    {
+        my_need_stat_check[0] = TRUE;
+        my_need_stat_check[1] = TRUE;
+        my_need_stat_check[2] = TRUE;
+        my_need_stat_check[3] = TRUE;
+        my_need_stat_check[4] = TRUE;
+        my_need_stat_check[5] = TRUE;
+    }
+
+    /* Nexus attacks, need to check everything! */
+    if (prefix(msg, "Your body starts to scramble..."))
+    {
+        my_need_stat_check[0] = TRUE;
+        my_need_stat_check[1] = TRUE;
+        my_need_stat_check[2] = TRUE;
+        my_need_stat_check[3] = TRUE;
+        my_need_stat_check[4] = TRUE;
+        my_need_stat_check[5] = TRUE;
+
+        /* max stats may have lowered */
+        my_stat_max[0] = 0;
+        my_stat_max[1] = 0;
+        my_stat_max[2] = 0;
+        my_stat_max[3] = 0;
+        my_stat_max[4] = 0;
+        my_stat_max[5] = 0;
+
+    }
+
+    /* A bug in the 280 game fails to inscribe {empty} on a staff-wand after
+     * being hit by amnesia (if the item had a sale inscription).
+     * So we will try to use the wand, see that it is empty then inscribe
+     * it ourselves.
+     */
+    if (prefix(msg, "The wand has no charges left") ||
+        prefix(msg, "The staff has no charges left"))
+    {
+        /* make the inscription */
+#if 0
+        /* not needed in 285,  the game bug was fixed. */
+        borg_keypress('{');
+        borg_keypress(I2A(zap_slot));
+
+        /* "you inscribe the " */
+        borg_keypress('e');
+        borg_keypress('m');
+        borg_keypress('p');
+        borg_keypress('t');
+        borg_keypress('y');
+        borg_keypress('\n');
+
+        /* done */
+#endif
+    }
+    /* amnesia attacks, re-id wands, staves, equipment. */
+    if (prefix(msg, "Your memories fade"))
+    {
+        int i;
+
+        /* I was hit by amnesia, forget things */
+        /* forget equipment */
+        /* Look for an item to forget (equipment) */
+        for (i = INVEN_WIELD; i <= INVEN_FEET; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+            /* Skip empty items */
+            if (!item->iqty) continue;
+
+            /* Skip known items */
+            if (item->fully_identified) continue;
+
+            /* skip certain easy know items */
+            if ((item->tval == TV_RING) &&
+                ((item->sval == SV_RING_FREE_ACTION) ||
+                 (item->sval == SV_RING_SEE_INVIS) ||
+                 (item->sval <= SV_RING_SUSTAIN_CHR))) continue;
+
+            /* skip already forgotten or non id'd items */
+            if (!item->able) continue;
+
+            /* forget it */
+            item->able = FALSE;
+
+            /* note the forgeting */
+            borg_note(format("Borg 'forgetting' qualities of %s",item->desc));
+
+        }
+
+        /* Look for an item to forget (inventory) */
+        for (i = 0; i <= INVEN_PACK; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+            /* Skip empty items */
+            if (!item->iqty) continue;
+
+            /* skip certain easy know items */
+            if ((item->tval == TV_RING) &&
+                (item->flags3 & TR3_EASY_KNOW)) continue;
+
+            if (item->fully_identified) continue;
+
+            switch (item->tval)
+            {
+                /* forget wands, staffs, weapons, armour */
+                case TV_WAND:
+                case TV_STAFF:
+                case TV_ROD:
+                case TV_RING:
+                case TV_AMULET:
+                case TV_LITE:
+                case TV_SHOT:
+                case TV_ARROW:
+                case TV_BOLT:
+                case TV_BOW:
+                case TV_DIGGING:
+                case TV_HAFTED:
+                case TV_POLEARM:
+                case TV_SWORD:
+                case TV_BOOTS:
+                case TV_GLOVES:
+                case TV_HELM:
+                case TV_CROWN:
+                case TV_SHIELD:
+                case TV_CLOAK:
+                case TV_SOFT_ARMOR:
+                case TV_HARD_ARMOR:
+                case TV_DRAG_ARMOR:
+                break;
+
+                default:
+                    continue;
+            }
+                /* forget it */
+                item->able = FALSE;
+
+                /* note the forgetting */
+                borg_note(format("Borg 'forgetting' qualities of %s",item->desc));
+         }
+    }
+
+    if (streq(msg, "You have been knocked out."))
+    {
+        borg_note("Ignoring Messages While KO'd");
+        borg_dont_react = TRUE;
+    }
+    if (streq(msg, "You are paralyzed"))
+    {
+        borg_note("Ignoring Messages While Paralyzed");
+        borg_dont_react = TRUE;
+    }
+
+    /* Hallucination -- Open */
+    if (streq(msg, "You feel drugged!"))
+    {
+        borg_note("# Hallucinating.  Special control of wanks.");
+        borg_skill[BI_ISIMAGE] = TRUE;
+    }
+
+    /* Hallucination -- Close */
+    if (streq(msg, "You can see clearly again."))
+    {
+        borg_note("# Hallucination ended.  Normal control of wanks.");
+        borg_skill[BI_ISIMAGE] = FALSE;
+    }
+
+    /* Hit somebody */
+    if (prefix(msg, "You hit "))
+    {
+        tmp = strlen("You hit ");
+        strnfmt(who, 1 + len - (tmp + 1), "%s", msg + tmp);
+        strnfmt(buf, 256, "HIT:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* Miss somebody */
+    if (prefix(msg, "You miss "))
+    {
+        tmp = strlen("You miss ");
+        strnfmt(who, 1 + len - (tmp + 1), "%s", msg + tmp);
+        strnfmt(buf, 256, "MISS:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* Miss somebody (because of fear) */
+    if (prefix(msg, "You are too afraid to attack "))
+    {
+        tmp = strlen("You are too afraid to attack ");
+        strnfmt(who, 1 + len - (tmp + 1), "%s", msg + tmp);
+        strnfmt(buf, 256, "MISS:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+	/* "Your <equipment> is unaffected!"
+	 * Note that this check must be before the suffix_pain
+	 * because suffix_pain will look for 'is unaffected!' and
+	 * assume it is talking about a monster which in turn will
+	 * yeild to the Player Ghost being created.
+	 */
+	if (prefix(msg, "Your "))
+	{
+		if (suffix(msg, " is unaffected!"))
+	  	{
+			/* Your equipment ignored the attack.
+			 * Ignore the message
+			 */
+ 		 	return;
+	 	}
+	}
+
+    /* "It screams in pain." (etc) */
+    for (i = 0; suffix_pain[i]; i++)
+    {
+        /* "It screams in pain." (etc) */
+        if (suffix(msg, suffix_pain[i]))
+        {
+            tmp = strlen(suffix_pain[i]);
+            strnfmt(who, 1 + len - tmp, "%s", msg);
+            strnfmt(buf, 256, "PAIN:%^s", who);
+            borg_react(msg, buf);
+            return;
+        }
+    }
+
+
+    /* "You have killed it." (etc) */
+    for (i = 0; prefix_kill[i]; i++)
+    {
+        /* "You have killed it." (etc) */
+        if (prefix(msg, prefix_kill[i]))
+        {
+            tmp = strlen(prefix_kill[i]);
+            strnfmt(who, 1 + len - (tmp + 1), "%s", msg + tmp);
+            strnfmt(buf, 256, "KILL:%^s", who);
+            borg_react(msg, buf);
+            return;
+        }
+    }
+
+
+    /* "It dies." (etc) */
+    for (i = 0; suffix_died[i]; i++)
+    {
+		/* "It dies." (etc) */
+        if (suffix(msg, suffix_died[i]))
+        {
+            tmp = strlen(suffix_died[i]);
+            strnfmt(who, 1 + len - tmp, "%s", msg);
+            strnfmt(buf, 256, "DIED:%^s", who);
+            borg_react(msg, buf);
+            return;
+        }
+    }
+
+    /* "It blinks or telports." (etc) */
+    for (i = 0; suffix_blink[i]; i++)
+    {
+        /* "It teleports." (etc) */
+        if (suffix(msg, suffix_blink[i]))
+        {
+            tmp = strlen(suffix_blink[i]);
+            strnfmt(who, 1 + len - tmp, "%s", msg);
+            strnfmt(buf, 256, "BLINK:%^s", who);
+            borg_react(msg, buf);
+            return;
+        }
+    }
+
+    /* "It misses you." */
+    if (suffix(msg, " misses you."))
+    {
+        tmp = strlen(" misses you.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "MISS_BY:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* "It is repelled.." */
+    /* treat as a miss */
+    if (suffix(msg, " is repelled."))
+    {
+        tmp = strlen(" is repelled.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "MISS_BY:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* "It hits you." (etc) */
+    for (i = 0; suffix_hit_by[i]; i++)
+    {
+        /* "It hits you." (etc) */
+        if (suffix(msg, suffix_hit_by[i]))
+        {
+            tmp = strlen(suffix_hit_by[i]);
+            strnfmt(who, 1 + len - tmp, "%s", msg);
+            strnfmt(buf, 256, "HIT_BY:%^s", who);
+            borg_react(msg, buf);
+
+            /* If I was hit, then I am not on a glyph */
+            if (track_glyph_num)
+            {
+                /* erase them all and
+                 * allow the borg to scan the screen and rebuild the array.
+                 * He won't see the one under him though.  So a special check
+                 * must be made.
+                 */
+                byte feat = cave_feat[c_y][c_x];
+
+                 /* Remove the entire array */
+                 for (i = 0; i < track_glyph_num; i++)
+                 {
+                     /* Stop if we already new about this glyph */
+                     track_glyph_x[i] = 0;
+                     track_glyph_y[i] = 0;
+                 }
+                 track_glyph_num = 0;
+
+                /* Check for glyphs under player -- Cheat*/
+                if (feat == FEAT_GLYPH)
+                {
+                    track_glyph_x[track_glyph_num] = c_x;
+                    track_glyph_y[track_glyph_num] = c_y;
+                    track_glyph_num++;
+                }
+            }
+            return;
+        }
+    }
+
+
+    /* "It casts a spell." (etc) */
+    for (i = 0; suffix_spell[i]; i++)
+    {
+        /* "It casts a spell." (etc) */
+        if (suffix(msg, suffix_spell[i]))
+        {
+            tmp = strlen(suffix_spell[i]);
+            strnfmt(who, 1 + len - tmp, "%s", msg);
+            strnfmt(buf, 256, "SPELL_%03d:%^s", i, who);
+            borg_react(msg, buf);
+            return;
+        }
+    }
+
+
+    /* State -- Asleep */
+    if (suffix(msg, " falls asleep!"))
+    {
+        tmp = strlen(" falls asleep!");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE_SLEEP:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* State -- confused */
+    if (suffix(msg, " looks confused."))
+    {
+        tmp = strlen(" looks confused.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE_CONFUSED:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* State -- confused */
+    if (suffix(msg, " looks more confused."))
+    {
+        tmp = strlen(" looks more confused.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE_CONFUSED:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* State -- Not Asleep */
+    if (suffix(msg, " wakes up."))
+    {
+        tmp = strlen(" wakes up.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE_AWAKE:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* State -- Afraid */
+    if (suffix(msg, " flees in terror!"))
+    {
+        tmp = strlen(" flees in terror!");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE__FEAR:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* State -- Not Afraid */
+    if (suffix(msg, " recovers his courage."))
+    {
+        tmp = strlen(" recovers his courage.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE__BOLD:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* State -- Not Afraid */
+    if (suffix(msg, " recovers her courage."))
+    {
+        tmp = strlen(" recovers her courage.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE__BOLD:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* State -- Not Afraid */
+    if (suffix(msg, " recovers its courage."))
+    {
+        tmp = strlen(" recovers its courage.");
+        strnfmt(who, 1 + len - tmp, "%s", msg);
+        strnfmt(buf, 256, "STATE__BOLD:%^s", who);
+        borg_react(msg, buf);
+        return;
+    }
+
+    /* Feature XXX XXX XXX */
+    if (streq(msg, "The door appears to be broken."))
+    {
+        /* Only process open doors */
+        if (ag->feat == FEAT_OPEN)
+        {
+            /* Mark as broken */
+            ag->feat = FEAT_BROKEN;
+
+            /* Clear goals */
+            goal = 0;
+        }
+        return;
+    }
+
+    /* Feature XXX XXX XXX */
+    if (streq(msg, "The door appears to be stuck."))
+    {
+        /* Only process non-jammed doors */
+        if ((ag->feat >= FEAT_DOOR_HEAD) && (ag->feat <= FEAT_DOOR_HEAD + 0x07))
+        {
+            /* Mark the door as jammed */
+            ag->feat = FEAT_DOOR_HEAD + 0x08;
+
+            /* Clear goals */
+            goal = 0;
+        }
+
+        return;
+    }
+
+
+
+    /* Feature XXX XXX XXX */
+    if (streq(msg, "This seems to be permanent rock."))
+    {
+        /* Only process walls */
+        if ((ag->feat >= FEAT_WALL_EXTRA) && (ag->feat <= FEAT_PERM_SOLID))
+        {
+            /* Mark the wall as permanent */
+            ag->feat = FEAT_PERM_EXTRA;
+
+            /* Clear goals */
+            goal = 0;
+        }
+
+        return;
+    }
+
+    /* Feature XXX XXX XXX */
+    if (streq(msg, "You tunnel into the granite wall."))
+    {
+        /* reseting my panel clock */
+        time_this_panel = 1;
+
+        /* Only process walls */
+        if ((ag->feat >= FEAT_WALL_EXTRA) && (ag->feat <= FEAT_PERM_SOLID))
+        {
+            /* Mark the wall as granite */
+            ag->feat = FEAT_WALL_EXTRA;
+
+            /* Clear goals */
+            goal = 0;
+        }
+
+        return;
+    }
+
+
+    /* Feature XXX XXX XXX */
+    if (streq(msg, "You tunnel into the quartz vein."))
+    {
+        /* Process magma veins with treasure */
+        if (ag->feat == FEAT_MAGMA_K)
+        {
+            /* Mark the vein */
+            ag->feat = FEAT_QUARTZ_K;
+
+            /* Clear goals */
+            goal = 0;
+        }
+
+        /* Process magma veins */
+        else if (ag->feat == FEAT_MAGMA)
+        {
+            /* Mark the vein */
+            ag->feat = FEAT_QUARTZ;
+
+            /* Clear goals */
+            goal = 0;
+        }
+
+        return;
+    }
+
+    /* Feature XXX XXX XXX */
+    if (streq(msg, "You tunnel into the magma vein."))
+    {
+        /* Process quartz veins with treasure */
+        if (ag->feat == FEAT_QUARTZ_K)
+        {
+            /* Mark the vein */
+            ag->feat = FEAT_MAGMA_K;
+
+            /* Clear goals */
+            goal = 0;
+        }
+
+        /* Process quartz veins */
+        else if (ag->feat == FEAT_QUARTZ)
+        {
+            /* Mark the vein */
+            ag->feat = FEAT_MAGMA;
+
+            /* Clear goals */
+            goal = 0;
+        }
+
+        return;
+    }
+
+    /* Word of Recall -- Ignition */
+    if (prefix(msg, "The air about you becomes "))
+    {
+        /* Initiate recall */
+        /* Guess how long it will take to lift off */
+        goal_recalling = 15000 + 5000; /* Guess. game turns x 1000 ( 15+rand(20))*/
+        return;
+    }
+
+    /* Word of Recall -- Lift off */
+    if (prefix(msg, "You feel yourself yanked "))
+    {
+        /* Recall complete */
+        goal_recalling = 0;
+        return;
+    }
+
+    /* Word of Recall -- Cancelled */
+    if (prefix(msg, "A tension leaves "))
+    {
+        /* Hack -- Oops */
+        goal_recalling = 0;
+        return;
+    }
+
+    /* Wearing Cursed Item */
+    if ((prefix(msg, "Oops! It feels deathly cold!")) ||
+        (suffix(msg, " seems to be cursed.")) ||
+        (suffix(msg, " appears to be cursed.")))
+    {
+        /* Hack -- Oops */
+        borg_wearing_cursed =TRUE;
+        return;
+    }
+
+    /* protect from evil */
+    if (prefix(msg, "You feel safe from evil!"))
+    {
+        borg_prot_from_evil = TRUE;
+        return;
+    }
+    if (prefix(msg, "You no longer feel safe from evil."))
+    {
+        borg_prot_from_evil = FALSE;
+        return;
+    }
+    /* haste self */
+    if (prefix(msg, "You feel yourself moving faster!"))
+    {
+        borg_speed = TRUE;
+        return;
+    }
+    if (prefix(msg, "You feel yourself slow down."))
+    {
+        borg_speed = FALSE;
+        return;
+    }
+    /* Bless */
+    if (prefix(msg, "You feel righteous!"))
+    {
+        borg_bless = TRUE;
+        return;
+    }
+    if (prefix(msg, "The prayer has expired."))
+    {
+        borg_bless = FALSE;
+        return;
+    }
+
+    /* hero */
+    if (prefix(msg, "You feel like a hero!"))
+    {
+        borg_hero = TRUE;
+        return;
+    }
+    if (prefix(msg, "The heroism wears off."))
+    {
+        borg_hero = FALSE;
+        return;
+    }
+
+    /* berserk */
+    if (prefix(msg, "You feel like a killing machine!"))
+    {
+        borg_berserk = TRUE;
+        return;
+    }
+    if (prefix(msg, "You feel less Berserk."))
+    {
+        borg_berserk = FALSE;
+        return;
+    }
+
+    /* Sense Invisible */
+    if (prefix(msg, "Your eyes feel very sensitive!"))
+    {
+        borg_see_inv = 30000;
+        return;
+    }
+    if (prefix(msg, "Your eyes feel less sensitive."))
+    {
+        borg_see_inv = 0;
+        return;
+    }
+
+    /* check for wall blocking but not when confused*/
+    if ((prefix(msg, "There is a wall ") &&
+        (!borg_skill[BI_ISCONFUSED])))
+    {
+        my_need_redraw = TRUE;
+        my_need_alter = TRUE;
+        goal = 0;
+        return;
+    }
+
+
+    /* check for closed door but not when confused*/
+    if ((prefix(msg, "There is a closed door blocking your way.") &&
+        (!borg_skill[BI_ISCONFUSED] &&
+         !borg_skill[BI_ISIMAGE])))
+    {
+        my_need_redraw = TRUE;
+        my_need_alter = TRUE;
+        goal = 0;
+        return;
+    }
+
+    /* check for mis-alter command.  Sometime induced by never_move guys*/
+    if (prefix(msg, "You spin around.") &&
+    !borg_skill[BI_ISCONFUSED])
+    {
+        /* Examine all the monsters */
+        for (i = 1; i < borg_kills_nxt; i++)
+        {
+
+            borg_kill *kill = &borg_kills[i];
+
+            /* Skip dead monsters */
+            if (!kill->r_idx) continue;
+
+			/* Now do distance considerations */
+	        x9 = kill->x;
+	        y9 = kill->y;
+
+	        /* Distance components */
+	        ax = (x9 > c_x) ? (x9 - c_x) : (c_x - x9);
+	        ay = (y9 > c_y) ? (y9 - c_y) : (c_y - y9);
+
+	        /* Distance */
+	        d = MAX(ax, ay);
+
+	        /* if the guy is too close then delete him. */
+	        if (d < 4)
+			{
+                /* Hack -- kill em */
+                borg_delete_kill(i);
+            }
+        }
+
+        my_no_alter = TRUE;
+        goal = 0;
+        return;
+    }
+
+	/* Check for the missing staircase */
+	if (suffix(msg, " staircase here."))
+	{
+		/* make sure the aligned dungeon is on */
+
+		/* make sure the borg does not think he's on one */
+        if (borg_on_dnstairs)
+        {
+            ag->feat = FEAT_FLOOR;
+            borg_on_dnstairs = FALSE;
+        }
+        if (borg_on_upstairs)
+        {
+            ag->feat = FEAT_FLOOR;
+            borg_on_upstairs = FALSE;
+        }
+
+		return;
+	}
+
+    /* Feature XXX XXX XXX */
+    if (prefix(msg, "You see nothing there "))
+    {
+        ag->feat = FEAT_BROKEN;
+
+        my_no_alter = TRUE;
+        /* Clear goals */
+        goal = 0;
+        return;
+
+    }
+
+    /* Hack to protect against clock overflows and errors */
+    if (prefix(msg, "Illegal "))
+    {
+        /* Hack -- Oops */
+        borg_respawning = 7;
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        time_this_panel +=100;
+        return;
+    }
+
+    /* Hack to protect against clock overflows and errors */
+    if (prefix(msg, "You have nothing to identify"))
+    {
+        /* Hack -- Oops */
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        time_this_panel +=100;
+
+        /* ID all items (equipment) */
+        for (i = INVEN_WIELD; i <= INVEN_FEET; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+            /* Skip empty items */
+            if (!item->iqty) continue;
+
+            item->able = TRUE;
+        }
+
+        /* ID all items  (inventory) */
+        for (i = 0; i <= INVEN_PACK; i++)
+        {
+            borg_item *item = &borg_items[i];
+
+            /* Skip empty items */
+            if (!item->iqty) continue;
+
+            item->able = TRUE;
+        }
+        return;
+    }
+
+    /* Hack to protect against clock overflows and errors */
+    if (prefix(msg, "Identifying The Phial"))
+    {
+
+        /* ID item (equipment) */
+        borg_item *item = &borg_items[INVEN_LITE];
+        item->able = TRUE;
+
+        /* Hack -- Oops */
+        borg_keypress(ESCAPE);
+        borg_keypress(ESCAPE);
+        time_this_panel +=100;
+    }
+
+    /* Hack to log certain events  */
+    if (prefix(msg, "In your pack:  The Phial "))
+    {
+		borg_log_event("Found the Phial.");
+	}
+
+    /* resist acid */
+    if (prefix(msg, "You feel resistant to acid!"))
+    {
+        my_oppose_acid = TRUE;
+        return;
+    }
+    if (prefix(msg, "You feel less resistant to acid."))
+    {
+        my_oppose_acid = FALSE;
+        return;
+    }
+    /* resist electricity */
+    if (prefix(msg, "You feel resistant to electricity!"))
+    {
+        my_oppose_elec = TRUE;
+        return;
+    }
+    if (prefix(msg, "You feel less resistant to electricity."))
+    {
+        my_oppose_elec = FALSE;
+        return;
+    }
+    /* resist fire */
+    if (prefix(msg, "You feel resistant to fire!"))
+    {
+        my_oppose_fire = TRUE;
+        return;
+    }
+    if (prefix(msg, "You feel less resistant to fire."))
+    {
+        my_oppose_fire = FALSE;
+        return;
+    }
+    /* resist cold */
+    if (prefix(msg, "You feel resistant to cold!"))
+    {
+        my_oppose_cold = TRUE;
+        return;
+    }
+    if (prefix(msg, "You feel less resistant to cold."))
+    {
+        my_oppose_cold = FALSE;
+        return;
+    }
+    /* resist poison */
+    if (prefix(msg, "You feel resistant to poison!"))
+    {
+        my_oppose_pois = TRUE;
+        return;
+    }
+    if (prefix(msg, "You feel less resistant to poison."))
+    {
+        my_oppose_pois = FALSE;
+        return;
+    }
+
+    /* Shield */
+    if (prefix(msg, "A mystic shield forms around your body!"))
+    {
+        borg_shield = TRUE;
+        return;
+    }
+    if (prefix(msg, "Your mystic shield crumbles away."))
+    {
+        borg_shield = FALSE;
+        return;
+    }
+
+    /* Glyph of Warding (the spell no longer gives a report)*/
+    /* Sadly  Rune of Protection has no message */
+    if (prefix(msg, "You inscribe a mystic symbol on the ground!"))
+    {
+            /* Check for an existing glyph */
+            for (i = 0; i < track_glyph_num; i++)
+            {
+                /* Stop if we already new about this glyph */
+                if ((track_glyph_x[i] == c_x) && (track_glyph_y[i] == c_y)) break;
+            }
+
+            /* Track the newly discovered glyph */
+            if ((i == track_glyph_num) && (track_glyph_size))
+            {
+                borg_note("# Noting the creation of a glyph.");
+                track_glyph_x[i] = c_x;
+                track_glyph_y[i] = c_y;
+                track_glyph_num++;
+            }
+    return;
+    }
+    if (prefix(msg, "The rune of protection is broken!"))
+    {
+        /* we won't know which is broken so erase them all and
+         * allow the borg to scan the screen and rebuild the array.
+         * He won't see the one under him though.  So a special check
+         * must be made.
+         */
+        byte feat = cave_feat[c_y][c_x];
+
+         /* Remove the entire array */
+         for (i = 0; i < track_glyph_num; i++)
+         {
+             /* Stop if we already new about this glyph */
+             track_glyph_x[i] = 0;
+             track_glyph_y[i] = 0;
+
+         }
+         /* no known glyphs */
+         track_glyph_num = 0;
+
+        /* Check for glyphs under player -- Cheat*/
+        if (feat == FEAT_GLYPH)
+        {
+            track_glyph_x[track_glyph_num] = c_x;
+            track_glyph_y[track_glyph_num] = c_y;
+            track_glyph_num++;
+        }
+        return;
+    }
+    /* failed glyph spell message */
+    if (prefix(msg, "The object resists the spell"))
+    {
+
+        /* Forget the newly created-though-failed  glyph */
+        track_glyph_x[track_glyph_num] = 0;
+        track_glyph_y[track_glyph_num] = 0;
+        track_glyph_num --;
+
+        /* note it */
+        borg_note("# Removing the Glyph under me, placing with broken door.");
+
+        /* mark that we are not on a clear spot.  The borg ignores
+         * broken doors and this will keep him from casting it again.
+         */
+        ag->feat = FEAT_BROKEN;
+        return;
+    }
+
+    /* Removed rubble.  Important when out of lite */
+    if (prefix(msg, "You have removed the "))
+    {
+        int x, y;
+        /* remove rubbles from array */
+        for (y = c_y -1; y < c_y +1; y++)
+        {
+            for (x = c_x -1; x < c_x +1; x++)
+            {
+                /* replace all rubble with broken doors, the borg ignores
+                 * broken doors.  This routine is only needed if the borg
+                 * is out of lite and searching in the dark.
+                 */
+                 if (borg_skill[BI_CURLITE]) continue;
+
+                 if (ag->feat == FEAT_RUBBLE) ag->feat = FEAT_BROKEN;
+             }
+         }
+        return;
+    }
+
+    if (prefix(msg, "The enchantment failed"))
+    {
+        /* reset our panel clock for this */
+        time_this_panel = 1;
+        return;
+    }
+
+    /* need to kill monsters when WoD is used */
+    if (prefix(msg, "There is a searing blast of light!"))
+    {
+        /* Examine all the monsters */
+        for (i = 1; i < borg_kills_nxt; i++)
+        {
+            borg_kill *kill = &borg_kills[i];
+
+            int x9 = kill->x;
+            int y9 = kill->y;
+            int ax, ay, d;
+
+            /* Skip dead monsters */
+            if (!kill->r_idx) continue;
+
+            /* Distance components */
+            ax = (x9 > c_x) ? (x9 - c_x) : (c_x - x9);
+            ay = (y9 > c_y) ? (y9 - c_y) : (c_y - y9);
+
+            /* Distance */
+            d = MAX(ax, ay);
+
+            /* Minimal distance */
+            if (d > 12) continue;
+
+            /* Hack -- kill em */
+            borg_delete_kill(i);
+        }
+
+        /* Remove the region fear as well */
+        borg_fear_region[c_y/11][c_x/11] = 0;
+
+        return;
+    }
+
+    /* Be aware and concerned of busted doors */
+    if (prefix(msg, "You hear a door burst open!"))
+    {
+        /* on level 1 and 2 be concerned.  Could be Grip or Fang */
+        if (borg_skill[BI_CDEPTH] <= 3 && borg_skill[BI_CLEVEL] <= 5) scaryguy_on_level = TRUE;
+    }
+
+	/* Some spells move the borg from his grid */
+	if (prefix(msg, "commands you to return.") ||
+	    prefix(msg, "teleports you away.") ||
+	    prefix(msg, "gestures at your feet."))
+	{
+		/* If in Lunal mode better shut that off, he is not on the stairs anymore */
+		if (borg_lunal_mode) borg_lunal_mode = FALSE;
+		borg_note("# Disconnecting Lunal Mode due to monster spell.");
+	}
+
+    /* Feelings about the level */
+    for (i = 0; prefix_feeling[i]; i++)
+    {
+        /* "You feel..." (etc) */
+        if (prefix(msg, prefix_feeling[i]))
+        {
+            strnfmt(buf, 256, "FEELING:%d", i);
+            borg_react(msg, buf);
+            return;
+        }
+    }
+}
+
+
+
+/*
+ * Parse a message, piece of a message, or set of messages.
+ *
+ * We must handle long messages which are "split" into multiple
+ * pieces, and also multiple messages which may be "combined"
+ * into a single set of messages.
+ */
+static void borg_parse(cptr msg)
+{
+    static char len = 0;
+    static char buf[1024];
+
+
+    /* Flush messages */
+    if (len && (!msg || (msg[0] != ' ')))
+    {
+        int i, j;
+
+        /* Split out punctuation */
+        for (j = i = 0; i < len-1; i++)
+        {
+            /* Check for punctuation */
+            if ((buf[i] == '.') ||
+                (buf[i] == '!') ||
+                (buf[i] == '?') ||
+                (buf[i] == '"'))
+            {
+                /* Require space */
+                if (buf[i+1] == ' ')
+                {
+                    /* Terminate */
+                    buf[i+1] = '\0';
+
+                    /* Parse fragment */
+                    borg_parse_aux(buf + j, (i + 1) - j);
+
+                    /* Restore */
+                    buf[i+1] = ' ';
+
+                    /* Advance past spaces */
+                    for (j = i + 2; buf[j] == ' '; j++) /* loop */;
+                }
+            }
+        }
+
+        /* Parse tail */
+        borg_parse_aux(buf + j, len - j);
+
+        /* Forget */
+        len = 0;
+    }
+
+
+    /* No message */
+    if (!msg)
+    {
+        /* Start over */
+        len = 0;
+    }
+
+    /* Continued message */
+    else if (msg[0] == ' ')
+    {
+        /* Collect, verify, and grow */
+        len += strnfmt(buf+len, 1024-len, "%s", msg+1);
+    }
+
+    /* New message */
+    else
+    {
+        /* Collect, verify, and grow */
+        len = strnfmt(buf, 1024, "%s", msg);
+    }
+}
+
+
+
+#ifndef BABLOS
+
+static int adjust_stat_borg(int value, int amount, int borg_roll)
+{
+    /* Negative amounts or maximize mode */
+    if ((amount < 0) || adult_maximize)
+    {
+        return (modify_stat_value(value, amount));
+    }
+
+    /* Special hack */
+    else
+    {
+        int i;
+
+        /* Apply reward */
+        for (i = 0; i < amount; i++)
+        {
+            if (value < 18)
+            {
+                value++;
+            }
+            else if (value < 18+70)
+            {
+                value += ((borg_roll ? 15 : randint(15)) + 5);
+            }
+            else if (value < 18+90)
+            {
+                value += ((borg_roll ? 6 : randint(6)) + 2);
+            }
+            else if (value < 18+100)
+            {
+                value++;
+            }
+        }
+    }
+
+    /* Return the result */
+    return (value);
+}
+
+static void get_stats_borg_aux(void)
+{
+    int i, j;
+
+    int bonus;
+
+    int dice[18];
+
+    /* Roll and verify some stats */
+    while (TRUE)
+    {
+        /* Roll some dice */
+        for (j = i = 0; i < 18; i++)
+        {
+            /* Roll the dice */
+            dice[i] = randint(3 + i % 3);
+
+            /* Collect the maximum */
+            j += dice[i];
+        }
+
+        /* Verify totals */
+        if ((j > 42) && (j < 54)) break;
+    }
+
+    /* Roll the stats */
+    for (i = 0; i < A_MAX; i++)
+    {
+        /* Extract 5 + 1d3 + 1d4 + 1d5 */
+        j = 5 + dice[3*i] + dice[3*i+1] + dice[3*i+2];
+
+        /* Save that value */
+        p_ptr->stat_max[i] = j;
+
+        /* Obtain a "bonus" for "race" and "class" */
+        bonus = rp_ptr->r_adj[i] + cp_ptr->c_adj[i];
+
+        /* Variable stat maxes */
+        if (adult_maximize)
+        {
+            /* Start fully healed */
+            p_ptr->stat_cur[i] = p_ptr->stat_max[i];
+
+            /* Efficiency -- Apply the racial/class bonuses */
+            stat_use[i] = modify_stat_value(p_ptr->stat_max[i], bonus);
+        }
+
+        /* Fixed stat maxes */
+        else
+        {
+            /* Apply the bonus to the stat (somewhat randomly) */
+            stat_use[i] = adjust_stat_borg(p_ptr->stat_max[i], bonus, FALSE);
+
+            /* Save the resulting stat maximum */
+            p_ptr->stat_cur[i] = p_ptr->stat_max[i] = stat_use[i];
+        }
+    }
+}
+/*
+ * Roll for a new characters stats
+ *
+ * For efficiency, we include a chunk of "calc_bonuses()".
+ */
+static void get_stats_borg(void)
+{
+    int i;
+
+    int stat_limit[6];
+
+    s32b borg_round = 0L;
+
+    /* load up min. stats */
+    stat_limit[0] = 15; /* Str */
+    stat_limit[1] = 0; /* Int */
+    stat_limit[2] = 0; /* Wis */
+    stat_limit[3] = 0; /* Dex */
+    stat_limit[4] = 14;/* Con */
+    stat_limit[5] = 0; /* Chr */
+
+    switch (p_ptr->pclass)
+    {
+        case CLASS_WARRIOR:
+            stat_limit[0] = 17;
+            stat_limit[3] = 16;
+            break;
+        case CLASS_MAGE:
+            stat_limit[1] = 17;
+            stat_limit[3] = 16;
+            break;
+        case CLASS_PRIEST:
+            stat_limit[2] = 17;
+            stat_limit[0] = 16;
+            break;
+        case CLASS_ROGUE:
+            stat_limit[0] = 17;
+            stat_limit[3] = 16;
+            break;
+        case CLASS_PALADIN:
+            stat_limit[0] = 17;
+            stat_limit[3] = 16;
+            break;
+        case CLASS_RANGER:
+            stat_limit[0] = 17;
+            stat_limit[3] = 16;
+            break;
+    }
+
+    /* Minimal stats selected */
+    if (stat_limit[0] + stat_limit[1] + stat_limit[2] + stat_limit[3] +
+        stat_limit[4] + stat_limit[5] >= 1)
+    {
+        /* Auto-roll */
+        while (1)
+        {
+            bool accept = TRUE;
+
+            /* Get a new character */
+            get_stats_borg_aux();
+
+            /* Advance the round */
+            borg_round++;
+
+            /* Hack -- Prevent overflow */
+            if (borg_round >= 750000L)
+            {
+                borg_note("# Minimal Stats too high.");
+                break;
+            }
+
+            /* Check and count acceptable stats */
+            for (i = 0; i < A_MAX; i++)
+            {
+                /* This stat is okay (JesperN)*/
+                if (p_ptr->stat_max[i] >= stat_limit[i])
+
+                {
+                    accept = TRUE;
+                }
+
+                /* This stat is not okay */
+                else
+                {
+                    accept = FALSE;
+                    break;
+                }
+             }
+
+             /* Break if "happy" */
+             if (accept) break;
+        } /* while */
+
+    /* Note the number of rolls to achieve stats */
+/*    borg_note(format("# Minimal stats rolled in %d turns.",borg_round)); */ //apw
+
+    } /* minimal stats */
+    else /* Otherwise just get a character */
+    {
+        borg_note("# Rolling random stats.");
+        get_stats_borg_aux();
+    }
+
+
+}
+
+/*
+ * Roll for some info that the auto-roller ignores
+ */
+static void get_extra_borg(void)
+{
+    int i, j, min_value, max_value;
+
+
+    /* Level one */
+    p_ptr->max_lev = p_ptr->lev = 1;
+
+    /* Experience factor */
+    p_ptr->expfact = rp_ptr->r_exp + cp_ptr->c_exp;
+
+    /* Hitdice */
+    p_ptr->hitdie = rp_ptr->r_mhp + cp_ptr->c_mhp;
+
+    /* Initial hitpoints */
+    p_ptr->mhp = p_ptr->hitdie;
+
+    /* Minimum hitpoints at highest level */
+    min_value = (PY_MAX_LEVEL * (p_ptr->hitdie - 1) * 3) / 8;
+    min_value += PY_MAX_LEVEL;
+
+    /* Maximum hitpoints at highest level */
+    max_value = (PY_MAX_LEVEL * (p_ptr->hitdie - 1) * 5) / 8;
+    max_value += PY_MAX_LEVEL;
+
+    /* Pre-calculate level 1 hitdice */
+    p_ptr->player_hp[0] = p_ptr->hitdie;
+
+    /* Roll out the hitpoints */
+    while (TRUE)
+    {
+        /* Roll the hitpoint values */
+        for (i = 1; i < PY_MAX_LEVEL; i++)
+        {
+            j = randint(p_ptr->hitdie);
+            p_ptr->player_hp[i] = p_ptr->player_hp[i-1] + j;
+        }
+
+        /* XXX Could also require acceptable "mid-level" hitpoints */
+
+        /* Require "valid" hitpoints at highest level */
+        if (p_ptr->player_hp[PY_MAX_LEVEL-1] < min_value) continue;
+        if (p_ptr->player_hp[PY_MAX_LEVEL-1] > max_value) continue;
+
+        /* Acceptable */
+        break;
+    }
+}
+
+
+/*
+ * Get the racial history, and social class, using the "history charts".
+ */
+static void get_history_borg(void)
+{
+    int i, chart, roll, social_class;
+
+
+    /* Clear the previous history strings */
+    p_ptr->history[0] = '\0';
+
+
+    /* Initial social class */
+    social_class = randint(4);
+
+    /* Starting place */
+    chart = rp_ptr->hist;
+
+
+    /* Process the history */
+    while (chart)
+    {
+        /* Start over */
+        i = 0;
+
+        /* Roll for nobility */
+        roll = randint(100);
+
+        /* Get the proper entry in the table */
+        while ((chart != h_info[i].chart) || (roll > h_info[i].roll)) i++;
+
+        /* Get the textual history */
+        my_strcat(p_ptr->history, (h_text + h_info[i].text), sizeof(p_ptr->history));
+
+        /* Add in the social class */
+        social_class += (int)(h_info[i].bonus) - 50;
+
+        /* Enter the next chart */
+        chart = h_info[i].next;
+    }
+
+    /* Verify social class */
+    if (social_class > 100) social_class = 100;
+    else if (social_class < 1) social_class = 1;
+
+    /* Save the social class */
+    p_ptr->sc = social_class;
+
+}
+
+
+/*
+ * Computes character's age, height, and weight
+ */
+static void get_ahw_borg(void)
+{
+    /* Calculate the age */
+    p_ptr->age = rp_ptr->b_age + randint(rp_ptr->m_age);
+
+    /* Calculate the height/weight for males */
+    if (p_ptr->psex == SEX_MALE)
+    {
+        p_ptr->ht = Rand_normal(rp_ptr->m_b_ht, rp_ptr->m_m_ht);
+        p_ptr->wt = Rand_normal(rp_ptr->m_b_wt, rp_ptr->m_m_wt);
+    }
+
+    /* Calculate the height/weight for females */
+    else if (p_ptr->psex == SEX_FEMALE)
+    {
+        p_ptr->ht = Rand_normal(rp_ptr->f_b_ht, rp_ptr->f_m_ht);
+        p_ptr->wt = Rand_normal(rp_ptr->f_b_wt, rp_ptr->f_m_wt);
+    }
+}
+
+
+
+
+/*
+ * Get the player's starting money
+ */
+static void get_money_borg(void)
+{
+    int i;
+
+    int gold = 0;
+
+    /* Social Class determines starting gold */
+    gold = (p_ptr->sc * 6) + randint(100) + 300;
+
+    /* Process the stats */
+    for (i = 0; i < A_MAX; i++)
+    {
+        /* Mega-Hack -- reduce gold for high stats */
+        if (stat_use[i] >= 18+50) gold -= 300;
+        else if (stat_use[i] >= 18+20) gold -= 200;
+        else if (stat_use[i] > 18) gold -= 150;
+        else gold -= (stat_use[i] - 8) * 10;
+    }
+
+    /* Minimum 100 gold */
+    if (gold < 100) gold = 100;
+
+    /* Save the gold */
+    p_ptr->au = gold;
+}
+/*
+ * Name segments for random player names
+ * Copied Cth by DvE
+ * Copied from borgband by APW
+ */
+
+/* Dwarves */
+static char *dwarf_syllable1[] =
+{
+    "B", "D", "F", "G", "Gl", "H", "K", "L", "M", "N", "R", "S", "T", "Th", "V",
+};
+
+static char *dwarf_syllable2[] =
+{
+    "a", "e", "i", "o", "oi", "u",
+};
+
+static char *dwarf_syllable3[] =
+{
+    "bur", "fur", "gan", "gnus", "gnar", "li", "lin", "lir", "mli", "nar", "nus", "rin", "ran", "sin", "sil", "sur",
+};
+
+/* Elves */
+static char *elf_syllable1[] =
+{
+    "Al", "An", "Bal", "Bel", "Cal", "Cel", "El", "Elr", "Elv", "Eow", "Ear", "F", "Fal", "Fel", "Fin", "G", "Gal", "Gel", "Gl", "Is", "Lan", "Leg", "Lom", "N", "Nal", "Nel",  "S", "Sal", "Sel", "T", "Tal", "Tel", "Thr", "Tin",
+};
+
+static char *elf_syllable2[] =
+{
+    "a", "adrie", "ara", "e", "ebri", "ele", "ere", "i", "io", "ithra", "ilma", "il-Ga", "ili", "o", "orfi", "u", "y",
+};
+
+static char *elf_syllable3[] =
+{
+    "l", "las", "lad", "ldor", "ldur", "linde", "lith", "mir", "n", "nd", "ndel", "ndil", "ndir", "nduil", "ng", "mbor", "r", "rith", "ril", "riand", "rion", "s", "thien", "viel", "wen", "wyn",
+};
+
+/* Gnomes */
+static char *gnome_syllable1[] =
+{
+    "Aar", "An", "Ar", "As", "C", "H", "Han", "Har", "Hel", "Iir", "J", "Jan", "Jar", "K", "L", "M", "Mar", "N", "Nik", "Os", "Ol", "P", "R", "S", "Sam", "San", "T", "Ter", "Tom", "Ul", "V", "W", "Y",
+};
+
+static char *gnome_syllable2[] =
+{
+    "a", "aa",  "ai", "e", "ei", "i", "o", "uo", "u", "uu",
+};
+
+static char *gnome_syllable3[] =
+{
+    "ron", "re", "la", "ki", "kseli", "ksi", "ku", "ja", "ta", "na", "namari", "neli", "nika", "nikki", "nu", "nukka", "ka", "ko", "li", "kki", "rik", "po", "to", "pekka", "rjaana", "rjatta", "rjukka", "la", "lla", "lli", "mo", "nni",
+};
+
+/* Hobbit */
+static char *hobbit_syllable1[] =
+{
+    "B", "Ber", "Br", "D", "Der", "Dr", "F", "Fr", "G", "H", "L", "Ler", "M", "Mer", "N", "P", "Pr", "Per", "R", "S", "T", "W",
+};
+
+static char *hobbit_syllable2[] =
+{
+    "a", "e", "i", "ia", "o", "oi", "u",
+};
+
+static char *hobbit_syllable3[] =
+{
+    "bo", "ck", "decan", "degar", "do", "doc", "go", "grin", "lba", "lbo", "lda", "ldo", "lla", "ll", "lo", "m", "mwise", "nac", "noc", "nwise", "p", "ppin", "pper", "tho", "to",
+};
+
+/* Human */
+static char *human_syllable1[] =
+{
+    "Ab", "Ac", "Ad", "Af", "Agr", "Ast", "As", "Al", "Adw", "Adr", "Ar", "B", "Br", "C", "Cr", "Ch", "Cad", "D", "Dr", "Dw", "Ed", "Eth", "Et", "Er", "El", "Eow", "F", "Fr", "G", "Gr", "Gw", "Gal", "Gl", "H", "Ha", "Ib", "Jer", "K", "Ka", "Ked", "L", "Loth", "Lar", "Leg", "M", "Mir", "N", "Nyd", "Ol", "Oc", "On", "P", "Pr", "R", "Rh", "S", "Sev", "T", "Tr", "Th", "V", "Y", "Z", "W", "Wic",
+};
+
+static char *human_syllable2[] =
+{
+    "a", "ae", "au", "ao", "are", "ale", "ali", "ay", "ardo", "e", "ei", "ea", "eri", "era", "ela", "eli", "enda", "erra", "i", "ia", "ie", "ire", "ira", "ila", "ili", "ira", "igo", "o", "oa", "oi", "oe", "ore", "u", "y",
+};
+
+static char *human_syllable3[] =
+{
+    "a", "and", "b", "bwyn", "baen", "bard", "c", "ctred", "cred", "ch", "can", "d", "dan", "don", "der", "dric", "dfrid", "dus", "f", "g", "gord", "gan", "l", "li", "lgrin", "lin", "lith", "lath", "loth", "ld", "ldric", "ldan", "m", "mas", "mos", "mar", "mond", "n", "nydd", "nidd", "nnon", "nwan", "nyth", "nad", "nn", "nnor", "nd", "p", "r", "ron", "rd", "s", "sh", "seth", "sean", "t", "th", "tha", "tlan", "trem", "tram", "v", "vudd", "w", "wan", "win", "wyn", "wyr", "wyr", "wyth",
+};
+
+/* Orc */
+static char *orc_syllable1[] =
+{
+    "B", "Er", "G", "Gr", "H", "P", "Pr", "R", "V", "Vr", "T", "Tr", "M", "Dr",
+};
+
+static char *orc_syllable2[] =
+{
+    "a", "i", "o", "oo", "u", "ui",
+};
+
+static char *orc_syllable3[] =
+{
+    "dash", "dish", "dush", "gar", "gor", "gdush", "lo", "gdish", "k", "lg", "nak", "rag", "rbag", "rg", "rk", "ng", "nk", "rt", "ol", "urk", "shnak", "mog", "mak", "rak",
+};
+
+
+/*
+ * Random Name Generator
+ * based on a Javascript by Michael Hensley
+ * "http://geocities.com/timessquare/castle/6274/"
+ * Copied from Cth by DvE
+ * Copied from borgband by APW
+ */
+static void create_random_name(int race, char *name)
+{
+    /* Paranoia */
+    if (!name) return;
+
+    /* Select the monster type */
+    switch (race)
+    {
+        /* Create the monster name */
+    case RACE_DWARF:
+        strcpy(name, dwarf_syllable1[rand_int(sizeof(dwarf_syllable1) / sizeof(char*))]);
+        strcat(name, dwarf_syllable2[rand_int(sizeof(dwarf_syllable2) / sizeof(char*))]);
+        strcat(name, dwarf_syllable3[rand_int(sizeof(dwarf_syllable3) / sizeof(char*))]);
+        break;
+    case RACE_ELF:
+    case RACE_HALF_ELF:
+    case RACE_HIGH_ELF:
+        strcpy(name, elf_syllable1[rand_int(sizeof(elf_syllable1) / sizeof(char*))]);
+        strcat(name, elf_syllable2[rand_int(sizeof(elf_syllable2) / sizeof(char*))]);
+        strcat(name, elf_syllable3[rand_int(sizeof(elf_syllable3) / sizeof(char*))]);
+        break;
+    case RACE_GNOME:
+        strcpy(name, gnome_syllable1[rand_int(sizeof(gnome_syllable1) / sizeof(char*))]);
+        strcat(name, gnome_syllable2[rand_int(sizeof(gnome_syllable2) / sizeof(char*))]);
+        strcat(name, gnome_syllable3[rand_int(sizeof(gnome_syllable3) / sizeof(char*))]);
+        break;
+    case RACE_HOBBIT:
+        strcpy(name, hobbit_syllable1[rand_int(sizeof(hobbit_syllable1) / sizeof(char*))]);
+        strcat(name, hobbit_syllable2[rand_int(sizeof(hobbit_syllable2) / sizeof(char*))]);
+        strcat(name, hobbit_syllable3[rand_int(sizeof(hobbit_syllable3) / sizeof(char*))]);
+        break;
+    case RACE_HUMAN:
+    case RACE_DUNADAN:
+        strcpy(name, human_syllable1[rand_int(sizeof(human_syllable1) / sizeof(char*))]);
+        strcat(name, human_syllable2[rand_int(sizeof(human_syllable2) / sizeof(char*))]);
+        strcat(name, human_syllable3[rand_int(sizeof(human_syllable3) / sizeof(char*))]);
+        break;
+    case RACE_HALF_ORC:
+    case RACE_HALF_TROLL:
+    case RACE_KOBOLD:
+        strcpy(name, orc_syllable1[rand_int(sizeof(orc_syllable1) / sizeof(char*))]);
+        strcat(name, orc_syllable2[rand_int(sizeof(orc_syllable2) / sizeof(char*))]);
+        strcat(name, orc_syllable3[rand_int(sizeof(orc_syllable3) / sizeof(char*))]);
+        break;
+        /* Create an empty name */
+    default:
+        name[0] = '\0';
+        break;
+    }
+}
+
+
+/*
+ * Init players with some belongings
+ *
+ * Having an item makes the player "aware" of its purpose.
+ */
+static void player_outfit_borg(void)
+{
+    int i;
+
+    object_type *i_ptr;
+    object_type object_type_body;
+    const start_item *e_ptr;
+
+
+    /* Get local object */
+    i_ptr = &object_type_body;
+
+    /* Hack -- Give the player some food */
+    object_prep(i_ptr, lookup_kind(TV_FOOD, SV_FOOD_RATION));
+    i_ptr->number = (byte)rand_range(3, 7);
+    object_aware(i_ptr);
+    object_known(i_ptr);
+    (void)inven_carry(i_ptr);
+
+
+    /* Get local object */
+    i_ptr = &object_type_body;
+
+    /* Hack -- Give the player some torches */
+    object_prep(i_ptr, lookup_kind(TV_LITE, SV_LITE_TORCH));
+    i_ptr->number = (byte)rand_range(3, 7);
+    i_ptr->pval = rand_range(3, 7) * 500;
+    object_aware(i_ptr);
+    object_known(i_ptr);
+    (void)inven_carry(i_ptr);
+
+    /* Hack -- Give the player his equipment */
+    for (i = 0; i < MAX_START_ITEMS; i++)
+    {
+        /* Access the item */
+        e_ptr = &(cp_ptr->start_items[i]);
+
+        /* Get local object */
+        i_ptr = &object_type_body;
+
+        /* Hack -- Give the player an object */
+        if (e_ptr->tval > 0)
+        {
+            /* Get the object_kind */
+            int k_idx = lookup_kind(e_ptr->tval, e_ptr->sval);
+
+            /* Valid item? */
+            if (!k_idx) continue;
+
+            /* Prepare the item */
+            object_prep(i_ptr, k_idx);
+            i_ptr->number = (byte)rand_range(e_ptr->min, e_ptr->max);
+
+            object_aware(i_ptr);
+            object_known(i_ptr);
+            (void)inven_carry(i_ptr);
+        }
+    }
+}
+
+#ifdef BORG_TK
+extern void borg_forget_messages(void);
+#endif /* borg_tk */
+
+
+/* Allow the borg to play continously.  Reset all values, */
+void resurrect_borg(void)
+{
+    int i,j;
+    int n;
+    /* Cheat death */
+    p_ptr->is_dead = FALSE;
+    borg_skill[BI_MAXDEPTH] = 0;
+    borg_skill[BI_MAXCLEVEL] = 1;
+
+    /* Flush message buffer */
+    borg_parse(NULL);
+
+    /* flush the commands */
+    borg_flush();
+
+#ifdef BORG_TK
+    void borg_forget_messages(void);
+#endif /* borg_tk */
+
+    /* remove the spell counters */
+    if (cp_ptr->spell_book)
+    {
+        for (i = 0; i < 9; i++ )
+        {
+           for (j = 0; j < 8; j++)
+            {
+                /* get the magics */
+                borg_magic *as = &borg_magics[i][j];
+                /* reset the counter */
+                as->times = 0;
+            }
+        }
+    }
+
+
+    /*** Wipe the player ***/
+    (void)WIPE(p_ptr, player_type);
+    turn = 0;
+    borg_skill[BI_ISCUT] = borg_skill[BI_ISSTUN] = borg_skill[BI_ISHEAVYSTUN] = borg_skill[BI_ISIMAGE] = borg_skill[BI_ISSTUDY] = FALSE;
+
+#ifdef GJW_RANDART
+    /* Hack -- seed for random artifacts */
+    seed_randart = rand_int(0x10000000);
+
+    /* Randomize the artifacts */
+    if (adult_rand_artifacts)
+    {
+		do_randart(seed_randart, TRUE);
+    }
+#endif
+
+    /* Set some player flags to keep it running */
+    p_ptr->playing = TRUE;
+    p_ptr->leaving = TRUE;
+
+    /* reset our panel clock */
+    time_this_panel =1;
+
+    /* reset our vault/unique check */
+    vault_on_level = FALSE;
+    unique_on_level = 0;
+    scaryguy_on_level = FALSE;
+
+    /* reset our breeder flag */
+    breeder_level = FALSE;
+
+    /* Assume not leaving the level */
+    goal_leaving = FALSE;
+
+    /* Assume not fleeing the level */
+    goal_fleeing = FALSE;
+
+    /* Assume not fleeing the level */
+    borg_fleeing_town = FALSE;
+
+    /* Assume not ignoring monsters */
+    goal_ignoring = FALSE;
+
+    /* Clear the inventory */
+    for (i = 0; i < INVEN_TOTAL; i++)
+    {
+        object_wipe(&inventory[i]);
+    }
+
+    flavor_init();
+
+    borg_clear_3();
+    borg_init_3();
+
+    /* Clear the inventory */
+    for (i = 0; i < INVEN_TOTAL; i++)
+    {
+        object_wipe(&inventory[i]);
+    }
+
+
+    /* Start with no artifacts made yet */
+    for (i = 0; i < z_info->a_max; i++)
+    {
+        artifact_type *a_ptr = &a_info[i];
+        a_ptr->cur_num = 0;
+    }
+
+    /* Start with no quests */
+    for (i = 0; i < MAX_Q_IDX; i++)
+    {
+        q_list[i].level = 0;
+    }
+
+#if 0
+    /* Free the "quarks" */
+    for (i = 1; i < quark__num; i++)
+    {
+        string_free(quark__str[i]);
+    }
+#endif
+
+    /* Add a special quest */
+    q_list[0].level = 99;
+
+    /* Add a second quest */
+    q_list[1].level = 100;
+
+
+    /* Reset the "objects" */
+    for (i = 1; i < z_info->k_max; i++)
+    {
+        object_kind *k_ptr = &k_info[i];
+
+
+        /* skip some stuff */
+        if (k_ptr->tval <= TV_AMULET ||
+            k_ptr->tval >= TV_FOOD) continue;
+
+        /* Reset "tried" */
+        k_ptr->tried = FALSE;
+
+        /* Reset "aware" */
+        k_ptr->aware = FALSE;
+    }
+
+
+    /* Reset the "monsters" */
+    for (i = 1; i < z_info->r_max; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+        monster_lore *l_ptr = &l_list[i];
+
+        /* Hack -- Reset the counter */
+        r_ptr->cur_num = 0;
+
+        /* Hack -- Reset the max counter */
+        r_ptr->max_num = 100;
+
+        /* Hack -- Reset the max counter */
+        if (r_ptr->flags1 & (RF1_UNIQUE)) r_ptr->max_num = 1;
+
+        /* Clear player kills */
+        l_ptr->pkills = 0;
+    }
+
+    /* Hack -- no ghosts */
+    r_info[z_info->r_max-1].max_num = 0;
+
+
+    /* Hack -- Well fed player */
+    p_ptr->food = PY_FOOD_FULL - 1;
+
+
+    /* None of the spells have been learned yet */
+    for (i = 0; i < 64; i++) p_ptr->spell_order[i] = 99;
+
+    /** Roll up a new character **/
+
+    /* Sex */
+    p_ptr->psex = rand_int(MAX_SEXES);
+    sp_ptr = &sex_info[p_ptr->psex];
+
+
+
+    /* Class */
+    if (borg_respawn_class == -1)
+    {
+        p_ptr->pclass = rand_int(z_info->c_max);
+    }
+    else
+    {
+        p_ptr->pclass = borg_respawn_class;
+    }
+
+    cp_ptr = &c_info[p_ptr->pclass];
+    mp_ptr = &cp_ptr->spells;
+
+
+   if (borg_respawn_race == -1)
+   {
+    while (1)
+    {
+       /* Race */
+       p_ptr->prace = rand_int(z_info->p_max);
+
+       rp_ptr = &p_info[p_ptr->prace];
+
+       /* Try again if not a legal choice */
+       if (!(rp_ptr->choice & (1L << p_ptr->pclass))) continue;
+       break;
+    }
+   }
+   else
+   {
+        p_ptr->prace = borg_respawn_race;
+        rp_ptr = &p_info[p_ptr->prace];
+   }
+
+    /* Some Extra things */
+    get_stats_borg();
+    get_extra_borg();
+    get_ahw_borg();
+    get_history_borg();
+    get_money_borg();
+
+    /* Get a random name */
+    create_random_name(p_ptr->prace,op_ptr->full_name);
+
+
+    /* outfit the player */
+    (void)player_outfit_borg();
+
+    /* Reset the Shops */
+    for (n = 0; n < MAX_STORES; n++)
+    {
+        /* Initialize */
+        store_init(n);
+
+        /* Maintain the shop (ten times) */
+        for (i = 0; i < 10; i++) store_maint(n);
+    }
+
+    /* Hack -- flush it */
+    Term_fresh();
+
+    /*** Hack -- Extract race ***/
+
+    /* Insert the player Race--cheat */
+    borg_race = p_ptr->prace;
+
+    /* Extract the race pointer */
+    rb_ptr = &p_info[borg_race];
+
+
+    /*** Hack -- Extract class ***/
+
+    /* Cheat the class */
+    borg_class = p_ptr->pclass;
+
+    /* Extract the class pointer */
+    cb_ptr = &c_info[borg_class];
+
+    /* Extract the magic pointer */
+    mb_ptr = &cb_ptr->spells;
+
+
+
+    /*** Hack -- react to race and class ***/
+
+    /* Notice the new race and class */
+    prepare_race_class_info();
+
+
+    /* need to check all stats */
+    my_need_stat_check[0] = TRUE;
+    my_need_stat_check[1] = TRUE;
+    my_need_stat_check[2] = TRUE;
+    my_need_stat_check[3] = TRUE;
+    my_need_stat_check[4] = TRUE;
+    my_need_stat_check[5] = TRUE;
+
+    /* Allowable Cheat -- Obtain "recall" flag */
+    goal_recalling = p_ptr->word_recall * 1000;
+
+    /* Allowable Cheat -- Obtain "prot_from_evil" flag */
+    borg_prot_from_evil = (p_ptr->protevil ? TRUE : FALSE);
+    /* Allowable Cheat -- Obtain "speed" flag */
+    borg_speed = (p_ptr->fast ? TRUE : FALSE);
+    /* Allowable Cheat -- Obtain "resist" flags */
+    my_oppose_acid = (p_ptr->oppose_acid ? TRUE : FALSE);
+    my_oppose_elec = (p_ptr->oppose_elec ? TRUE : FALSE);
+    my_oppose_fire = (p_ptr->oppose_fire ? TRUE : FALSE);
+    my_oppose_cold = (p_ptr->oppose_cold ? TRUE : FALSE);
+    my_oppose_pois = (p_ptr->oppose_pois ? TRUE : FALSE);
+    borg_bless = (p_ptr->blessed ? TRUE : FALSE);
+    borg_shield = (p_ptr->shield ? TRUE : FALSE);
+    borg_hero = (p_ptr->hero ? TRUE : FALSE);
+    borg_berserk = (p_ptr->shero ? TRUE : FALSE);
+    if (p_ptr->see_inv) borg_see_inv = 10000;
+
+    /* Message */
+    borg_note("# Respawning");
+    borg_respawning = 5;
+
+    /* fully healed and rested */
+    p_ptr->chp = p_ptr->mhp;
+    p_ptr->csp = p_ptr->msp;
+
+#ifdef BORG_TK
+    angtk_eval("angband_borg", "rebirth", NULL);
+#endif /* borg_tk */
+
+	/* Mark savefile as borg cheater */
+	if (!(p_ptr->noscore & 0x0010)) p_ptr->noscore |= 0x0010;
+
+   /* Done.  Play on */
+}
+
+/*
+ * The "highscore" file descriptor, if available.
+ */
+static int highscore_fd = -1;
+
+/*
+ * Seek score 'i' in the highscore file
+ */
+static int borg_highscore_seek(int i)
+{
+    /* Seek for the requested record */
+    return (fd_seek(highscore_fd, i * sizeof(high_score)));
+}
+
+
+/*
+ * Read one score from the highscore file
+ */
+static errr borg_highscore_read(high_score *score)
+{
+    /* Read the record, note failure */
+    return (fd_read(highscore_fd, (char*)(score), sizeof(high_score)));
+}
+
+
+/*
+ * Write one score to the highscore file
+ */
+static int borg_highscore_write(const high_score *score)
+{
+    /* Write the record, note failure */
+    return (fd_write(highscore_fd, (char*)(score), sizeof(high_score)));
+}
+
+
+
+
+/*
+ * Just determine where a new score *would* be placed
+ * Return the location (0 is best) or -1 on failure
+ */
+static int borg_highscore_where(const high_score *score)
+{
+    int i;
+
+    high_score the_score;
+
+    /* Paranoia -- it may not have opened */
+    if (highscore_fd < 0) return (-1);
+
+    /* Go to the start of the highscore file */
+    if (borg_highscore_seek(0)) return (-1);
+
+    /* Read until we get to a higher score */
+    for (i = 0; i < MAX_HISCORES; i++)
+    {
+        if (borg_highscore_read(&the_score)) return (i);
+        if (strcmp(the_score.pts, score->pts) < 0) return (i);
+    }
+
+    /* The "last" entry is always usable */
+    return (MAX_HISCORES - 1);
+}
+
+
+/*
+ * Actually place an entry into the high score file
+ * Return the location (0 is best) or -1 on "failure"
+ */
+static int borg_highscore_add(const high_score *score)
+{
+    int i, slot;
+    bool done = FALSE;
+
+    high_score the_score, tmpscore;
+
+
+    /* Paranoia -- it may not have opened */
+    if (highscore_fd < 0) return (-1);
+
+    /* Determine where the score should go */
+    slot = borg_highscore_where(score);
+
+    /* Hack -- Not on the list */
+    if (slot < 0) return (-1);
+
+    /* Hack -- prepare to dump the new score */
+    the_score = (*score);
+
+    /* Slide all the scores down one */
+    for (i = slot; !done && (i < MAX_HISCORES); i++)
+    {
+        /* Read the old guy, note errors */
+        if (borg_highscore_seek(i)) return (-1);
+        if (borg_highscore_read(&tmpscore)) done = TRUE;
+
+        /* Back up and dump the score we were holding */
+        if (borg_highscore_seek(i)) return (-1);
+        if (borg_highscore_write(&the_score)) return (-1);
+
+        /* Hack -- Save the old score, for the next pass */
+        the_score = tmpscore;
+    }
+
+    /* Return location used */
+    return (slot);
+}
+
+
+
+
+/*
+ * Enters a players name on a hi-score table, if "legal".
+ *
+ * Assumes "signals_ignore_tstp()" has been called.
+ */
+extern errr borg_enter_score(void)
+{
+    char buf[1024];
+    int score_idx = -1;
+
+    high_score the_score;
+    time_t death_time;
+
+    /* Build the filename */
+    path_build(buf, 1024, ANGBAND_DIR_APEX, "scores.raw");
+
+    /* Grab permissions */
+    safe_setuid_grab();
+
+    /* Open the high score file, for reading/writing */
+    highscore_fd = fd_open(buf, O_RDWR);
+
+    /* Drop permissions */
+    safe_setuid_drop();
+
+
+    /* No score file */
+    if (highscore_fd < 0)
+    {
+        return (0);
+    }
+
+    /* Clear the record */
+    (void)WIPE(&the_score, high_score);
+
+    /* Get time of death */
+    (void)time(&death_time);
+
+    /* Save the version */
+    sprintf(the_score.what, "%s", VERSION_STRING);
+
+    /* Calculate and save the points */
+    sprintf(the_score.pts, "%9lu", (long)total_points());
+    the_score.pts[9] = '\0';
+
+    /* Save the current gold */
+    sprintf(the_score.gold, "%9lu", (long)p_ptr->au);
+    the_score.gold[9] = '\0';
+
+    /* Save the current turn */
+    sprintf(the_score.turns, "%9lu", (long)turn);
+    the_score.turns[9] = '\0';
+
+#ifdef HIGHSCORE_DATE_HACK
+    /* Save the date in a hacked up form (9 chars) */
+    sprintf(the_score.day, "%-.6s %-.2s",
+            ctime(&death_time) + 4, ctime(&death_time) + 22);
+#else
+    /* Save the date in standard encoded form (9 chars) */
+    strftime(the_score.day, 10, "@%Y%m%d", localtime(&death_time));
+#endif
+
+    /* Save the player name (15 chars) */
+    sprintf(the_score.who, "%-.15s", op_ptr->full_name);
+
+    /* Save the player info XXX XXX XXX */
+    sprintf(the_score.uid, "%7u", player_uid);
+    sprintf(the_score.sex, "%c", (p_ptr->psex ? 'm' : 'f'));
+    sprintf(the_score.p_r, "%2d", p_ptr->prace);
+    sprintf(the_score.p_c, "%2d", p_ptr->pclass);
+
+    /* Save the level and such */
+    sprintf(the_score.cur_lev, "%3d", p_ptr->lev);
+    sprintf(the_score.cur_dun, "%3d", p_ptr->depth);
+    sprintf(the_score.max_lev, "%3d", p_ptr->max_lev);
+    sprintf(the_score.max_dun, "%3d", p_ptr->max_depth);
+
+    /* Save the cause of death (31 chars) */
+    sprintf(the_score.how, "%-.31s", p_ptr->died_from);
+
+    /* Grab permissions */
+    safe_setuid_grab();
+
+    /* Lock (for writing) the highscore file, or fail */
+    if (fd_lock(highscore_fd, F_WRLCK)) return (1);
+
+    /* Drop permissions */
+    safe_setuid_drop();
+
+    /* Add a new entry to the score list, see where it went */
+    score_idx = borg_highscore_add(&the_score);
+
+    /* Grab permissions */
+    safe_setuid_grab();
+
+    /* Unlock the highscore file, or fail */
+    if (fd_lock(highscore_fd, F_UNLCK)) return (1);
+
+    /* Drop permissions */
+    safe_setuid_drop();
+
+
+
+    /* Shut the high score file */
+    fd_close(highscore_fd);
+
+    /* Forget the high score fd */
+    highscore_fd = -1;
+
+
+
+    /* Success */
+    return (0);
+}
+
+#endif /* bablos */
+
+/*
+ * Mega-Hack -- special "inkey_hack" hook.  XXX XXX XXX
+ *
+ * A special function hook (see "util.c") which allows the Borg to take
+ * control of the "inkey()" function, and substitute in fake keypresses.
+ */
+#ifdef BORG_TK
+ANG_EXTERN char (*inkey_hack)(int flush_first);
+#else /* BORG_TK */
+extern char (*inkey_hack)(int flush_first);
+#endif /* BORG_TK */
+
+/*
+ * This function lets the Borg "steal" control from the user.
+ *
+ * The "util.c" file provides a special "inkey_hack" hook which we use
+ * to steal control of the keyboard, using the special function below.
+ *
+ * Since this function bypasses the code in "inkey()" which "refreshes"
+ * the screen whenever the game has to wait for a keypress, the screen
+ * will only get refreshed when (1) an option such as "fresh_before"
+ * induces regular screen refreshing or (2) various explicit calls to
+ * "Term_fresh" are made, such as in the "project()" function.  This
+ * has the interesting side effect that the screen is never refreshed
+ * while the Borg is browsing stores, checking his inventory/equipment,
+ * browsing spell books, checking the current panel, or examining an
+ * object, which reduces the "screen flicker" considerably.  :-)
+ *
+ * The only way that the Borg can be stopped once it is started, unless
+ * it dies or encounters an error, is to press any key.  This function
+ * checks for real user input on a regular basic, and if any is found,
+ * it is flushed, and after completing any actions in progress, this
+ * function hook is removed, and control is returned to the user.
+ *
+ * We handle "broken" messages, in which long messages are "broken" into
+ * pieces, and all but the first message are "indented" by one space, by
+ * collecting all the pieces into a complete message and then parsing the
+ * message once it is known to be complete.
+ *
+ * This function hook automatically removes itself when it realizes that
+ * it should no longer be active.  Note that this may take place after
+ * the game has asked for the next keypress, but the various "keypress"
+ * routines should be able to handle this.
+ */
+static char borg_inkey_hack(int flush_first)
+{
+    char ch;
+
+    int y = 0;
+    int x = 80;
+
+    byte t_a;
+
+    char buf[1024];
+
+bool borg_prompt;  /* ajg  For now we can just use this locally.
+                           in the 283 borg he uses this to optimize knowing if
+                           we are waiting at a prompt for info */
+
+    /* Locate the cursor */
+    (void)Term_locate(&x, &y);
+
+#ifndef BORG_TK
+    /* Refresh the screen */
+    Term_fresh();
+#endif /* not BORG_TK */
+
+    /* Deactivate */
+    if (!borg_active)
+    {
+        /* Message */
+        borg_note("# Removing keypress hook");
+
+        /* Remove hook */
+        inkey_hack = NULL;
+
+        /* Flush keys */
+        borg_flush();
+
+        /* Flush */
+        flush();
+#ifdef BORG_TK
+        angtk_eval("angband_borg", "deactivate", NULL);
+#endif /* BORG_TK */
+
+        /* Done */
+        return (0);
+    }
+
+
+    /* Mega-Hack -- flush keys */
+    if (flush_first)
+    {
+        /* Only flush if needed */
+        if (borg_inkey(FALSE) != 0)
+        {
+            /* Message */
+            borg_note("# Flushing keypress buffer");
+
+            /* Flush keys */
+            borg_flush();
+
+            /* Cycle a few times to catch up if needed */
+            if (time_this_panel > 250)
+            {
+				borg_respawning = 3;
+			}
+        }
+    }
+
+
+#ifdef BORG_TK
+    /* Do this after flushing (or else?) */
+    if (inkey_flags)
+        Bind_Generic(EVENT_INKEY, inkey_flags);
+#endif /* BORG_TK */
+
+    /* Assume no prompt/message is available */
+    borg_prompt = FALSE;
+
+#ifdef BORG_TK
+
+    /* Mega-Hack -- check for possible prompts/messages */
+    if (strlen(angtk_prompt_text))
+    {
+        /* Get the text */
+        strcpy(buf, angtk_prompt_text);
+
+        /* Assume a prompt/message is available */
+        borg_prompt = TRUE;
+    }
+    /* with 292, there is a flush() introduced as it asks for confirmation.
+     * This flush is messing up the borg.  This will allow the borg to
+     * work around the flush
+     * Attempt to catch "Attempt it anyway? [y/n]"
+     */
+    if (borg_prompt && !inkey_flag &&
+        streq(buf, "Atte"))
+    {
+        /* Return the confirmation */
+        borg_note("# Confirming use of Spell/Prayer.");
+        return ('y');
+    }
+
+    /* with 292, there is a flush() introduced as it asks for confirmation.
+     * This flush is messing up the borg.  This will allow the borg to
+     * work around the flush
+     * This is used only with emergency use of spells like Magic Missile
+     * Attempt to catch "Direction (5 old target"
+     */
+    if (borg_prompt && !inkey_flag && borg_confirm_target &&
+        streq(buf, "Dire"))
+    {
+        /* reset the flag */
+        borg_confirm_target = FALSE;
+        /* Return 5 for old target */
+            return ('5');
+    }
+
+
+    /* Mega-Hack -- Catch "Die? [y/n]" messages */
+    if (borg_prompt && !inkey_flag &&
+        streq(buf, "Die? [y/n]"))
+    {
+        /* Flush messages */
+        borg_parse(NULL);
+
+        /* flush the buffer */
+        borg_flush();
+
+        /* Take note */
+        borg_note("# Cheating death...");
+
+#ifndef BABLOS
+        /* Dump the Character Map*/
+        if (borg_skill[BI_CLEVEL] >= borg_dump_level ||
+            strstr(p_ptr->died_from, "starvation")) borg_write_map(FALSE);
+
+        /* Log the death */
+        borg_log_death();
+        borg_log_death_data();
+
+        /* Note in score file */
+        borg_enter_score();
+
+        /* Reset the player game data then resurrect a new player */
+        resurrect_borg();
+#endif /* BABLOS */
+
+        /* Cheat death */
+        return ('n');
+    }
+
+
+    /* Mega-Hack -- Handle death */
+    if (p_ptr->is_dead)
+    {
+
+#ifndef BABLOS
+        /* Print the map */
+        if (borg_skill[BI_CLEVEL] >= borg_dump_level ||
+            strstr(p_ptr->died_from, "starvation"))  borg_write_map(FALSE);
+
+        /* Log death */
+        borg_log_death();
+        borg_log_death_data();
+
+        /* Note the score */
+        borg_enter_score();
+#endif /* BABLOS */
+
+        /* flush the buffer */
+        borg_flush();
+
+        if (borg_cheat_death)
+        {
+            /* Reset death flag */
+            p_ptr->is_dead = FALSE;
+
+#ifndef BABLOS
+            /* Reset the player game data then resurrect a new player */
+            resurrect_borg();
+#endif /* BABLOS */
+
+        }
+        else
+        {
+            /* Oops  */
+            borg_oops("player died");
+
+            /* Useless keypress */
+            return (KTRL('C'));
+        }
+    }
+
+
+    /* Mega-Hack -- Catch "-more-" messages */
+    if (borg_prompt && (inkey_flags == INKEY_MORE))
+    {
+        char msg[160];
+
+        strcpy(msg, buf);
+        msg[strlen(msg) - 7] = '\0';
+
+        /* Parse it */
+        borg_parse(msg);
+
+        /* Clear the message */
+        return (KTRL('M'));
+    }
+
+    /* Mega-Hack -- catch normal messages */
+    if (borg_prompt && inkey_flag)
+    {
+        int k = strlen(buf);
+
+        /* Strip trailing spaces */
+        while ((k > 0) && (buf[k-1] == ' ')) k--;
+
+        /* Terminate */
+        buf[k] = '\0';
+
+        /* Parse it */
+        borg_parse(buf);
+
+        /* Clear the message */
+        return (KTRL('M'));
+    }
+
+#else /* Not BORG_TK will follow */
+
+    /* Mega-Hack -- check for possible prompts/messages */
+    /* If the first four characters on the message line all */
+    /* have the same attribute (or are all spaces), and they */
+    /* are not all spaces (ascii value 0x20)... */
+    if ((0 == borg_what_text(0, 0, 4, &t_a, buf)) &&
+        (t_a != TERM_DARK) &&
+        (*((u32b*)(buf)) != 0x20202020))
+    {
+        /* Assume a prompt/message is available */
+        borg_prompt = TRUE;
+    }
+
+
+    /* Mega-Hack -- Catch "Die? [y/n]" messages */
+    /* If there is text on the first line... */
+    /* And the game does not want a command... */
+    /* And the cursor is on the top line... */
+    /* And the text acquired above is "Die?" */
+    if (borg_prompt && !inkey_flag &&
+        (y == 0) && (x >= 4) &&
+        streq(buf, "Die?") &&
+        borg_cheat_death)
+    {
+        /* Flush messages */
+        borg_parse(NULL);
+
+        /* flush the buffer */
+        borg_flush();
+
+        /* Take note */
+        borg_note("# Cheating death...");
+
+#ifndef BABLOS
+        /* Dump the Character Map*/
+        if (borg_skill[BI_CLEVEL] >= borg_dump_level ||
+            strstr(p_ptr->died_from, "starvation")) borg_write_map(FALSE);
+
+        /* Log the death */
+        borg_log_death();
+        borg_log_death_data();
+
+        /* Note the score */
+        borg_enter_score();
+
+        /* Reset the player game data then resurrect a new player */
+        resurrect_borg();
+
+#endif /* BABLOS */
+
+        /* Cheat death */
+        return ('n');
+    }
+
+    /* with 292, there is a flush() introduced as it asks for confirmation.
+     * This flush is messing up the borg.  This will allow the borg to
+     * work around the flush
+     * Attempt to catch "Attempt it anyway? [y/n]"
+     */
+    if (borg_prompt && !inkey_flag &&
+        (y == 0) && (x >= 4) &&
+        streq(buf, "Atte"))
+    {
+        /* Return the confirmation */
+        borg_note("# Confirming use of Spell/Prayer.");
+        return ('y');
+    }
+
+    /* with 292, there is a flush() introduced as it asks for confirmation.
+     * This flush is messing up the borg.  This will allow the borg to
+     * work around the flush
+     * This is used only with emergency use of spells like Magic Missile
+     * Attempt to catch "Direction (5 old target"
+     */
+    if (borg_prompt && !inkey_flag && borg_confirm_target &&
+        (y == 0) && (x >= 4) &&
+        streq(buf, "Dire"))
+    {
+        /* reset the flag */
+        borg_confirm_target = FALSE;
+        /* Return 5 for old target */
+            return ('5');
+    }
+
+    /* Mega-Hack -- Handle death */
+    if (p_ptr->is_dead)
+    {
+#ifndef BABLOS
+        /* Print the map */
+        if (borg_skill[BI_CLEVEL] >= borg_dump_level ||
+            strstr(p_ptr->died_from, "starvation"))  borg_write_map(FALSE);
+
+        /* Log death */
+        borg_log_death();
+        borg_log_death_data();
+
+        /* Note the score */
+        borg_enter_score();
+
+#endif /* bablos */
+        /* flush the buffer */
+        borg_flush();
+
+        if (borg_cheat_death)
+        {
+            /* Reset death flag */
+            p_ptr->is_dead = FALSE;
+#ifndef BABLOS
+            /* Reset the player game data then resurrect a new player */
+            resurrect_borg();
+#endif /* bablos */
+        }
+        else
+        {
+            /* Oops  */
+            borg_oops("player died");
+
+            /* Useless keypress */
+            return (KTRL('C'));
+        }
+    }
+
+
+    /* Mega-Hack -- Catch "-more-" messages */
+    /* If there is text on the first line... */
+    /* And the game does not want a command... */
+    /* And the cursor is on the top line... */
+    /* And there is text before the cursor... */
+    /* And that text is "-more-" */
+    if (borg_prompt && !inkey_flag &&
+        (y == 0) && (x >= 7) &&
+        (0 == borg_what_text(x-7, y, 7, &t_a, buf)) &&
+        (streq(buf, " -more-")))
+    {
+        /* Get the message */
+        if (0 == borg_what_text(0, 0, x-7, &t_a, buf))
+        {
+            /* Parse it */
+            borg_parse(buf);
+        }
+        /* Clear the message */
+        return (KTRL('M'));
+    }
+
+
+    /* Mega-Hack -- catch normal messages */
+    /* If there is text on the first line... */
+    /* And the game wants a command */
+    if (borg_prompt && inkey_flag)
+    {
+        /* Get the message(s) */
+/*         if (0 == borg_what_text(0, 0, -w, &t_a, buf)) */
+        if (0 == borg_what_text(0, 0, -80, &t_a, buf))
+        {
+            int k = strlen(buf);
+
+            /* Strip trailing spaces */
+            while ((k > 0) && (buf[k-1] == ' ')) k--;
+
+            /* Terminate */
+            buf[k] = '\0';
+
+            /* Parse it */
+            borg_parse(buf);
+        }
+
+        /* Clear the message */
+        return (KTRL('M'));
+#endif /* not BORG_TK */
+    }
+    /* Flush messages */
+    borg_parse(NULL);
+    borg_dont_react = FALSE;
+
+    /* Check for key */
+    ch = borg_inkey(TRUE);
+
+    /* Use the key */
+    if (ch) return (ch);
+
+
+    /* Check for user abort */
+    (void)Term_inkey(&ch, FALSE, FALSE);
+
+    /* User Abort */
+    if (ch != 0)
+    {
+        /* Oops */
+        borg_oops("user abort");
+
+        /* Hack -- Escape */
+        return (ESCAPE);
+    }
+
+    /* Save the system random info */
+    borg_rand_quick = Rand_quick;
+    borg_rand_value = Rand_value;
+
+    /* Use the local random info */
+    Rand_quick = TRUE;
+    Rand_value = borg_rand_local;
+
+
+    /* Think */
+    while (!borg_think()) /* loop */;
+
+    /* DVE- Update the status screen */
+    borg_status();
+
+    /* Save the local random info */
+    borg_rand_local = Rand_value;
+
+    /* Restore the system random info */
+    Rand_quick = borg_rand_quick;
+    Rand_value = borg_rand_value;
+
+    /* Hack -- allow stepping to induce a clean cancel */
+    if (borg_step && (!--borg_step)) borg_cancel = TRUE;
+
+
+    /* Check for key */
+    ch = borg_inkey(TRUE);
+
+    /* Use the key */
+    if (ch) return (ch);
+
+
+    /* Oops */
+    borg_oops("normal abort");
+
+    /* Hack -- Escape */
+    return (ESCAPE);
+}
+
+/*
+ * Output a long int in binary format.
+ */
+static void borg_prt_binary(u32b flags, int row, int col)
+{
+	int        	i;
+	u32b        bitmask;
+
+	/* Scan the flags */
+	for (i = bitmask = 1; i <= 32; i++, bitmask *= 2)
+	{
+		/* Dump set bits */
+		if (flags & bitmask)
+		{
+			Term_putch(col++, row, TERM_BLUE, '*');
+		}
+
+		/* Dump unset bits */
+		else
+		{
+			Term_putch(col++, row, TERM_WHITE, '-');
+		}
+	}
+}
+
+/* this will display the values which the borg believes an
+ * item has.  Select the item by inven # prior to hitting
+ * the ^zo.
+ */
+static void borg_display_item(object_type *item2)
+{
+	int j = 0;
+
+	u32b f1, f2, f3;
+
+	borg_item *item;
+
+	item = &borg_items[p_ptr->command_arg];
+
+	/* Extract the flags */
+	object_flags(item2, &f1, &f2, &f3);
+
+	/* Clear screen */
+	Term_clear();
+
+	/* Describe fully */
+	prt(item->desc, 2, j);
+
+	prt(format("kind = %-5d  level = %-4d  tval = %-5d  sval = %-5d",
+	           item->kind, item->level,
+	           item->tval, item->sval), 4, j);
+
+	prt(format("number = %-3d  wgt = %-6d  ac = %-5d    damage = %dd%d",
+	           item->iqty, item->weight,
+	           item->ac, item->dd, item->ds), 5, j);
+
+	prt(format("pval = %-5d  toac = %-5d  tohit = %-4d  todam = %-4d",
+	           item->pval, item->to_a, item->to_h, item->to_d), 6, j);
+
+	prt(format("name1 = %-4d  name2 = %-4d  value = %d   cursed = %ld",
+	           item->name1, item->name2, (long)item->value, item->cursed), 7, j);
+
+	prt(format("*id*need = %d  able = %d      fully_id = %d  timeout = %-d",
+	           item->needs_I, item->able, item->fully_identified, item->timeout), 8, j);
+
+	/* maybe print the inscription */
+	prt(format("Inscription: %s, activation: %d",item->note, item->activation),9,j);
+
+	prt("+------------FLAGS1------------+", 10, j);
+	prt("AFFECT..........SLAY.......BRAND", 11, j);
+	prt("                ae      xxxpaefc", 12, j);
+	prt("siwdcc  ssidsasmnvudotgddduoclio", 13, j);
+	prt("tnieoh  trnipthgiinmrrnrrmniierl", 14, j);
+	prt("rtsxna..lcfgdkttmldncltggndsdced", 15, j);
+	if (item->able) borg_prt_binary(f1, 16, j);
+
+	prt("+------------FLAGS2------------+", 17, j);
+	prt("SUST........IMM.RESIST.........", 18, j);
+	prt("            afecaefcpfldbc s n  ", 19, j);
+	prt("siwdcc      cilocliooeialoshnecd", 20, j);
+	prt("tnieoh      irelierliatrnnnrethi", 21, j);
+	prt("rtsxna......decddcedsrekdfddxhss", 22, j);
+	if (item->fully_identified) borg_prt_binary(f2, 23, j);
+
+	prt("+------------FLAGS3------------+", 10, j+32);
+	prt("s   ts h     tadiiii   aiehs  hp", 11, j+32);
+	prt("lf  eefo     egrgggg  bcnaih  vr", 12, j+32);
+	prt("we  lerl    ilgannnn  ltssdo  ym", 13, j+32);
+	prt("da reied    merirrrr  eityew ccc", 14, j+32);
+	prt("itlepnel    ppanaefc  svaktm uuu", 15, j+32);
+	prt("ghigavai    aoveclio  saanyo rrr", 16, j+32);
+	prt("seteticf    craxierl  etropd sss", 17, j+32);
+	prt("trenhste    tttpdced  detwes eee", 18, j+32);
+	if (item->fully_identified) borg_prt_binary(f3, 19, j+32);
+}
+
+
+#ifdef ALLOW_BORG_GRAPHICS
+
+glyph translate_visuals[255][255];
+
+/*
+ * Return the "attr" for a given item.
+ * Use "flavor" if available.
+ * Default to user definitions.
+ */
+#define object_kind_attr(T) \
+   (((T)->flavor) ? \
+    (flavor_info[(T)->flavor].x_attr) : \
+    ((T)->x_attr))
+
+/*
+ * Return the "char" for a given item.
+ * Use "flavor" if available.
+ * Default to user definitions.
+ */
+#define object_kind_char(T) \
+   (((T)->flavor) ? \
+    (flavor_info[(T)->flavor].x_char) : \
+    ((T)->x_char))
+
+
+void init_translate_visuals(void)
+{
+    int i, j;
+
+    bool graf_new = (use_graphics && streq(ANGBAND_GRAF, "new"));
+
+
+    /* Extract default attr/char code for features */
+    for (i = 0; i < z_info->f_max; i++)
+    {
+        feature_type *f_ptr = &f_info[i];
+
+        if (!f_ptr->name) continue;
+
+        /* Store the underlying values */
+        translate_visuals[(byte)f_ptr->x_attr][(byte)f_ptr->x_char].d_attr = f_ptr->d_attr;
+        translate_visuals[(byte)f_ptr->x_attr][(byte)f_ptr->x_char].d_char = f_ptr->d_char;
+
+        /* Add the various ASCII lighting levels */
+        if (f_ptr->x_attr == TERM_WHITE)
+        {
+            translate_visuals[TERM_YELLOW][(byte)f_ptr->x_char].d_attr = f_ptr->d_attr;
+            translate_visuals[TERM_YELLOW][(byte)f_ptr->x_char].d_char = f_ptr->d_char;
+
+            translate_visuals[TERM_L_DARK][(byte)f_ptr->x_char].d_attr = f_ptr->d_attr;
+            translate_visuals[TERM_L_DARK][(byte)f_ptr->x_char].d_char = f_ptr->d_char;
+
+            translate_visuals[TERM_SLATE][(byte)f_ptr->x_char].d_attr = f_ptr->d_attr;
+            translate_visuals[TERM_SLATE][(byte)f_ptr->x_char].d_char = f_ptr->d_char;
+        }
+        else if (graf_new && feat_supports_lighting((byte)i) &&
+                 (f_ptr->x_char & 0x80) && (f_ptr->x_attr & 0x80))
+        {
+            translate_visuals[(byte)f_ptr->x_attr][(byte)f_ptr->x_char + 1].d_attr = f_ptr->d_attr;
+            translate_visuals[(byte)f_ptr->x_attr][(byte)f_ptr->x_char + 1].d_char = f_ptr->d_char;
+
+            translate_visuals[(byte)f_ptr->x_attr][(byte)f_ptr->x_char + 2].d_attr = f_ptr->d_attr;
+            translate_visuals[(byte)f_ptr->x_attr][(byte)f_ptr->x_char + 2].d_char = f_ptr->d_char;
+        }
+    }
+
+    /* Extract default attr/char code for objects */
+    for (i = 0; i < z_info->k_max; i++)
+    {
+        object_kind *k_ptr = &k_info[i];
+
+        if (!k_ptr->name) continue;
+
+        /* Store the underlying values */
+        translate_visuals[(byte)object_kind_attr(k_ptr)][(byte)object_kind_char(k_ptr)].d_attr = k_ptr->d_attr;
+        translate_visuals[(byte)object_kind_attr(k_ptr)][(byte)object_kind_char(k_ptr)].d_char = k_ptr->d_char;
+    }
+
+    /* Extract default attr/char code for monsters */
+    for (i = 0; i < z_info->r_max; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+
+        if (!r_ptr->name) continue;
+
+        /* Store the underlying values */
+        translate_visuals[(byte)r_ptr->x_attr][(byte)r_ptr->x_char].d_attr = r_ptr->d_attr;
+        translate_visuals[(byte)r_ptr->x_attr][(byte)r_ptr->x_char].d_char = r_ptr->d_char;
+
+        /* Multi-hued monster in ASCII mode */
+        if ((r_ptr->flags1 & (RF1_ATTR_MULTI)) &&
+            !((r_ptr->x_attr & 0x80) && (r_ptr->x_char & 0x80)))
+        {
+            for (j = 0; j < 16; j++)
+            {
+                translate_visuals[j][(byte)r_ptr->x_char].d_attr = j;
+                translate_visuals[j][(byte)r_ptr->x_char].d_char = r_ptr->d_char;
+            }
+        }
+    }
+}
+
+#endif /* ALLOW_BORG_GRAPHICS */
+
+static int
+borg_getval(char ** string, char * val)
+{
+    char    string2[4];
+    int     retval;
+
+    if (!prefix(*string, val))
+    {
+        return -1000;
+    }
+    (*string) += strlen(val);
+    memmove(string2, *string, 3);
+    string2[3] = 0;
+    sscanf(string2, "%d", &retval);
+    *string+=3;
+    return retval;
+}
+
+static bool borg_load_formula(char * string)
+{
+    int formula_num;
+    int iformula = 0;
+    int x = 0;
+    int value= 0;
+    char string2[4];
+
+    memmove(string2, string, 3);
+    string2[3] = 0;
+    sscanf(string2, "%d", &formula_num);
+    string+=4;
+    if (formula[formula_num])
+    {
+        borg_note(format("formula defined twice %03d", formula_num));
+        return FALSE;
+    }
+    C_MAKE(formula[formula_num], MAX_FORMULA_ELEMENTS, int);
+
+    while (string && *string)
+    {
+        switch (*string)
+        {
+            case ' ':
+                string++;
+                continue;
+            case '0':
+            case '1':
+            case '2':
+            case '3':
+            case '4':
+            case '5':
+            case '6':
+            case '7':
+            case '8':
+            case '9':
+                sscanf(string, "%d", &value);
+                if (iformula+2 > MAX_FORMULA_ELEMENTS)
+                {
+                    borg_note(format("too many elements in formula %03d", formula_num));
+                    formula[formula_num][0] = BFO_NUMBER;
+                    formula[formula_num][1] = 0;
+                    return FALSE;
+                }
+                formula[formula_num][iformula++] = BFO_NUMBER;
+                formula[formula_num][iformula++] = value;
+                break;
+            case '_':
+                if (iformula+2 > MAX_FORMULA_ELEMENTS)
+                {
+                    borg_note(format("too many elements in formula %03d", formula_num));
+                    formula[formula_num][0] = BFO_NUMBER;
+                    formula[formula_num][1] = 0;
+                    return FALSE;
+                }
+                formula[formula_num][iformula++] = BFO_VARIABLE;
+                if (-1000 != (value = borg_getval(&string, "_ITEM")))
+                {
+                    formula[formula_num][iformula++] = value;
+                    break;
+                }
+                if (-1000 != (value = borg_getval(&string, "_WITEM")))
+                {
+                    formula[formula_num][iformula++] = value + z_info->k_max;
+                    break;
+                }
+                if (-1000 != (value = borg_getval(&string, "_ARTIFACT")))
+                {
+                    formula[formula_num][iformula++] = value +
+                                                       z_info->k_max +
+                                                       z_info->k_max;
+                    break;
+                }
+
+                for (x = 0; x < BI_MAX; x++)
+                {
+                    if (prefix(string, prefix_pref[x]))
+                    {
+                        value = z_info->k_max + z_info->k_max + z_info->a_max + x;
+                        formula[formula_num][iformula++] = value;
+                        break;
+                    }
+                }
+                if (x == BI_MAX)
+                {
+                    formula[formula_num][0] = BFO_NUMBER;
+                    formula[formula_num][1] = 0;
+                    borg_note(format("bad item in formula%03d %s", formula_num, string));
+                    return FALSE;
+                }
+
+                break;
+            default:
+                if (iformula+1 > MAX_FORMULA_ELEMENTS)
+                {
+                    borg_note(format("too many elements in formula %03d", formula_num));
+                    formula[formula_num][0] = BFO_NUMBER;
+                    formula[formula_num][1] = 0;
+                    return FALSE;
+                }
+                if (*string == '>')
+                {
+                    if (*(string+1) == '=')
+                    {
+                        formula[formula_num][iformula++] = BFO_GTE;
+                        break;
+                    }
+                    formula[formula_num][iformula++] = BFO_GT;
+                    break;
+                }
+                if (*string == '<')
+                {
+                    if (*(string+1) == '=')
+                    {
+                        formula[formula_num][iformula++] = BFO_LTE;
+                        break;
+                    }
+                    formula[formula_num][iformula++] = BFO_LT;
+                    break;
+                }
+                if (*string == '!')
+                {
+                    if (*(string+1) == '=')
+                        formula[formula_num][iformula++] = BFO_NEQ;
+                    else
+                        formula[formula_num][iformula++] = BFO_NOT;
+                    break;
+                }
+                if (*string == '=')
+                {
+                    formula[formula_num][iformula++] = BFO_EQ;
+                    break;
+                }
+                if (*string == '&')
+                {
+                    formula[formula_num][iformula++] = BFO_AND;
+                    break;
+                }
+                if (*string == '-')
+                {
+                    /* - followed by space is a minus.  */
+                    if (*(string+1) == ' ')
+                    {
+                        formula[formula_num][iformula++] = BFO_MINUS;
+                        break;
+                    }
+                    if (iformula+1 > MAX_FORMULA_ELEMENTS)
+                    {
+                        borg_note(format("too many elements in formula %03d", formula_num));
+                        formula[formula_num][0] = BFO_NUMBER;
+                        formula[formula_num][1] = 0;
+                        return FALSE;
+                    }
+
+                    /* - followed by anything else is a negative number */
+                    sscanf(string, "%d", &value);
+                    formula[formula_num][iformula++] = BFO_NUMBER;
+                    formula[formula_num][iformula++] = value;
+                    break;
+                }
+                if (*string == '+')
+                {
+                    formula[formula_num][iformula++] = BFO_PLUS;
+                    break;
+                }
+                if (*string == '/')
+                {
+                    formula[formula_num][iformula++] = BFO_DIVIDE;
+                    break;
+                }
+                if (*string == '*')
+                {
+                    formula[formula_num][iformula++] = BFO_MULT;
+                    break;
+                }
+                if (*string == '|')
+                {
+                    formula[formula_num][iformula++] = BFO_OR;
+                    break;
+                }
+                borg_note(format("bad item in formula %03d %s", formula_num, string));
+                formula[formula_num][0] = BFO_NUMBER;
+                formula[formula_num][1] = 0;
+                return FALSE;
+        }
+        string = strchr(string, ' ');
+    }
+    if (!borg_check_formula(formula[formula_num]))
+    {
+        borg_note(format("bad formula %03d", formula_num));
+        formula[formula_num][0] = BFO_NUMBER;
+        formula[formula_num][1] = 0;
+        return FALSE;
+    }
+    return TRUE;
+}
+
+
+static bool add_power_item(int class_num,
+                           int depth_num,
+                           int cnd_num,
+                           int range_to,
+                           int range_from,
+                           bool each,
+                           int item_num,
+                           int power)
+{
+    if ((class_num >= z_info->c_max &&
+        class_num != 999 ) ||
+        depth_num >= MAX_DEPTH ||
+        item_num >= (z_info->k_max + z_info->k_max + z_info->a_max + BI_MAX) ||
+        range_to < range_from)
+    {
+        borg_note("Malformed item power in borg.txt: values out of range");
+        return FALSE;
+    }
+    /* The class 999 is for all classes */
+    if (class_num == 999)
+    {
+        for (class_num = 0; class_num < z_info->c_max; class_num ++)
+        {
+            borg_power_item[class_num][n_pwr[class_num]].depth = depth_num;
+            borg_power_item[class_num][n_pwr[class_num]].cnd = cnd_num;
+            borg_power_item[class_num][n_pwr[class_num]].item = item_num;
+            borg_power_item[class_num][n_pwr[class_num]].power = power;
+            borg_power_item[class_num][n_pwr[class_num]].from = range_from;
+            borg_power_item[class_num][n_pwr[class_num]].to = range_to;
+            borg_power_item[class_num][n_pwr[class_num]].each = each;
+            n_pwr[class_num]++;
+        }
+    }
+    else
+    {
+        borg_power_item[class_num][n_pwr[class_num]].depth = depth_num;
+        borg_power_item[class_num][n_pwr[class_num]].cnd = cnd_num;
+        borg_power_item[class_num][n_pwr[class_num]].item = item_num;
+        borg_power_item[class_num][n_pwr[class_num]].power = power;
+        borg_power_item[class_num][n_pwr[class_num]].from = range_from;
+        borg_power_item[class_num][n_pwr[class_num]].to = range_to;
+        borg_power_item[class_num][n_pwr[class_num]].each = each;
+        n_pwr[class_num]++;
+    }
+    return TRUE;
+}
+
+static bool borg_load_power(char * string)
+{
+    int class_num= -1;
+    int depth_num= -1;
+    int cnd_num = -1;
+    int range_to= -1;
+    int range_from= -1;
+    bool each = FALSE;
+    int item_num= -1;
+    int power= -1;
+    int x;
+
+
+    if (-1000 == (class_num = borg_getval(&string, "_CLASS")))
+    {
+        borg_note("Malformed item power in borg.txt: missing _CLASS");
+        return FALSE;
+    }
+    if (-1000 == (depth_num = borg_getval(&string, "_DEPTH")))
+    {
+        borg_note("Malformed item power in borg.txt: missing _DEPTH");
+        return FALSE;
+    }
+    if (-1000 == (cnd_num = borg_getval(&string, "_CND")))
+    {
+        /* condition is optional */
+        cnd_num = -1;
+    }
+    if (-1000 == (range_from = borg_getval(&string, "_RANGE")))
+    {
+        borg_note("Malformed item power in borg.txt: missing _RANGE");
+        return FALSE;
+    }
+    if (-1000 == (range_to = borg_getval(&string, "TO")))
+    {
+        borg_note("Malformed item power in borg.txt: messed up _RANGE");
+        return FALSE;
+    }
+
+    if (-1000 != (item_num = borg_getval(&string, "_FORMULA")))
+    {
+        if (range_to != 999 || range_from != 0)
+        {
+            borg_note("Malformed item power in borg.txt: range must be 0-999 formulas");
+            return FALSE;
+        }
+        return add_power_item(class_num,
+                       depth_num,
+                       cnd_num,
+                       range_to,
+                       range_from,
+                       each,
+                       -1,
+                       item_num);
+    }
+    if (-1000 != (item_num = borg_getval(&string, "_ITEM")))
+    {
+        string++;
+        sscanf(string, "%d", &power);
+        if (strstr(string, "EACH"))
+            each = TRUE;
+
+        return add_power_item(class_num,
+                       depth_num,
+                       cnd_num,
+                       range_to,
+                       range_from,
+                       each,
+                       item_num,
+                       power);
+    }
+    if (-1000 != (item_num = borg_getval(&string, "_WITEM")))
+    {
+        string++;
+        sscanf(string, "%d", &power);
+        if (strstr(string, "EACH"))
+            each = TRUE;
+
+        return add_power_item(class_num,
+                       depth_num,
+                       cnd_num,
+                       range_to,
+                       range_from,
+                       each,
+                       z_info->k_max + item_num,
+                       power);
+    }
+    if (-1000 != (item_num = borg_getval(&string, "_ARTIFACT")))
+    {
+        string++;
+        sscanf(string, "%d", &power);
+        if (strstr(string, "EACH"))
+            each = TRUE;
+        item_num += z_info->k_max + z_info->k_max;
+        return add_power_item(class_num,
+                       depth_num,
+                       cnd_num,
+                       range_to,
+                       range_from,
+                       each,
+                       item_num,
+                       power);
+    }
+
+    for (x = 0; x < BI_MAX; x++)
+    {
+
+        if (prefix(string, prefix_pref[x]))
+        {
+            string += strlen(prefix_pref[x]);
+            item_num = z_info->k_max + z_info->k_max + z_info->a_max + x;
+            string++;
+            sscanf(string, "%d", &power);
+            if (strstr(string, "EACH"))
+                each = TRUE;
+            return add_power_item(class_num,
+                           depth_num,
+                           cnd_num,
+                           range_to,
+                           range_from,
+                           each,
+                           item_num,
+                           power);
+        }
+    }
+    borg_note("Malformed item power in borg.txt");
+    return FALSE;
+}
+static bool add_required_item(int class_num, int depth_num, int item_num, int number_items)
+{
+    if ((class_num >= z_info->c_max &&
+        class_num != 999 ) ||
+        depth_num >= MAX_DEPTH ||
+        item_num >= (z_info->k_max + z_info->k_max + z_info->a_max + BI_MAX))
+    {
+        borg_note("Malformed item requirment in borg.txt: value out of range");
+        return FALSE;
+    }
+    /* The class 999 is for all classes */
+    if (class_num == 999)
+    {
+        for (class_num = 0; class_num < z_info->c_max; class_num ++)
+        {
+            borg_required_item[class_num][n_req[class_num]].depth = depth_num;
+            borg_required_item[class_num][n_req[class_num]].item = item_num;
+            borg_required_item[class_num][n_req[class_num]].number = number_items;
+            n_req[class_num]++;
+        }
+    }
+    else
+    {
+        borg_required_item[class_num][n_req[class_num]].depth = depth_num;
+        borg_required_item[class_num][n_req[class_num]].item = item_num;
+        borg_required_item[class_num][n_req[class_num]].number = number_items;
+        n_req[class_num]++;
+    }
+    return TRUE;
+}
+
+static bool borg_load_requirement(char * string)
+{
+    int class_num=-1;
+    int depth_num=-1;
+    int item_num=-1;
+    int number_items=-1;
+    int x=-1;
+
+    if (-1000 == (class_num = borg_getval(&string, "_CLASS")))
+    {
+        borg_note("Malformed item requirment in borg.txt");
+        return FALSE;
+    }
+    if (-1000 == (depth_num = borg_getval(&string, "_DEPTH")))
+    {
+        borg_note("Malformed item requirment in borg.txt");
+        return FALSE;
+    }
+    if (-1000 != (item_num = borg_getval(&string, "_FORMULA")))
+    {
+        return add_required_item(class_num, depth_num, -1, item_num);
+    }
+    if (-1000 != (item_num = borg_getval(&string, "_ITEM")))
+    {
+        string++;
+        sscanf(string, "%d", &number_items);
+        return add_required_item(class_num, depth_num, item_num, number_items);
+    }
+    if (-1000 != (item_num = borg_getval(&string, "_WITEM")))
+    {
+        string++;
+        sscanf(string, "%d", &number_items);
+        return add_required_item(class_num, depth_num,  z_info->k_max + item_num, number_items);
+    }
+    if (-1000 != (item_num = borg_getval(&string, "_ARTIFACT")))
+    {
+        string++;
+        sscanf(string, "%d", &number_items);
+        return add_required_item(class_num, depth_num, z_info->k_max + z_info->k_max +item_num, number_items);
+    }
+
+    for (x = 0; x < BI_MAX; x++)
+    {
+
+        if (prefix(string, prefix_pref[x]))
+        {
+            string += strlen(prefix_pref[x]);
+            item_num = z_info->k_max + z_info->k_max + z_info->a_max + x;
+            string++;
+            sscanf(string, "%d", &number_items);
+            return add_required_item(class_num, depth_num, item_num, number_items);
+        }
+    }
+    borg_note("Malformed item requirment in borg.txt");
+    return FALSE;
+}
+
+/* just used to do a quick sort on the required items array */
+int borg_item_cmp(const void * item1, const void * item2)
+{
+    if (((req_item*)item1)->depth != ((req_item*)item2)->depth)
+        return ((req_item*)item1)->depth - ((req_item*)item2)->depth;
+    if (((req_item*)item1)->item != ((req_item*)item2)->item)
+        return ((req_item*)item1)->item - ((req_item*)item2)->item;
+    return ((req_item*)item1)->number - ((req_item*)item2)->number;
+}
+
+
+/*
+ * Initialize borg.txt
+ */
+void init_borg_txt_file(void)
+{
+
+    FILE *fp;
+
+    char buf[1024];
+    int i;
+
+    /* Array of borg variables is stored as */
+    /* 0 to k_max = items in inventory */
+    /* k_max to 2*k_max  = items being worn */
+    /* 2*k_max to a_max  = artifacts worn */
+    /* 2*k_max + a_max to end of array = Other skills/possessions */
+    size_obj = z_info->k_max + z_info->k_max + z_info->a_max + BI_MAX;
+
+    /* note: C_MAKE automaticly 0 inits things */
+
+    for (i = 0; i < z_info->c_max; i++)
+    {
+        C_MAKE(borg_required_item[i], 400, req_item); /* externalize the 400 later */
+        n_req[i] = 0;
+        C_MAKE(borg_power_item[i], 400, power_item); /* externalize the 400 later */
+        n_pwr[i] = 0;
+    }
+    for (i = 0; i < 999; i++)
+    {
+        formula[i] = 0;
+    }
+    C_MAKE(borg_has, size_obj, int);
+
+    /* make some shortcut pointers into the array */
+    borg_has_on = borg_has + z_info->k_max;
+    borg_artifact = borg_has_on + z_info->k_max;
+    borg_skill = borg_artifact + z_info->a_max;
+#ifdef BORG_TK
+    path_build(buf, 1024, BORG_DIR_ROOT, "borg.prf");
+#else /* BORG_TK */
+    path_build(buf, 1024, ANGBAND_DIR_USER, "borg.txt");
+#endif /* BORG_TK */
+
+    /* Open the file */
+    fp = my_fopen(buf, "r");
+
+    /* No file, use defaults*/
+    if (!fp)
+    {
+        /* Complain */
+        msg_print("*****WARNING***** You do not have a proper BORG.TXT file!");
+        msg_print("Make sure BORG.TXT is located in the \\user\\ subdirectory!");
+        msg_print(NULL);
+
+        /* use default values */
+        borg_worships_damage = FALSE;
+        borg_worships_speed = FALSE;
+        borg_worships_hp= FALSE;
+        borg_worships_mana = FALSE;
+        borg_worships_ac = FALSE;
+        borg_worships_gold = FALSE;
+        borg_plays_risky = FALSE;
+        borg_scums_uniques = TRUE;
+        borg_uses_swaps = TRUE;
+        borg_slow_optimizehome = FALSE;
+        borg_stop_dlevel = 128;
+        borg_stop_clevel = 55;
+		borg_no_deeper = 127;
+        borg_stop_king = TRUE;
+        borg_uses_calcs = FALSE;
+        borg_respawn_winners = FALSE;
+        borg_respawn_class = -1;
+        borg_respawn_race = -1;
+        borg_chest_fail_tolerance = 7;
+        borg_delay_factor = 1;
+        borg_money_scum_amount = 0;
+		borg_self_scum = TRUE;
+		borg_lunal_mode = FALSE;
+		borg_self_lunal = TRUE;
+        return;
+    }
+
+
+    /* Parse the file */
+/* AJG needed to make this wider so I could read long formulas */
+    while (0 == my_fgets(fp, buf, sizeof(buf)-1))
+    {
+        /* Skip comments and blank lines */
+        if (!buf[0] || (buf[0] == '#')) continue;
+
+        /* Chop the buffer */
+        buf[sizeof(buf)-1] = '\0';
+
+        /* Extract the true/false */
+        if (prefix(buf, "borg_worships_damage ="))
+        {
+            if (buf[strlen("borg_worships_damage =")+1] == 'T' ||
+                buf[strlen("borg_worships_damage =")+1] == '1' ||
+                buf[strlen("borg_worships_damage =")+1] == 't')
+                borg_worships_damage=TRUE;
+            else
+                borg_worships_damage = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_worships_speed ="))
+        {
+            if (buf[strlen("borg_worships_speed =")+1] == 'T' ||
+                buf[strlen("borg_worships_speed =")+1] == '1' ||
+                buf[strlen("borg_worships_speed =")+1] == 't') borg_worships_speed=TRUE;
+            else borg_worships_speed = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_worships_hp ="))
+        {
+            if (buf[strlen("borg_worships_hp =")+1] == 'T' ||
+                buf[strlen("borg_worships_hp =")+1] == '1' ||
+                buf[strlen("borg_worships_hp =")+1] == 't') borg_worships_hp=TRUE;
+            else borg_worships_hp= FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_worships_mana ="))
+        {
+            if (buf[strlen("borg_worships_mana =")+1] == 'T' ||
+                buf[strlen("borg_worships_mana =")+1] == '1' ||
+                buf[strlen("borg_worships_mana =")+1] == 't') borg_worships_mana=TRUE;
+            else borg_worships_mana = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_worships_ac ="))
+        {
+            if (buf[strlen("borg_worships_ac =")+1] == 'T' ||
+                buf[strlen("borg_worships_ac =")+1] == '1' ||
+                buf[strlen("borg_worships_ac =")+1] == 't') borg_worships_ac=TRUE;
+            else borg_worships_ac= FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_worships_gold ="))
+        {
+            if (buf[strlen("borg_worships_gold =")+1] == 'T' ||
+                buf[strlen("borg_worships_gold =")+1] == '1' ||
+                buf[strlen("borg_worships_gold =")+1] == 't') borg_worships_gold=TRUE;
+            else borg_worships_gold= FALSE;
+            continue;
+        }
+
+
+        if (prefix(buf, "borg_plays_risky ="))
+        {
+            if (buf[strlen("borg_plays_risky =")+1] == 'T' ||
+                buf[strlen("borg_plays_risky =")+1] == '1' ||
+                buf[strlen("borg_plays_risky =")+1] == 't') borg_plays_risky=TRUE;
+            else borg_plays_risky = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_scums_uniques ="))
+        {
+            if (buf[strlen("borg_scums_uniques =")+1] == 'T' ||
+                buf[strlen("borg_scums_uniques =")+1] == '1' ||
+                buf[strlen("borg_scums_uniques =")+1] == 't') borg_scums_uniques=TRUE;
+            else borg_scums_uniques = FALSE;
+            continue;
+        }
+        if (prefix(buf, "borg_uses_swaps ="))
+        {
+            if (buf[strlen("borg_uses_swaps =")+1] == 'T' ||
+                buf[strlen("borg_uses_swaps =")+1] == '1' ||
+                buf[strlen("borg_uses_swaps =")+1] == 't') borg_uses_swaps=TRUE;
+            else borg_uses_swaps = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_slow_optimizehome ="))
+        {
+            if (buf[strlen("borg_slow_optimizehome =")+1] == 'T' ||
+                buf[strlen("borg_slow_optimizehome =")+1] == '1' ||
+                buf[strlen("borg_slow_optimizehome =")+1] == 't') borg_slow_optimizehome=TRUE;
+            else borg_slow_optimizehome = FALSE;
+
+            /* for now always leave as false since its broken */
+            borg_slow_optimizehome = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_stop_king ="))
+        {
+            if (buf[strlen("borg_stop_king =")+1] == 'T' ||
+                buf[strlen("borg_stop_king =")+1] == '1' ||
+                buf[strlen("borg_stop_king =")+1] == 't') borg_stop_king=TRUE;
+            else borg_stop_king = FALSE;
+            continue;
+        }
+
+
+        if (prefix(buf, "borg_uses_dynamic_calcs ="))
+        {
+            if (buf[strlen("borg_uses_dynamic_calcs =")+1] == 'T' ||
+                buf[strlen("borg_uses_dynamic_calcs =")+1] == '1' ||
+                buf[strlen("borg_uses_dynamic_calcs =")+1] == 't') borg_uses_calcs=TRUE;
+            else borg_uses_calcs = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_respawn_winners ="))
+        {
+            if (buf[strlen("borg_respawn_winners =")+1] == 'T' ||
+                buf[strlen("borg_respawn_winners =")+1] == '1' ||
+                buf[strlen("borg_respawn_winners =")+1] == 't') borg_respawn_winners = TRUE;
+            else borg_respawn_winners = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_lunal_mode ="))
+        {
+            if (buf[strlen("borg_lunal_mode =")+1] == 'T' ||
+                buf[strlen("borg_lunal_mode =")+1] == '1' ||
+                buf[strlen("borg_lunal_mode =")+1] == 't') borg_lunal_mode = TRUE;
+            else borg_lunal_mode = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_self_lunal ="))
+        {
+            if (buf[strlen("borg_self_lunal =")+1] == 'T' ||
+                buf[strlen("borg_self_lunal =")+1] == '1' ||
+                buf[strlen("borg_self_lunal =")+1] == 't') borg_self_lunal = TRUE;
+            else borg_self_lunal = FALSE;
+            continue;
+        }
+
+        if (prefix(buf, "borg_self_scum ="))
+        {
+            if (buf[strlen("borg_self_scum =")+1] == 'T' ||
+                buf[strlen("borg_self_scum =")+1] == '1' ||
+                buf[strlen("borg_self_scum =")+1] == 't') borg_self_scum = TRUE;
+            else borg_self_scum = FALSE;
+            continue;
+        }
+
+
+        /* Extract the integers */
+        if (prefix(buf, "borg_respawn_race ="))
+        {
+            sscanf(buf+strlen("borg_respawn_race =")+1, "%d", &borg_respawn_race);
+            continue;
+        }
+        if (prefix(buf, "borg_respawn_class ="))
+        {
+            sscanf(buf+strlen("borg_respawn_class =")+1, "%d", &borg_respawn_class);
+            continue;
+        }
+        if (prefix(buf, "borg_dump_level ="))
+        {
+            sscanf(buf+strlen("borg_dump_level =")+1, "%d", &borg_dump_level);
+            continue;
+        }
+
+        if (prefix(buf, "borg_save_death ="))
+        {
+            sscanf(buf+strlen("borg_save_death =")+1, "%d", &borg_save_death);
+            continue;
+        }
+
+        if (prefix(buf, "borg_stop_clevel ="))
+        {
+            sscanf(buf+strlen("borg_stop_clevel =")+1, "%d", &borg_stop_clevel);
+            continue;
+        }
+        if (prefix(buf, "borg_stop_dlevel ="))
+        {
+            sscanf(buf+strlen("borg_stop_dlevel =")+1, "%d", &borg_stop_dlevel);
+            continue;
+        }
+        if (prefix(buf, "borg_no_deeper ="))
+        {
+            sscanf(buf+strlen("borg_no_deeper =")+1, "%d", &borg_no_deeper);
+            continue;
+        }
+        if (prefix(buf, "borg_chest_fail_tolerance ="))
+        {
+            sscanf(buf+strlen("borg_chest_fail_tolerance =")+1, "%d", &borg_chest_fail_tolerance);
+            continue;
+        }
+        if (prefix(buf, "borg_delay_factor ="))
+        {
+            sscanf(buf+strlen("borg_delay_factor =")+1, "%d", &borg_delay_factor);
+            if (borg_delay_factor >= 9) borg_delay_factor = 9;
+            continue;
+        }
+        if (prefix(buf, "borg_money_scum_amount ="))
+        {
+            sscanf(buf+strlen("borg_money_scum_amount =")+1, "%d",  &borg_money_scum_amount);
+            continue;
+        }
+
+        if (prefix(buf, "REQ"))
+        {
+            if (!borg_load_requirement(buf+strlen("REQ")))
+                borg_note(buf);
+            continue;
+        }
+        if (prefix(buf, "FORMULA"))
+        {
+            if (!borg_load_formula(buf+strlen("FORMULA")))
+                borg_note(buf);
+            continue;
+        }
+        if (prefix(buf, "CND"))
+        {
+            if (!borg_load_formula(buf+strlen("CND")))
+            borg_note(buf);
+            continue;
+        }
+        if (prefix(buf, "POWER"))
+        {
+            if (!borg_load_power(buf+strlen("POWER")))
+                borg_note(buf);
+
+            continue;
+        }
+    }
+
+    /* Close it */
+    my_fclose(fp);
+
+    for (i = 0; i < z_info->c_max; i++)
+        qsort(borg_required_item[i], n_req[i], sizeof(req_item), borg_item_cmp);
+
+    /* make sure it continues to run if reset */
+    if (borg_respawn_winners) borg_stop_king = FALSE;
+
+    /* Success */
+    return;
+}
+
+/*
+ * Initialize the Borg
+ */
+void borg_init_9(void)
+{
+    byte *test;
+	int i;
+
+
+    /*** Hack -- verify system ***/
+
+    /* Message */
+    prt("Initializing the Borg... (memory)", 0, 0);
+
+    /* Hack -- flush it */
+    Term_fresh();
+
+    /* Mega-Hack -- verify memory */
+    C_MAKE(test, 400 * 1024L, byte);
+    FREE(test);
+
+
+    /*** Hack -- initialize some stuff ***/
+    C_MAKE(borg_required_item, z_info->c_max, req_item*);
+    C_MAKE(n_req, z_info->c_max, int);
+    C_MAKE(borg_power_item, z_info->c_max, power_item*);
+    C_MAKE(n_pwr, z_info->c_max, int);
+
+
+    /*** Hack -- initialize borg.ini options ***/
+
+    /* Message */
+    prt("Initializing the Borg... (borg.txt)", 0, 0);
+    init_borg_txt_file();
+
+
+    /*** Hack -- initialize game options ***/
+
+    /* Message */
+    prt("Initializing the Borg... (options)", 0, 0);
+
+    /* Hack -- flush it */
+    Term_fresh();
+
+    /* We use the original keypress codes */
+    rogue_like_commands = FALSE;
+
+    /* No auto_more */
+    auto_more = FALSE;
+
+    /* We pick up items when we step on them */
+    always_pickup = TRUE;
+
+    /* We specify targets by hand */
+    use_old_target = FALSE;
+
+    /* We must use the top object in stacks */
+    floor_query_flag = FALSE;
+
+    /* We must pick items up without verification */
+    carry_query_flag = FALSE;
+
+    /* We repeat by hand */
+    always_repeat = FALSE;
+
+    /* We do not haggle */
+	/* auto_haggle = TRUE; */
+
+    /* We do not start Scumming */
+    auto_scum = FALSE;
+
+    /* We need space */
+    show_labels = FALSE;
+    show_weights = FALSE;
+    show_flavors = FALSE;
+
+    /* We need the dungeon level */
+    depth_in_feet = FALSE;
+
+    /* Allow items to stack */
+    stack_force_notes = TRUE;
+    stack_force_costs = TRUE;
+
+
+    /* Ignore discounts */
+    stack_force_costs = TRUE;
+
+    /* Ignore inscriptions */
+    stack_force_notes = TRUE;
+
+    /* Efficiency */
+    avoid_abort = TRUE;
+
+    /* Efficiency */
+    op_ptr->hitpoint_warn = 0;
+
+    /* Hack -- notice "command" mode */
+    hilite_player = FALSE;
+
+#if 0
+    /* for now, please turn this off.  It crashes from multihued guys */
+    borg_graphics = FALSE;
+#endif
+
+   /* The "easy" options confuse the Borg */
+   easy_open = FALSE;
+   easy_alter = FALSE;
+   easy_floor = FALSE;
+
+#ifdef BORG_TK
+
+#ifdef ALLOW_EASY_SENSE
+    easy_sense = FALSE;
+#endif /* ALLOW_EASY_SENSE */
+
+#ifdef ALLOW_EASY_RING
+    easy_ring = FALSE; /* This could actually help the Borg! */
+#endif /* ALLOW_EASY_RING */
+
+#ifdef ALLOW_REMEMBER_RECALL
+    remember_recall = FALSE;
+#endif /* ALLOW_REMEMBER_RECALL */
+
+#endif /* BORG_TK */
+
+#ifndef ALLOW_BORG_GRAPHICS
+    if (!borg_graphics)
+    {
+        /* Reset the # and % -- Scan the features */
+        for (i = 1; i < z_info->f_max; i++)
+        {
+            feature_type *f_ptr = &f_info[i];
+
+            /* Skip non-features */
+            if (!f_ptr->name) continue;
+
+            /* Switch off "graphics" */
+            f_ptr->x_attr = f_ptr->d_attr;
+            f_ptr->x_char = f_ptr->d_char;
+        }
+    }
+#endif
+
+#ifdef ALLOW_BORG_GRAPHICS
+
+   init_translate_visuals();
+
+#else /* ALLOW_BORG_GRAPHICS */
+
+#ifdef USE_GRAPHICS
+#ifndef BORG_TK
+   /* The Borg can't work with graphics on, so switch it off */
+   if (use_graphics)
+   {
+       /* Reset to ASCII mode */
+       use_graphics = FALSE;
+       arg_graphics = FALSE;
+
+       /* Reset visuals */
+       reset_visuals(TRUE);
+   }
+#endif /* not BORG_TK */
+#endif /* USE_GRAPHICS */
+
+#endif /* ALLOW_BORG_GRAPHICS */
+
+    /*** Redraw ***/
+    /* Redraw map */
+    p_ptr->redraw |= (PR_MAP);
+
+    /* Window stuff */
+    p_ptr->window |= (PW_OVERHEAD);
+
+    /* Redraw everything */
+    do_cmd_redraw();
+    /*** Various ***/
+
+    /* Message */
+    prt("Initializing the Borg... (various)", 0, 0);
+
+    /* Hack -- flush it */
+    Term_fresh();
+
+
+    /*** Cheat / Panic ***/
+
+    /* more cheating */
+    borg_cheat_death = FALSE;
+
+    /* set the continous play mode if the game cheat death is on */
+    if (cheat_live) borg_cheat_death = TRUE;
+
+    /*** Initialize ***/
+
+    /* Initialize */
+    borg_init_1();
+    borg_init_2();
+    borg_init_3();
+    borg_init_4();
+    borg_init_5();
+    borg_init_6();
+    borg_init_7();
+    borg_init_8();
+
+#if 0
+	/* Maintain a correct base for randart values. */
+	for (i = 0; i < artifact_count; i++)
+	{
+		artifact_type *a_ptr = &a_info[i];
+
+		borg_art_save_tval[i] = a_ptr->tval;
+		borg_art_save_sval[i] = a_ptr->sval;
+		borg_art_save_pval[i] = a_ptr->pval;
+
+		borg_art_save_to_h[i] = a_ptr->to_h;
+		borg_art_save_to_d[i] = a_ptr->to_d;
+		borg_art_save_to_a[i] = a_ptr->to_a;
+		borg_art_save_ac[i] = a_ptr->ac;
+
+		borg_art_save_dd[i] = a_ptr->dd;
+		borg_art_save_ds[i] = a_ptr->ds;
+
+		borg_art_save_weight[i] = a_ptr->weight;
+
+		borg_art_save_cost[i] = a_ptr->cost;
+
+		borg_art_save_flags1[i] = a_ptr->flags1;
+		borg_art_save_flags2[i] = a_ptr->flags2;
+		borg_art_save_flags3[i] = a_ptr->flags3;
+
+		borg_art_save_level[i] = a_ptr->level;
+		borg_art_save_rarity[i] = a_ptr->rarity;
+
+		borg_art_save_activation[i] = a_ptr->activation;
+		borg_art_save_time[i] = a_ptr->time;
+		borg_art_save_randtime[i] = a_ptr->randtime;
+	}
+#endif
+
+    /*** Hack -- Extract race ***/
+
+    /* Insert the player Race--cheat */
+    borg_race = p_ptr->prace;
+
+    /* Extract the race pointer */
+    rb_ptr = &p_info[borg_race];
+
+
+    /*** Hack -- Extract class ***/
+    borg_class = p_ptr->pclass;
+
+    /* Extract the class pointer */
+    cb_ptr = &c_info[borg_class];
+
+    /* Extract the magic pointer */
+    mb_ptr = &cb_ptr->spells;
+
+
+    /*** Hack -- react to race and class ***/
+
+    /* Notice the new race and class */
+    prepare_race_class_info();
+
+
+    /*** All done ***/
+
+    /* Done initialization */
+    prt("Initializing the Borg... done.", 0, 0);
+
+    /* Clear line */
+    prt("", 0, 0);
+
+    /* Reset the clock */
+    borg_t = 10;
+
+    /* Official message */
+    borg_note("# Ready...");
+
+    /* Now it is ready */
+    initialized = TRUE;
+}
+
+#ifndef BABLOS
+/*
+ * Write a file with the current dungeon info (Borg)
+ * and his equipment, inventory and home (Player)
+ * and his swap armor, weapon (Borg)
+ * From Dennis Van Es,  With an addition of last messages from me (APW)
+ */
+void borg_write_map(bool ask)
+{
+    char buf2[1024];
+    char buf[80];
+    FILE *borg_map_file;
+    char line[DUNGEON_WID + 1];
+
+    borg_item *item;
+
+    int i,j;
+	int to, itemm;
+
+    s16b m_idx;
+
+    store_type *st_ptr = &store[7];
+
+    bool *okay;
+#ifdef BORG_TK
+    char o_name[O_NAME_MAX];
+#else
+    char o_name[80];
+#endif
+    /* Allocate the "okay" array */
+    C_MAKE(okay, z_info->a_max, bool);
+
+    /* Hack -- drop permissions */
+    safe_setuid_drop();
+
+    /* Process the player name */
+    for (i = 0; op_ptr->full_name[i]; i++)
+    {
+        char c = op_ptr->full_name[i];
+
+        /* No control characters */
+        if (iscntrl(c))
+        {
+            /* Illegal characters */
+            quit_fmt("Illegal control char (0x%02X) in player name", c);
+        }
+
+        /* Convert all non-alphanumeric symbols */
+        if (!isalpha(c) && !isdigit(c)) c = '_';
+
+        /* Build "file_name" */
+        buf[i] = c;
+    }
+
+    /* Terminate */
+    buf[i++] = '.';
+    buf[i++] = 'm';
+    buf[i++] = 'a';
+    buf[i++] = 'p';
+    buf[i++] = '\0';
+#ifdef BORG_TK
+    path_build(buf2, 1024, BORG_DIR_DATA, buf);
+#else /* BORG_TK */
+    path_build(buf2, 1024, ANGBAND_DIR_USER, buf);
+#endif /* BORG_TK */
+
+    /* XXX XXX XXX Get the name and open the map file */
+    if (ask && get_string("Borg map File: ", buf2, 70))
+    {
+        /* Open a new file */
+        borg_map_file = my_fopen(buf2, "a");
+
+        /* Failure */
+        if (!borg_map_file) msg_print("Cannot open that file.");
+    }
+    else if (!ask) borg_map_file = my_fopen(buf2, "a");
+
+    /* Hack -- grab permissions */
+    safe_setuid_grab();
+
+   fprintf(borg_map_file, "%s the %s %s, Level %d/%d\n", op_ptr->full_name,
+           p_name + p_info[p_ptr->prace].name,
+           c_name + c_info[p_ptr->pclass].name,
+           p_ptr->lev, p_ptr->max_lev);
+
+   fprintf(borg_map_file, "Exp: %lu  Gold: %lu  Turn: %lu\n", (long)total_points(), (long)p_ptr->au, (long)turn);
+   fprintf(borg_map_file, "Killed on level: %d (max. %d) by %s\n\n", p_ptr->depth, p_ptr->max_depth, p_ptr->died_from);
+   fprintf(borg_map_file, "Borg Compile Date: %s\n", borg_engine_date);
+
+    for (i = 0; i < DUNGEON_HGT; i++)
+    {
+        for (j = 0; j < DUNGEON_WID; j++)
+        {
+            char ch;
+
+            borg_grid *ag= &borg_grids[i][j];
+            m_idx = cave_m_idx[i][j];
+
+
+            /* reset the ch each time through */
+            ch = ' ';
+
+            /* Known grids */
+            if (ag->feat)
+            {
+                ch = f_info[ag->feat].d_char;
+            }
+
+            /* Known Items */
+            if (ag->take)
+            {
+                borg_take *take = &borg_takes[ag->take];
+                object_kind *k_ptr = &k_info[take->k_idx];
+                ch = k_ptr->d_char;
+            }
+
+            /* UnKnown Monsters */
+            if (m_idx)
+            {
+                ch = '&';
+            }
+
+            /* Known Monsters */
+            if (ag->kill)
+            {
+                borg_kill *kill = &borg_kills[ag->kill];
+                monster_race *r_ptr = &r_info[kill->r_idx];
+                ch = r_ptr->d_char;
+            }
+
+
+            /* The Player */
+            if ((i == c_y) && (j == c_x)) ch = '@';
+
+            line[j] = ch;
+        }
+        /* terminate the line */
+        line[j++] = '\0';
+
+        fprintf(borg_map_file, "%s\n", line);
+    }
+
+
+    /* Known/Seen monsters */
+    for (i = 1; i < borg_kills_nxt; i++)
+    {
+        borg_kill *kill = &borg_kills[i];
+
+        /* Skip dead monsters */
+        if (!kill->r_idx) continue;
+
+        /* Note */
+        fprintf(borg_map_file,"monster '%s' (%d) at (%d,%d) speed:%d \n",
+                         (r_name + r_info[kill->r_idx].name), kill->r_idx,
+                         kill->y, kill->x, kill->speed);
+    }
+
+    /*** Dump the last few messages ***/
+    i = message_num();
+    if (i > 250) i = 250;
+    fprintf(borg_map_file, "\n\n  [Last Messages]\n\n");
+    while (i-- >0)
+    {
+        cptr msg  = message_str((s16b)i);
+
+        /* Eliminate some lines */
+        if (prefix(msg, "# Matched")
+        ||  prefix(msg, "# There is")
+        ||  prefix(msg, "# Tracking")
+        ||  prefix(msg, "# MISS_BY:")
+        ||  prefix(msg, "# HIT_BY:")
+        ||  prefix(msg, "> "))
+            continue;
+
+        fprintf(borg_map_file, "%s\n", msg);
+    }
+
+    /*** Player Equipment ***/
+    fprintf(borg_map_file, "\n\n  [Character Equipment]\n\n");
+    for (i = INVEN_WIELD; i < INVEN_TOTAL; i++)
+    {
+        object_desc(o_name, sizeof(o_name), &inventory[i], TRUE, 3);
+        fprintf(borg_map_file, "%c) %s\n",
+                index_to_label(i), o_name);
+    }
+
+    fprintf(borg_map_file, "\n\n");
+
+
+    /* Dump the inventory */
+    fprintf(borg_map_file, "  [Character Inventory]\n\n");
+    for (i = 0; i < INVEN_PACK; i++)
+    {
+		borg_item *item = &borg_items[i];
+
+        fprintf(borg_map_file, "%c) %s\n",
+                index_to_label(i), item->desc);
+    }
+    fprintf(borg_map_file, "\n\n");
+
+
+    /* Dump the Home (page 1) */
+    fprintf(borg_map_file, "  [Home Inventory (page 1)]\n\n");
+    for (i = 0; i < 12; i++)
+    {
+        object_desc(o_name, sizeof(o_name), &st_ptr->stock[i], TRUE, 3);
+        fprintf(borg_map_file, "%c) %s\n", I2A(i%12), o_name);
+    }
+    fprintf(borg_map_file, "\n\n");
+
+    /* Dump the Home (page 2) */
+    fprintf(borg_map_file, "  [Home Inventory (page 2)]\n\n");
+    for (i = 12; i < 24; i++)
+    {
+        object_desc(o_name, sizeof(o_name), &st_ptr->stock[i], TRUE, 3);
+        fprintf(borg_map_file, "%c) %s\n", I2A(i%12), o_name);
+    }
+    fprintf(borg_map_file, "\n\n");
+
+    /* Write swap info */
+    if (borg_uses_swaps)
+    {
+        fprintf(borg_map_file, "  [Swap info]\n\n");
+        item = &borg_items[weapon_swap];
+        fprintf(borg_map_file,"Swap Weapon:  %s\n", item->desc);
+        item = &borg_items[armour_swap];
+        fprintf(borg_map_file,"Swap Armour:  %s", item->desc);
+        fprintf(borg_map_file, "\n\n");
+    }
+    fprintf(borg_map_file, "   [Player State at Death] \n\n");
+
+    /* Dump the player state */
+    fprintf(borg_map_file,  format("Current speed: %d. \n", borg_skill[BI_SPEED]));
+
+    if (p_ptr->blind)
+    {
+        fprintf(borg_map_file,  "You cannot see.\n");
+    }
+    if (p_ptr->confused)
+    {
+        fprintf(borg_map_file,  "You are confused.\n");
+    }
+    if (p_ptr->afraid)
+    {
+        fprintf(borg_map_file,  "You are terrified.\n");
+    }
+    if (p_ptr->cut)
+    {
+        fprintf(borg_map_file,  "You are bleeding.\n");
+    }
+    if (p_ptr->stun)
+    {
+        fprintf(borg_map_file,  "You are stunned.\n");
+    }
+    if (p_ptr->poisoned)
+    {
+        fprintf(borg_map_file,  "You are poisoned.\n");
+    }
+    if (p_ptr->image)
+    {
+        fprintf(borg_map_file,  "You are hallucinating.\n");
+    }
+    if (p_ptr->aggravate)
+    {
+        fprintf(borg_map_file,  "You aggravate monsters.\n");
+    }
+    if (p_ptr->blessed)
+    {
+        fprintf(borg_map_file,  "You feel rightous.\n");
+    }
+    if (p_ptr->hero)
+    {
+        fprintf(borg_map_file,  "You feel heroic.\n");
+    }
+    if (p_ptr->shero)
+    {
+        fprintf(borg_map_file,  "You are in a battle rage.\n");
+    }
+    if (p_ptr->protevil)
+    {
+        fprintf(borg_map_file,  "You are protected from evil.\n");
+    }
+    if (p_ptr->shield)
+    {
+        fprintf(borg_map_file,  "You are protected by a mystic shield.\n");
+    }
+    if (p_ptr->invuln)
+    {
+        fprintf(borg_map_file,  "You are temporarily invulnerable.\n");
+    }
+    if (p_ptr->confusing)
+    {
+        fprintf(borg_map_file,  "Your hands are glowing dull red.\n");
+    }
+    if (p_ptr->word_recall)
+    {
+        fprintf(borg_map_file,  format("You will soon be recalled.  (%d turns)\n", p_ptr->word_recall));
+    }
+    if (p_ptr->oppose_fire)
+    {
+        fprintf(borg_map_file,  format("You resist fire exceptionally well.\n"));
+    }
+    if (p_ptr->oppose_acid)
+    {
+        fprintf(borg_map_file,  format("You resist acid exceptionally well.\n"));
+    }
+    if (p_ptr->oppose_elec)
+    {
+        fprintf(borg_map_file,  format("You resist elec exceptionally well.\n"));
+    }
+    if (p_ptr->oppose_cold)
+    {
+        fprintf(borg_map_file,  format("You resist cold exceptionally well.\n"));
+    }
+    if (p_ptr->oppose_pois)
+    {
+        fprintf(borg_map_file,  format("You resist poison exceptionally well.\n"));
+    }
+    fprintf(borg_map_file, "\n\n");
+
+	/* Dump the Time Variables */
+    fprintf(borg_map_file, "Time on this panel; %d\n", time_this_panel);
+    fprintf(borg_map_file, "Time on this level; %d\n", borg_t - borg_began);
+    fprintf(borg_map_file, "Time since left town; %d\n", borg_time_town + (borg_t - borg_began));
+    fprintf(borg_map_file, "Food in town; %d\n", borg_food_onsale);
+    fprintf(borg_map_file, "Fuel in town; %d\n", borg_fuel_onsale);
+    fprintf(borg_map_file, "Borg_no_retreat; %d\n", borg_no_retreat);
+    fprintf(borg_map_file, "Breeder_level; %d\n", breeder_level);
+    fprintf(borg_map_file, "Unique_on_level; %d\n", unique_on_level);
+    if ((turn % (10L * TOWN_DAWN)) < ((10L * TOWN_DAWN) / 2))
+		fprintf(borg_map_file, "It is daytime in town.\n");
+    else fprintf(borg_map_file, "It is night-time in town.\n");
+    fprintf(borg_map_file, "\n\n");
+
+    fprintf(borg_map_file, "borg_uses_swaps; %d\n", borg_uses_swaps);
+    fprintf(borg_map_file, "borg_worships_damage; %d\n", borg_worships_damage);
+    fprintf(borg_map_file, "borg_worships_speed; %d\n", borg_worships_speed);
+    fprintf(borg_map_file, "borg_worships_hp; %d\n", borg_worships_hp);
+    fprintf(borg_map_file, "borg_worships_mana; %d\n",borg_worships_mana);
+    fprintf(borg_map_file, "borg_worships_ac; %d\n",borg_worships_ac);
+    fprintf(borg_map_file, "borg_worships_gold; %d\n",borg_worships_gold);
+    fprintf(borg_map_file, "borg_plays_risky; %d\n",borg_plays_risky);
+    fprintf(borg_map_file, "borg_slow_optimizehome; %d\n\n",borg_slow_optimizehome);
+    fprintf(borg_map_file, "\n\n");
+
+
+    /* Dump the spells */
+    if (cp_ptr->spell_book)
+    {
+        fprintf(borg_map_file,"\n\n   [ Spells ] \n\n");
+        fprintf(borg_map_file,"Name                           Legal Times cast\n");
+        for (i = 0; i < 9; i++ )
+        {
+            for (j = 0; j < 8; j++)
+            {
+                borg_magic *as = &borg_magics[i][j];
+                cptr legal;
+                int failpercent =0;
+
+                if (as->level <99)
+                {
+                    if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+                    {
+                        legal = (borg_prayer_legal(i, j) ? "Yes" : "No ");
+	                    failpercent = (borg_prayer_fail_rate( i,  j));
+                    }
+                    else
+                    {
+                        legal = (borg_spell_legal(i, j) ? "Yes" : "No ");
+	                    failpercent = (borg_spell_fail_rate(i, j));
+                    }
+
+                    fprintf(borg_map_file,"%-30s   %s   %d   fail:%d \n",as->name, legal, (long)as->times, failpercent);
+                }
+            }
+            fprintf(borg_map_file,"\n");
+        }
+    }
+
+	/* Dump the borg_skill[] information */
+    itemm = z_info->k_max + z_info->k_max + z_info->a_max;
+    to = z_info->k_max + z_info->k_max + z_info->a_max + BI_MAX;
+    for (;itemm < to; itemm++)
+    {
+         fprintf(borg_map_file,"skill %d (%s) value= %d.\n",itemm,
+                      prefix_pref[itemm -
+                      z_info->k_max -
+                      z_info->k_max -
+                      z_info->a_max], borg_has[itemm]);
+	}
+
+#if 0
+    /*** Dump the Uniques and Artifact Lists ***/
+
+    /* Scan the artifacts */
+    for (k = 0; k < z_info->a_max; k++)
+    {
+        artifact_type *a_ptr = &a_info[k];
+
+        /* Default */
+        okay[k] = FALSE;
+
+        /* Skip "empty" artifacts */
+        if (!a_ptr->name) continue;
+
+        /* Skip "uncreated" artifacts */
+        if (!a_ptr->cur_num) continue;
+
+        /* Assume okay */
+        okay[k] = TRUE;
+    }
+
+    /* Check the dungeon */
+    for (y = 0; y < DUNGEON_HGT; y++)
+    {
+        for (x = 0; x < DUNGEON_WID; x++)
+        {
+            s16b this_o_idx, next_o_idx = 0;
+
+            /* Scan all objects in the grid */
+            for (this_o_idx = cave_o_idx[y][x]; this_o_idx; this_o_idx = next_o_idx)
+            {
+                object_type *o_ptr;
+
+                /* Get the object */
+                o_ptr = &o_list[this_o_idx];
+
+                /* Get the next object */
+                next_o_idx = o_ptr->next_o_idx;
+
+                /* Ignore non-artifacts */
+                if (!artifact_p(o_ptr)) continue;
+
+                /* Ignore known items */
+                if (object_known_p(o_ptr)) continue;
+
+                /* Note the artifact */
+                okay[o_ptr->name1] = FALSE;
+            }
+        }
+    }
+
+    /* Check the inventory and equipment */
+    for (i = 0; i < INVEN_TOTAL; i++)
+    {
+        object_type *o_ptr = &inventory[i];
+
+        /* Ignore non-objects */
+        if (!o_ptr->k_idx) continue;
+
+        /* Ignore non-artifacts */
+        if (!artifact_p(o_ptr)) continue;
+
+        /* Ignore known items */
+        if (object_known_p(o_ptr)) continue;
+
+        /* Note the artifact */
+        okay[o_ptr->name1] = FALSE;
+    }
+
+    fprintf(borg_map_file, "\n\n");
+
+
+    /* Hack -- Build the artifact name */
+    fprintf(borg_map_file, "   [Artifact Info] \n\n");
+
+    /* Scan the artifacts */
+    for (k = 0; k < z_info->a_max; k++)
+    {
+        artifact_type *a_ptr = &a_info[k];
+
+        /* List "dead" ones */
+        if (!okay[k]) continue;
+
+        /* Paranoia */
+        strcpy(o_name, "Unknown Artifact");
+
+        /* Obtain the base object type */
+        z = lookup_kind(a_ptr->tval, a_ptr->sval);
+
+        /* Real object */
+        if (z)
+        {
+            object_type *i_ptr;
+            object_type object_type_body;
+
+            /* Get local object */
+            i_ptr = &object_type_body;
+
+            /* Create fake object */
+            object_prep(i_ptr, z);
+
+            /* Make it an artifact */
+            i_ptr->name1 = k;
+
+            /* Describe the artifact */
+            object_desc_spoil(o_name, sizeof(o_name), i_ptr, FALSE, 0);
+        }
+
+        /* Hack -- Build the artifact name */
+        fprintf(borg_map_file, "The %s\n", o_name);
+    }
+
+    /* Free the "okay" array */
+    FREE(okay);
+    fprintf(borg_map_file, "\n\n");
+
+ /* Display known uniques
+  *
+  * Note that the player ghosts are ignored.  XXX XXX XXX
+  */
+    /* Allocate the "who" array */
+    C_MAKE(who, z_info->r_max, u16b);
+
+    /* Collect matching monsters */
+    for (i = 1, n = 0; i < z_info->r_max; i++)
+    {
+        monster_race *r_ptr = &r_info[i];
+        monster_lore *l_ptr = &l_list[i];
+
+        /* Require known monsters */
+        if (!cheat_know && !l_ptr->r_sights) continue;
+
+        /* Require unique monsters */
+        if (!(r_ptr->flags1 & (RF1_UNIQUE))) continue;
+
+        /* Collect "appropriate" monsters */
+        who[n++] = i;
+    }
+
+    borg_sort_comp = borg_sort_comp_hook;
+    borg_sort_swap = borg_sort_swap_hook;
+    /* Sort the array by dungeon depth of monsters */
+    borg_sort(who, &why, n);
+
+
+    /* Hack -- Build the artifact name */
+    fprintf(borg_map_file, "   [Unique Info] \n\n");
+
+    /* Print the monsters */
+    for (i = 0; i < n; i++)
+    {
+        monster_race *r_ptr = &r_info[who[i]];
+        bool dead = (r_ptr->max_num == 0);
+
+        /* Print a message */
+        fprintf(borg_map_file, "%s is %s\n",
+                (r_name + r_ptr->name),
+                (dead ? "dead" : "alive"));
+    }
+
+    /* Free the "who" array */
+    FREE(who);
+
+#endif  /* extra dump stuff */
+
+    my_fclose(borg_map_file);
+}
+
+/* Try to make a scumfile so we can see what went wrong. */
+void borg_save_scumfile(void)
+{
+	static char svSavefile[1024];
+	static char svSavefile2[1024];
+	int i;
+
+    /* Create a scum file */
+    if (borg_save_death  &&
+        (borg_skill[BI_CLEVEL] >= borg_dump_level ||
+        strstr(p_ptr->died_from, "starvation")))
+    {
+        memcpy(svSavefile, savefile, sizeof(savefile));
+        /* Process the player name */
+        for (i = 0; op_ptr->full_name[i]; i++)
+        {
+            char c = op_ptr->full_name[i];
+
+            /* No control characters */
+            if (iscntrl(c))
+            {
+                /* Illegal characters */
+                quit_fmt("Illegal control char (0x%02X) in player name", c);
+            }
+
+            /* Convert all non-alphanumeric symbols */
+            if (!isalpha(c) && !isdigit(c)) c = '_';
+
+            /* Build "file_name" */
+            svSavefile2[i] = c;
+        }
+        svSavefile2[i]  = 0;
+#ifdef BORG_TK
+             path_build(savefile, 1024, BORG_DIR_DATA, svSavefile2);
+#else /* BORG_TK */
+             path_build(savefile, 1024, ANGBAND_DIR_USER, svSavefile2);
+#endif /* BORG_TK */
+        }
+
+}
+#endif /* BABLOS */
+
+/* DVE's function for displaying the status of various info */
+/* Display what the borg is thinking DvE*/
+void borg_status(void)
+{
+#ifndef BORG_TK
+ int j;
+
+ /* Scan windows */
+ for (j = 0; j < 8; j++)
+ {
+  term *old = Term;
+
+  /* Unused */
+  if (!angband_term[j]) continue;
+
+  /* Check for borg status term */
+  if (op_ptr->window_flag[j] & (PW_BORG_2))
+  {
+   byte attr;
+
+   /* Activate */
+   Term_activate(angband_term[j]);
+
+   /* Display what resists the borg (thinks he) has */
+   Term_putstr(5, 0, -1,TERM_WHITE, "RESISTS");
+
+   /* Basic four */
+   attr = TERM_SLATE;
+   if (borg_skill[BI_RACID]) attr = TERM_BLUE;
+   if (my_oppose_acid) attr = TERM_GREEN;
+   if (borg_skill[BI_IACID]) attr = TERM_WHITE;
+   Term_putstr(1, 1, -1, attr, "Acid");
+
+   attr = TERM_SLATE;
+   if (borg_skill[BI_RELEC]) attr = TERM_BLUE;
+   if (my_oppose_elec) attr = TERM_GREEN;
+   if (borg_skill[BI_IELEC]) attr = TERM_WHITE;
+   Term_putstr(1, 2, -1, attr, "Elec");
+
+   attr = TERM_SLATE;
+   if (borg_skill[BI_RFIRE]) attr = TERM_BLUE;
+   if (my_oppose_fire) attr = TERM_GREEN;
+   if (borg_skill[BI_IFIRE]) attr = TERM_WHITE;
+   Term_putstr(1, 3, -1, attr, "Fire");
+
+   attr = TERM_SLATE;
+   if (borg_skill[BI_RCOLD]) attr = TERM_BLUE;
+   if (my_oppose_cold) attr = TERM_GREEN;
+   if (borg_skill[BI_ICOLD]) attr = TERM_WHITE;
+   Term_putstr(1, 4, -1, attr, "Cold");
+
+   /* High resists */
+   attr = TERM_SLATE;
+   if (borg_skill[BI_RPOIS]) attr = TERM_BLUE;
+   if (my_oppose_pois) attr = TERM_GREEN;
+   Term_putstr(1, 5, -1, attr, "Pois");
+
+   if (borg_skill[BI_RFEAR]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(1, 6, -1, attr, "Fear");
+
+   if (borg_skill[BI_RLITE]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(1, 7, -1, attr, "Lite");
+
+   if (borg_skill[BI_RDARK]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(1, 8, -1, attr, "Dark");
+
+   if (borg_skill[BI_RBLIND]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 1, -1, attr, "Blind");
+
+   if (borg_skill[BI_RCONF]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 2, -1, attr, "Confu");
+
+   if (borg_skill[BI_RSND]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 3, -1, attr, "Sound");
+
+   if (borg_skill[BI_RSHRD]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 4, -1, attr, "Shard");
+
+   if (borg_skill[BI_RNXUS]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 5, -1, attr, "Nexus");
+
+   if (borg_skill[BI_RNTHR]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 6, -1, attr, "Nethr");
+
+   if (borg_skill[BI_RKAOS]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 7, -1, attr, "Chaos");
+
+   if (borg_skill[BI_RDIS]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(6, 8, -1, attr, "Disen");
+
+   /* Other abilities */
+   if (borg_skill[BI_SDIG]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 1, -1, attr, "S.Dig");
+
+   if (borg_skill[BI_FEATH]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 2, -1, attr, "Feath");
+
+   if (borg_skill[BI_LITE]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 3, -1, attr, "PLite");
+
+   if (borg_skill[BI_REG]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 4, -1, attr, "Regen");
+
+   if (borg_skill[BI_ESP]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 5, -1, attr, "Telep");
+
+   if (borg_skill[BI_SINV]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 6, -1, attr, "Invis");
+
+   if (borg_skill[BI_FRACT]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 7, -1, attr, "FrAct");
+
+   if (borg_skill[BI_HLIFE]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(12, 8, -1, attr, "HLife");
+
+   /* Display the slays */
+   Term_putstr(5, 10, -1,TERM_WHITE, "Weapon Slays:");
+
+   if (borg_skill[BI_WS_ANIMAL]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(1, 11, -1, attr, "Animal");
+
+   if (borg_skill[BI_WS_EVIL]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(8, 11, -1, attr, "Evil");
+
+   if (borg_skill[BI_WS_UNDEAD]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(15, 11, -1, attr, "Undead");
+
+   if (borg_skill[BI_WS_DEMON]) attr = TERM_BLUE;
+   if (borg_skill[BI_WK_DEMON]) attr = TERM_GREEN;
+   else attr = TERM_SLATE;
+   Term_putstr(22, 11, -1, attr, "Demon");
+
+   if (borg_skill[BI_WS_ORC]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(1, 12, -1, attr, "Orc");
+
+   if (borg_skill[BI_WS_TROLL]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(8, 12, -1, attr, "Troll");
+
+   if (borg_skill[BI_WS_GIANT]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(15, 12, -1, attr, "Giant");
+
+   if (borg_skill[BI_WS_DRAGON]) attr = TERM_BLUE;
+   if (borg_skill[BI_WK_DRAGON]) attr = TERM_GREEN;
+   else attr = TERM_SLATE;
+   Term_putstr(22, 12, -1, attr, "Dragon");
+
+   if (borg_skill[BI_WB_ACID]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(1, 13, -1, attr, "Acid");
+
+   if (borg_skill[BI_WB_COLD]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(8, 13, -1, attr, "Cold");
+
+   if (borg_skill[BI_WB_ELEC]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(15, 13, -1, attr, "Elec");
+
+   if (borg_skill[BI_WB_FIRE]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(22, 13, -1, attr, "Fire");
+
+
+   /* Display the Concerns */
+   Term_putstr(36, 10, -1,TERM_WHITE, "Concerns:");
+
+   if (borg_wearing_cursed) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(29, 11, -1, attr, "Cursed");
+
+   if (borg_skill[BI_ISWEAK]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(36, 11, -1, attr, "Weak");
+
+   if (borg_skill[BI_ISPOISONED]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(43, 11, -1, attr, "Poison");
+
+   if (borg_skill[BI_ISCUT]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(29, 12, -1, attr, "Cut");
+
+   if (borg_skill[BI_ISSTUN]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(36, 12, -1, attr, "Stun");
+
+   if (borg_skill[BI_ISCONFUSED]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(43, 12, -1, attr, "Confused");
+
+   if (goal_fleeing) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(29, 13, -1, attr, "Goal Fleeing");
+
+   if (borg_skill[BI_ISFIXEXP]) attr = TERM_BLUE;
+   else attr = TERM_SLATE;
+   Term_putstr(43, 13, -1, attr, "Exp Drain");
+
+   /* Display the Time */
+   Term_putstr(60, 10, -1,TERM_WHITE, "Time:");
+
+   Term_putstr(54, 11, -1, TERM_SLATE, "This Level         ");
+   Term_putstr(65, 11, -1, TERM_WHITE, format("%d",borg_t - borg_began));
+
+   Term_putstr(54, 12, -1, TERM_SLATE, "Since Town         ");
+   Term_putstr(65, 12, -1, TERM_WHITE, format("%d",borg_time_town + (borg_t - borg_began)));
+
+   Term_putstr(54, 13, -1, TERM_SLATE, "This Panel         ");
+   Term_putstr(65, 13, -1, TERM_WHITE, format("%d",time_this_panel));
+
+
+   /* Sustains */
+   Term_putstr(19, 0, -1, TERM_WHITE, "Sustains");
+
+   if (borg_skill[BI_SSTR]) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(21, 1, -1, attr, "STR");
+
+   if (borg_skill[BI_SINT]) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(21, 2, -1, attr, "INT");
+
+   if (borg_skill[BI_SWIS]) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(21, 3, -1, attr, "WIS");
+
+   if (borg_skill[BI_SDEX]) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(21, 4, -1, attr, "DEX");
+
+   if (borg_skill[BI_SCON]) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(21, 5, -1, attr, "CON");
+
+   if (borg_skill[BI_SCHR]) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(21, 6, -1, attr, "CHR");
+
+
+   /* Temporary effects */
+   Term_putstr(28, 0, -1, TERM_WHITE, "Temp Effects");
+
+   if (borg_prot_from_evil) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(28, 1, -1, attr, "Prot. Evil");
+
+   if (borg_hero) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(28, 2, -1, attr, "Heroism");
+
+   if (borg_berserk) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(28, 3, -1, attr, "Berserk");
+
+   if (borg_shield) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(28, 4, -1, attr, "Shielded");
+
+   if (borg_bless) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(28, 5, -1, attr, "Blessed");
+
+    if (borg_speed) attr = TERM_WHITE;
+    else attr = TERM_SLATE;
+    Term_putstr(28, 6, -1, attr, "Fast");
+
+    if (borg_see_inv >= 1) attr = TERM_WHITE;
+    else attr = TERM_SLATE;
+    Term_putstr(28, 6, -1, attr, "See Inv");
+
+   /* Temporary effects */
+   Term_putstr(42, 0, -1, TERM_WHITE, "Level Information");
+
+   if (vault_on_level) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(42, 1, -1, attr, "Vault on level");
+
+   if (unique_on_level) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(42, 2, -1, attr, "Unique on level");
+   if (unique_on_level) Term_putstr(58, 2, -1, attr, format("(%s)",
+                       r_name + r_info[unique_on_level].name));
+   else Term_putstr(58, 2, -1, attr, "                                   ");
+
+   if (scaryguy_on_level) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(42, 3, -1, attr, "Scary Guy on level");
+
+   if (breeder_level) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(42, 4, -1, attr,"Breeder level (closing doors)");
+
+   if (borg_kills_summoner != -1) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(42, 5, -1, attr,"Summoner very close (AS-Corridor)");
+
+    /* level preparedness */
+   attr = TERM_SLATE;
+   Term_putstr(42, 6, -1, attr,"Reason for not diving:");
+   attr = TERM_WHITE;
+   Term_putstr(64, 6, -1, attr,format("%s                              ", borg_prepared(borg_skill[BI_MAXDEPTH]+1)));
+
+   if (borg_money_scum_amount != 0) attr = TERM_WHITE;
+   else attr = TERM_SLATE;
+   Term_putstr(42, 7, -1, attr,format("Money Scumming:$%d          ", borg_money_scum_amount));
+
+   attr = TERM_SLATE;
+   Term_putstr(42, 8, -1, attr,"Maximal Depth:");
+   attr = TERM_WHITE;
+   Term_putstr(56, 8, -1, attr,format("%d    ", borg_skill[BI_MAXDEPTH]));
+
+    /* Important endgame information */
+   if (borg_skill[BI_MAXDEPTH] >= 80)
+   {
+       Term_putstr(5, 15, -1,TERM_WHITE, "Important Deep Events:");
+
+       attr = TERM_SLATE;
+       Term_putstr(1, 16, -1, attr, "Home *Heal*:        ");
+       attr = TERM_WHITE;
+       Term_putstr(13, 16, -1, attr, format("%d   ",num_ez_heal));
+
+       attr = TERM_SLATE;
+       Term_putstr(1, 17, -1, attr, "Home Heal:        ");
+       attr = TERM_WHITE;
+       Term_putstr(11, 17, -1, attr, format("%d   ",num_heal));
+
+       attr = TERM_SLATE;
+       Term_putstr(1, 18, -1, attr, "Res_Mana:        ");
+       attr = TERM_WHITE;
+       Term_putstr(11, 18, -1, attr, format("%d   ",num_mana));
+
+       if (morgoth_on_level)  attr = TERM_BLUE;
+       else attr = TERM_SLATE;
+       Term_putstr(1, 19, -1, attr, format("Morgoth on Level.  Last seen:%d       ", borg_t - borg_t_morgoth));
+
+       if (borg_morgoth_position)  attr = TERM_BLUE;
+       else attr = TERM_SLATE;
+       if (borg_needs_new_sea) attr = TERM_WHITE;
+       Term_putstr(1, 20, -1, attr, "Sea of Runes.");
+
+       if (borg_ready_morgoth)  attr = TERM_BLUE;
+       else attr = TERM_SLATE;
+       Term_putstr(1, 21, -1, attr, "Ready for Morgoth.");
+   }
+   else
+   {
+       Term_putstr(5, 15, -1,TERM_WHITE, "                        ");
+
+       attr = TERM_SLATE;
+       Term_putstr(1, 16, -1, attr, "                    ");
+       attr = TERM_WHITE;
+       Term_putstr(10, 16, -1, attr, format("       ",num_ez_heal));
+
+       attr = TERM_SLATE;
+       Term_putstr(1, 17, -1, attr, "                    ");
+       attr = TERM_WHITE;
+       Term_putstr(11, 17, -1, attr, format("       ",num_heal));
+
+       attr = TERM_SLATE;
+       Term_putstr(1, 18, -1, attr, "                   ");
+       attr = TERM_WHITE;
+       Term_putstr(11, 18, -1, attr, format("       ",num_mana));
+   }
+
+
+   /* Fresh */
+   Term_fresh();
+
+   /* Restore */
+   Term_activate(old);
+  }
+ }
+#endif /* borg_tk */
+}
+
+
+/* keep a log of certain battles, used on Questor uniques */
+void borg_log_battle(bool keep_log)
+{
+     char buf[80];
+
+/* for now the log is deactivated */
+return;
+
+    /* Close the log file */
+    if (!keep_log)
+    {
+        borg_info("Closing Battle Log");
+        borg_info("**************");
+        my_fclose(borg_fff);
+        borg_fff=NULL; /* needed on unix! */
+        return;
+    }
+
+    /* Hack -- drop permissions */
+    safe_setuid_drop();
+
+    /* Default  */
+    strcpy(buf, "battle.log");
+
+    /* Open a new file */
+    borg_fff = my_fopen(buf, "a");
+    /* Failure */
+    if (!borg_fff) msg_print("Cannot open that file.");
+
+    /* Note start of log */
+    borg_info("**************");
+    borg_info("Opening Battle Log");
+
+    /* Hack -- grab permissions */
+    safe_setuid_grab();
+    return;
+}
+
+/* keep a log of certain events. */
+void borg_log_event(cptr event)
+{
+#if 0
+	 char buf[80];
+     char buf2[1024];
+     FILE *borg_log_event_file;
+     int i;
+
+    /* Hack -- drop permissions */
+    safe_setuid_drop();
+
+    /* Process the player name */
+    for (i = 0; op_ptr->full_name[i]; i++)
+    {
+        char c = op_ptr->full_name[i];
+
+        /* No control characters */
+        if (iscntrl(c))
+        {
+            /* Illegal characters */
+            quit_fmt("Illegal control char (0x%02X) in player name", c);
+        }
+
+        /* Convert all non-alphanumeric symbols */
+        if (!isalpha(c) && !isdigit(c)) c = '_';
+
+        /* Build "file_name" */
+        buf[i] = c;
+    }
+
+    /* Terminate */
+    buf[i++] = '.';
+    buf[i++] = 'm';
+    buf[i++] = 'a';
+    buf[i++] = 'p';
+    buf[i++] = '\0';
+
+#ifdef BORG_TK
+    path_build(buf2, 1024, BORG_DIR_DATA, buf);
+#else /* BORG_TK */
+    path_build(buf2, 1024, ANGBAND_DIR_USER, buf);
+#endif /* BORG_TK */
+
+	/* Append to the file */
+	borg_log_event_file = my_fopen(buf2, "a");
+
+	/* Grab permission */
+	safe_setuid_grab();
+
+    /* Failure */
+    if (!borg_log_event_file) return;
+
+	/* Dump the important information */
+	fprintf(borg_log_event_file, "%d, %s\n",(long)turn, event);
+
+	my_fclose(borg_log_event_file);
+#endif
+
+}
+
+
+/*
+ * Hack -- forward declare
+ */
+void do_cmd_borg(void);
+
+
+/*
+ * Hack -- interact with the "Ben Borg".
+ */
+void do_cmd_borg(void)
+{
+    char cmd;
+
+
+#ifdef BABLOS
+
+    if (auto_play)
+    {
+        auto_play = FALSE;
+        keep_playing = TRUE;
+        cmd = 'z';
+    }
+    else
+    {
+
+#endif /* BABLOS */
+
+    /* Get a "Borg command", or abort */
+    if (!get_com("Borg command: ", &cmd)) return;
+
+#ifdef BABLOS
+
+    }
+
+#endif /* BABLOS */
+#ifndef BORG_TK
+    /* Simple help */
+    if (cmd == '?')
+    {
+        int i = 2;
+
+        /* Save the screen */
+        Term_save();
+
+        /* Clear the screen */
+        Term_clear();
+
+        i++;
+        Term_putstr(2, i, -1, TERM_WHITE, "Command 'z' activates the Borg.");
+        Term_putstr(42, i++, -1, TERM_WHITE, "Command 'u' updates the Borg.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'x' steps the Borg.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'f' modifies the normal flags.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'c' modifies the cheat flags.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'l' activates a log file.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 's' activates search mode.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'i' displays grid info.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'g' displays grid feature.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'a' displays avoidances.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'k' displays monster info.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 't' displays object info.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command '%' displays targetting flow.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command '#' displays danger grid.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command '_' Regional Fear info.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'p' Borg Power.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command '1' change max depth.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command '2' level prep info.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command '3' Feature of grid.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command '!' Time.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command '@' Borg LOS.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'w' My Swap Weapon.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'q' Auto stop on level.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'v' Version stamp.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'd' Dump spell info.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'h' Borg_Has function.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command '$' Reload Borg.txt.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'y' Last 75 steps.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'm' money Scum.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command '^' Flow Pathway.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'R' Respawn Borg.");
+        Term_putstr(42, i, -1, TERM_WHITE, "Command 'o' Object Flags.");
+        Term_putstr(2, i++, -1, TERM_WHITE, "Command 'r' Restock Stores.");
+
+        /* Prompt for key */
+        msg_print("Commands: ");
+        msg_print(NULL);
+
+        /* Restore the screen */
+        Term_load();
+
+        /* Done */
+        return;
+    }
+
+#endif /* not BORG_TK */
+
+    /* Hack -- force initialization */
+    if (!initialized) borg_init_9();
+
+    switch (cmd)
+    {
+        /* Command: Nothing */
+        case '$':
+        {
+			int j;
+
+            /*** Hack -- initialize borg.ini options ***/
+
+            /* Message */
+            borg_note("Reloading the Borg rules... (borg.txt)");
+
+			for (j = 0; j < z_info->c_max; j++)
+			{
+	            FREE(borg_required_item[j]); /* externalize the 400 later */
+	            FREE(borg_power_item[j]); /* externalize the 400 later */
+			}
+            FREE(borg_required_item); /* externalize the 400 later */
+            FREE(borg_power_item); /* externalize the 400 later */
+            FREE(borg_has);
+			for (j = 0; j < 1000; j++)
+			{
+				if (formula[j])
+				{
+					FREE(formula[j]);
+					formula[j] = 0;
+				}
+			}
+		    FREE(n_req);
+		    FREE(n_pwr);
+
+    		C_MAKE(borg_required_item, z_info->c_max, req_item*);
+    		C_MAKE(n_req, z_info->c_max, int);
+    		C_MAKE(borg_power_item, z_info->c_max, power_item*);
+    		C_MAKE(n_pwr, z_info->c_max, int);
+
+            init_borg_txt_file();
+            borg_note("# Ready...");
+            break;
+        }
+        /* Command: Activate */
+        case 'z':
+        case 'Z':
+        {
+            /* Activate */
+            borg_active = TRUE;
+
+            /* Reset cancel */
+            borg_cancel = FALSE;
+
+            /* Step forever */
+            borg_step = 0;
+
+            /* need to check all stats */
+            my_need_stat_check[0] = TRUE;
+            my_need_stat_check[1] = TRUE;
+            my_need_stat_check[2] = TRUE;
+            my_need_stat_check[3] = TRUE;
+            my_need_stat_check[4] = TRUE;
+            my_need_stat_check[5] = TRUE;
+
+            /* Allowable Cheat -- Obtain "recall" flag */
+            goal_recalling = p_ptr->word_recall * 1000;
+
+            /* Allowable Cheat -- Obtain "prot_from_evil" flag */
+            borg_prot_from_evil = (p_ptr->protevil ? TRUE : FALSE);
+            /* Allowable Cheat -- Obtain "speed" flag */
+            borg_speed = (p_ptr->fast ? TRUE : FALSE);
+            /* Allowable Cheat -- Obtain "resist" flags */
+            my_oppose_acid = (p_ptr->oppose_acid ? TRUE : FALSE);
+            my_oppose_elec = (p_ptr->oppose_elec ? TRUE : FALSE);
+            my_oppose_fire = (p_ptr->oppose_fire ? TRUE : FALSE);
+            my_oppose_cold = (p_ptr->oppose_cold ? TRUE : FALSE);
+            my_oppose_pois = (p_ptr->oppose_pois ? TRUE : FALSE);
+            borg_bless = (p_ptr->blessed ? TRUE : FALSE);
+            borg_shield = (p_ptr->shield ? TRUE : FALSE);
+            borg_hero = (p_ptr->hero ? TRUE : FALSE);
+            borg_berserk = (p_ptr->shero ? TRUE : FALSE);
+            if (p_ptr->see_inv) borg_see_inv = 10000;
+
+            /* Message */
+            borg_note("# Installing keypress hook");
+
+            /* If the clock overflowed, fix that  */
+            if (borg_t > 9000)
+                borg_t = 9000;
+
+            /* Activate the key stealer */
+            inkey_hack = borg_inkey_hack;
+#ifdef BORG_TK
+            angtk_eval("angband_borg", "activate", NULL);
+#endif /* BORG_TK */
+
+            break;
+        }
+
+        /* Command: Update */
+        case 'u':
+        case 'U':
+        {
+            /* Activate */
+            borg_active = TRUE;
+
+            /* Immediate cancel */
+            borg_cancel = TRUE;
+
+            /* Step forever */
+            borg_step = 0;
+
+            /* Allowable Cheat -- Obtain "recall" flag */
+            goal_recalling = p_ptr->word_recall * 1000;
+
+            /* Allowable Cheat -- Obtain "prot_from_evil" flag */
+            borg_prot_from_evil = (p_ptr->protevil ? TRUE : FALSE);
+            /* Allowable Cheat -- Obtain "speed" flag */
+            borg_speed = (p_ptr->fast ? TRUE : FALSE);
+            /* Allowable Cheat -- Obtain "resist" flags */
+            my_oppose_acid = (p_ptr->oppose_acid ? TRUE : FALSE);
+            my_oppose_elec = (p_ptr->oppose_elec ? TRUE : FALSE);
+            my_oppose_fire = (p_ptr->oppose_fire ? TRUE : FALSE);
+            my_oppose_cold = (p_ptr->oppose_cold ? TRUE : FALSE);
+            my_oppose_pois = (p_ptr->oppose_pois ? TRUE : FALSE);
+            borg_bless = (p_ptr->blessed ? TRUE : FALSE);
+            borg_shield = (p_ptr->shield ? TRUE : FALSE);
+            borg_hero = (p_ptr->hero ? TRUE : FALSE);
+            borg_berserk = (p_ptr->shero ? TRUE : FALSE);
+            if (p_ptr->see_inv) borg_see_inv = 10000;
+
+            /* Message */
+            borg_note("# Installing keypress hook");
+#ifdef BORG_TK
+            angtk_eval("angband_borg", "activate", NULL);
+#endif /* BORG_TK */
+
+            /* Activate the key stealer */
+            inkey_hack = borg_inkey_hack;
+
+            break;
+        }
+
+
+        /* Command: Step */
+        case 'x':
+        case 'X':
+        {
+            /* Activate */
+            borg_active = TRUE;
+
+            /* Reset cancel */
+            borg_cancel = FALSE;
+
+            /* Step N times */
+			borg_step  = (p_ptr->command_arg ? p_ptr->command_arg : 1);
+
+            /* need to check all stats */
+            my_need_stat_check[0] = TRUE;
+            my_need_stat_check[1] = TRUE;
+            my_need_stat_check[2] = TRUE;
+            my_need_stat_check[3] = TRUE;
+            my_need_stat_check[4] = TRUE;
+            my_need_stat_check[5] = TRUE;
+
+            /* Allowable Cheat -- Obtain "recall" flag */
+            goal_recalling = p_ptr->word_recall * 1000;
+            /* Allowable Cheat -- Obtain "prot_from_evil" flag */
+            borg_prot_from_evil = (p_ptr->protevil ? TRUE : FALSE);
+            /* Allowable Cheat -- Obtain "speed" flag */
+            borg_speed = (p_ptr->fast ? TRUE : FALSE);
+            /* Allowable Cheat -- Obtain "resist" flags */
+            my_oppose_acid = (p_ptr->oppose_acid ? TRUE : FALSE);
+            my_oppose_elec = (p_ptr->oppose_elec ? TRUE : FALSE);
+            my_oppose_fire = (p_ptr->oppose_fire ? TRUE : FALSE);
+            my_oppose_cold = (p_ptr->oppose_cold ? TRUE : FALSE);
+            my_oppose_pois = (p_ptr->oppose_pois ? TRUE : FALSE);
+            borg_bless = (p_ptr->blessed ? TRUE : FALSE);
+            borg_shield = (p_ptr->shield ? TRUE : FALSE);
+            borg_hero = (p_ptr->hero ? TRUE : FALSE);
+            borg_berserk = (p_ptr->shero ? TRUE : FALSE);
+            if (p_ptr->see_inv) borg_see_inv = 10000;
+
+            /* Message */
+            borg_note("# Installing keypress hook");
+            borg_note(format("# Stepping Borg %d times", borg_step));
+
+            /* If the clock overflowed, fix that  */
+            if (borg_t > 9000)
+                borg_t = 9000;
+
+            /* Activate the key stealer */
+            inkey_hack = borg_inkey_hack;
+#ifdef BORG_TK
+            angtk_eval("angband_borg", "activate", NULL);
+#endif /* BORG_TK */
+
+            break;
+        }
+
+        /* Command: toggle "flags" */
+        case 'f':
+        case 'F':
+        {
+            /* Get a "Borg command", or abort */
+            if (!get_com("Borg command: Toggle Flag: (m/d/s/f/g) ", &cmd)) return;
+
+            switch (cmd)
+            {
+                /* Give borg thought messages in window */
+                case 'm':
+                case 'M':
+                {
+                    break;
+                }
+
+                /* Give borg the ability to use graphics ----broken */
+                case 'g':
+                case 'G':
+                {
+                    borg_graphics = !borg_graphics;
+                    msg_format("Borg -- borg_graphics is now %d.",
+                                borg_graphics);
+                    break;
+                }
+
+                /* Dump savefile at each death */
+                case 'd':
+                case 'D':
+                {
+                    borg_flag_dump = !borg_flag_dump;
+                    msg_format("Borg -- borg_flag_dump is now %d.",
+                                borg_flag_dump);
+                    break;
+                }
+
+                /* Dump savefile at each level */
+                case 's':
+                case 'S':
+                {
+                    borg_flag_save = !borg_flag_save;
+                    msg_format("Borg -- borg_flag_save is now %d.",
+                                borg_flag_save);
+                    break;
+                }
+
+                /* clear 'fear' levels */
+                case 'f':
+                case 'F':
+                {
+                    msg_format("Command No Longer Usefull");
+                    break;
+                }
+            }
+            break;
+        }
+
+
+
+        /* Command: toggle "cheat" flags */
+        case 'c':
+        case 'C':
+        {
+            /* Get a "Borg command", or abort */
+            if (!get_com("Borg command: Toggle Cheat: (d/i/e/s/p)", &cmd))
+                return;
+
+            switch (cmd)
+            {
+                case 'd':
+                case 'D':
+                {
+                    borg_cheat_death = !borg_cheat_death;
+                    msg_format("Borg -- borg_cheat_death is now %d.",
+                                borg_cheat_death);
+                    break;
+                }
+            }
+            break;
+
+        }
+
+
+        /* Start a new log file */
+        case 'l':
+        case 'L':
+        {
+            char buf[80];
+
+            /* Close the log file */
+            if (borg_fff) my_fclose(borg_fff);
+
+            /* Hack -- drop permissions */
+            safe_setuid_drop();
+
+            /* Default  */
+            strcpy(buf, "borg.log");
+
+            /* XXX XXX XXX Get the name and open the log file */
+            if (get_string("Borg Log File: ", buf, 70))
+            {
+                /* Open a new file */
+                borg_fff = my_fopen(buf, "w");
+
+                /* Failure */
+                if (!borg_fff) msg_print("Cannot open that file.");
+            }
+
+            /* Hack -- grab permissions */
+            safe_setuid_grab();
+            break;
+        }
+
+
+        /* Activate a search string */
+        case 's':
+        case 'S':
+        {
+            /* Get the new search string (or cancel the matching) */
+            if (!get_string("Borg Match String: ", borg_match, 70))
+            {
+                /* Cancel it */
+                strcpy(borg_match, "");
+
+                /* Message */
+                msg_print("Borg Match String de-activated.");
+            }
+            break;
+        }
+
+#ifndef BORG_TK
+        /* Command: check Grid "feature" flags */
+        case 'g':
+        case 'G':
+        {
+            int x, y;
+
+            u16b low, high = 0;
+
+            /* Get a "Borg command", or abort */
+            if (!get_com("Borg command: Show grids: ", &cmd)) return;
+
+            /* Extract a flag */
+            switch (cmd)
+            {
+                case '0': low = high = 1 << 0; break;
+                case '1': low = high = 1 << 1; break;
+                case '2': low = high = 1 << 2; break;
+                case '3': low = high = 1 << 3; break;
+                case '4': low = high = 1 << 4; break;
+                case '5': low = high = 1 << 5; break;
+                case '6': low = high = 1 << 6; break;
+                case '7': low = high = 1 << 7; break;
+
+                case '.': low = high = FEAT_FLOOR; break;
+                case ' ': low = high = FEAT_NONE; break;
+                case 'i': low = high = FEAT_INVIS; break;
+                case ';': low = high = FEAT_GLYPH; break;
+                case ',': low = high = FEAT_OPEN; break;
+                case 'x': low = high = FEAT_BROKEN; break;
+                case '<': low = high = FEAT_LESS; break;
+                case '>': low = high = FEAT_MORE; break;
+                case '@': low = FEAT_SHOP_HEAD;
+                          high = FEAT_SHOP_TAIL;
+                           break;
+                case '^': low = FEAT_TRAP_HEAD;
+                          high = FEAT_TRAP_TAIL;
+                          break;
+                case '+': low  = FEAT_DOOR_HEAD;
+                          high = FEAT_DOOR_TAIL; break;
+                case 's': low = high = FEAT_SECRET; break;
+                case ':': low = high = FEAT_RUBBLE; break;
+                case 'm': low = high = FEAT_MAGMA; break;
+                case 'q': low = high = FEAT_QUARTZ; break;
+                case 'r': low = high = FEAT_QUARTZ_H; break;
+                case 'k': low = high = FEAT_MAGMA_K; break;
+                case '&': low = high = FEAT_QUARTZ_K; break;
+                case 'w': low = FEAT_WALL_EXTRA;
+                          high = FEAT_WALL_SOLID;
+                          break;
+                case 'p': low = FEAT_PERM_EXTRA;
+                          high = FEAT_PERM_SOLID;
+                          break;
+
+                default: low = high = 0x00; break;
+            }
+
+            /* Scan map */
+            for (y = 1; y <= AUTO_MAX_Y - 1; y++)
+            {
+                for (x = 1; x <= AUTO_MAX_X - 1; x++)
+                {
+                    byte a = TERM_RED;
+
+                    borg_grid *ag = &borg_grids[y][x];
+
+                    /* show only those grids */
+                    if (!(ag->feat >= low && ag->feat <= high)) continue;
+
+                    /* Color */
+                    if (borg_cave_floor_bold(y, x)) a = TERM_YELLOW;
+
+                    /* Display */
+                    print_rel('*', a, y, x);
+                }
+            }
+
+            /* Get keypress */
+            msg_print("Press any key.");
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+
+        /* Command: check "info" flags */
+        case 'i':
+        case 'I':
+        {
+            int x, y;
+
+            u16b mask;
+
+            /* Get a "Borg command", or abort */
+            if (!get_com("Borg command: Show grids: ", &cmd)) return;
+
+            /* Extract a flag */
+            switch (cmd)
+            {
+                case '0': mask = 1 << 0; break;
+                case '1': mask = 1 << 1; break;
+                case '2': mask = 1 << 2; break;
+                case '3': mask = 1 << 3; break;
+                case '4': mask = 1 << 4; break;
+                case '5': mask = 1 << 5; break;
+                case '6': mask = 1 << 6; break;
+                case '7': mask = 1 << 7; break;
+
+                case 'm': mask = BORG_MARK; break;
+                case 'g': mask = BORG_GLOW; break;
+                case 'd': mask = BORG_DARK; break;
+                case 'o': mask = BORG_OKAY; break;
+                case 'l': mask = BORG_LITE; break;
+                case 'v': mask = BORG_VIEW; break;
+                case 't': mask = BORG_TEMP; break;
+                case 'x': mask = BORG_XTRA; break;
+
+                default: mask = 0x000; break;
+            }
+
+            /* Scan map */
+            for (y = 1; y <= AUTO_MAX_Y - 1; y++)
+            {
+                for (x = 1; x <= AUTO_MAX_X - 1; x++)
+                {
+                    byte a = TERM_RED;
+
+                    borg_grid *ag = &borg_grids[y][x];
+
+                    /* Given mask, show only those grids */
+                    if (mask && !(ag->info & mask)) continue;
+
+                    /* Given no mask, show unknown grids */
+                    if (!mask && (ag->info & BORG_MARK)) continue;
+
+                    /* Color */
+                    if (borg_cave_floor_bold(y, x)) a = TERM_YELLOW;
+
+                    /* Display */
+                    print_rel('*', a, y, x);
+                }
+            }
+
+            /* Get keypress */
+            msg_print("Press any key.");
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+
+    /* Command: check "avoidances" */
+        case 'a':
+        case 'A':
+        {
+            int x, y, p;
+
+            /* Scan map */
+            for (y = 1; y <= AUTO_MAX_Y - 1; y++)
+            {
+                for (x = 1; x <= AUTO_MAX_X - 1; x++)
+                {
+                    byte a = TERM_RED;
+
+                    /* Obtain danger */
+                    p = borg_danger(y, x, 1, TRUE);
+
+                    /* Skip non-avoidances */
+                    if (p <= avoidance / 3) continue;
+
+                    /* Use yellow for less painful */
+                    if (p <= avoidance) a = TERM_YELLOW;
+
+                    /* Display */
+                    print_rel('*', a, y, x);
+                }
+            }
+
+            /* Get keypress */
+            msg_format("(%d,%d of %d,%d) Avoidance value %d.", c_y, c_x, Term->offset_y / PANEL_HGT,Term->offset_x / PANEL_WID,avoidance);
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+
+
+    /* Command: check previous steps */
+        case 'y':
+        {
+            int x, y, i;
+
+            /* Scan map */
+            for (y = 1; y <= AUTO_MAX_Y - 1; y++)
+            {
+                for (x = 1; x <= AUTO_MAX_X - 1; x++)
+                {
+                    byte a = TERM_RED;
+                    /* Check for an existing step */
+                    for (i = 0; i < track_step_num; i++)
+                    {
+                        /* Stop if we already new about this glyph */
+                        if ((track_step_x[i] == x) && (track_step_y[i] == y))
+                        /* Display */
+                        print_rel('*', a, y, x);
+                    }
+                }
+            }
+
+            /* Get keypress */
+            msg_format("(%d) Steps noted", track_step_num);
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+
+        /* Command: show "monsters" */
+        case 'k':
+        case 'K':
+        {
+            int i, n = 0;
+
+            /* Scan the monsters */
+            for (i = 1; i < borg_kills_nxt; i++)
+            {
+                borg_kill *kill = &borg_kills[i];
+
+                /* Still alive */
+                if (kill->r_idx)
+                {
+                    int x = kill->x;
+                    int y = kill->y;
+
+                    /* Display */
+                    print_rel('*', TERM_RED, y, x);
+
+                    /* Count */
+                    n++;
+                }
+            }
+
+            /* Get keypress */
+            msg_format("There are %d known monsters.", n);
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+
+
+        /* Command: show "objects" */
+        case 't':
+        case 'T':
+        {
+            int i, n = 0;
+
+            /* Scan the objects */
+            for (i = 1; i < borg_takes_nxt; i++)
+            {
+                borg_take *take = &borg_takes[i];
+
+                /* Still alive */
+                if (take->k_idx)
+                {
+                    int x = take->x;
+                    int y = take->y;
+
+                    /* Display */
+                    print_rel('*', TERM_RED, y, x);
+
+                    /* Count */
+                    n++;
+                }
+            }
+
+            /* Get keypress */
+            msg_format("There are %d known objects.", n);
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+
+
+        /* Command: debug -- current flow */
+        case '%':
+        {
+			int x, y;
+			int n_x;
+			int n_y;
+
+		    /* Determine "path" */
+		    n_x = p_ptr->px;
+		    n_y = p_ptr->py;
+			x = p_ptr->target_col;
+			y =  p_ptr->target_row;
+
+			/* Borg's pathway */
+			while (1)
+			{
+
+                /* Display */
+                print_rel('*', TERM_RED, n_y, n_x);
+
+		        if (n_x == x && n_y == y) break;
+
+		        /* Calculate the new location */
+        		mmove2(&n_y, &n_x, p_ptr->py, p_ptr->px, y, x);
+
+			}
+
+            msg_print("Borg's Targetting Path");
+            msg_print(NULL);
+
+		    /* Determine "path" */
+		    n_x = p_ptr->px;
+		    n_y = p_ptr->py;
+			x = p_ptr->target_col;
+			y = p_ptr->target_row;
+
+			/* Real LOS */
+      		project(-1, 0, y, x, 1, GF_MISSILE, PROJECT_BEAM);
+
+
+
+            msg_print("Actual Targetting Path");
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+
+			break;
+		}
+        /* Display the intended path to the flow */
+        case '^':
+        {
+                int x, y;
+                int o;
+                int false_y, false_x;
+                borg_grid *ag;
+
+                false_y = c_y;
+                false_x = c_x;
+
+                /* Continue */
+                for (o = 0; o < 250; o++)
+                {
+                    int b_n = 0;
+
+                    int i, b_i = -1;
+
+                    int c, b_c;
+
+
+                    /* Flow cost of current grid */
+                    b_c = borg_data_flow->data[c_y][c_x] * 10;
+
+                    /* Prevent loops */
+                    b_c = b_c - 5;
+
+                    /* Look around */
+                    for (i = 0; i < 8; i++)
+                    {
+                        /* Grid in that direction */
+                        x = false_x + ddx_ddd[i];
+                        y = false_y + ddy_ddd[i];
+
+                        /* Access the grid */
+                        ag = &borg_grids[y][x];
+
+                        /* Flow cost at that grid */
+                        c = borg_data_flow->data[y][x] * 10;
+
+                        /* Never backtrack */
+                        if (c > b_c) continue;
+
+                        /* Notice new best value */
+                        if (c < b_c) b_n = 0;
+
+                        /* Apply the randomizer to equivalent values */
+                        if ((++b_n >= 2) && (rand_int(b_n) != 0)) continue;
+
+                        /* Track it */
+                        b_i = i; b_c = c;
+                    }
+
+                    /* Try it */
+                    if (b_i >= 0)
+                    {
+                        /* Access the location */
+                        x = false_x + ddx_ddd[b_i];
+                        y = false_y + ddy_ddd[b_i];
+
+                        /* Display */
+                        print_rel('*', TERM_RED, y, x);
+
+                        /* Simulate motion */
+                        false_y = y;
+                        false_x = x;
+                    }
+
+                }
+                msg_print("Probable Flow Path");
+                msg_print(NULL);
+
+                /* Redraw map */
+                prt_map();
+        break;
+        }
+
+
+
+#endif /* not BORG_TK */
+        /* Command: debug -- danger of grid */
+        case '#':
+        {
+            int n;
+
+            /* Turns */
+            n = (p_ptr->command_arg ? p_ptr->command_arg : 1);
+
+            /* Danger of grid */
+            msg_format("Danger(%d,%d,%d) is %d",
+                        p_ptr->target_col, p_ptr->target_row, n,
+                        borg_danger(p_ptr->target_row, p_ptr->target_col, n, TRUE));
+            break;
+        }
+
+        /* Command: Regional Fear Info*/
+        case '_':
+        {
+            int x, y, p;
+
+            /* Scan map */
+            for (y = 1; y <= AUTO_MAX_Y - 1; y++)
+            {
+                for (x = 1; x <= AUTO_MAX_X - 1; x++)
+                {
+                    byte a = TERM_RED;
+
+                    /* Obtain danger */
+                    p =  borg_fear_region[y/11][x/11];
+
+                    /* Skip non-fears */
+                    if (p <= avoidance / 10) continue;
+
+                    /* Use yellow for less painful */
+                    if (p <= avoidance / 4) a = TERM_YELLOW;
+
+                    /* Display */
+                    print_rel('*', a, y, x);
+                }
+            }
+
+            /* Get keypress */
+            msg_format("(%d,%d of %d,%d) Regional Fear.", c_y, c_x, Term->offset_y / PANEL_HGT,Term->offset_x / PANEL_WID);
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+
+            /* Scan map */
+            for (y = 1; y <= AUTO_MAX_Y; y++)
+            {
+                for (x = 1; x <= AUTO_MAX_X; x++)
+                {
+                    byte a = TERM_BLUE;
+
+                    /* Obtain danger */
+                    p =  borg_fear_monsters[y][x];
+
+                    /* Skip non-fears */
+                    if (p <= 0) continue;
+
+                    /* Color Defines */
+                    if (p == 1)  a = TERM_L_BLUE;
+
+                    /* Color Defines */
+                    if (p <= avoidance / 20 &&
+                        p > 1) a = TERM_BLUE;
+
+                    /* Color Defines */
+                    if (p <= avoidance / 10 &&
+                        p > avoidance / 20) a = TERM_GREEN;
+
+                    /* Color Defines */
+                    if (p <= avoidance / 4 &&
+                        p > avoidance / 10) a = TERM_YELLOW;
+
+                    /* Color Defines */
+                    if (p <= avoidance / 2 &&
+                        p > avoidance / 4) a = TERM_ORANGE;
+
+                    /* Color Defines */
+                    if (p > avoidance / 2)  a = TERM_RED;
+
+                    /* Display */
+                    print_rel('*', a, y, x);
+                }
+            }
+
+            /* Get keypress */
+            msg_format("(%d,%d of %d,%d) Monster Fear.", c_y, c_x, Term->offset_y / PANEL_HGT,Term->offset_x / PANEL_WID);
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+
+        /* Command: debug -- Power */
+        case 'p':
+        case 'P':
+        {
+            s32b p;
+
+            /* Examine the screen */
+            borg_update_frame();
+
+            /* Examine the screen */
+            borg_update();
+
+            /* Cheat the "equip" screen */
+            borg_cheat_equip();
+
+            /* Cheat the "inven" screen */
+            borg_cheat_inven();
+
+            /* Extract some "hidden" variables */
+            borg_hidden();
+
+            /* Examine the inventory */
+            borg_object_star_id();
+            borg_notice(TRUE);
+            /* Evaluate */
+            p = borg_power();
+
+            borg_notice_home(NULL, FALSE);
+
+            /* Report it */
+            msg_format("Current Borg Power %ld", p);
+            msg_format("Current Home Power %ld", borg_power_home());
+
+            break;
+        }
+
+        /* Command: Show time */
+        case '!':
+        {
+            s32b time = borg_t - borg_began;
+            msg_format("time: (%d) ", time);
+            time = (borg_time_town + (borg_t - borg_began));
+            msg_format("; from town (%d)", time);
+            msg_format("; on this panel (%d)", time_this_panel);
+            msg_format("; need inviso (%d)", need_see_inviso);
+            break;
+        }
+
+        /* Command: LOS */
+        case '@':
+        {
+            int x, y;
+
+            /* Scan map */
+            for (y = w_y; y < w_y + SCREEN_HGT; y++)
+            {
+                for (x = w_x; x < w_x + SCREEN_WID; x++)
+                {
+                    byte a = TERM_RED;
+
+                    /* Obtain danger */
+                    if (!borg_los(c_y,c_x, y, x)) continue;
+
+                    /* Display */
+                    print_rel('*', a, y, x);
+                }
+            }
+
+            /* Get keypress */
+            msg_format("Borg has LOS to these places.");
+            msg_print(NULL);
+
+            /* Scan map */
+            for (y = w_y; y < w_y + SCREEN_HGT; y++)
+            {
+                for (x = w_x; x < w_x + SCREEN_WID; x++)
+                {
+                    byte a = TERM_YELLOW;
+
+                    /* Obtain danger */
+                    if (!borg_projectable_dark(c_y, c_x, y, x)) continue;
+
+                    /* Display */
+                    print_rel('*', a, y, x);
+                }
+            }
+            msg_format("Borg has Projectable Dark to these places.");
+            msg_print(NULL);
+
+            /* Redraw map */
+            prt_map();
+            break;
+        }
+       /* APW command: debug -- change max depth */
+       case '1':
+        {
+           int new_borg_skill[BI_MAXDEPTH];
+           /* Get the new max depth */
+           new_borg_skill[BI_MAXDEPTH] = get_quantity("Enter new Max Depth: ", MAX_DEPTH - 1);
+
+           /* Allow user abort */
+           if (new_borg_skill[BI_MAXDEPTH] >= 0)
+           {
+               p_ptr->max_depth = new_borg_skill[BI_MAXDEPTH];
+               borg_skill[BI_MAXDEPTH] = new_borg_skill[BI_MAXDEPTH];
+           }
+
+           break;
+       }
+       /* APW command: debug -- allow borg to stop */
+       case 'q':
+        {
+           int new_borg_stop_dlevel = 127;
+           int new_borg_stop_clevel = 51;
+           char cmd;
+
+           /* Get the new max depth */
+           new_borg_stop_dlevel = get_quantity("Enter new auto-stop dlevel: ", MAX_DEPTH -1);
+           new_borg_stop_clevel = get_quantity("Enter new auto-stop clevel: ", 51);
+           get_com("Stop when Morgoth Dies? (y or n)? ", &cmd);
+
+           borg_stop_dlevel = new_borg_stop_dlevel;
+           borg_stop_clevel = new_borg_stop_clevel;
+           if (cmd =='n' || cmd =='N' ) borg_stop_king = FALSE;
+
+           break;
+       }
+
+       /* command: money Scum-- allow borg to stop when he gets a certain amount of money*/
+       case 'm':
+        {
+           int new_borg_money_scum_amount = 0;
+
+           /* report current status */
+           msg_format("money Scumming for %d, I need %d more.", borg_money_scum_amount,
+                             borg_money_scum_amount - borg_gold);
+
+           /* Get the new amount */
+           new_borg_money_scum_amount = get_quantity("Enter new dollar amount for money scumming (0 for no scumming):", borg_money_scum_amount);
+
+           borg_money_scum_amount = new_borg_money_scum_amount;
+
+           break;
+       }
+        /* Command: APW HACK debug -- preparation for level */
+        case '2':
+        {
+          int i=0;
+
+            /* Examine the screen */
+            borg_update_frame();
+            borg_update();
+
+            /* Extract some "hidden" variables */
+            borg_cheat_equip();
+            borg_cheat_inven();
+            borg_hidden();
+
+            /* Examine the inventory */
+            borg_object_star_id();
+            borg_notice(TRUE);
+            borg_notice_home(NULL, FALSE);
+
+            /* Dump prep codes */
+            for (i = 1; i <= 101; i++)
+            {
+  			   /* Dump fear code*/
+               if ((cptr)NULL != borg_prepared(i)) break;
+            }
+            borg_slow_return = TRUE;
+            msg_format("Max Level: %d  Prep'd For: %d  Reason: %s", borg_skill[BI_MAXDEPTH], i-1, borg_prepared(i) );
+            borg_slow_return = FALSE;
+            if (borg_ready_morgoth == 1)
+            {
+                msg_format("You are ready for the big fight!!");
+            }
+            else if (borg_ready_morgoth == 0)
+            {
+                msg_format("You are NOT ready for the big fight!!");
+            }
+            else if (borg_ready_morgoth == -1)
+            {
+                msg_format("No readiness check done.");
+            }
+
+            break;
+        }
+        /* Command: debug -- Feature of grid */
+        case '3':
+        {
+
+			int i;
+			for (i =0; i < 6; i++)
+			{
+				borg_note(format("stat # %d, is: %d", i, my_stat_cur[i]));
+			}
+#if 0
+			artifact_type *a_ptr;
+
+			int i;
+            for (i = 0; i < z_info->a_max; i++)
+            {
+                 a_ptr = &a_info[i];
+				 borg_note(format("(%d) %d, %d (act:%d)",i, a_ptr->name, a_ptr->text, a_ptr->activation));
+			}
+#endif
+            break;
+        }
+
+        /* Command: List the swap weapon and armour */
+        case 'w':
+        case 'W':
+        {
+            borg_item *item;
+
+            /* Examine the screen */
+            borg_update();
+
+            /* Extract some "hidden" variables */
+            borg_hidden();
+
+            /* Cheat the "equip" screen */
+            borg_cheat_equip();
+            /* Cheat the "inven" screen */
+            borg_cheat_inven();
+            /* Examine the inventory */
+            borg_notice(TRUE);
+            borg_notice_home(NULL, FALSE);
+            /* Check the power */
+            borg_power();
+
+            /* Examine the screen */
+            borg_update_frame();
+
+            /* note the swap items */
+            item = &borg_items[weapon_swap];
+            msg_format("Swap Weapon:  %s, value= %d", item->desc, weapon_swap_value);
+            item = &borg_items[armour_swap];
+            msg_format("Swap Armour:  %s, value= %d", item->desc, armour_swap_value);
+            break;
+        }
+#ifndef BORG_TK
+        case 'd':
+        case 'D':
+        {
+            int ii= 1;
+
+            /* Save the screen */
+            Term_save();
+
+            /* Dump the spells */
+            if (cp_ptr->spell_book)
+            {
+
+            int i,j;
+
+            for (i = 0; i < 9; i++ )
+            {
+                /* Clear the screen */
+                Term_clear();
+
+                ii = 2;
+                Term_putstr(1, ii, -1, TERM_WHITE, "[ Spells ].");
+                for (j = 0; j < 9; j++)
+                {
+                    borg_magic *as = &borg_magics[i][j];
+                    cptr legal;
+                    int failpercent = 0;
+
+                    if (as->level <99)
+                    {
+                        if (cp_ptr->spell_book == TV_PRAYER_BOOK)
+                        {
+                            legal = (borg_prayer_legal(i, j) ? "Legal" : "Not Legal ");
+		                    failpercent = (borg_prayer_fail_rate(i, j));
+                        }
+                        else
+                        {
+                            legal = (borg_spell_legal(i, j) ? "legal" : "Not Legal ");
+		                    failpercent = (borg_spell_fail_rate(i,j));
+                        }
+                        Term_putstr(1, ii++, -1, TERM_WHITE, format("%s, %s, attempted %d times, fail rate:%d",as->name, legal, as->times, failpercent));
+                    }
+                }
+            get_com("Exam spell books.  Press any key for next book.", &cmd);
+            } /* dumps */
+            } /* spells */
+
+           /* Restore the screen */
+           Term_load();
+
+            /* Done */
+            return;
+        }
+#endif /* BORG_TK */
+        /* dump borg 'has' information */
+        case 'h':
+        case 'H':
+        {
+            char cmd;
+            int item, to;
+
+            /* Get a "Borg command", or abort */
+            if (!get_com("Dynamic Borg Has What: ((i)nv/(w)orn/(a)rtifact/(s)kill) ", &cmd)) return;
+
+            switch (cmd)
+            {
+                case 'i':
+                case 'I':
+                    item = 0;
+                    to = z_info->k_max;
+                    break;
+                case 'w':
+                case 'W':
+                    item = z_info->k_max;
+                    to = z_info->k_max + z_info->k_max;
+                    break;
+                case 'a':
+                case 'A':
+                    item = z_info->k_max + z_info->k_max;
+                    to = z_info->k_max + z_info->k_max + z_info->a_max;
+                    break;
+                default:
+                    item = z_info->k_max + z_info->k_max + z_info->a_max;
+                    to = z_info->k_max + z_info->k_max + z_info->a_max + BI_MAX;
+                    break;
+            }
+            /* Examine the screen */
+            borg_update_frame();
+
+            /* Examine the screen */
+            borg_update();
+
+            /* Cheat the "equip" screen */
+            borg_cheat_equip();
+
+            /* Cheat the "inven" screen */
+            borg_cheat_inven();
+
+            /* Extract some "hidden" variables */
+            borg_hidden();
+
+            /* Examine the inventory */
+            borg_object_star_id();
+            borg_notice(TRUE);
+            borg_notice_home(NULL, FALSE);
+            for (;item < to; item++)
+            {
+                switch (cmd)
+                {
+                    case 'i':
+                    case 'I':
+                        borg_note(format("Item%03d value= %d.", item, borg_has[item]));
+                        break;
+                    case 'w':
+                    case 'W':
+                        borg_note(format("WItem%03d value= %d.", item-z_info->k_max, borg_has[item]));
+                        break;
+                    case 'a':
+                    case 'A':
+                        borg_note(format("Artifact%03d value= %d.", item-z_info->k_max-z_info->k_max, borg_has[item]));
+                        break;
+                    default:
+                        borg_note(format("skill %d (%s) value= %d.",item,
+                            prefix_pref[item -
+                                        z_info->k_max -
+                                        z_info->k_max -
+                                        z_info->a_max], borg_has[item]));
+                        break;
+                }
+            }
+
+            /* note the completion. */
+            msg_format("Borg_has[] dump complete.  Examine Log. ");
+            break;
+        }
+
+        /* Version of the game */
+        case 'v':
+        case 'V':
+        {
+            msg_format("APWBorg Version: %s",borg_engine_date);
+            break;
+        }
+        /* Command: Display all known info on item */
+        case 'o':
+        case 'O':
+        {
+			int n =0;
+
+			object_type *item2;
+
+			/* use this item */
+            n = (p_ptr->command_arg ? p_ptr->command_arg : 1);
+
+            /* Examine the screen */
+            borg_update();
+
+            /* Extract some "hidden" variables */
+            borg_hidden();
+
+            /* Cheat the "equip" screen */
+            borg_cheat_equip();
+            /* Cheat the "inven" screen */
+            borg_cheat_inven();
+            /* Examine the inventory */
+            borg_notice(TRUE);
+            borg_notice_home(NULL, FALSE);
+            /* Check the power */
+            borg_power();
+
+            /* Examine the screen */
+            borg_update_frame();
+
+			/* Save the screen */
+			Term_save();
+
+			/* get the item */
+			item2 = &inventory[n];
+
+			/* Display the special screen */
+			borg_display_item(item2);
+
+			/* pause for study */
+            msg_format("Borg believes: ");
+            msg_print(NULL);
+
+			/* Restore the screen */
+            Term_load();
+
+
+            break;
+        }
+
+		/* Command: Resurrect Borg */
+		case 'R':
+		{
+           char cmd;
+			int i =0;
+
+           /* Confirm it */
+           get_com("Are you sure you want to Respawn this borg? (y or n)? ", &cmd);
+
+		   if (cmd =='y' || cmd =='Y' )
+           {
+			   resurrect_borg();
+		   }
+           break;
+       }
+
+		/* Command: Restock the Stores */
+		case 'r':
+		{
+           char cmd;
+			int n;
+
+           /* Confirm it */
+           get_com("Are you sure you want to Restock the stores? (y or n)? ", &cmd);
+
+           if (cmd =='y' || cmd =='Y' )
+           {
+				/* Message */
+				msg_print("Updating Shops...");
+
+				/* Maintain each shop (except home) */
+				for (n = 0; n < MAX_STORES; n++)
+				{
+					/* Skip the home */
+					if (n == STORE_HOME) continue;
+
+					/* Maintain */
+					store_maint(n);
+				}
+		   }
+
+           break;
+       }
+
+        /* Oops */
+        default:
+        {
+            /* Message */
+            msg_print("That is not a legal Borg command.");
+            break;
+        }
+    }
+}
+
+#ifdef BORG_TK
+
+byte borgtk_delay_factor = 0;
+
+cptr BORG_DIR_ROOT = NULL;
+cptr BORG_DIR_DATA = NULL;
+
+/* SettingType */
+struct
+{
+    cptr name; /* Keyword */
+    cptr desc; /* Human-readable description */
+    void (*proc)();
+    long data;
+} settings[] = {
+    {"borg_flag_save",
+        "Save the game when the dungeon level changes",
+        NULL, (long) &borg_flag_save},
+    {"borg_stop_king",
+        "Stop the borg on win",
+        NULL, (long) &borg_stop_king},
+    {"borg_worships_damage",
+        "Borg worships damage",
+        NULL, (long) &borg_worships_damage},
+    {"borg_worships_speed",
+        "Borg worships speed",
+        NULL, (long) &borg_worships_speed},
+    {"borg_worships_hp",
+        "Borg worshops hitpoints",
+        NULL, (long) &borg_worships_hp},
+    {"borg_worships_mana",
+        "Borg worships mana",
+        NULL, (long) &borg_worships_mana},
+    {"borg_worships_gold",
+        "Borg worships gold",
+        NULL, (long) &borg_worships_gold},
+    {"borg_worships_ac",
+        "Borg worships armor class",
+        NULL, (long) &borg_worships_ac},
+    {"borg_plays_risky",
+        "Borg plays risky",
+        NULL, (long) &borg_plays_risky},
+    {"borg_slow_optimizehome",
+        "Slow home optimize",
+        NULL, (long) &borg_slow_optimizehome},
+    {"borg_uses_swaps",
+        "Borg uses Swap Items",
+        NULL, (long) &borg_uses_swaps},
+    {"borg_uses_calcs",
+        "Borg uses Dynamic Calculations (slow)",
+        NULL, (long) &borg_uses_calcs},
+    {"delay_factor",
+        "xyz",
+        NULL, (long) &borgtk_delay_factor},
+    {NULL, NULL, NULL, 0L},
+};
+
+void *Borg_GetSettings(void)
+{
+    return settings;
+}
+
+#define TCL_OK 0
+typedef struct Tcl_Interp Tcl_Interp;
+
+int Borg_Init(Tcl_Interp *interp, char *path)
+{
+    char path2[1024];
+
+    BORG_DIR_ROOT = string_make(path);
+
+    path_build(path2, 1024, BORG_DIR_ROOT, "data");
+    BORG_DIR_DATA = string_make(path2);
+
+    return TCL_OK;
+}
+
+#endif /* BORG_TK */
+
+
+
+
+#else
+
+#ifdef MACINTOSH
+static int HACK = 0;
+#endif
+
+#endif
diff -Nru --strip-trailing-cr angband-3.0.6/src/borg9.h angband-3.0.6-borg/src/borg9.h
--- angband-3.0.6/src/borg9.h	1969-12-31 16:00:00.000000000 -0800
+++ angband-3.0.6-borg/src/borg9.h	2004-01-10 19:57:42.000000000 -0800
@@ -0,0 +1,32 @@
+/* File: borg9.h */
+/* Purpose: Header file for "borg9.c" -BEN- */
+
+#ifndef INCLUDED_BORG9_H
+#define INCLUDED_BORG9_H
+
+#include "angband.h"
+
+#ifdef ALLOW_BORG
+
+/*
+ * This file provides support for "borg9.c".
+ */
+#ifndef BABLOS
+extern void resurrect_borg(void);
+extern void borg_write_map(bool ask);
+extern errr borg_enter_score(void);
+
+#endif /* bablos */
+
+extern void borg_save_scumfile(void);
+extern void borg_status(void);
+/*
+ * Initialize this file
+ */
+extern void borg_init_9(void);
+
+
+#endif
+
+#endif
+
diff -Nru --strip-trailing-cr angband-3.0.6/src/config.h angband-3.0.6-borg/src/config.h
--- angband-3.0.6/src/config.h	2005-02-08 05:16:36.000000000 -0800
+++ angband-3.0.6-borg/src/config.h	2010-09-28 06:59:13.445790919 -0700
@@ -141,7 +141,7 @@
 /*
  * OPTION: Hack -- Compile in support for "Borg mode"
  */
-/* #define ALLOW_BORG */
+#define ALLOW_BORG
 
 
 /*
@@ -220,7 +220,7 @@
 /*
  * OPTION: Allow "Borgs" to yield "high scores"
  */
-/* #define SCORE_BORGS */
+#define SCORE_BORGS
 
 /*
  * OPTION: Allow "Cheaters" to yield "high scores"
